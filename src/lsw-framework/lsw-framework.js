(function(factory) {
  const mod = factory();
  if(typeof window !== 'undefined') {
    window["Lsw_framework_components"] = mod;
  }
  if(typeof global !== 'undefined') {
    global["Lsw_framework_components"] = mod;
  }
  if(typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function() {

// @vuebundler[Lsw_framework_components][0]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/styles/lsw-styling-structure.css

// @vuebundler[Lsw_framework_components][1]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/styles/lsw-styling-theme.css

// @vuebundler[Lsw_framework_components][2]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/styles/lsw-styling-framework.css

// @vuebundler[Lsw_framework_components][3]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/others/vue/vue2.min.js
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Vue=e()}(this,(function(){"use strict";var t=Object.freeze({}),e=Array.isArray;function n(t){return null==t}function r(t){return null!=t}function o(t){return!0===t}function i(t){return"string"==typeof t||"number"==typeof t||"symbol"==typeof t||"boolean"==typeof t}function a(t){return"function"==typeof t}function s(t){return null!==t&&"object"==typeof t}var c=Object.prototype.toString;function u(t){return"[object Object]"===c.call(t)}function l(t){var e=parseFloat(String(t));return e>=0&&Math.floor(e)===e&&isFinite(t)}function f(t){return r(t)&&"function"==typeof t.then&&"function"==typeof t.catch}function d(t){return null==t?"":Array.isArray(t)||u(t)&&t.toString===c?JSON.stringify(t,p,2):String(t)}function p(t,e){return e&&e.__v_isRef?e.value:e}function v(t){var e=parseFloat(t);return isNaN(e)?t:e}function h(t,e){for(var n=Object.create(null),r=t.split(","),o=0;o<r.length;o++)n[r[o]]=!0;return e?function(t){return n[t.toLowerCase()]}:function(t){return n[t]}}var m=h("slot,component",!0),g=h("key,ref,slot,slot-scope,is");function y(t,e){var n=t.length;if(n){if(e===t[n-1])return void(t.length=n-1);var r=t.indexOf(e);if(r>-1)return t.splice(r,1)}}var _=Object.prototype.hasOwnProperty;function b(t,e){return _.call(t,e)}function $(t){var e=Object.create(null);return function(n){return e[n]||(e[n]=t(n))}}var w=/-(\w)/g,x=$((function(t){return t.replace(w,(function(t,e){return e?e.toUpperCase():""}))})),C=$((function(t){return t.charAt(0).toUpperCase()+t.slice(1)})),k=/\B([A-Z])/g,S=$((function(t){return t.replace(k,"-$1").toLowerCase()}));var O=Function.prototype.bind?function(t,e){return t.bind(e)}:function(t,e){function n(n){var r=arguments.length;return r?r>1?t.apply(e,arguments):t.call(e,n):t.call(e)}return n._length=t.length,n};function T(t,e){e=e||0;for(var n=t.length-e,r=new Array(n);n--;)r[n]=t[n+e];return r}function A(t,e){for(var n in e)t[n]=e[n];return t}function j(t){for(var e={},n=0;n<t.length;n++)t[n]&&A(e,t[n]);return e}function E(t,e,n){}var N=function(t,e,n){return!1},P=function(t){return t};function D(t,e){if(t===e)return!0;var n=s(t),r=s(e);if(!n||!r)return!n&&!r&&String(t)===String(e);try{var o=Array.isArray(t),i=Array.isArray(e);if(o&&i)return t.length===e.length&&t.every((function(t,n){return D(t,e[n])}));if(t instanceof Date&&e instanceof Date)return t.getTime()===e.getTime();if(o||i)return!1;var a=Object.keys(t),c=Object.keys(e);return a.length===c.length&&a.every((function(n){return D(t[n],e[n])}))}catch(t){return!1}}function M(t,e){for(var n=0;n<t.length;n++)if(D(t[n],e))return n;return-1}function I(t){var e=!1;return function(){e||(e=!0,t.apply(this,arguments))}}function L(t,e){return t===e?0===t&&1/t!=1/e:t==t||e==e}var R="data-server-rendered",F=["component","directive","filter"],H=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],B={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:N,isReservedAttr:N,isUnknownElement:N,getTagNamespace:E,parsePlatformTagName:P,mustUseProp:N,async:!0,_lifecycleHooks:H},U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function z(t){var e=(t+"").charCodeAt(0);return 36===e||95===e}function V(t,e,n,r){Object.defineProperty(t,e,{value:n,enumerable:!!r,writable:!0,configurable:!0})}var K=new RegExp("[^".concat(U.source,".$_\\d]"));var J="__proto__"in{},q="undefined"!=typeof window,W=q&&window.navigator.userAgent.toLowerCase(),Z=W&&/msie|trident/.test(W),G=W&&W.indexOf("msie 9.0")>0,X=W&&W.indexOf("edge/")>0;W&&W.indexOf("android");var Y=W&&/iphone|ipad|ipod|ios/.test(W);W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W);var Q,tt=W&&W.match(/firefox\/(\d+)/),et={}.watch,nt=!1;if(q)try{var rt={};Object.defineProperty(rt,"passive",{get:function(){nt=!0}}),window.addEventListener("test-passive",null,rt)}catch(t){}var ot=function(){return void 0===Q&&(Q=!q&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),Q},it=q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function at(t){return"function"==typeof t&&/native code/.test(t.toString())}var st,ct="undefined"!=typeof Symbol&&at(Symbol)&&"undefined"!=typeof Reflect&&at(Reflect.ownKeys);st="undefined"!=typeof Set&&at(Set)?Set:function(){function t(){this.set=Object.create(null)}return t.prototype.has=function(t){return!0===this.set[t]},t.prototype.add=function(t){this.set[t]=!0},t.prototype.clear=function(){this.set=Object.create(null)},t}();var ut=null;function lt(t){void 0===t&&(t=null),t||ut&&ut._scope.off(),ut=t,t&&t._scope.on()}var ft=function(){function t(t,e,n,r,o,i,a,s){this.tag=t,this.data=e,this.children=n,this.text=r,this.elm=o,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(t.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),t}(),dt=function(t){void 0===t&&(t="");var e=new ft;return e.text=t,e.isComment=!0,e};function pt(t){return new ft(void 0,void 0,void 0,String(t))}function vt(t){var e=new ft(t.tag,t.data,t.children&&t.children.slice(),t.text,t.elm,t.context,t.componentOptions,t.asyncFactory);return e.ns=t.ns,e.isStatic=t.isStatic,e.key=t.key,e.isComment=t.isComment,e.fnContext=t.fnContext,e.fnOptions=t.fnOptions,e.fnScopeId=t.fnScopeId,e.asyncMeta=t.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var ht=0,mt=[],gt=function(){for(var t=0;t<mt.length;t++){var e=mt[t];e.subs=e.subs.filter((function(t){return t})),e._pending=!1}mt.length=0},yt=function(){function t(){this._pending=!1,this.id=ht++,this.subs=[]}return t.prototype.addSub=function(t){this.subs.push(t)},t.prototype.removeSub=function(t){this.subs[this.subs.indexOf(t)]=null,this._pending||(this._pending=!0,mt.push(this))},t.prototype.depend=function(e){t.target&&t.target.addDep(this)},t.prototype.notify=function(t){for(var e=this.subs.filter((function(t){return t})),n=0,r=e.length;n<r;n++){e[n].update()}},t}();yt.target=null;var _t=[];function bt(t){_t.push(t),yt.target=t}function $t(){_t.pop(),yt.target=_t[_t.length-1]}var wt=Array.prototype,xt=Object.create(wt);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(t){var e=wt[t];V(xt,t,(function(){for(var n=[],r=0;r<arguments.length;r++)n[r]=arguments[r];var o,i=e.apply(this,n),a=this.__ob__;switch(t){case"push":case"unshift":o=n;break;case"splice":o=n.slice(2)}return o&&a.observeArray(o),a.dep.notify(),i}))}));var Ct=Object.getOwnPropertyNames(xt),kt={},St=!0;function Ot(t){St=t}var Tt={notify:E,depend:E,addSub:E,removeSub:E},At=function(){function t(t,n,r){if(void 0===n&&(n=!1),void 0===r&&(r=!1),this.value=t,this.shallow=n,this.mock=r,this.dep=r?Tt:new yt,this.vmCount=0,V(t,"__ob__",this),e(t)){if(!r)if(J)t.__proto__=xt;else for(var o=0,i=Ct.length;o<i;o++){V(t,s=Ct[o],xt[s])}n||this.observeArray(t)}else{var a=Object.keys(t);for(o=0;o<a.length;o++){var s;Et(t,s=a[o],kt,void 0,n,r)}}}return t.prototype.observeArray=function(t){for(var e=0,n=t.length;e<n;e++)jt(t[e],!1,this.mock)},t}();function jt(t,n,r){return t&&b(t,"__ob__")&&t.__ob__ instanceof At?t.__ob__:!St||!r&&ot()||!e(t)&&!u(t)||!Object.isExtensible(t)||t.__v_skip||Bt(t)||t instanceof ft?void 0:new At(t,n,r)}function Et(t,n,r,o,i,a,s){void 0===s&&(s=!1);var c=new yt,u=Object.getOwnPropertyDescriptor(t,n);if(!u||!1!==u.configurable){var l=u&&u.get,f=u&&u.set;l&&!f||r!==kt&&2!==arguments.length||(r=t[n]);var d=i?r&&r.__ob__:jt(r,!1,a);return Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:function(){var n=l?l.call(t):r;return yt.target&&(c.depend(),d&&(d.dep.depend(),e(n)&&Dt(n))),Bt(n)&&!i?n.value:n},set:function(e){var n=l?l.call(t):r;if(L(n,e)){if(f)f.call(t,e);else{if(l)return;if(!i&&Bt(n)&&!Bt(e))return void(n.value=e);r=e}d=i?e&&e.__ob__:jt(e,!1,a),c.notify()}}}),c}}function Nt(t,n,r){if(!Ft(t)){var o=t.__ob__;return e(t)&&l(n)?(t.length=Math.max(t.length,n),t.splice(n,1,r),o&&!o.shallow&&o.mock&&jt(r,!1,!0),r):n in t&&!(n in Object.prototype)?(t[n]=r,r):t._isVue||o&&o.vmCount?r:o?(Et(o.value,n,r,void 0,o.shallow,o.mock),o.dep.notify(),r):(t[n]=r,r)}}function Pt(t,n){if(e(t)&&l(n))t.splice(n,1);else{var r=t.__ob__;t._isVue||r&&r.vmCount||Ft(t)||b(t,n)&&(delete t[n],r&&r.dep.notify())}}function Dt(t){for(var n=void 0,r=0,o=t.length;r<o;r++)(n=t[r])&&n.__ob__&&n.__ob__.dep.depend(),e(n)&&Dt(n)}function Mt(t){return It(t,!0),V(t,"__v_isShallow",!0),t}function It(t,e){Ft(t)||jt(t,e,ot())}function Lt(t){return Ft(t)?Lt(t.__v_raw):!(!t||!t.__ob__)}function Rt(t){return!(!t||!t.__v_isShallow)}function Ft(t){return!(!t||!t.__v_isReadonly)}var Ht="__v_isRef";function Bt(t){return!(!t||!0!==t.__v_isRef)}function Ut(t,e){if(Bt(t))return t;var n={};return V(n,Ht,!0),V(n,"__v_isShallow",e),V(n,"dep",Et(n,"value",t,null,e,ot())),n}function zt(t,e,n){Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:function(){var t=e[n];if(Bt(t))return t.value;var r=t&&t.__ob__;return r&&r.dep.depend(),t},set:function(t){var r=e[n];Bt(r)&&!Bt(t)?r.value=t:e[n]=t}})}function Vt(t,e,n){var r=t[e];if(Bt(r))return r;var o={get value(){var r=t[e];return void 0===r?n:r},set value(n){t[e]=n}};return V(o,Ht,!0),o}var Kt="__v_rawToReadonly",Jt="__v_rawToShallowReadonly";function qt(t){return Wt(t,!1)}function Wt(t,e){if(!u(t))return t;if(Ft(t))return t;var n=e?Jt:Kt,r=t[n];if(r)return r;var o=Object.create(Object.getPrototypeOf(t));V(t,n,o),V(o,"__v_isReadonly",!0),V(o,"__v_raw",t),Bt(t)&&V(o,Ht,!0),(e||Rt(t))&&V(o,"__v_isShallow",!0);for(var i=Object.keys(t),a=0;a<i.length;a++)Zt(o,t,i[a],e);return o}function Zt(t,e,n,r){Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:function(){var t=e[n];return r||!u(t)?t:qt(t)},set:function(){}})}var Gt=$((function(t){var e="&"===t.charAt(0),n="~"===(t=e?t.slice(1):t).charAt(0),r="!"===(t=n?t.slice(1):t).charAt(0);return{name:t=r?t.slice(1):t,once:n,capture:r,passive:e}}));function Xt(t,n){function r(){var t=r.fns;if(!e(t))return _n(t,null,arguments,n,"v-on handler");for(var o=t.slice(),i=0;i<o.length;i++)_n(o[i],null,arguments,n,"v-on handler")}return r.fns=t,r}function Yt(t,e,r,i,a,s){var c,u,l,f;for(c in t)u=t[c],l=e[c],f=Gt(c),n(u)||(n(l)?(n(u.fns)&&(u=t[c]=Xt(u,s)),o(f.once)&&(u=t[c]=a(f.name,u,f.capture)),r(f.name,u,f.capture,f.passive,f.params)):u!==l&&(l.fns=u,t[c]=l));for(c in e)n(t[c])&&i((f=Gt(c)).name,e[c],f.capture)}function Qt(t,e,i){var a;t instanceof ft&&(t=t.data.hook||(t.data.hook={}));var s=t[e];function c(){i.apply(this,arguments),y(a.fns,c)}n(s)?a=Xt([c]):r(s.fns)&&o(s.merged)?(a=s).fns.push(c):a=Xt([s,c]),a.merged=!0,t[e]=a}function te(t,e,n,o,i){if(r(e)){if(b(e,n))return t[n]=e[n],i||delete e[n],!0;if(b(e,o))return t[n]=e[o],i||delete e[o],!0}return!1}function ee(t){return i(t)?[pt(t)]:e(t)?re(t):void 0}function ne(t){return r(t)&&r(t.text)&&!1===t.isComment}function re(t,a){var s,c,u,l,f=[];for(s=0;s<t.length;s++)n(c=t[s])||"boolean"==typeof c||(l=f[u=f.length-1],e(c)?c.length>0&&(ne((c=re(c,"".concat(a||"","_").concat(s)))[0])&&ne(l)&&(f[u]=pt(l.text+c[0].text),c.shift()),f.push.apply(f,c)):i(c)?ne(l)?f[u]=pt(l.text+c):""!==c&&f.push(pt(c)):ne(c)&&ne(l)?f[u]=pt(l.text+c.text):(o(t._isVList)&&r(c.tag)&&n(c.key)&&r(a)&&(c.key="__vlist".concat(a,"_").concat(s,"__")),f.push(c)));return f}var oe=1,ie=2;function ae(t,n,c,u,l,f){return(e(c)||i(c))&&(l=u,u=c,c=void 0),o(f)&&(l=ie),function(t,n,o,i,c){if(r(o)&&r(o.__ob__))return dt();r(o)&&r(o.is)&&(n=o.is);if(!n)return dt();e(i)&&a(i[0])&&((o=o||{}).scopedSlots={default:i[0]},i.length=0);c===ie?i=ee(i):c===oe&&(i=function(t){for(var n=0;n<t.length;n++)if(e(t[n]))return Array.prototype.concat.apply([],t);return t}(i));var u,l;if("string"==typeof n){var f=void 0;l=t.$vnode&&t.$vnode.ns||B.getTagNamespace(n),u=B.isReservedTag(n)?new ft(B.parsePlatformTagName(n),o,i,void 0,void 0,t):o&&o.pre||!r(f=kr(t.$options,"components",n))?new ft(n,o,i,void 0,void 0,t):hr(f,o,t,i,n)}else u=hr(n,o,t,i);return e(u)?u:r(u)?(r(l)&&se(u,l),r(o)&&function(t){s(t.style)&&Wn(t.style);s(t.class)&&Wn(t.class)}(o),u):dt()}(t,n,c,u,l)}function se(t,e,i){if(t.ns=e,"foreignObject"===t.tag&&(e=void 0,i=!0),r(t.children))for(var a=0,s=t.children.length;a<s;a++){var c=t.children[a];r(c.tag)&&(n(c.ns)||o(i)&&"svg"!==c.tag)&&se(c,e,i)}}function ce(t,n){var o,i,a,c,u=null;if(e(t)||"string"==typeof t)for(u=new Array(t.length),o=0,i=t.length;o<i;o++)u[o]=n(t[o],o);else if("number"==typeof t)for(u=new Array(t),o=0;o<t;o++)u[o]=n(o+1,o);else if(s(t))if(ct&&t[Symbol.iterator]){u=[];for(var l=t[Symbol.iterator](),f=l.next();!f.done;)u.push(n(f.value,u.length)),f=l.next()}else for(a=Object.keys(t),u=new Array(a.length),o=0,i=a.length;o<i;o++)c=a[o],u[o]=n(t[c],c,o);return r(u)||(u=[]),u._isVList=!0,u}function ue(t,e,n,r){var o,i=this.$scopedSlots[t];i?(n=n||{},r&&(n=A(A({},r),n)),o=i(n)||(a(e)?e():e)):o=this.$slots[t]||(a(e)?e():e);var s=n&&n.slot;return s?this.$createElement("template",{slot:s},o):o}function le(t){return kr(this.$options,"filters",t)||P}function fe(t,n){return e(t)?-1===t.indexOf(n):t!==n}function de(t,e,n,r,o){var i=B.keyCodes[e]||n;return o&&r&&!B.keyCodes[e]?fe(o,r):i?fe(i,t):r?S(r)!==e:void 0===t}function pe(t,n,r,o,i){if(r)if(s(r)){e(r)&&(r=j(r));var a=void 0,c=function(e){if("class"===e||"style"===e||g(e))a=t;else{var s=t.attrs&&t.attrs.type;a=o||B.mustUseProp(n,s,e)?t.domProps||(t.domProps={}):t.attrs||(t.attrs={})}var c=x(e),u=S(e);c in a||u in a||(a[e]=r[e],i&&((t.on||(t.on={}))["update:".concat(e)]=function(t){r[e]=t}))};for(var u in r)c(u)}else;return t}function ve(t,e){var n=this._staticTrees||(this._staticTrees=[]),r=n[t];return r&&!e||me(r=n[t]=this.$options.staticRenderFns[t].call(this._renderProxy,this._c,this),"__static__".concat(t),!1),r}function he(t,e,n){return me(t,"__once__".concat(e).concat(n?"_".concat(n):""),!0),t}function me(t,n,r){if(e(t))for(var o=0;o<t.length;o++)t[o]&&"string"!=typeof t[o]&&ge(t[o],"".concat(n,"_").concat(o),r);else ge(t,n,r)}function ge(t,e,n){t.isStatic=!0,t.key=e,t.isOnce=n}function ye(t,e){if(e)if(u(e)){var n=t.on=t.on?A({},t.on):{};for(var r in e){var o=n[r],i=e[r];n[r]=o?[].concat(o,i):i}}else;return t}function _e(t,n,r,o){n=n||{$stable:!r};for(var i=0;i<t.length;i++){var a=t[i];e(a)?_e(a,n,r):a&&(a.proxy&&(a.fn.proxy=!0),n[a.key]=a.fn)}return o&&(n.$key=o),n}function be(t,e){for(var n=0;n<e.length;n+=2){var r=e[n];"string"==typeof r&&r&&(t[e[n]]=e[n+1])}return t}function $e(t,e){return"string"==typeof t?e+t:t}function we(t){t._o=he,t._n=v,t._s=d,t._l=ce,t._t=ue,t._q=D,t._i=M,t._m=ve,t._f=le,t._k=de,t._b=pe,t._v=pt,t._e=dt,t._u=_e,t._g=ye,t._d=be,t._p=$e}function xe(t,e){if(!t||!t.length)return{};for(var n={},r=0,o=t.length;r<o;r++){var i=t[r],a=i.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,i.context!==e&&i.fnContext!==e||!a||null==a.slot)(n.default||(n.default=[])).push(i);else{var s=a.slot,c=n[s]||(n[s]=[]);"template"===i.tag?c.push.apply(c,i.children||[]):c.push(i)}}for(var u in n)n[u].every(Ce)&&delete n[u];return n}function Ce(t){return t.isComment&&!t.asyncFactory||" "===t.text}function ke(t){return t.isComment&&t.asyncFactory}function Se(e,n,r,o){var i,a=Object.keys(r).length>0,s=n?!!n.$stable:!a,c=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(s&&o&&o!==t&&c===o.$key&&!a&&!o.$hasNormal)return o;for(var u in i={},n)n[u]&&"$"!==u[0]&&(i[u]=Oe(e,r,u,n[u]))}else i={};for(var l in r)l in i||(i[l]=Te(r,l));return n&&Object.isExtensible(n)&&(n._normalized=i),V(i,"$stable",s),V(i,"$key",c),V(i,"$hasNormal",a),i}function Oe(t,n,r,o){var i=function(){var n=ut;lt(t);var r=arguments.length?o.apply(null,arguments):o({}),i=(r=r&&"object"==typeof r&&!e(r)?[r]:ee(r))&&r[0];return lt(n),r&&(!i||1===r.length&&i.isComment&&!ke(i))?void 0:r};return o.proxy&&Object.defineProperty(n,r,{get:i,enumerable:!0,configurable:!0}),i}function Te(t,e){return function(){return t[e]}}function Ae(e){return{get attrs(){if(!e._attrsProxy){var n=e._attrsProxy={};V(n,"_v_attr_proxy",!0),je(n,e.$attrs,t,e,"$attrs")}return e._attrsProxy},get listeners(){e._listenersProxy||je(e._listenersProxy={},e.$listeners,t,e,"$listeners");return e._listenersProxy},get slots(){return function(t){t._slotsProxy||Ne(t._slotsProxy={},t.$scopedSlots);return t._slotsProxy}(e)},emit:O(e.$emit,e),expose:function(t){t&&Object.keys(t).forEach((function(n){return zt(e,t,n)}))}}}function je(t,e,n,r,o){var i=!1;for(var a in e)a in t?e[a]!==n[a]&&(i=!0):(i=!0,Ee(t,a,r,o));for(var a in t)a in e||(i=!0,delete t[a]);return i}function Ee(t,e,n,r){Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:function(){return n[r][e]}})}function Ne(t,e){for(var n in e)t[n]=e[n];for(var n in t)n in e||delete t[n]}function Pe(){var t=ut;return t._setupContext||(t._setupContext=Ae(t))}var De,Me,Ie=null;function Le(t,e){return(t.__esModule||ct&&"Module"===t[Symbol.toStringTag])&&(t=t.default),s(t)?e.extend(t):t}function Re(t){if(e(t))for(var n=0;n<t.length;n++){var o=t[n];if(r(o)&&(r(o.componentOptions)||ke(o)))return o}}function Fe(t,e){De.$on(t,e)}function He(t,e){De.$off(t,e)}function Be(t,e){var n=De;return function r(){null!==e.apply(null,arguments)&&n.$off(t,r)}}function Ue(t,e,n){De=t,Yt(e,n||{},Fe,He,Be,t),De=void 0}var ze=function(){function t(t){void 0===t&&(t=!1),this.detached=t,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Me,!t&&Me&&(this.index=(Me.scopes||(Me.scopes=[])).push(this)-1)}return t.prototype.run=function(t){if(this.active){var e=Me;try{return Me=this,t()}finally{Me=e}}},t.prototype.on=function(){Me=this},t.prototype.off=function(){Me=this.parent},t.prototype.stop=function(t){if(this.active){var e=void 0,n=void 0;for(e=0,n=this.effects.length;e<n;e++)this.effects[e].teardown();for(e=0,n=this.cleanups.length;e<n;e++)this.cleanups[e]();if(this.scopes)for(e=0,n=this.scopes.length;e<n;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!t){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},t}();function Ve(){return Me}var Ke=null;function Je(t){var e=Ke;return Ke=t,function(){Ke=e}}function qe(t){for(;t&&(t=t.$parent);)if(t._inactive)return!0;return!1}function We(t,e){if(e){if(t._directInactive=!1,qe(t))return}else if(t._directInactive)return;if(t._inactive||null===t._inactive){t._inactive=!1;for(var n=0;n<t.$children.length;n++)We(t.$children[n]);Ge(t,"activated")}}function Ze(t,e){if(!(e&&(t._directInactive=!0,qe(t))||t._inactive)){t._inactive=!0;for(var n=0;n<t.$children.length;n++)Ze(t.$children[n]);Ge(t,"deactivated")}}function Ge(t,e,n,r){void 0===r&&(r=!0),bt();var o=ut,i=Ve();r&&lt(t);var a=t.$options[e],s="".concat(e," hook");if(a)for(var c=0,u=a.length;c<u;c++)_n(a[c],t,n||null,t,s);t._hasHookEvent&&t.$emit("hook:"+e),r&&(lt(o),i&&i.on()),$t()}var Xe=[],Ye=[],Qe={},tn=!1,en=!1,nn=0;var rn=0,on=Date.now;if(q&&!Z){var an=window.performance;an&&"function"==typeof an.now&&on()>document.createEvent("Event").timeStamp&&(on=function(){return an.now()})}var sn=function(t,e){if(t.post){if(!e.post)return 1}else if(e.post)return-1;return t.id-e.id};function cn(){var t,e;for(rn=on(),en=!0,Xe.sort(sn),nn=0;nn<Xe.length;nn++)(t=Xe[nn]).before&&t.before(),e=t.id,Qe[e]=null,t.run();var n=Ye.slice(),r=Xe.slice();nn=Xe.length=Ye.length=0,Qe={},tn=en=!1,function(t){for(var e=0;e<t.length;e++)t[e]._inactive=!0,We(t[e],!0)}(n),function(t){var e=t.length;for(;e--;){var n=t[e],r=n.vm;r&&r._watcher===n&&r._isMounted&&!r._isDestroyed&&Ge(r,"updated")}}(r),gt(),it&&B.devtools&&it.emit("flush")}function un(t){var e=t.id;if(null==Qe[e]&&(t!==yt.target||!t.noRecurse)){if(Qe[e]=!0,en){for(var n=Xe.length-1;n>nn&&Xe[n].id>t.id;)n--;Xe.splice(n+1,0,t)}else Xe.push(t);tn||(tn=!0,En(cn))}}var ln="watcher",fn="".concat(ln," callback"),dn="".concat(ln," getter"),pn="".concat(ln," cleanup");function vn(t,e){return mn(t,null,{flush:"post"})}var hn={};function mn(n,r,o){var i=void 0===o?t:o,s=i.immediate,c=i.deep,u=i.flush,l=void 0===u?"pre":u;i.onTrack,i.onTrigger;var f,d,p=ut,v=function(t,e,n){void 0===n&&(n=null);var r=_n(t,null,n,p,e);return c&&r&&r.__ob__&&r.__ob__.dep.depend(),r},h=!1,m=!1;if(Bt(n)?(f=function(){return n.value},h=Rt(n)):Lt(n)?(f=function(){return n.__ob__.dep.depend(),n},c=!0):e(n)?(m=!0,h=n.some((function(t){return Lt(t)||Rt(t)})),f=function(){return n.map((function(t){return Bt(t)?t.value:Lt(t)?(t.__ob__.dep.depend(),Wn(t)):a(t)?v(t,dn):void 0}))}):f=a(n)?r?function(){return v(n,dn)}:function(){if(!p||!p._isDestroyed)return d&&d(),v(n,ln,[y])}:E,r&&c){var g=f;f=function(){return Wn(g())}}var y=function(t){d=_.onStop=function(){v(t,pn)}};if(ot())return y=E,r?s&&v(r,fn,[f(),m?[]:void 0,y]):f(),E;var _=new Xn(ut,f,E,{lazy:!0});_.noRecurse=!r;var b=m?[]:hn;return _.run=function(){if(_.active)if(r){var t=_.get();(c||h||(m?t.some((function(t,e){return L(t,b[e])})):L(t,b)))&&(d&&d(),v(r,fn,[t,b===hn?void 0:b,y]),b=t)}else _.get()},"sync"===l?_.update=_.run:"post"===l?(_.post=!0,_.update=function(){return un(_)}):_.update=function(){if(p&&p===ut&&!p._isMounted){var t=p._preWatchers||(p._preWatchers=[]);t.indexOf(_)<0&&t.push(_)}else un(_)},r?s?_.run():b=_.get():"post"===l&&p?p.$once("hook:mounted",(function(){return _.get()})):_.get(),function(){_.teardown()}}function gn(t){var e=t._provided,n=t.$parent&&t.$parent._provided;return n===e?t._provided=Object.create(n):e}function yn(t,e,n){bt();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var i=0;i<o.length;i++)try{if(!1===o[i].call(r,t,e,n))return}catch(t){bn(t,r,"errorCaptured hook")}}bn(t,e,n)}finally{$t()}}function _n(t,e,n,r,o){var i;try{(i=n?t.apply(e,n):t.call(e))&&!i._isVue&&f(i)&&!i._handled&&(i.catch((function(t){return yn(t,r,o+" (Promise/async)")})),i._handled=!0)}catch(t){yn(t,r,o)}return i}function bn(t,e,n){if(B.errorHandler)try{return B.errorHandler.call(null,t,e,n)}catch(e){e!==t&&$n(e)}$n(t)}function $n(t,e,n){if(!q||"undefined"==typeof console)throw t;console.error(t)}var wn,xn=!1,Cn=[],kn=!1;function Sn(){kn=!1;var t=Cn.slice(0);Cn.length=0;for(var e=0;e<t.length;e++)t[e]()}if("undefined"!=typeof Promise&&at(Promise)){var On=Promise.resolve();wn=function(){On.then(Sn),Y&&setTimeout(E)},xn=!0}else if(Z||"undefined"==typeof MutationObserver||!at(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())wn="undefined"!=typeof setImmediate&&at(setImmediate)?function(){setImmediate(Sn)}:function(){setTimeout(Sn,0)};else{var Tn=1,An=new MutationObserver(Sn),jn=document.createTextNode(String(Tn));An.observe(jn,{characterData:!0}),wn=function(){Tn=(Tn+1)%2,jn.data=String(Tn)},xn=!0}function En(t,e){var n;if(Cn.push((function(){if(t)try{t.call(e)}catch(t){yn(t,e,"nextTick")}else n&&n(e)})),kn||(kn=!0,wn()),!t&&"undefined"!=typeof Promise)return new Promise((function(t){n=t}))}function Nn(t){return function(e,n){if(void 0===n&&(n=ut),n)return function(t,e,n){var r=t.$options;r[e]=$r(r[e],n)}(n,t,e)}}var Pn=Nn("beforeMount"),Dn=Nn("mounted"),Mn=Nn("beforeUpdate"),In=Nn("updated"),Ln=Nn("beforeDestroy"),Rn=Nn("destroyed"),Fn=Nn("activated"),Hn=Nn("deactivated"),Bn=Nn("serverPrefetch"),Un=Nn("renderTracked"),zn=Nn("renderTriggered"),Vn=Nn("errorCaptured");var Kn="2.7.16";var Jn=Object.freeze({__proto__:null,version:Kn,defineComponent:function(t){return t},ref:function(t){return Ut(t,!1)},shallowRef:function(t){return Ut(t,!0)},isRef:Bt,toRef:Vt,toRefs:function(t){var n=e(t)?new Array(t.length):{};for(var r in t)n[r]=Vt(t,r);return n},unref:function(t){return Bt(t)?t.value:t},proxyRefs:function(t){if(Lt(t))return t;for(var e={},n=Object.keys(t),r=0;r<n.length;r++)zt(e,t,n[r]);return e},customRef:function(t){var e=new yt,n=t((function(){e.depend()}),(function(){e.notify()})),r=n.get,o=n.set,i={get value(){return r()},set value(t){o(t)}};return V(i,Ht,!0),i},triggerRef:function(t){t.dep&&t.dep.notify()},reactive:function(t){return It(t,!1),t},isReactive:Lt,isReadonly:Ft,isShallow:Rt,isProxy:function(t){return Lt(t)||Ft(t)},shallowReactive:Mt,markRaw:function(t){return Object.isExtensible(t)&&V(t,"__v_skip",!0),t},toRaw:function t(e){var n=e&&e.__v_raw;return n?t(n):e},readonly:qt,shallowReadonly:function(t){return Wt(t,!0)},computed:function(t,e){var n,r,o=a(t);o?(n=t,r=E):(n=t.get,r=t.set);var i=ot()?null:new Xn(ut,n,E,{lazy:!0}),s={effect:i,get value(){return i?(i.dirty&&i.evaluate(),yt.target&&i.depend(),i.value):n()},set value(t){r(t)}};return V(s,Ht,!0),V(s,"__v_isReadonly",o),s},watch:function(t,e,n){return mn(t,e,n)},watchEffect:function(t,e){return mn(t,null,e)},watchPostEffect:vn,watchSyncEffect:function(t,e){return mn(t,null,{flush:"sync"})},EffectScope:ze,effectScope:function(t){return new ze(t)},onScopeDispose:function(t){Me&&Me.cleanups.push(t)},getCurrentScope:Ve,provide:function(t,e){ut&&(gn(ut)[t]=e)},inject:function(t,e,n){void 0===n&&(n=!1);var r=ut;if(r){var o=r.$parent&&r.$parent._provided;if(o&&t in o)return o[t];if(arguments.length>1)return n&&a(e)?e.call(r):e}},h:function(t,e,n){return ae(ut,t,e,n,2,!0)},getCurrentInstance:function(){return ut&&{proxy:ut}},useSlots:function(){return Pe().slots},useAttrs:function(){return Pe().attrs},useListeners:function(){return Pe().listeners},mergeDefaults:function(t,n){var r=e(t)?t.reduce((function(t,e){return t[e]={},t}),{}):t;for(var o in n){var i=r[o];i?e(i)||a(i)?r[o]={type:i,default:n[o]}:i.default=n[o]:null===i&&(r[o]={default:n[o]})}return r},nextTick:En,set:Nt,del:Pt,useCssModule:function(e){return t},useCssVars:function(t){if(q){var e=ut;e&&vn((function(){var n=e.$el,r=t(e,e._setupProxy);if(n&&1===n.nodeType){var o=n.style;for(var i in r)o.setProperty("--".concat(i),r[i])}}))}},defineAsyncComponent:function(t){a(t)&&(t={loader:t});var e=t.loader,n=t.loadingComponent,r=t.errorComponent,o=t.delay,i=void 0===o?200:o,s=t.timeout;t.suspensible;var c=t.onError,u=null,l=0,f=function(){var t;return u||(t=u=e().catch((function(t){if(t=t instanceof Error?t:new Error(String(t)),c)return new Promise((function(e,n){c(t,(function(){return e((l++,u=null,f()))}),(function(){return n(t)}),l+1)}));throw t})).then((function(e){return t!==u&&u?u:(e&&(e.__esModule||"Module"===e[Symbol.toStringTag])&&(e=e.default),e)})))};return function(){return{component:f(),delay:i,timeout:s,error:r,loading:n}}},onBeforeMount:Pn,onMounted:Dn,onBeforeUpdate:Mn,onUpdated:In,onBeforeUnmount:Ln,onUnmounted:Rn,onActivated:Fn,onDeactivated:Hn,onServerPrefetch:Bn,onRenderTracked:Un,onRenderTriggered:zn,onErrorCaptured:function(t,e){void 0===e&&(e=ut),Vn(t,e)}}),qn=new st;function Wn(t){return Zn(t,qn),qn.clear(),t}function Zn(t,n){var r,o,i=e(t);if(!(!i&&!s(t)||t.__v_skip||Object.isFrozen(t)||t instanceof ft)){if(t.__ob__){var a=t.__ob__.dep.id;if(n.has(a))return;n.add(a)}if(i)for(r=t.length;r--;)Zn(t[r],n);else if(Bt(t))Zn(t.value,n);else for(r=(o=Object.keys(t)).length;r--;)Zn(t[o[r]],n)}}var Gn=0,Xn=function(){function t(t,e,n,r,o){!function(t,e){void 0===e&&(e=Me),e&&e.active&&e.effects.push(t)}(this,Me&&!Me._vm?Me:t?t._scope:void 0),(this.vm=t)&&o&&(t._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++Gn,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new st,this.newDepIds=new st,this.expression="",a(e)?this.getter=e:(this.getter=function(t){if(!K.test(t)){var e=t.split(".");return function(t){for(var n=0;n<e.length;n++){if(!t)return;t=t[e[n]]}return t}}}(e),this.getter||(this.getter=E)),this.value=this.lazy?void 0:this.get()}return t.prototype.get=function(){var t;bt(this);var e=this.vm;try{t=this.getter.call(e,e)}catch(t){if(!this.user)throw t;yn(t,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Wn(t),$t(),this.cleanupDeps()}return t},t.prototype.addDep=function(t){var e=t.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(t),this.depIds.has(e)||t.addSub(this))},t.prototype.cleanupDeps=function(){for(var t=this.deps.length;t--;){var e=this.deps[t];this.newDepIds.has(e.id)||e.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},t.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():un(this)},t.prototype.run=function(){if(this.active){var t=this.get();if(t!==this.value||s(t)||this.deep){var e=this.value;if(this.value=t,this.user){var n='callback for watcher "'.concat(this.expression,'"');_n(this.cb,this.vm,[t,e],this.vm,n)}else this.cb.call(this.vm,t,e)}}},t.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},t.prototype.depend=function(){for(var t=this.deps.length;t--;)this.deps[t].depend()},t.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&y(this.vm._scope.effects,this),this.active){for(var t=this.deps.length;t--;)this.deps[t].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},t}(),Yn={enumerable:!0,configurable:!0,get:E,set:E};function Qn(t,e,n){Yn.get=function(){return this[e][n]},Yn.set=function(t){this[e][n]=t},Object.defineProperty(t,n,Yn)}function tr(t){var n=t.$options;if(n.props&&function(t,e){var n=t.$options.propsData||{},r=t._props=Mt({}),o=t.$options._propKeys=[],i=!t.$parent;i||Ot(!1);var a=function(i){o.push(i);var a=Sr(i,e,n,t);Et(r,i,a,void 0,!0),i in t||Qn(t,"_props",i)};for(var s in e)a(s);Ot(!0)}(t,n.props),function(t){var e=t.$options,n=e.setup;if(n){var r=t._setupContext=Ae(t);lt(t),bt();var o=_n(n,null,[t._props||Mt({}),r],t,"setup");if($t(),lt(),a(o))e.render=o;else if(s(o))if(t._setupState=o,o.__sfc){var i=t._setupProxy={};for(var c in o)"__sfc"!==c&&zt(i,o,c)}else for(var c in o)z(c)||zt(t,o,c)}}(t),n.methods&&function(t,e){for(var n in t.$options.props,e)t[n]="function"!=typeof e[n]?E:O(e[n],t)}(t,n.methods),n.data)!function(t){var e=t.$options.data;e=t._data=a(e)?function(t,e){bt();try{return t.call(e,e)}catch(t){return yn(t,e,"data()"),{}}finally{$t()}}(e,t):e||{},u(e)||(e={});var n=Object.keys(e),r=t.$options.props;t.$options.methods;var o=n.length;for(;o--;){var i=n[o];r&&b(r,i)||z(i)||Qn(t,"_data",i)}var s=jt(e);s&&s.vmCount++}(t);else{var r=jt(t._data={});r&&r.vmCount++}n.computed&&function(t,e){var n=t._computedWatchers=Object.create(null),r=ot();for(var o in e){var i=e[o],s=a(i)?i:i.get;r||(n[o]=new Xn(t,s||E,E,er)),o in t||nr(t,o,i)}}(t,n.computed),n.watch&&n.watch!==et&&function(t,n){for(var r in n){var o=n[r];if(e(o))for(var i=0;i<o.length;i++)ir(t,r,o[i]);else ir(t,r,o)}}(t,n.watch)}var er={lazy:!0};function nr(t,e,n){var r=!ot();a(n)?(Yn.get=r?rr(e):or(n),Yn.set=E):(Yn.get=n.get?r&&!1!==n.cache?rr(e):or(n.get):E,Yn.set=n.set||E),Object.defineProperty(t,e,Yn)}function rr(t){return function(){var e=this._computedWatchers&&this._computedWatchers[t];if(e)return e.dirty&&e.evaluate(),yt.target&&e.depend(),e.value}}function or(t){return function(){return t.call(this,this)}}function ir(t,e,n,r){return u(n)&&(r=n,n=n.handler),"string"==typeof n&&(n=t[n]),t.$watch(e,n,r)}function ar(t,e){if(t){for(var n=Object.create(null),r=ct?Reflect.ownKeys(t):Object.keys(t),o=0;o<r.length;o++){var i=r[o];if("__ob__"!==i){var s=t[i].from;if(s in e._provided)n[i]=e._provided[s];else if("default"in t[i]){var c=t[i].default;n[i]=a(c)?c.call(e):c}}}return n}}var sr=0;function cr(t){var e=t.options;if(t.super){var n=cr(t.super);if(n!==t.superOptions){t.superOptions=n;var r=function(t){var e,n=t.options,r=t.sealedOptions;for(var o in n)n[o]!==r[o]&&(e||(e={}),e[o]=n[o]);return e}(t);r&&A(t.extendOptions,r),(e=t.options=Cr(n,t.extendOptions)).name&&(e.components[e.name]=t)}}return e}function ur(n,r,i,a,s){var c,u=this,l=s.options;b(a,"_uid")?(c=Object.create(a))._original=a:(c=a,a=a._original);var f=o(l._compiled),d=!f;this.data=n,this.props=r,this.children=i,this.parent=a,this.listeners=n.on||t,this.injections=ar(l.inject,a),this.slots=function(){return u.$slots||Se(a,n.scopedSlots,u.$slots=xe(i,a)),u.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return Se(a,n.scopedSlots,this.slots())}}),f&&(this.$options=l,this.$slots=this.slots(),this.$scopedSlots=Se(a,n.scopedSlots,this.$slots)),l._scopeId?this._c=function(t,n,r,o){var i=ae(c,t,n,r,o,d);return i&&!e(i)&&(i.fnScopeId=l._scopeId,i.fnContext=a),i}:this._c=function(t,e,n,r){return ae(c,t,e,n,r,d)}}function lr(t,e,n,r,o){var i=vt(t);return i.fnContext=n,i.fnOptions=r,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function fr(t,e){for(var n in e)t[x(n)]=e[n]}function dr(t){return t.name||t.__name||t._componentTag}we(ur.prototype);var pr={init:function(t,e){if(t.componentInstance&&!t.componentInstance._isDestroyed&&t.data.keepAlive){var n=t;pr.prepatch(n,n)}else{(t.componentInstance=function(t,e){var n={_isComponent:!0,_parentVnode:t,parent:e},o=t.data.inlineTemplate;r(o)&&(n.render=o.render,n.staticRenderFns=o.staticRenderFns);return new t.componentOptions.Ctor(n)}(t,Ke)).$mount(e?t.elm:void 0,e)}},prepatch:function(e,n){var r=n.componentOptions;!function(e,n,r,o,i){var a=o.data.scopedSlots,s=e.$scopedSlots,c=!!(a&&!a.$stable||s!==t&&!s.$stable||a&&e.$scopedSlots.$key!==a.$key||!a&&e.$scopedSlots.$key),u=!!(i||e.$options._renderChildren||c),l=e.$vnode;e.$options._parentVnode=o,e.$vnode=o,e._vnode&&(e._vnode.parent=o),e.$options._renderChildren=i;var f=o.data.attrs||t;e._attrsProxy&&je(e._attrsProxy,f,l.data&&l.data.attrs||t,e,"$attrs")&&(u=!0),e.$attrs=f,r=r||t;var d=e.$options._parentListeners;if(e._listenersProxy&&je(e._listenersProxy,r,d||t,e,"$listeners"),e.$listeners=e.$options._parentListeners=r,Ue(e,r,d),n&&e.$options.props){Ot(!1);for(var p=e._props,v=e.$options._propKeys||[],h=0;h<v.length;h++){var m=v[h],g=e.$options.props;p[m]=Sr(m,g,n,e)}Ot(!0),e.$options.propsData=n}u&&(e.$slots=xe(i,o.context),e.$forceUpdate())}(n.componentInstance=e.componentInstance,r.propsData,r.listeners,n,r.children)},insert:function(t){var e,n=t.context,r=t.componentInstance;r._isMounted||(r._isMounted=!0,Ge(r,"mounted")),t.data.keepAlive&&(n._isMounted?((e=r)._inactive=!1,Ye.push(e)):We(r,!0))},destroy:function(t){var e=t.componentInstance;e._isDestroyed||(t.data.keepAlive?Ze(e,!0):e.$destroy())}},vr=Object.keys(pr);function hr(i,a,c,u,l){if(!n(i)){var d=c.$options._base;if(s(i)&&(i=d.extend(i)),"function"==typeof i){var p;if(n(i.cid)&&(i=function(t,e){if(o(t.error)&&r(t.errorComp))return t.errorComp;if(r(t.resolved))return t.resolved;var i=Ie;if(i&&r(t.owners)&&-1===t.owners.indexOf(i)&&t.owners.push(i),o(t.loading)&&r(t.loadingComp))return t.loadingComp;if(i&&!r(t.owners)){var a=t.owners=[i],c=!0,u=null,l=null;i.$on("hook:destroyed",(function(){return y(a,i)}));var d=function(t){for(var e=0,n=a.length;e<n;e++)a[e].$forceUpdate();t&&(a.length=0,null!==u&&(clearTimeout(u),u=null),null!==l&&(clearTimeout(l),l=null))},p=I((function(n){t.resolved=Le(n,e),c?a.length=0:d(!0)})),v=I((function(e){r(t.errorComp)&&(t.error=!0,d(!0))})),h=t(p,v);return s(h)&&(f(h)?n(t.resolved)&&h.then(p,v):f(h.component)&&(h.component.then(p,v),r(h.error)&&(t.errorComp=Le(h.error,e)),r(h.loading)&&(t.loadingComp=Le(h.loading,e),0===h.delay?t.loading=!0:u=setTimeout((function(){u=null,n(t.resolved)&&n(t.error)&&(t.loading=!0,d(!1))}),h.delay||200)),r(h.timeout)&&(l=setTimeout((function(){l=null,n(t.resolved)&&v(null)}),h.timeout)))),c=!1,t.loading?t.loadingComp:t.resolved}}(p=i,d),void 0===i))return function(t,e,n,r,o){var i=dt();return i.asyncFactory=t,i.asyncMeta={data:e,context:n,children:r,tag:o},i}(p,a,c,u,l);a=a||{},cr(i),r(a.model)&&function(t,n){var o=t.model&&t.model.prop||"value",i=t.model&&t.model.event||"input";(n.attrs||(n.attrs={}))[o]=n.model.value;var a=n.on||(n.on={}),s=a[i],c=n.model.callback;r(s)?(e(s)?-1===s.indexOf(c):s!==c)&&(a[i]=[c].concat(s)):a[i]=c}(i.options,a);var v=function(t,e,o){var i=e.options.props;if(!n(i)){var a={},s=t.attrs,c=t.props;if(r(s)||r(c))for(var u in i){var l=S(u);te(a,c,u,l,!0)||te(a,s,u,l,!1)}return a}}(a,i);if(o(i.options.functional))return function(n,o,i,a,s){var c=n.options,u={},l=c.props;if(r(l))for(var f in l)u[f]=Sr(f,l,o||t);else r(i.attrs)&&fr(u,i.attrs),r(i.props)&&fr(u,i.props);var d=new ur(i,u,s,a,n),p=c.render.call(null,d._c,d);if(p instanceof ft)return lr(p,i,d.parent,c);if(e(p)){for(var v=ee(p)||[],h=new Array(v.length),m=0;m<v.length;m++)h[m]=lr(v[m],i,d.parent,c);return h}}(i,v,a,c,u);var h=a.on;if(a.on=a.nativeOn,o(i.options.abstract)){var m=a.slot;a={},m&&(a.slot=m)}!function(t){for(var e=t.hook||(t.hook={}),n=0;n<vr.length;n++){var r=vr[n],o=e[r],i=pr[r];o===i||o&&o._merged||(e[r]=o?mr(i,o):i)}}(a);var g=dr(i.options)||l;return new ft("vue-component-".concat(i.cid).concat(g?"-".concat(g):""),a,void 0,void 0,void 0,c,{Ctor:i,propsData:v,listeners:h,tag:l,children:u},p)}}}function mr(t,e){var n=function(n,r){t(n,r),e(n,r)};return n._merged=!0,n}var gr=E,yr=B.optionMergeStrategies;function _r(t,e,n){if(void 0===n&&(n=!0),!e)return t;for(var r,o,i,a=ct?Reflect.ownKeys(e):Object.keys(e),s=0;s<a.length;s++)"__ob__"!==(r=a[s])&&(o=t[r],i=e[r],n&&b(t,r)?o!==i&&u(o)&&u(i)&&_r(o,i):Nt(t,r,i));return t}function br(t,e,n){return n?function(){var r=a(e)?e.call(n,n):e,o=a(t)?t.call(n,n):t;return r?_r(r,o):o}:e?t?function(){return _r(a(e)?e.call(this,this):e,a(t)?t.call(this,this):t)}:e:t}function $r(t,n){var r=n?t?t.concat(n):e(n)?n:[n]:t;return r?function(t){for(var e=[],n=0;n<t.length;n++)-1===e.indexOf(t[n])&&e.push(t[n]);return e}(r):r}function wr(t,e,n,r){var o=Object.create(t||null);return e?A(o,e):o}yr.data=function(t,e,n){return n?br(t,e,n):e&&"function"!=typeof e?t:br(t,e)},H.forEach((function(t){yr[t]=$r})),F.forEach((function(t){yr[t+"s"]=wr})),yr.watch=function(t,n,r,o){if(t===et&&(t=void 0),n===et&&(n=void 0),!n)return Object.create(t||null);if(!t)return n;var i={};for(var a in A(i,t),n){var s=i[a],c=n[a];s&&!e(s)&&(s=[s]),i[a]=s?s.concat(c):e(c)?c:[c]}return i},yr.props=yr.methods=yr.inject=yr.computed=function(t,e,n,r){if(!t)return e;var o=Object.create(null);return A(o,t),e&&A(o,e),o},yr.provide=function(t,e){return t?function(){var n=Object.create(null);return _r(n,a(t)?t.call(this):t),e&&_r(n,a(e)?e.call(this):e,!1),n}:e};var xr=function(t,e){return void 0===e?t:e};function Cr(t,n,r){if(a(n)&&(n=n.options),function(t,n){var r=t.props;if(r){var o,i,a={};if(e(r))for(o=r.length;o--;)"string"==typeof(i=r[o])&&(a[x(i)]={type:null});else if(u(r))for(var s in r)i=r[s],a[x(s)]=u(i)?i:{type:i};t.props=a}}(n),function(t,n){var r=t.inject;if(r){var o=t.inject={};if(e(r))for(var i=0;i<r.length;i++)o[r[i]]={from:r[i]};else if(u(r))for(var a in r){var s=r[a];o[a]=u(s)?A({from:a},s):{from:s}}}}(n),function(t){var e=t.directives;if(e)for(var n in e){var r=e[n];a(r)&&(e[n]={bind:r,update:r})}}(n),!n._base&&(n.extends&&(t=Cr(t,n.extends,r)),n.mixins))for(var o=0,i=n.mixins.length;o<i;o++)t=Cr(t,n.mixins[o],r);var s,c={};for(s in t)l(s);for(s in n)b(t,s)||l(s);function l(e){var o=yr[e]||xr;c[e]=o(t[e],n[e],r,e)}return c}function kr(t,e,n,r){if("string"==typeof n){var o=t[e];if(b(o,n))return o[n];var i=x(n);if(b(o,i))return o[i];var a=C(i);return b(o,a)?o[a]:o[n]||o[i]||o[a]}}function Sr(t,e,n,r){var o=e[t],i=!b(n,t),s=n[t],c=jr(Boolean,o.type);if(c>-1)if(i&&!b(o,"default"))s=!1;else if(""===s||s===S(t)){var u=jr(String,o.type);(u<0||c<u)&&(s=!0)}if(void 0===s){s=function(t,e,n){if(!b(e,"default"))return;var r=e.default;if(t&&t.$options.propsData&&void 0===t.$options.propsData[n]&&void 0!==t._props[n])return t._props[n];return a(r)&&"Function"!==Tr(e.type)?r.call(t):r}(r,o,t);var l=St;Ot(!0),jt(s),Ot(l)}return s}var Or=/^\s*function (\w+)/;function Tr(t){var e=t&&t.toString().match(Or);return e?e[1]:""}function Ar(t,e){return Tr(t)===Tr(e)}function jr(t,n){if(!e(n))return Ar(n,t)?0:-1;for(var r=0,o=n.length;r<o;r++)if(Ar(n[r],t))return r;return-1}function Er(t){this._init(t)}function Nr(t){t.cid=0;var e=1;t.extend=function(t){t=t||{};var n=this,r=n.cid,o=t._Ctor||(t._Ctor={});if(o[r])return o[r];var i=dr(t)||dr(n.options),a=function(t){this._init(t)};return(a.prototype=Object.create(n.prototype)).constructor=a,a.cid=e++,a.options=Cr(n.options,t),a.super=n,a.options.props&&function(t){var e=t.options.props;for(var n in e)Qn(t.prototype,"_props",n)}(a),a.options.computed&&function(t){var e=t.options.computed;for(var n in e)nr(t.prototype,n,e[n])}(a),a.extend=n.extend,a.mixin=n.mixin,a.use=n.use,F.forEach((function(t){a[t]=n[t]})),i&&(a.options.components[i]=a),a.superOptions=n.options,a.extendOptions=t,a.sealedOptions=A({},a.options),o[r]=a,a}}function Pr(t){return t&&(dr(t.Ctor.options)||t.tag)}function Dr(t,n){return e(t)?t.indexOf(n)>-1:"string"==typeof t?t.split(",").indexOf(n)>-1:(r=t,"[object RegExp]"===c.call(r)&&t.test(n));var r}function Mr(t,e){var n=t.cache,r=t.keys,o=t._vnode,i=t.$vnode;for(var a in n){var s=n[a];if(s){var c=s.name;c&&!e(c)&&Ir(n,a,r,o)}}i.componentOptions.children=void 0}function Ir(t,e,n,r){var o=t[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),t[e]=null,y(n,e)}!function(e){e.prototype._init=function(e){var n=this;n._uid=sr++,n._isVue=!0,n.__v_skip=!0,n._scope=new ze(!0),n._scope.parent=void 0,n._scope._vm=!0,e&&e._isComponent?function(t,e){var n=t.$options=Object.create(t.constructor.options),r=e._parentVnode;n.parent=e.parent,n._parentVnode=r;var o=r.componentOptions;n.propsData=o.propsData,n._parentListeners=o.listeners,n._renderChildren=o.children,n._componentTag=o.tag,e.render&&(n.render=e.render,n.staticRenderFns=e.staticRenderFns)}(n,e):n.$options=Cr(cr(n.constructor),e||{},n),n._renderProxy=n,n._self=n,function(t){var e=t.$options,n=e.parent;if(n&&!e.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(t)}t.$parent=n,t.$root=n?n.$root:t,t.$children=[],t.$refs={},t._provided=n?n._provided:Object.create(null),t._watcher=null,t._inactive=null,t._directInactive=!1,t._isMounted=!1,t._isDestroyed=!1,t._isBeingDestroyed=!1}(n),function(t){t._events=Object.create(null),t._hasHookEvent=!1;var e=t.$options._parentListeners;e&&Ue(t,e)}(n),function(e){e._vnode=null,e._staticTrees=null;var n=e.$options,r=e.$vnode=n._parentVnode,o=r&&r.context;e.$slots=xe(n._renderChildren,o),e.$scopedSlots=r?Se(e.$parent,r.data.scopedSlots,e.$slots):t,e._c=function(t,n,r,o){return ae(e,t,n,r,o,!1)},e.$createElement=function(t,n,r,o){return ae(e,t,n,r,o,!0)};var i=r&&r.data;Et(e,"$attrs",i&&i.attrs||t,null,!0),Et(e,"$listeners",n._parentListeners||t,null,!0)}(n),Ge(n,"beforeCreate",void 0,!1),function(t){var e=ar(t.$options.inject,t);e&&(Ot(!1),Object.keys(e).forEach((function(n){Et(t,n,e[n])})),Ot(!0))}(n),tr(n),function(t){var e=t.$options.provide;if(e){var n=a(e)?e.call(t):e;if(!s(n))return;for(var r=gn(t),o=ct?Reflect.ownKeys(n):Object.keys(n),i=0;i<o.length;i++){var c=o[i];Object.defineProperty(r,c,Object.getOwnPropertyDescriptor(n,c))}}}(n),Ge(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(Er),function(t){var e={get:function(){return this._data}},n={get:function(){return this._props}};Object.defineProperty(t.prototype,"$data",e),Object.defineProperty(t.prototype,"$props",n),t.prototype.$set=Nt,t.prototype.$delete=Pt,t.prototype.$watch=function(t,e,n){var r=this;if(u(e))return ir(r,t,e,n);(n=n||{}).user=!0;var o=new Xn(r,t,e,n);if(n.immediate){var i='callback for immediate watcher "'.concat(o.expression,'"');bt(),_n(e,r,[o.value],r,i),$t()}return function(){o.teardown()}}}(Er),function(t){var n=/^hook:/;t.prototype.$on=function(t,r){var o=this;if(e(t))for(var i=0,a=t.length;i<a;i++)o.$on(t[i],r);else(o._events[t]||(o._events[t]=[])).push(r),n.test(t)&&(o._hasHookEvent=!0);return o},t.prototype.$once=function(t,e){var n=this;function r(){n.$off(t,r),e.apply(n,arguments)}return r.fn=e,n.$on(t,r),n},t.prototype.$off=function(t,n){var r=this;if(!arguments.length)return r._events=Object.create(null),r;if(e(t)){for(var o=0,i=t.length;o<i;o++)r.$off(t[o],n);return r}var a,s=r._events[t];if(!s)return r;if(!n)return r._events[t]=null,r;for(var c=s.length;c--;)if((a=s[c])===n||a.fn===n){s.splice(c,1);break}return r},t.prototype.$emit=function(t){var e=this,n=e._events[t];if(n){n=n.length>1?T(n):n;for(var r=T(arguments,1),o='event handler for "'.concat(t,'"'),i=0,a=n.length;i<a;i++)_n(n[i],e,r,e,o)}return e}}(Er),function(t){t.prototype._update=function(t,e){var n=this,r=n.$el,o=n._vnode,i=Je(n);n._vnode=t,n.$el=o?n.__patch__(o,t):n.__patch__(n.$el,t,e,!1),i(),r&&(r.__vue__=null),n.$el&&(n.$el.__vue__=n);for(var a=n;a&&a.$vnode&&a.$parent&&a.$vnode===a.$parent._vnode;)a.$parent.$el=a.$el,a=a.$parent},t.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},t.prototype.$destroy=function(){var t=this;if(!t._isBeingDestroyed){Ge(t,"beforeDestroy"),t._isBeingDestroyed=!0;var e=t.$parent;!e||e._isBeingDestroyed||t.$options.abstract||y(e.$children,t),t._scope.stop(),t._data.__ob__&&t._data.__ob__.vmCount--,t._isDestroyed=!0,t.__patch__(t._vnode,null),Ge(t,"destroyed"),t.$off(),t.$el&&(t.$el.__vue__=null),t.$vnode&&(t.$vnode.parent=null)}}}(Er),function(t){we(t.prototype),t.prototype.$nextTick=function(t){return En(t,this)},t.prototype._render=function(){var t=this,n=t.$options,r=n.render,o=n._parentVnode;o&&t._isMounted&&(t.$scopedSlots=Se(t.$parent,o.data.scopedSlots,t.$slots,t.$scopedSlots),t._slotsProxy&&Ne(t._slotsProxy,t.$scopedSlots)),t.$vnode=o;var i,a=ut,s=Ie;try{lt(t),Ie=t,i=r.call(t._renderProxy,t.$createElement)}catch(e){yn(e,t,"render"),i=t._vnode}finally{Ie=s,lt(a)}return e(i)&&1===i.length&&(i=i[0]),i instanceof ft||(i=dt()),i.parent=o,i}}(Er);var Lr=[String,RegExp,Array],Rr={name:"keep-alive",abstract:!0,props:{include:Lr,exclude:Lr,max:[String,Number]},methods:{cacheVNode:function(){var t=this,e=t.cache,n=t.keys,r=t.vnodeToCache,o=t.keyToCache;if(r){var i=r.tag,a=r.componentInstance,s=r.componentOptions;e[o]={name:Pr(s),tag:i,componentInstance:a},n.push(o),this.max&&n.length>parseInt(this.max)&&Ir(e,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var t in this.cache)Ir(this.cache,t,this.keys)},mounted:function(){var t=this;this.cacheVNode(),this.$watch("include",(function(e){Mr(t,(function(t){return Dr(e,t)}))})),this.$watch("exclude",(function(e){Mr(t,(function(t){return!Dr(e,t)}))}))},updated:function(){this.cacheVNode()},render:function(){var t=this.$slots.default,e=Re(t),n=e&&e.componentOptions;if(n){var r=Pr(n),o=this.include,i=this.exclude;if(o&&(!r||!Dr(o,r))||i&&r&&Dr(i,r))return e;var a=this.cache,s=this.keys,c=null==e.key?n.Ctor.cid+(n.tag?"::".concat(n.tag):""):e.key;a[c]?(e.componentInstance=a[c].componentInstance,y(s,c),s.push(c)):(this.vnodeToCache=e,this.keyToCache=c),e.data.keepAlive=!0}return e||t&&t[0]}},Fr={KeepAlive:Rr};!function(t){var e={get:function(){return B}};Object.defineProperty(t,"config",e),t.util={warn:gr,extend:A,mergeOptions:Cr,defineReactive:Et},t.set=Nt,t.delete=Pt,t.nextTick=En,t.observable=function(t){return jt(t),t},t.options=Object.create(null),F.forEach((function(e){t.options[e+"s"]=Object.create(null)})),t.options._base=t,A(t.options.components,Fr),function(t){t.use=function(t){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(t)>-1)return this;var n=T(arguments,1);return n.unshift(this),a(t.install)?t.install.apply(t,n):a(t)&&t.apply(null,n),e.push(t),this}}(t),function(t){t.mixin=function(t){return this.options=Cr(this.options,t),this}}(t),Nr(t),function(t){F.forEach((function(e){t[e]=function(t,n){return n?("component"===e&&u(n)&&(n.name=n.name||t,n=this.options._base.extend(n)),"directive"===e&&a(n)&&(n={bind:n,update:n}),this.options[e+"s"][t]=n,n):this.options[e+"s"][t]}}))}(t)}(Er),Object.defineProperty(Er.prototype,"$isServer",{get:ot}),Object.defineProperty(Er.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Er,"FunctionalRenderContext",{value:ur}),Er.version=Kn;var Hr=h("style,class"),Br=h("input,textarea,option,select,progress"),Ur=function(t,e,n){return"value"===n&&Br(t)&&"button"!==e||"selected"===n&&"option"===t||"checked"===n&&"input"===t||"muted"===n&&"video"===t},zr=h("contenteditable,draggable,spellcheck"),Vr=h("events,caret,typing,plaintext-only"),Kr=function(t,e){return Gr(e)||"false"===e?"false":"contenteditable"===t&&Vr(e)?e:"true"},Jr=h("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),qr="http://www.w3.org/1999/xlink",Wr=function(t){return":"===t.charAt(5)&&"xlink"===t.slice(0,5)},Zr=function(t){return Wr(t)?t.slice(6,t.length):""},Gr=function(t){return null==t||!1===t};function Xr(t){for(var e=t.data,n=t,o=t;r(o.componentInstance);)(o=o.componentInstance._vnode)&&o.data&&(e=Yr(o.data,e));for(;r(n=n.parent);)n&&n.data&&(e=Yr(e,n.data));return function(t,e){if(r(t)||r(e))return Qr(t,to(e));return""}(e.staticClass,e.class)}function Yr(t,e){return{staticClass:Qr(t.staticClass,e.staticClass),class:r(t.class)?[t.class,e.class]:e.class}}function Qr(t,e){return t?e?t+" "+e:t:e||""}function to(t){return Array.isArray(t)?function(t){for(var e,n="",o=0,i=t.length;o<i;o++)r(e=to(t[o]))&&""!==e&&(n&&(n+=" "),n+=e);return n}(t):s(t)?function(t){var e="";for(var n in t)t[n]&&(e&&(e+=" "),e+=n);return e}(t):"string"==typeof t?t:""}var eo={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},no=h("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ro=h("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),oo=function(t){return no(t)||ro(t)};function io(t){return ro(t)?"svg":"math"===t?"math":void 0}var ao=Object.create(null);var so=h("text,number,password,search,email,tel,url");function co(t){if("string"==typeof t){var e=document.querySelector(t);return e||document.createElement("div")}return t}var uo=Object.freeze({__proto__:null,createElement:function(t,e){var n=document.createElement(t);return"select"!==t||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(t,e){return document.createElementNS(eo[t],e)},createTextNode:function(t){return document.createTextNode(t)},createComment:function(t){return document.createComment(t)},insertBefore:function(t,e,n){t.insertBefore(e,n)},removeChild:function(t,e){t.removeChild(e)},appendChild:function(t,e){t.appendChild(e)},parentNode:function(t){return t.parentNode},nextSibling:function(t){return t.nextSibling},tagName:function(t){return t.tagName},setTextContent:function(t,e){t.textContent=e},setStyleScope:function(t,e){t.setAttribute(e,"")}}),lo={create:function(t,e){fo(e)},update:function(t,e){t.data.ref!==e.data.ref&&(fo(t,!0),fo(e))},destroy:function(t){fo(t,!0)}};function fo(t,n){var o=t.data.ref;if(r(o)){var i=t.context,s=t.componentInstance||t.elm,c=n?null:s,u=n?void 0:s;if(a(o))_n(o,i,[c],i,"template ref function");else{var l=t.data.refInFor,f="string"==typeof o||"number"==typeof o,d=Bt(o),p=i.$refs;if(f||d)if(l){var v=f?p[o]:o.value;n?e(v)&&y(v,s):e(v)?v.includes(s)||v.push(s):f?(p[o]=[s],po(i,o,p[o])):o.value=[s]}else if(f){if(n&&p[o]!==s)return;p[o]=u,po(i,o,c)}else if(d){if(n&&o.value!==s)return;o.value=c}}}}function po(t,e,n){var r=t._setupState;r&&b(r,e)&&(Bt(r[e])?r[e].value=n:r[e]=n)}var vo=new ft("",{},[]),ho=["create","activate","update","remove","destroy"];function mo(t,e){return t.key===e.key&&t.asyncFactory===e.asyncFactory&&(t.tag===e.tag&&t.isComment===e.isComment&&r(t.data)===r(e.data)&&function(t,e){if("input"!==t.tag)return!0;var n,o=r(n=t.data)&&r(n=n.attrs)&&n.type,i=r(n=e.data)&&r(n=n.attrs)&&n.type;return o===i||so(o)&&so(i)}(t,e)||o(t.isAsyncPlaceholder)&&n(e.asyncFactory.error))}function go(t,e,n){var o,i,a={};for(o=e;o<=n;++o)r(i=t[o].key)&&(a[i]=o);return a}var yo={create:_o,update:_o,destroy:function(t){_o(t,vo)}};function _o(t,e){(t.data.directives||e.data.directives)&&function(t,e){var n,r,o,i=t===vo,a=e===vo,s=$o(t.data.directives,t.context),c=$o(e.data.directives,e.context),u=[],l=[];for(n in c)r=s[n],o=c[n],r?(o.oldValue=r.value,o.oldArg=r.arg,xo(o,"update",e,t),o.def&&o.def.componentUpdated&&l.push(o)):(xo(o,"bind",e,t),o.def&&o.def.inserted&&u.push(o));if(u.length){var f=function(){for(var n=0;n<u.length;n++)xo(u[n],"inserted",e,t)};i?Qt(e,"insert",f):f()}l.length&&Qt(e,"postpatch",(function(){for(var n=0;n<l.length;n++)xo(l[n],"componentUpdated",e,t)}));if(!i)for(n in s)c[n]||xo(s[n],"unbind",t,t,a)}(t,e)}var bo=Object.create(null);function $o(t,e){var n,r,o=Object.create(null);if(!t)return o;for(n=0;n<t.length;n++){if((r=t[n]).modifiers||(r.modifiers=bo),o[wo(r)]=r,e._setupState&&e._setupState.__sfc){var i=r.def||kr(e,"_setupState","v-"+r.name);r.def="function"==typeof i?{bind:i,update:i}:i}r.def=r.def||kr(e.$options,"directives",r.name)}return o}function wo(t){return t.rawName||"".concat(t.name,".").concat(Object.keys(t.modifiers||{}).join("."))}function xo(t,e,n,r,o){var i=t.def&&t.def[e];if(i)try{i(n.elm,t,n,r,o)}catch(r){yn(r,n.context,"directive ".concat(t.name," ").concat(e," hook"))}}var Co=[lo,yo];function ko(t,e){var i=e.componentOptions;if(!(r(i)&&!1===i.Ctor.options.inheritAttrs||n(t.data.attrs)&&n(e.data.attrs))){var a,s,c=e.elm,u=t.data.attrs||{},l=e.data.attrs||{};for(a in(r(l.__ob__)||o(l._v_attr_proxy))&&(l=e.data.attrs=A({},l)),l)s=l[a],u[a]!==s&&So(c,a,s,e.data.pre);for(a in(Z||X)&&l.value!==u.value&&So(c,"value",l.value),u)n(l[a])&&(Wr(a)?c.removeAttributeNS(qr,Zr(a)):zr(a)||c.removeAttribute(a))}}function So(t,e,n,r){r||t.tagName.indexOf("-")>-1?Oo(t,e,n):Jr(e)?Gr(n)?t.removeAttribute(e):(n="allowfullscreen"===e&&"EMBED"===t.tagName?"true":e,t.setAttribute(e,n)):zr(e)?t.setAttribute(e,Kr(e,n)):Wr(e)?Gr(n)?t.removeAttributeNS(qr,Zr(e)):t.setAttributeNS(qr,e,n):Oo(t,e,n)}function Oo(t,e,n){if(Gr(n))t.removeAttribute(e);else{if(Z&&!G&&"TEXTAREA"===t.tagName&&"placeholder"===e&&""!==n&&!t.__ieph){var r=function(e){e.stopImmediatePropagation(),t.removeEventListener("input",r)};t.addEventListener("input",r),t.__ieph=!0}t.setAttribute(e,n)}}var To={create:ko,update:ko};function Ao(t,e){var o=e.elm,i=e.data,a=t.data;if(!(n(i.staticClass)&&n(i.class)&&(n(a)||n(a.staticClass)&&n(a.class)))){var s=Xr(e),c=o._transitionClasses;r(c)&&(s=Qr(s,to(c))),s!==o._prevClass&&(o.setAttribute("class",s),o._prevClass=s)}}var jo,Eo,No,Po,Do,Mo,Io={create:Ao,update:Ao},Lo=/[\w).+\-_$\]]/;function Ro(t){var e,n,r,o,i,a=!1,s=!1,c=!1,u=!1,l=0,f=0,d=0,p=0;for(r=0;r<t.length;r++)if(n=e,e=t.charCodeAt(r),a)39===e&&92!==n&&(a=!1);else if(s)34===e&&92!==n&&(s=!1);else if(c)96===e&&92!==n&&(c=!1);else if(u)47===e&&92!==n&&(u=!1);else if(124!==e||124===t.charCodeAt(r+1)||124===t.charCodeAt(r-1)||l||f||d){switch(e){case 34:s=!0;break;case 39:a=!0;break;case 96:c=!0;break;case 40:d++;break;case 41:d--;break;case 91:f++;break;case 93:f--;break;case 123:l++;break;case 125:l--}if(47===e){for(var v=r-1,h=void 0;v>=0&&" "===(h=t.charAt(v));v--);h&&Lo.test(h)||(u=!0)}}else void 0===o?(p=r+1,o=t.slice(0,r).trim()):m();function m(){(i||(i=[])).push(t.slice(p,r).trim()),p=r+1}if(void 0===o?o=t.slice(0,r).trim():0!==p&&m(),i)for(r=0;r<i.length;r++)o=Fo(o,i[r]);return o}function Fo(t,e){var n=e.indexOf("(");if(n<0)return'_f("'.concat(e,'")(').concat(t,")");var r=e.slice(0,n),o=e.slice(n+1);return'_f("'.concat(r,'")(').concat(t).concat(")"!==o?","+o:o)}function Ho(t,e){console.error("[Vue compiler]: ".concat(t))}function Bo(t,e){return t?t.map((function(t){return t[e]})).filter((function(t){return t})):[]}function Uo(t,e,n,r,o){(t.props||(t.props=[])).push(Xo({name:e,value:n,dynamic:o},r)),t.plain=!1}function zo(t,e,n,r,o){(o?t.dynamicAttrs||(t.dynamicAttrs=[]):t.attrs||(t.attrs=[])).push(Xo({name:e,value:n,dynamic:o},r)),t.plain=!1}function Vo(t,e,n,r){t.attrsMap[e]=n,t.attrsList.push(Xo({name:e,value:n},r))}function Ko(t,e,n,r,o,i,a,s){(t.directives||(t.directives=[])).push(Xo({name:e,rawName:n,value:r,arg:o,isDynamicArg:i,modifiers:a},s)),t.plain=!1}function Jo(t,e,n){return n?"_p(".concat(e,',"').concat(t,'")'):t+e}function qo(e,n,r,o,i,a,s,c){var u;(o=o||t).right?c?n="(".concat(n,")==='click'?'contextmenu':(").concat(n,")"):"click"===n&&(n="contextmenu",delete o.right):o.middle&&(c?n="(".concat(n,")==='click'?'mouseup':(").concat(n,")"):"click"===n&&(n="mouseup")),o.capture&&(delete o.capture,n=Jo("!",n,c)),o.once&&(delete o.once,n=Jo("~",n,c)),o.passive&&(delete o.passive,n=Jo("&",n,c)),o.native?(delete o.native,u=e.nativeEvents||(e.nativeEvents={})):u=e.events||(e.events={});var l=Xo({value:r.trim(),dynamic:c},s);o!==t&&(l.modifiers=o);var f=u[n];Array.isArray(f)?i?f.unshift(l):f.push(l):u[n]=f?i?[l,f]:[f,l]:l,e.plain=!1}function Wo(t,e,n){var r=Zo(t,":"+e)||Zo(t,"v-bind:"+e);if(null!=r)return Ro(r);if(!1!==n){var o=Zo(t,e);if(null!=o)return JSON.stringify(o)}}function Zo(t,e,n){var r;if(null!=(r=t.attrsMap[e]))for(var o=t.attrsList,i=0,a=o.length;i<a;i++)if(o[i].name===e){o.splice(i,1);break}return n&&delete t.attrsMap[e],r}function Go(t,e){for(var n=t.attrsList,r=0,o=n.length;r<o;r++){var i=n[r];if(e.test(i.name))return n.splice(r,1),i}}function Xo(t,e){return e&&(null!=e.start&&(t.start=e.start),null!=e.end&&(t.end=e.end)),t}function Yo(t,e,n){var r=n||{},o=r.number,i="$$v",a=i;r.trim&&(a="(typeof ".concat(i," === 'string'")+"? ".concat(i,".trim()")+": ".concat(i,")")),o&&(a="_n(".concat(a,")"));var s=Qo(e,a);t.model={value:"(".concat(e,")"),expression:JSON.stringify(e),callback:"function (".concat(i,") {").concat(s,"}")}}function Qo(t,e){var n=function(t){if(t=t.trim(),jo=t.length,t.indexOf("[")<0||t.lastIndexOf("]")<jo-1)return(Po=t.lastIndexOf("."))>-1?{exp:t.slice(0,Po),key:'"'+t.slice(Po+1)+'"'}:{exp:t,key:null};Eo=t,Po=Do=Mo=0;for(;!ei();)ni(No=ti())?oi(No):91===No&&ri(No);return{exp:t.slice(0,Do),key:t.slice(Do+1,Mo)}}(t);return null===n.key?"".concat(t,"=").concat(e):"$set(".concat(n.exp,", ").concat(n.key,", ").concat(e,")")}function ti(){return Eo.charCodeAt(++Po)}function ei(){return Po>=jo}function ni(t){return 34===t||39===t}function ri(t){var e=1;for(Do=Po;!ei();)if(ni(t=ti()))oi(t);else if(91===t&&e++,93===t&&e--,0===e){Mo=Po;break}}function oi(t){for(var e=t;!ei()&&(t=ti())!==e;);}var ii,ai="__r",si="__c";function ci(t,e,n){var r=ii;return function o(){null!==e.apply(null,arguments)&&fi(t,o,n,r)}}var ui=xn&&!(tt&&Number(tt[1])<=53);function li(t,e,n,r){if(ui){var o=rn,i=e;e=i._wrapper=function(t){if(t.target===t.currentTarget||t.timeStamp>=o||t.timeStamp<=0||t.target.ownerDocument!==document)return i.apply(this,arguments)}}ii.addEventListener(t,e,nt?{capture:n,passive:r}:n)}function fi(t,e,n,r){(r||ii).removeEventListener(t,e._wrapper||e,n)}function di(t,e){if(!n(t.data.on)||!n(e.data.on)){var o=e.data.on||{},i=t.data.on||{};ii=e.elm||t.elm,function(t){if(r(t[ai])){var e=Z?"change":"input";t[e]=[].concat(t[ai],t[e]||[]),delete t[ai]}r(t[si])&&(t.change=[].concat(t[si],t.change||[]),delete t[si])}(o),Yt(o,i,li,fi,ci,e.context),ii=void 0}}var pi,vi={create:di,update:di,destroy:function(t){return di(t,vo)}};function hi(t,e){if(!n(t.data.domProps)||!n(e.data.domProps)){var i,a,s=e.elm,c=t.data.domProps||{},u=e.data.domProps||{};for(i in(r(u.__ob__)||o(u._v_attr_proxy))&&(u=e.data.domProps=A({},u)),c)i in u||(s[i]="");for(i in u){if(a=u[i],"textContent"===i||"innerHTML"===i){if(e.children&&(e.children.length=0),a===c[i])continue;1===s.childNodes.length&&s.removeChild(s.childNodes[0])}if("value"===i&&"PROGRESS"!==s.tagName){s._value=a;var l=n(a)?"":String(a);mi(s,l)&&(s.value=l)}else if("innerHTML"===i&&ro(s.tagName)&&n(s.innerHTML)){(pi=pi||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var f=pi.firstChild;s.firstChild;)s.removeChild(s.firstChild);for(;f.firstChild;)s.appendChild(f.firstChild)}else if(a!==c[i])try{s[i]=a}catch(t){}}}}function mi(t,e){return!t.composing&&("OPTION"===t.tagName||function(t,e){var n=!0;try{n=document.activeElement!==t}catch(t){}return n&&t.value!==e}(t,e)||function(t,e){var n=t.value,o=t._vModifiers;if(r(o)){if(o.number)return v(n)!==v(e);if(o.trim)return n.trim()!==e.trim()}return n!==e}(t,e))}var gi={create:hi,update:hi},yi=$((function(t){var e={},n=/:(.+)/;return t.split(/;(?![^(]*\))/g).forEach((function(t){if(t){var r=t.split(n);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function _i(t){var e=bi(t.style);return t.staticStyle?A(t.staticStyle,e):e}function bi(t){return Array.isArray(t)?j(t):"string"==typeof t?yi(t):t}var $i,wi=/^--/,xi=/\s*!important$/,Ci=function(t,e,n){if(wi.test(e))t.style.setProperty(e,n);else if(xi.test(n))t.style.setProperty(S(e),n.replace(xi,""),"important");else{var r=Si(e);if(Array.isArray(n))for(var o=0,i=n.length;o<i;o++)t.style[r]=n[o];else t.style[r]=n}},ki=["Webkit","Moz","ms"],Si=$((function(t){if($i=$i||document.createElement("div").style,"filter"!==(t=x(t))&&t in $i)return t;for(var e=t.charAt(0).toUpperCase()+t.slice(1),n=0;n<ki.length;n++){var r=ki[n]+e;if(r in $i)return r}}));function Oi(t,e){var o=e.data,i=t.data;if(!(n(o.staticStyle)&&n(o.style)&&n(i.staticStyle)&&n(i.style))){var a,s,c=e.elm,u=i.staticStyle,l=i.normalizedStyle||i.style||{},f=u||l,d=bi(e.data.style)||{};e.data.normalizedStyle=r(d.__ob__)?A({},d):d;var p=function(t,e){var n,r={};if(e)for(var o=t;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(n=_i(o.data))&&A(r,n);(n=_i(t.data))&&A(r,n);for(var i=t;i=i.parent;)i.data&&(n=_i(i.data))&&A(r,n);return r}(e,!0);for(s in f)n(p[s])&&Ci(c,s,"");for(s in p)a=p[s],Ci(c,s,null==a?"":a)}}var Ti={create:Oi,update:Oi},Ai=/\s+/;function ji(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(Ai).forEach((function(e){return t.classList.add(e)})):t.classList.add(e);else{var n=" ".concat(t.getAttribute("class")||""," ");n.indexOf(" "+e+" ")<0&&t.setAttribute("class",(n+e).trim())}}function Ei(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(Ai).forEach((function(e){return t.classList.remove(e)})):t.classList.remove(e),t.classList.length||t.removeAttribute("class");else{for(var n=" ".concat(t.getAttribute("class")||""," "),r=" "+e+" ";n.indexOf(r)>=0;)n=n.replace(r," ");(n=n.trim())?t.setAttribute("class",n):t.removeAttribute("class")}}function Ni(t){if(t){if("object"==typeof t){var e={};return!1!==t.css&&A(e,Pi(t.name||"v")),A(e,t),e}return"string"==typeof t?Pi(t):void 0}}var Pi=$((function(t){return{enterClass:"".concat(t,"-enter"),enterToClass:"".concat(t,"-enter-to"),enterActiveClass:"".concat(t,"-enter-active"),leaveClass:"".concat(t,"-leave"),leaveToClass:"".concat(t,"-leave-to"),leaveActiveClass:"".concat(t,"-leave-active")}})),Di=q&&!G,Mi="transition",Ii="animation",Li="transition",Ri="transitionend",Fi="animation",Hi="animationend";Di&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Li="WebkitTransition",Ri="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Fi="WebkitAnimation",Hi="webkitAnimationEnd"));var Bi=q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(t){return t()};function Ui(t){Bi((function(){Bi(t)}))}function zi(t,e){var n=t._transitionClasses||(t._transitionClasses=[]);n.indexOf(e)<0&&(n.push(e),ji(t,e))}function Vi(t,e){t._transitionClasses&&y(t._transitionClasses,e),Ei(t,e)}function Ki(t,e,n){var r=qi(t,e),o=r.type,i=r.timeout,a=r.propCount;if(!o)return n();var s=o===Mi?Ri:Hi,c=0,u=function(){t.removeEventListener(s,l),n()},l=function(e){e.target===t&&++c>=a&&u()};setTimeout((function(){c<a&&u()}),i+1),t.addEventListener(s,l)}var Ji=/\b(transform|all)(,|$)/;function qi(t,e){var n,r=window.getComputedStyle(t),o=(r[Li+"Delay"]||"").split(", "),i=(r[Li+"Duration"]||"").split(", "),a=Wi(o,i),s=(r[Fi+"Delay"]||"").split(", "),c=(r[Fi+"Duration"]||"").split(", "),u=Wi(s,c),l=0,f=0;return e===Mi?a>0&&(n=Mi,l=a,f=i.length):e===Ii?u>0&&(n=Ii,l=u,f=c.length):f=(n=(l=Math.max(a,u))>0?a>u?Mi:Ii:null)?n===Mi?i.length:c.length:0,{type:n,timeout:l,propCount:f,hasTransform:n===Mi&&Ji.test(r[Li+"Property"])}}function Wi(t,e){for(;t.length<e.length;)t=t.concat(t);return Math.max.apply(null,e.map((function(e,n){return Zi(e)+Zi(t[n])})))}function Zi(t){return 1e3*Number(t.slice(0,-1).replace(",","."))}function Gi(t,e){var o=t.elm;r(o._leaveCb)&&(o._leaveCb.cancelled=!0,o._leaveCb());var i=Ni(t.data.transition);if(!n(i)&&!r(o._enterCb)&&1===o.nodeType){for(var c=i.css,u=i.type,l=i.enterClass,f=i.enterToClass,d=i.enterActiveClass,p=i.appearClass,h=i.appearToClass,m=i.appearActiveClass,g=i.beforeEnter,y=i.enter,_=i.afterEnter,b=i.enterCancelled,$=i.beforeAppear,w=i.appear,x=i.afterAppear,C=i.appearCancelled,k=i.duration,S=Ke,O=Ke.$vnode;O&&O.parent;)S=O.context,O=O.parent;var T=!S._isMounted||!t.isRootInsert;if(!T||w||""===w){var A=T&&p?p:l,j=T&&m?m:d,E=T&&h?h:f,N=T&&$||g,P=T&&a(w)?w:y,D=T&&x||_,M=T&&C||b,L=v(s(k)?k.enter:k),R=!1!==c&&!G,F=Qi(P),H=o._enterCb=I((function(){R&&(Vi(o,E),Vi(o,j)),H.cancelled?(R&&Vi(o,A),M&&M(o)):D&&D(o),o._enterCb=null}));t.data.show||Qt(t,"insert",(function(){var e=o.parentNode,n=e&&e._pending&&e._pending[t.key];n&&n.tag===t.tag&&n.elm._leaveCb&&n.elm._leaveCb(),P&&P(o,H)})),N&&N(o),R&&(zi(o,A),zi(o,j),Ui((function(){Vi(o,A),H.cancelled||(zi(o,E),F||(Yi(L)?setTimeout(H,L):Ki(o,u,H)))}))),t.data.show&&(e&&e(),P&&P(o,H)),R||F||H()}}}function Xi(t,e){var o=t.elm;r(o._enterCb)&&(o._enterCb.cancelled=!0,o._enterCb());var i=Ni(t.data.transition);if(n(i)||1!==o.nodeType)return e();if(!r(o._leaveCb)){var a=i.css,c=i.type,u=i.leaveClass,l=i.leaveToClass,f=i.leaveActiveClass,d=i.beforeLeave,p=i.leave,h=i.afterLeave,m=i.leaveCancelled,g=i.delayLeave,y=i.duration,_=!1!==a&&!G,b=Qi(p),$=v(s(y)?y.leave:y),w=o._leaveCb=I((function(){o.parentNode&&o.parentNode._pending&&(o.parentNode._pending[t.key]=null),_&&(Vi(o,l),Vi(o,f)),w.cancelled?(_&&Vi(o,u),m&&m(o)):(e(),h&&h(o)),o._leaveCb=null}));g?g(x):x()}function x(){w.cancelled||(!t.data.show&&o.parentNode&&((o.parentNode._pending||(o.parentNode._pending={}))[t.key]=t),d&&d(o),_&&(zi(o,u),zi(o,f),Ui((function(){Vi(o,u),w.cancelled||(zi(o,l),b||(Yi($)?setTimeout(w,$):Ki(o,c,w)))}))),p&&p(o,w),_||b||w())}}function Yi(t){return"number"==typeof t&&!isNaN(t)}function Qi(t){if(n(t))return!1;var e=t.fns;return r(e)?Qi(Array.isArray(e)?e[0]:e):(t._length||t.length)>1}function ta(t,e){!0!==e.data.show&&Gi(e)}var ea=function(t){var a,s,c={},u=t.modules,l=t.nodeOps;for(a=0;a<ho.length;++a)for(c[ho[a]]=[],s=0;s<u.length;++s)r(u[s][ho[a]])&&c[ho[a]].push(u[s][ho[a]]);function f(t){var e=l.parentNode(t);r(e)&&l.removeChild(e,t)}function d(t,e,n,i,a,s,u){if(r(t.elm)&&r(s)&&(t=s[u]=vt(t)),t.isRootInsert=!a,!function(t,e,n,i){var a=t.data;if(r(a)){var s=r(t.componentInstance)&&a.keepAlive;if(r(a=a.hook)&&r(a=a.init)&&a(t,!1),r(t.componentInstance))return p(t,e),v(n,t.elm,i),o(s)&&function(t,e,n,o){var i,a=t;for(;a.componentInstance;)if(r(i=(a=a.componentInstance._vnode).data)&&r(i=i.transition)){for(i=0;i<c.activate.length;++i)c.activate[i](vo,a);e.push(a);break}v(n,t.elm,o)}(t,e,n,i),!0}}(t,e,n,i)){var f=t.data,d=t.children,h=t.tag;r(h)?(t.elm=t.ns?l.createElementNS(t.ns,h):l.createElement(h,t),_(t),m(t,d,e),r(f)&&y(t,e),v(n,t.elm,i)):o(t.isComment)?(t.elm=l.createComment(t.text),v(n,t.elm,i)):(t.elm=l.createTextNode(t.text),v(n,t.elm,i))}}function p(t,e){r(t.data.pendingInsert)&&(e.push.apply(e,t.data.pendingInsert),t.data.pendingInsert=null),t.elm=t.componentInstance.$el,g(t)?(y(t,e),_(t)):(fo(t),e.push(t))}function v(t,e,n){r(t)&&(r(n)?l.parentNode(n)===t&&l.insertBefore(t,e,n):l.appendChild(t,e))}function m(t,n,r){if(e(n))for(var o=0;o<n.length;++o)d(n[o],r,t.elm,null,!0,n,o);else i(t.text)&&l.appendChild(t.elm,l.createTextNode(String(t.text)))}function g(t){for(;t.componentInstance;)t=t.componentInstance._vnode;return r(t.tag)}function y(t,e){for(var n=0;n<c.create.length;++n)c.create[n](vo,t);r(a=t.data.hook)&&(r(a.create)&&a.create(vo,t),r(a.insert)&&e.push(t))}function _(t){var e;if(r(e=t.fnScopeId))l.setStyleScope(t.elm,e);else for(var n=t;n;)r(e=n.context)&&r(e=e.$options._scopeId)&&l.setStyleScope(t.elm,e),n=n.parent;r(e=Ke)&&e!==t.context&&e!==t.fnContext&&r(e=e.$options._scopeId)&&l.setStyleScope(t.elm,e)}function b(t,e,n,r,o,i){for(;r<=o;++r)d(n[r],i,t,e,!1,n,r)}function $(t){var e,n,o=t.data;if(r(o))for(r(e=o.hook)&&r(e=e.destroy)&&e(t),e=0;e<c.destroy.length;++e)c.destroy[e](t);if(r(e=t.children))for(n=0;n<t.children.length;++n)$(t.children[n])}function w(t,e,n){for(;e<=n;++e){var o=t[e];r(o)&&(r(o.tag)?(x(o),$(o)):f(o.elm))}}function x(t,e){if(r(e)||r(t.data)){var n,o=c.remove.length+1;for(r(e)?e.listeners+=o:e=function(t,e){function n(){0==--n.listeners&&f(t)}return n.listeners=e,n}(t.elm,o),r(n=t.componentInstance)&&r(n=n._vnode)&&r(n.data)&&x(n,e),n=0;n<c.remove.length;++n)c.remove[n](t,e);r(n=t.data.hook)&&r(n=n.remove)?n(t,e):e()}else f(t.elm)}function C(t,e,n,o){for(var i=n;i<o;i++){var a=e[i];if(r(a)&&mo(t,a))return i}}function k(t,e,i,a,s,u){if(t!==e){r(e.elm)&&r(a)&&(e=a[s]=vt(e));var f=e.elm=t.elm;if(o(t.isAsyncPlaceholder))r(e.asyncFactory.resolved)?T(t.elm,e,i):e.isAsyncPlaceholder=!0;else if(o(e.isStatic)&&o(t.isStatic)&&e.key===t.key&&(o(e.isCloned)||o(e.isOnce)))e.componentInstance=t.componentInstance;else{var p,v=e.data;r(v)&&r(p=v.hook)&&r(p=p.prepatch)&&p(t,e);var h=t.children,m=e.children;if(r(v)&&g(e)){for(p=0;p<c.update.length;++p)c.update[p](t,e);r(p=v.hook)&&r(p=p.update)&&p(t,e)}n(e.text)?r(h)&&r(m)?h!==m&&function(t,e,o,i,a){for(var s,c,u,f=0,p=0,v=e.length-1,h=e[0],m=e[v],g=o.length-1,y=o[0],_=o[g],$=!a;f<=v&&p<=g;)n(h)?h=e[++f]:n(m)?m=e[--v]:mo(h,y)?(k(h,y,i,o,p),h=e[++f],y=o[++p]):mo(m,_)?(k(m,_,i,o,g),m=e[--v],_=o[--g]):mo(h,_)?(k(h,_,i,o,g),$&&l.insertBefore(t,h.elm,l.nextSibling(m.elm)),h=e[++f],_=o[--g]):mo(m,y)?(k(m,y,i,o,p),$&&l.insertBefore(t,m.elm,h.elm),m=e[--v],y=o[++p]):(n(s)&&(s=go(e,f,v)),n(c=r(y.key)?s[y.key]:C(y,e,f,v))?d(y,i,t,h.elm,!1,o,p):mo(u=e[c],y)?(k(u,y,i,o,p),e[c]=void 0,$&&l.insertBefore(t,u.elm,h.elm)):d(y,i,t,h.elm,!1,o,p),y=o[++p]);f>v?b(t,n(o[g+1])?null:o[g+1].elm,o,p,g,i):p>g&&w(e,f,v)}(f,h,m,i,u):r(m)?(r(t.text)&&l.setTextContent(f,""),b(f,null,m,0,m.length-1,i)):r(h)?w(h,0,h.length-1):r(t.text)&&l.setTextContent(f,""):t.text!==e.text&&l.setTextContent(f,e.text),r(v)&&r(p=v.hook)&&r(p=p.postpatch)&&p(t,e)}}}function S(t,e,n){if(o(n)&&r(t.parent))t.parent.data.pendingInsert=e;else for(var i=0;i<e.length;++i)e[i].data.hook.insert(e[i])}var O=h("attrs,class,staticClass,staticStyle,key");function T(t,e,n,i){var a,s=e.tag,c=e.data,u=e.children;if(i=i||c&&c.pre,e.elm=t,o(e.isComment)&&r(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(r(c)&&(r(a=c.hook)&&r(a=a.init)&&a(e,!0),r(a=e.componentInstance)))return p(e,n),!0;if(r(s)){if(r(u))if(t.hasChildNodes())if(r(a=c)&&r(a=a.domProps)&&r(a=a.innerHTML)){if(a!==t.innerHTML)return!1}else{for(var l=!0,f=t.firstChild,d=0;d<u.length;d++){if(!f||!T(f,u[d],n,i)){l=!1;break}f=f.nextSibling}if(!l||f)return!1}else m(e,u,n);if(r(c)){var v=!1;for(var h in c)if(!O(h)){v=!0,y(e,n);break}!v&&c.class&&Wn(c.class)}}else t.data!==e.text&&(t.data=e.text);return!0}return function(t,e,i,a){if(!n(e)){var s,u=!1,f=[];if(n(t))u=!0,d(e,f);else{var p=r(t.nodeType);if(!p&&mo(t,e))k(t,e,f,null,null,a);else{if(p){if(1===t.nodeType&&t.hasAttribute(R)&&(t.removeAttribute(R),i=!0),o(i)&&T(t,e,f))return S(e,f,!0),t;s=t,t=new ft(l.tagName(s).toLowerCase(),{},[],void 0,s)}var v=t.elm,h=l.parentNode(v);if(d(e,f,v._leaveCb?null:h,l.nextSibling(v)),r(e.parent))for(var m=e.parent,y=g(e);m;){for(var _=0;_<c.destroy.length;++_)c.destroy[_](m);if(m.elm=e.elm,y){for(var b=0;b<c.create.length;++b)c.create[b](vo,m);var x=m.data.hook.insert;if(x.merged)for(var C=x.fns.slice(1),O=0;O<C.length;O++)C[O]()}else fo(m);m=m.parent}r(h)?w([t],0,0):r(t.tag)&&$(t)}}return S(e,f,u),e.elm}r(t)&&$(t)}}({nodeOps:uo,modules:[To,Io,vi,gi,Ti,q?{create:ta,activate:ta,remove:function(t,e){!0!==t.data.show?Xi(t,e):e()}}:{}].concat(Co)});G&&document.addEventListener("selectionchange",(function(){var t=document.activeElement;t&&t.vmodel&&ua(t,"input")}));var na={inserted:function(t,e,n,r){"select"===n.tag?(r.elm&&!r.elm._vOptions?Qt(n,"postpatch",(function(){na.componentUpdated(t,e,n)})):ra(t,e,n.context),t._vOptions=[].map.call(t.options,aa)):("textarea"===n.tag||so(t.type))&&(t._vModifiers=e.modifiers,e.modifiers.lazy||(t.addEventListener("compositionstart",sa),t.addEventListener("compositionend",ca),t.addEventListener("change",ca),G&&(t.vmodel=!0)))},componentUpdated:function(t,e,n){if("select"===n.tag){ra(t,e,n.context);var r=t._vOptions,o=t._vOptions=[].map.call(t.options,aa);if(o.some((function(t,e){return!D(t,r[e])})))(t.multiple?e.value.some((function(t){return ia(t,o)})):e.value!==e.oldValue&&ia(e.value,o))&&ua(t,"change")}}};function ra(t,e,n){oa(t,e),(Z||X)&&setTimeout((function(){oa(t,e)}),0)}function oa(t,e,n){var r=e.value,o=t.multiple;if(!o||Array.isArray(r)){for(var i,a,s=0,c=t.options.length;s<c;s++)if(a=t.options[s],o)i=M(r,aa(a))>-1,a.selected!==i&&(a.selected=i);else if(D(aa(a),r))return void(t.selectedIndex!==s&&(t.selectedIndex=s));o||(t.selectedIndex=-1)}}function ia(t,e){return e.every((function(e){return!D(e,t)}))}function aa(t){return"_value"in t?t._value:t.value}function sa(t){t.target.composing=!0}function ca(t){t.target.composing&&(t.target.composing=!1,ua(t.target,"input"))}function ua(t,e){var n=document.createEvent("HTMLEvents");n.initEvent(e,!0,!0),t.dispatchEvent(n)}function la(t){return!t.componentInstance||t.data&&t.data.transition?t:la(t.componentInstance._vnode)}var fa={bind:function(t,e,n){var r=e.value,o=(n=la(n)).data&&n.data.transition,i=t.__vOriginalDisplay="none"===t.style.display?"":t.style.display;r&&o?(n.data.show=!0,Gi(n,(function(){t.style.display=i}))):t.style.display=r?i:"none"},update:function(t,e,n){var r=e.value;!r!=!e.oldValue&&((n=la(n)).data&&n.data.transition?(n.data.show=!0,r?Gi(n,(function(){t.style.display=t.__vOriginalDisplay})):Xi(n,(function(){t.style.display="none"}))):t.style.display=r?t.__vOriginalDisplay:"none")},unbind:function(t,e,n,r,o){o||(t.style.display=t.__vOriginalDisplay)}},da={model:na,show:fa},pa={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function va(t){var e=t&&t.componentOptions;return e&&e.Ctor.options.abstract?va(Re(e.children)):t}function ha(t){var e={},n=t.$options;for(var r in n.propsData)e[r]=t[r];var o=n._parentListeners;for(var r in o)e[x(r)]=o[r];return e}function ma(t,e){if(/\d-keep-alive$/.test(e.tag))return t("keep-alive",{props:e.componentOptions.propsData})}var ga=function(t){return t.tag||ke(t)},ya=function(t){return"show"===t.name},_a={name:"transition",props:pa,abstract:!0,render:function(t){var e=this,n=this.$slots.default;if(n&&(n=n.filter(ga)).length){var r=this.mode,o=n[0];if(function(t){for(;t=t.parent;)if(t.data.transition)return!0}(this.$vnode))return o;var a=va(o);if(!a)return o;if(this._leaving)return ma(t,o);var s="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?s+"comment":s+a.tag:i(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var c=(a.data||(a.data={})).transition=ha(this),u=this._vnode,l=va(u);if(a.data.directives&&a.data.directives.some(ya)&&(a.data.show=!0),l&&l.data&&!function(t,e){return e.key===t.key&&e.tag===t.tag}(a,l)&&!ke(l)&&(!l.componentInstance||!l.componentInstance._vnode.isComment)){var f=l.data.transition=A({},c);if("out-in"===r)return this._leaving=!0,Qt(f,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),ma(t,o);if("in-out"===r){if(ke(a))return u;var d,p=function(){d()};Qt(c,"afterEnter",p),Qt(c,"enterCancelled",p),Qt(f,"delayLeave",(function(t){d=t}))}}return o}}},ba=A({tag:String,moveClass:String},pa);delete ba.mode;var $a={props:ba,beforeMount:function(){var t=this,e=this._update;this._update=function(n,r){var o=Je(t);t.__patch__(t._vnode,t.kept,!1,!0),t._vnode=t.kept,o(),e.call(t,n,r)}},render:function(t){for(var e=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],i=this.children=[],a=ha(this),s=0;s<o.length;s++){(l=o[s]).tag&&null!=l.key&&0!==String(l.key).indexOf("__vlist")&&(i.push(l),n[l.key]=l,(l.data||(l.data={})).transition=a)}if(r){var c=[],u=[];for(s=0;s<r.length;s++){var l;(l=r[s]).data.transition=a,l.data.pos=l.elm.getBoundingClientRect(),n[l.key]?c.push(l):u.push(l)}this.kept=t(e,null,c),this.removed=u}return t(e,null,i)},updated:function(){var t=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";t.length&&this.hasMove(t[0].elm,e)&&(t.forEach(wa),t.forEach(xa),t.forEach(Ca),this._reflow=document.body.offsetHeight,t.forEach((function(t){if(t.data.moved){var n=t.elm,r=n.style;zi(n,e),r.transform=r.WebkitTransform=r.transitionDuration="",n.addEventListener(Ri,n._moveCb=function t(r){r&&r.target!==n||r&&!/transform$/.test(r.propertyName)||(n.removeEventListener(Ri,t),n._moveCb=null,Vi(n,e))})}})))},methods:{hasMove:function(t,e){if(!Di)return!1;if(this._hasMove)return this._hasMove;var n=t.cloneNode();t._transitionClasses&&t._transitionClasses.forEach((function(t){Ei(n,t)})),ji(n,e),n.style.display="none",this.$el.appendChild(n);var r=qi(n);return this.$el.removeChild(n),this._hasMove=r.hasTransform}}};function wa(t){t.elm._moveCb&&t.elm._moveCb(),t.elm._enterCb&&t.elm._enterCb()}function xa(t){t.data.newPos=t.elm.getBoundingClientRect()}function Ca(t){var e=t.data.pos,n=t.data.newPos,r=e.left-n.left,o=e.top-n.top;if(r||o){t.data.moved=!0;var i=t.elm.style;i.transform=i.WebkitTransform="translate(".concat(r,"px,").concat(o,"px)"),i.transitionDuration="0s"}}var ka={Transition:_a,TransitionGroup:$a};Er.config.mustUseProp=Ur,Er.config.isReservedTag=oo,Er.config.isReservedAttr=Hr,Er.config.getTagNamespace=io,Er.config.isUnknownElement=function(t){if(!q)return!0;if(oo(t))return!1;if(t=t.toLowerCase(),null!=ao[t])return ao[t];var e=document.createElement(t);return t.indexOf("-")>-1?ao[t]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ao[t]=/HTMLUnknownElement/.test(e.toString())},A(Er.options.directives,da),A(Er.options.components,ka),Er.prototype.__patch__=q?ea:E,Er.prototype.$mount=function(t,e){return function(t,e,n){var r;t.$el=e,t.$options.render||(t.$options.render=dt),Ge(t,"beforeMount"),r=function(){t._update(t._render(),n)},new Xn(t,r,E,{before:function(){t._isMounted&&!t._isDestroyed&&Ge(t,"beforeUpdate")}},!0),n=!1;var o=t._preWatchers;if(o)for(var i=0;i<o.length;i++)o[i].run();return null==t.$vnode&&(t._isMounted=!0,Ge(t,"mounted")),t}(this,t=t&&q?co(t):void 0,e)},q&&setTimeout((function(){B.devtools&&it&&it.emit("init",Er)}),0);var Sa=/\{\{((?:.|\r?\n)+?)\}\}/g,Oa=/[-.*+?^${}()|[\]\/\\]/g,Ta=$((function(t){var e=t[0].replace(Oa,"\\$&"),n=t[1].replace(Oa,"\\$&");return new RegExp(e+"((?:.|\\n)+?)"+n,"g")}));var Aa={staticKeys:["staticClass"],transformNode:function(t,e){e.warn;var n=Zo(t,"class");n&&(t.staticClass=JSON.stringify(n.replace(/\s+/g," ").trim()));var r=Wo(t,"class",!1);r&&(t.classBinding=r)},genData:function(t){var e="";return t.staticClass&&(e+="staticClass:".concat(t.staticClass,",")),t.classBinding&&(e+="class:".concat(t.classBinding,",")),e}};var ja,Ea={staticKeys:["staticStyle"],transformNode:function(t,e){e.warn;var n=Zo(t,"style");n&&(t.staticStyle=JSON.stringify(yi(n)));var r=Wo(t,"style",!1);r&&(t.styleBinding=r)},genData:function(t){var e="";return t.staticStyle&&(e+="staticStyle:".concat(t.staticStyle,",")),t.styleBinding&&(e+="style:(".concat(t.styleBinding,"),")),e}},Na=function(t){return(ja=ja||document.createElement("div")).innerHTML=t,ja.textContent},Pa=h("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Da=h("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Ma=h("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),Ia=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,La=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Ra="[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(U.source,"]*"),Fa="((?:".concat(Ra,"\\:)?").concat(Ra,")"),Ha=new RegExp("^<".concat(Fa)),Ba=/^\s*(\/?)>/,Ua=new RegExp("^<\\/".concat(Fa,"[^>]*>")),za=/^<!DOCTYPE [^>]+>/i,Va=/^<!\--/,Ka=/^<!\[/,Ja=h("script,style,textarea",!0),qa={},Wa={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},Za=/&(?:lt|gt|quot|amp|#39);/g,Ga=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,Xa=h("pre,textarea",!0),Ya=function(t,e){return t&&Xa(t)&&"\n"===e[0]};function Qa(t,e){var n=e?Ga:Za;return t.replace(n,(function(t){return Wa[t]}))}function ts(t,e){for(var n,r,o=[],i=e.expectHTML,a=e.isUnaryTag||N,s=e.canBeLeftOpenTag||N,c=0,u=function(){if(n=t,r&&Ja(r)){var u=0,d=r.toLowerCase(),p=qa[d]||(qa[d]=new RegExp("([\\s\\S]*?)(</"+d+"[^>]*>)","i"));w=t.replace(p,(function(t,n,r){return u=r.length,Ja(d)||"noscript"===d||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),Ya(d,n)&&(n=n.slice(1)),e.chars&&e.chars(n),""}));c+=t.length-w.length,t=w,f(d,c-u,c)}else{var v=t.indexOf("<");if(0===v){if(Va.test(t)){var h=t.indexOf("--\x3e");if(h>=0)return e.shouldKeepComment&&e.comment&&e.comment(t.substring(4,h),c,c+h+3),l(h+3),"continue"}if(Ka.test(t)){var m=t.indexOf("]>");if(m>=0)return l(m+2),"continue"}var g=t.match(za);if(g)return l(g[0].length),"continue";var y=t.match(Ua);if(y){var _=c;return l(y[0].length),f(y[1],_,c),"continue"}var b=function(){var e=t.match(Ha);if(e){var n={tagName:e[1],attrs:[],start:c};l(e[0].length);for(var r=void 0,o=void 0;!(r=t.match(Ba))&&(o=t.match(La)||t.match(Ia));)o.start=c,l(o[0].length),o.end=c,n.attrs.push(o);if(r)return n.unarySlash=r[1],l(r[0].length),n.end=c,n}}();if(b)return function(t){var n=t.tagName,c=t.unarySlash;i&&("p"===r&&Ma(n)&&f(r),s(n)&&r===n&&f(n));for(var u=a(n)||!!c,l=t.attrs.length,d=new Array(l),p=0;p<l;p++){var v=t.attrs[p],h=v[3]||v[4]||v[5]||"",m="a"===n&&"href"===v[1]?e.shouldDecodeNewlinesForHref:e.shouldDecodeNewlines;d[p]={name:v[1],value:Qa(h,m)}}u||(o.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:d,start:t.start,end:t.end}),r=n);e.start&&e.start(n,d,u,t.start,t.end)}(b),Ya(b.tagName,t)&&l(1),"continue"}var $=void 0,w=void 0,x=void 0;if(v>=0){for(w=t.slice(v);!(Ua.test(w)||Ha.test(w)||Va.test(w)||Ka.test(w)||(x=w.indexOf("<",1))<0);)v+=x,w=t.slice(v);$=t.substring(0,v)}v<0&&($=t),$&&l($.length),e.chars&&$&&e.chars($,c-$.length,c)}if(t===n)return e.chars&&e.chars(t),"break"};t;){if("break"===u())break}function l(e){c+=e,t=t.substring(e)}function f(t,n,i){var a,s;if(null==n&&(n=c),null==i&&(i=c),t)for(s=t.toLowerCase(),a=o.length-1;a>=0&&o[a].lowerCasedTag!==s;a--);else a=0;if(a>=0){for(var u=o.length-1;u>=a;u--)e.end&&e.end(o[u].tag,n,i);o.length=a,r=a&&o[a-1].tag}else"br"===s?e.start&&e.start(t,[],!0,n,i):"p"===s&&(e.start&&e.start(t,[],!1,n,i),e.end&&e.end(t,n,i))}f()}var es,ns,rs,os,is,as,ss,cs,us=/^@|^v-on:/,ls=/^v-|^@|^:|^#/,fs=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,ds=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,ps=/^\(|\)$/g,vs=/^\[.*\]$/,hs=/:(.*)$/,ms=/^:|^\.|^v-bind:/,gs=/\.[^.\]]+(?=[^\]]*$)/g,ys=/^v-slot(:|$)|^#/,_s=/[\r\n]/,bs=/[ \f\t\r\n]+/g,$s=$(Na),ws="_empty_";function xs(t,e,n){return{type:1,tag:t,attrsList:e,attrsMap:js(e),rawAttrsMap:{},parent:n,children:[]}}function Cs(t,e){es=e.warn||Ho,as=e.isPreTag||N,ss=e.mustUseProp||N,cs=e.getTagNamespace||N,e.isReservedTag,rs=Bo(e.modules,"transformNode"),os=Bo(e.modules,"preTransformNode"),is=Bo(e.modules,"postTransformNode"),ns=e.delimiters;var n,r,o=[],i=!1!==e.preserveWhitespace,a=e.whitespace,s=!1,c=!1;function u(t){if(l(t),s||t.processed||(t=ks(t,e)),o.length||t===n||n.if&&(t.elseif||t.else)&&Os(n,{exp:t.elseif,block:t}),r&&!t.forbidden)if(t.elseif||t.else)a=t,u=function(t){for(var e=t.length;e--;){if(1===t[e].type)return t[e];t.pop()}}(r.children),u&&u.if&&Os(u,{exp:a.elseif,block:a});else{if(t.slotScope){var i=t.slotTarget||'"default"';(r.scopedSlots||(r.scopedSlots={}))[i]=t}r.children.push(t),t.parent=r}var a,u;t.children=t.children.filter((function(t){return!t.slotScope})),l(t),t.pre&&(s=!1),as(t.tag)&&(c=!1);for(var f=0;f<is.length;f++)is[f](t,e)}function l(t){if(!c)for(var e=void 0;(e=t.children[t.children.length-1])&&3===e.type&&" "===e.text;)t.children.pop()}return ts(t,{warn:es,expectHTML:e.expectHTML,isUnaryTag:e.isUnaryTag,canBeLeftOpenTag:e.canBeLeftOpenTag,shouldDecodeNewlines:e.shouldDecodeNewlines,shouldDecodeNewlinesForHref:e.shouldDecodeNewlinesForHref,shouldKeepComment:e.comments,outputSourceRange:e.outputSourceRange,start:function(t,i,a,l,f){var d=r&&r.ns||cs(t);Z&&"svg"===d&&(i=function(t){for(var e=[],n=0;n<t.length;n++){var r=t[n];Es.test(r.name)||(r.name=r.name.replace(Ns,""),e.push(r))}return e}(i));var p,v=xs(t,i,r);d&&(v.ns=d),"style"!==(p=v).tag&&("script"!==p.tag||p.attrsMap.type&&"text/javascript"!==p.attrsMap.type)||ot()||(v.forbidden=!0);for(var h=0;h<os.length;h++)v=os[h](v,e)||v;s||(!function(t){null!=Zo(t,"v-pre")&&(t.pre=!0)}(v),v.pre&&(s=!0)),as(v.tag)&&(c=!0),s?function(t){var e=t.attrsList,n=e.length;if(n)for(var r=t.attrs=new Array(n),o=0;o<n;o++)r[o]={name:e[o].name,value:JSON.stringify(e[o].value)},null!=e[o].start&&(r[o].start=e[o].start,r[o].end=e[o].end);else t.pre||(t.plain=!0)}(v):v.processed||(Ss(v),function(t){var e=Zo(t,"v-if");if(e)t.if=e,Os(t,{exp:e,block:t});else{null!=Zo(t,"v-else")&&(t.else=!0);var n=Zo(t,"v-else-if");n&&(t.elseif=n)}}(v),function(t){var e=Zo(t,"v-once");null!=e&&(t.once=!0)}(v)),n||(n=v),a?u(v):(r=v,o.push(v))},end:function(t,e,n){var i=o[o.length-1];o.length-=1,r=o[o.length-1],u(i)},chars:function(t,e,n){if(r&&(!Z||"textarea"!==r.tag||r.attrsMap.placeholder!==t)){var o,u=r.children;if(t=c||t.trim()?"script"===(o=r).tag||"style"===o.tag?t:$s(t):u.length?a?"condense"===a&&_s.test(t)?"":" ":i?" ":"":""){c||"condense"!==a||(t=t.replace(bs," "));var l=void 0,f=void 0;!s&&" "!==t&&(l=function(t,e){var n=e?Ta(e):Sa;if(n.test(t)){for(var r,o,i,a=[],s=[],c=n.lastIndex=0;r=n.exec(t);){(o=r.index)>c&&(s.push(i=t.slice(c,o)),a.push(JSON.stringify(i)));var u=Ro(r[1].trim());a.push("_s(".concat(u,")")),s.push({"@binding":u}),c=o+r[0].length}return c<t.length&&(s.push(i=t.slice(c)),a.push(JSON.stringify(i))),{expression:a.join("+"),tokens:s}}}(t,ns))?f={type:2,expression:l.expression,tokens:l.tokens,text:t}:" "===t&&u.length&&" "===u[u.length-1].text||(f={type:3,text:t}),f&&u.push(f)}}},comment:function(t,e,n){if(r){var o={type:3,text:t,isComment:!0};r.children.push(o)}}}),n}function ks(t,e){var n,r;(r=Wo(n=t,"key"))&&(n.key=r),t.plain=!t.key&&!t.scopedSlots&&!t.attrsList.length,function(t){var e=Wo(t,"ref");e&&(t.ref=e,t.refInFor=function(t){var e=t;for(;e;){if(void 0!==e.for)return!0;e=e.parent}return!1}(t))}(t),function(t){var e;"template"===t.tag?(e=Zo(t,"scope"),t.slotScope=e||Zo(t,"slot-scope")):(e=Zo(t,"slot-scope"))&&(t.slotScope=e);var n=Wo(t,"slot");n&&(t.slotTarget='""'===n?'"default"':n,t.slotTargetDynamic=!(!t.attrsMap[":slot"]&&!t.attrsMap["v-bind:slot"]),"template"===t.tag||t.slotScope||zo(t,"slot",n,function(t,e){return t.rawAttrsMap[":"+e]||t.rawAttrsMap["v-bind:"+e]||t.rawAttrsMap[e]}(t,"slot")));if("template"===t.tag){if(a=Go(t,ys)){var r=Ts(a),o=r.name,i=r.dynamic;t.slotTarget=o,t.slotTargetDynamic=i,t.slotScope=a.value||ws}}else{var a;if(a=Go(t,ys)){var s=t.scopedSlots||(t.scopedSlots={}),c=Ts(a),u=c.name,l=(i=c.dynamic,s[u]=xs("template",[],t));l.slotTarget=u,l.slotTargetDynamic=i,l.children=t.children.filter((function(t){if(!t.slotScope)return t.parent=l,!0})),l.slotScope=a.value||ws,t.children=[],t.plain=!1}}}(t),function(t){"slot"===t.tag&&(t.slotName=Wo(t,"name"))}(t),function(t){var e;(e=Wo(t,"is"))&&(t.component=e);null!=Zo(t,"inline-template")&&(t.inlineTemplate=!0)}(t);for(var o=0;o<rs.length;o++)t=rs[o](t,e)||t;return function(t){var e,n,r,o,i,a,s,c,u=t.attrsList;for(e=0,n=u.length;e<n;e++)if(r=o=u[e].name,i=u[e].value,ls.test(r))if(t.hasBindings=!0,(a=As(r.replace(ls,"")))&&(r=r.replace(gs,"")),ms.test(r))r=r.replace(ms,""),i=Ro(i),(c=vs.test(r))&&(r=r.slice(1,-1)),a&&(a.prop&&!c&&"innerHtml"===(r=x(r))&&(r="innerHTML"),a.camel&&!c&&(r=x(r)),a.sync&&(s=Qo(i,"$event"),c?qo(t,'"update:"+('.concat(r,")"),s,null,!1,0,u[e],!0):(qo(t,"update:".concat(x(r)),s,null,!1,0,u[e]),S(r)!==x(r)&&qo(t,"update:".concat(S(r)),s,null,!1,0,u[e])))),a&&a.prop||!t.component&&ss(t.tag,t.attrsMap.type,r)?Uo(t,r,i,u[e],c):zo(t,r,i,u[e],c);else if(us.test(r))r=r.replace(us,""),(c=vs.test(r))&&(r=r.slice(1,-1)),qo(t,r,i,a,!1,0,u[e],c);else{var l=(r=r.replace(ls,"")).match(hs),f=l&&l[1];c=!1,f&&(r=r.slice(0,-(f.length+1)),vs.test(f)&&(f=f.slice(1,-1),c=!0)),Ko(t,r,o,i,f,c,a,u[e])}else zo(t,r,JSON.stringify(i),u[e]),!t.component&&"muted"===r&&ss(t.tag,t.attrsMap.type,r)&&Uo(t,r,"true",u[e])}(t),t}function Ss(t){var e;if(e=Zo(t,"v-for")){var n=function(t){var e=t.match(fs);if(!e)return;var n={};n.for=e[2].trim();var r=e[1].trim().replace(ps,""),o=r.match(ds);o?(n.alias=r.replace(ds,"").trim(),n.iterator1=o[1].trim(),o[2]&&(n.iterator2=o[2].trim())):n.alias=r;return n}(e);n&&A(t,n)}}function Os(t,e){t.ifConditions||(t.ifConditions=[]),t.ifConditions.push(e)}function Ts(t){var e=t.name.replace(ys,"");return e||"#"!==t.name[0]&&(e="default"),vs.test(e)?{name:e.slice(1,-1),dynamic:!0}:{name:'"'.concat(e,'"'),dynamic:!1}}function As(t){var e=t.match(gs);if(e){var n={};return e.forEach((function(t){n[t.slice(1)]=!0})),n}}function js(t){for(var e={},n=0,r=t.length;n<r;n++)e[t[n].name]=t[n].value;return e}var Es=/^xmlns:NS\d+/,Ns=/^NS\d+:/;function Ps(t){return xs(t.tag,t.attrsList.slice(),t.parent)}var Ds=[Aa,Ea,{preTransformNode:function(t,e){if("input"===t.tag){var n=t.attrsMap;if(!n["v-model"])return;var r=void 0;if((n[":type"]||n["v-bind:type"])&&(r=Wo(t,"type")),n.type||r||!n["v-bind"]||(r="(".concat(n["v-bind"],").type")),r){var o=Zo(t,"v-if",!0),i=o?"&&(".concat(o,")"):"",a=null!=Zo(t,"v-else",!0),s=Zo(t,"v-else-if",!0),c=Ps(t);Ss(c),Vo(c,"type","checkbox"),ks(c,e),c.processed=!0,c.if="(".concat(r,")==='checkbox'")+i,Os(c,{exp:c.if,block:c});var u=Ps(t);Zo(u,"v-for",!0),Vo(u,"type","radio"),ks(u,e),Os(c,{exp:"(".concat(r,")==='radio'")+i,block:u});var l=Ps(t);return Zo(l,"v-for",!0),Vo(l,":type",r),ks(l,e),Os(c,{exp:o,block:l}),a?c.else=!0:s&&(c.elseif=s),c}}}}];var Ms,Is,Ls={model:function(t,e,n){var r=e.value,o=e.modifiers,i=t.tag,a=t.attrsMap.type;if(t.component)return Yo(t,r,o),!1;if("select"===i)!function(t,e,n){var r=n&&n.number,o='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;'+"return ".concat(r?"_n(val)":"val","})"),i="$event.target.multiple ? $$selectedVal : $$selectedVal[0]",a="var $$selectedVal = ".concat(o,";");a="".concat(a," ").concat(Qo(e,i)),qo(t,"change",a,null,!0)}(t,r,o);else if("input"===i&&"checkbox"===a)!function(t,e,n){var r=n&&n.number,o=Wo(t,"value")||"null",i=Wo(t,"true-value")||"true",a=Wo(t,"false-value")||"false";Uo(t,"checked","Array.isArray(".concat(e,")")+"?_i(".concat(e,",").concat(o,")>-1")+("true"===i?":(".concat(e,")"):":_q(".concat(e,",").concat(i,")"))),qo(t,"change","var $$a=".concat(e,",")+"$$el=$event.target,"+"$$c=$$el.checked?(".concat(i,"):(").concat(a,");")+"if(Array.isArray($$a)){"+"var $$v=".concat(r?"_n("+o+")":o,",")+"$$i=_i($$a,$$v);"+"if($$el.checked){$$i<0&&(".concat(Qo(e,"$$a.concat([$$v])"),")}")+"else{$$i>-1&&(".concat(Qo(e,"$$a.slice(0,$$i).concat($$a.slice($$i+1))"),")}")+"}else{".concat(Qo(e,"$$c"),"}"),null,!0)}(t,r,o);else if("input"===i&&"radio"===a)!function(t,e,n){var r=n&&n.number,o=Wo(t,"value")||"null";o=r?"_n(".concat(o,")"):o,Uo(t,"checked","_q(".concat(e,",").concat(o,")")),qo(t,"change",Qo(e,o),null,!0)}(t,r,o);else if("input"===i||"textarea"===i)!function(t,e,n){var r=t.attrsMap.type,o=n||{},i=o.lazy,a=o.number,s=o.trim,c=!i&&"range"!==r,u=i?"change":"range"===r?ai:"input",l="$event.target.value";s&&(l="$event.target.value.trim()");a&&(l="_n(".concat(l,")"));var f=Qo(e,l);c&&(f="if($event.target.composing)return;".concat(f));Uo(t,"value","(".concat(e,")")),qo(t,u,f,null,!0),(s||a)&&qo(t,"blur","$forceUpdate()")}(t,r,o);else if(!B.isReservedTag(i))return Yo(t,r,o),!1;return!0},text:function(t,e){e.value&&Uo(t,"textContent","_s(".concat(e.value,")"),e)},html:function(t,e){e.value&&Uo(t,"innerHTML","_s(".concat(e.value,")"),e)}},Rs={expectHTML:!0,modules:Ds,directives:Ls,isPreTag:function(t){return"pre"===t},isUnaryTag:Pa,mustUseProp:Ur,canBeLeftOpenTag:Da,isReservedTag:oo,getTagNamespace:io,staticKeys:function(t){return t.reduce((function(t,e){return t.concat(e.staticKeys||[])}),[]).join(",")}(Ds)},Fs=$((function(t){return h("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(t?","+t:""))}));function Hs(t,e){t&&(Ms=Fs(e.staticKeys||""),Is=e.isReservedTag||N,Bs(t),Us(t,!1))}function Bs(t){if(t.static=function(t){if(2===t.type)return!1;if(3===t.type)return!0;return!(!t.pre&&(t.hasBindings||t.if||t.for||m(t.tag)||!Is(t.tag)||function(t){for(;t.parent;){if("template"!==(t=t.parent).tag)return!1;if(t.for)return!0}return!1}(t)||!Object.keys(t).every(Ms)))}(t),1===t.type){if(!Is(t.tag)&&"slot"!==t.tag&&null==t.attrsMap["inline-template"])return;for(var e=0,n=t.children.length;e<n;e++){var r=t.children[e];Bs(r),r.static||(t.static=!1)}if(t.ifConditions)for(e=1,n=t.ifConditions.length;e<n;e++){var o=t.ifConditions[e].block;Bs(o),o.static||(t.static=!1)}}}function Us(t,e){if(1===t.type){if((t.static||t.once)&&(t.staticInFor=e),t.static&&t.children.length&&(1!==t.children.length||3!==t.children[0].type))return void(t.staticRoot=!0);if(t.staticRoot=!1,t.children)for(var n=0,r=t.children.length;n<r;n++)Us(t.children[n],e||!!t.for);if(t.ifConditions)for(n=1,r=t.ifConditions.length;n<r;n++)Us(t.ifConditions[n].block,e)}}var zs=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Vs=/\([^)]*?\);*$/,Ks=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Js={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},qs={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},Ws=function(t){return"if(".concat(t,")return null;")},Zs={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Ws("$event.target !== $event.currentTarget"),ctrl:Ws("!$event.ctrlKey"),shift:Ws("!$event.shiftKey"),alt:Ws("!$event.altKey"),meta:Ws("!$event.metaKey"),left:Ws("'button' in $event && $event.button !== 0"),middle:Ws("'button' in $event && $event.button !== 1"),right:Ws("'button' in $event && $event.button !== 2")};function Gs(t,e){var n=e?"nativeOn:":"on:",r="",o="";for(var i in t){var a=Xs(t[i]);t[i]&&t[i].dynamic?o+="".concat(i,",").concat(a,","):r+='"'.concat(i,'":').concat(a,",")}return r="{".concat(r.slice(0,-1),"}"),o?n+"_d(".concat(r,",[").concat(o.slice(0,-1),"])"):n+r}function Xs(t){if(!t)return"function(){}";if(Array.isArray(t))return"[".concat(t.map((function(t){return Xs(t)})).join(","),"]");var e=Ks.test(t.value),n=zs.test(t.value),r=Ks.test(t.value.replace(Vs,""));if(t.modifiers){var o="",i="",a=[],s=function(e){if(Zs[e])i+=Zs[e],Js[e]&&a.push(e);else if("exact"===e){var n=t.modifiers;i+=Ws(["ctrl","shift","alt","meta"].filter((function(t){return!n[t]})).map((function(t){return"$event.".concat(t,"Key")})).join("||"))}else a.push(e)};for(var c in t.modifiers)s(c);a.length&&(o+=function(t){return"if(!$event.type.indexOf('key')&&"+"".concat(t.map(Ys).join("&&"),")return null;")}(a)),i&&(o+=i);var u=e?"return ".concat(t.value,".apply(null, arguments)"):n?"return (".concat(t.value,").apply(null, arguments)"):r?"return ".concat(t.value):t.value;return"function($event){".concat(o).concat(u,"}")}return e||n?t.value:"function($event){".concat(r?"return ".concat(t.value):t.value,"}")}function Ys(t){var e=parseInt(t,10);if(e)return"$event.keyCode!==".concat(e);var n=Js[t],r=qs[t];return"_k($event.keyCode,"+"".concat(JSON.stringify(t),",")+"".concat(JSON.stringify(n),",")+"$event.key,"+"".concat(JSON.stringify(r))+")"}var Qs={on:function(t,e){t.wrapListeners=function(t){return"_g(".concat(t,",").concat(e.value,")")}},bind:function(t,e){t.wrapData=function(n){return"_b(".concat(n,",'").concat(t.tag,"',").concat(e.value,",").concat(e.modifiers&&e.modifiers.prop?"true":"false").concat(e.modifiers&&e.modifiers.sync?",true":"",")")}},cloak:E},tc=function(t){this.options=t,this.warn=t.warn||Ho,this.transforms=Bo(t.modules,"transformCode"),this.dataGenFns=Bo(t.modules,"genData"),this.directives=A(A({},Qs),t.directives);var e=t.isReservedTag||N;this.maybeComponent=function(t){return!!t.component||!e(t.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function ec(t,e){var n=new tc(e),r=t?"script"===t.tag?"null":nc(t,n):'_c("div")';return{render:"with(this){return ".concat(r,"}"),staticRenderFns:n.staticRenderFns}}function nc(t,e){if(t.parent&&(t.pre=t.pre||t.parent.pre),t.staticRoot&&!t.staticProcessed)return rc(t,e);if(t.once&&!t.onceProcessed)return oc(t,e);if(t.for&&!t.forProcessed)return sc(t,e);if(t.if&&!t.ifProcessed)return ic(t,e);if("template"!==t.tag||t.slotTarget||e.pre){if("slot"===t.tag)return function(t,e){var n=t.slotName||'"default"',r=fc(t,e),o="_t(".concat(n).concat(r?",function(){return ".concat(r,"}"):""),i=t.attrs||t.dynamicAttrs?vc((t.attrs||[]).concat(t.dynamicAttrs||[]).map((function(t){return{name:x(t.name),value:t.value,dynamic:t.dynamic}}))):null,a=t.attrsMap["v-bind"];!i&&!a||r||(o+=",null");i&&(o+=",".concat(i));a&&(o+="".concat(i?"":",null",",").concat(a));return o+")"}(t,e);var n=void 0;if(t.component)n=function(t,e,n){var r=e.inlineTemplate?null:fc(e,n,!0);return"_c(".concat(t,",").concat(cc(e,n)).concat(r?",".concat(r):"",")")}(t.component,t,e);else{var r=void 0,o=e.maybeComponent(t);(!t.plain||t.pre&&o)&&(r=cc(t,e));var i=void 0,a=e.options.bindings;o&&a&&!1!==a.__isScriptSetup&&(i=function(t,e){var n=x(e),r=C(n),o=function(o){return t[e]===o?e:t[n]===o?n:t[r]===o?r:void 0},i=o("setup-const")||o("setup-reactive-const");if(i)return i;var a=o("setup-let")||o("setup-ref")||o("setup-maybe-ref");if(a)return a}(a,t.tag)),i||(i="'".concat(t.tag,"'"));var s=t.inlineTemplate?null:fc(t,e,!0);n="_c(".concat(i).concat(r?",".concat(r):"").concat(s?",".concat(s):"",")")}for(var c=0;c<e.transforms.length;c++)n=e.transforms[c](t,n);return n}return fc(t,e)||"void 0"}function rc(t,e){t.staticProcessed=!0;var n=e.pre;return t.pre&&(e.pre=t.pre),e.staticRenderFns.push("with(this){return ".concat(nc(t,e),"}")),e.pre=n,"_m(".concat(e.staticRenderFns.length-1).concat(t.staticInFor?",true":"",")")}function oc(t,e){if(t.onceProcessed=!0,t.if&&!t.ifProcessed)return ic(t,e);if(t.staticInFor){for(var n="",r=t.parent;r;){if(r.for){n=r.key;break}r=r.parent}return n?"_o(".concat(nc(t,e),",").concat(e.onceId++,",").concat(n,")"):nc(t,e)}return rc(t,e)}function ic(t,e,n,r){return t.ifProcessed=!0,ac(t.ifConditions.slice(),e,n,r)}function ac(t,e,n,r){if(!t.length)return r||"_e()";var o=t.shift();return o.exp?"(".concat(o.exp,")?").concat(i(o.block),":").concat(ac(t,e,n,r)):"".concat(i(o.block));function i(t){return n?n(t,e):t.once?oc(t,e):nc(t,e)}}function sc(t,e,n,r){var o=t.for,i=t.alias,a=t.iterator1?",".concat(t.iterator1):"",s=t.iterator2?",".concat(t.iterator2):"";return t.forProcessed=!0,"".concat(r||"_l","((").concat(o,"),")+"function(".concat(i).concat(a).concat(s,"){")+"return ".concat((n||nc)(t,e))+"})"}function cc(t,e){var n="{",r=function(t,e){var n=t.directives;if(!n)return;var r,o,i,a,s="directives:[",c=!1;for(r=0,o=n.length;r<o;r++){i=n[r],a=!0;var u=e.directives[i.name];u&&(a=!!u(t,i,e.warn)),a&&(c=!0,s+='{name:"'.concat(i.name,'",rawName:"').concat(i.rawName,'"').concat(i.value?",value:(".concat(i.value,"),expression:").concat(JSON.stringify(i.value)):"").concat(i.arg?",arg:".concat(i.isDynamicArg?i.arg:'"'.concat(i.arg,'"')):"").concat(i.modifiers?",modifiers:".concat(JSON.stringify(i.modifiers)):"","},"))}if(c)return s.slice(0,-1)+"]"}(t,e);r&&(n+=r+","),t.key&&(n+="key:".concat(t.key,",")),t.ref&&(n+="ref:".concat(t.ref,",")),t.refInFor&&(n+="refInFor:true,"),t.pre&&(n+="pre:true,"),t.component&&(n+='tag:"'.concat(t.tag,'",'));for(var o=0;o<e.dataGenFns.length;o++)n+=e.dataGenFns[o](t);if(t.attrs&&(n+="attrs:".concat(vc(t.attrs),",")),t.props&&(n+="domProps:".concat(vc(t.props),",")),t.events&&(n+="".concat(Gs(t.events,!1),",")),t.nativeEvents&&(n+="".concat(Gs(t.nativeEvents,!0),",")),t.slotTarget&&!t.slotScope&&(n+="slot:".concat(t.slotTarget,",")),t.scopedSlots&&(n+="".concat(function(t,e,n){var r=t.for||Object.keys(e).some((function(t){var n=e[t];return n.slotTargetDynamic||n.if||n.for||uc(n)})),o=!!t.if;if(!r)for(var i=t.parent;i;){if(i.slotScope&&i.slotScope!==ws||i.for){r=!0;break}i.if&&(o=!0),i=i.parent}var a=Object.keys(e).map((function(t){return lc(e[t],n)})).join(",");return"scopedSlots:_u([".concat(a,"]").concat(r?",null,true":"").concat(!r&&o?",null,false,".concat(function(t){var e=5381,n=t.length;for(;n;)e=33*e^t.charCodeAt(--n);return e>>>0}(a)):"",")")}(t,t.scopedSlots,e),",")),t.model&&(n+="model:{value:".concat(t.model.value,",callback:").concat(t.model.callback,",expression:").concat(t.model.expression,"},")),t.inlineTemplate){var i=function(t,e){var n=t.children[0];if(n&&1===n.type){var r=ec(n,e.options);return"inlineTemplate:{render:function(){".concat(r.render,"},staticRenderFns:[").concat(r.staticRenderFns.map((function(t){return"function(){".concat(t,"}")})).join(","),"]}")}}(t,e);i&&(n+="".concat(i,","))}return n=n.replace(/,$/,"")+"}",t.dynamicAttrs&&(n="_b(".concat(n,',"').concat(t.tag,'",').concat(vc(t.dynamicAttrs),")")),t.wrapData&&(n=t.wrapData(n)),t.wrapListeners&&(n=t.wrapListeners(n)),n}function uc(t){return 1===t.type&&("slot"===t.tag||t.children.some(uc))}function lc(t,e){var n=t.attrsMap["slot-scope"];if(t.if&&!t.ifProcessed&&!n)return ic(t,e,lc,"null");if(t.for&&!t.forProcessed)return sc(t,e,lc);var r=t.slotScope===ws?"":String(t.slotScope),o="function(".concat(r,"){")+"return ".concat("template"===t.tag?t.if&&n?"(".concat(t.if,")?").concat(fc(t,e)||"undefined",":undefined"):fc(t,e)||"undefined":nc(t,e),"}"),i=r?"":",proxy:true";return"{key:".concat(t.slotTarget||'"default"',",fn:").concat(o).concat(i,"}")}function fc(t,e,n,r,o){var i=t.children;if(i.length){var a=i[0];if(1===i.length&&a.for&&"template"!==a.tag&&"slot"!==a.tag){var s=n?e.maybeComponent(a)?",1":",0":"";return"".concat((r||nc)(a,e)).concat(s)}var c=n?function(t,e){for(var n=0,r=0;r<t.length;r++){var o=t[r];if(1===o.type){if(dc(o)||o.ifConditions&&o.ifConditions.some((function(t){return dc(t.block)}))){n=2;break}(e(o)||o.ifConditions&&o.ifConditions.some((function(t){return e(t.block)})))&&(n=1)}}return n}(i,e.maybeComponent):0,u=o||pc;return"[".concat(i.map((function(t){return u(t,e)})).join(","),"]").concat(c?",".concat(c):"")}}function dc(t){return void 0!==t.for||"template"===t.tag||"slot"===t.tag}function pc(t,e){return 1===t.type?nc(t,e):3===t.type&&t.isComment?function(t){return"_e(".concat(JSON.stringify(t.text),")")}(t):function(t){return"_v(".concat(2===t.type?t.expression:hc(JSON.stringify(t.text)),")")}(t)}function vc(t){for(var e="",n="",r=0;r<t.length;r++){var o=t[r],i=hc(o.value);o.dynamic?n+="".concat(o.name,",").concat(i,","):e+='"'.concat(o.name,'":').concat(i,",")}return e="{".concat(e.slice(0,-1),"}"),n?"_d(".concat(e,",[").concat(n.slice(0,-1),"])"):e}function hc(t){return t.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function mc(t,e){try{return new Function(t)}catch(n){return e.push({err:n,code:t}),E}}function gc(t){var e=Object.create(null);return function(n,r,o){(r=A({},r)).warn,delete r.warn;var i=r.delimiters?String(r.delimiters)+n:n;if(e[i])return e[i];var a=t(n,r),s={},c=[];return s.render=mc(a.render,c),s.staticRenderFns=a.staticRenderFns.map((function(t){return mc(t,c)})),e[i]=s}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var yc,_c,bc=(yc=function(t,e){var n=Cs(t.trim(),e);!1!==e.optimize&&Hs(n,e);var r=ec(n,e);return{ast:n,render:r.render,staticRenderFns:r.staticRenderFns}},function(t){function e(e,n){var r=Object.create(t),o=[],i=[];if(n)for(var a in n.modules&&(r.modules=(t.modules||[]).concat(n.modules)),n.directives&&(r.directives=A(Object.create(t.directives||null),n.directives)),n)"modules"!==a&&"directives"!==a&&(r[a]=n[a]);r.warn=function(t,e,n){(n?i:o).push(t)};var s=yc(e.trim(),r);return s.errors=o,s.tips=i,s}return{compile:e,compileToFunctions:gc(e)}}),$c=bc(Rs).compileToFunctions;function wc(t){return(_c=_c||document.createElement("div")).innerHTML=t?'<a href="\n"/>':'<div a="\n"/>',_c.innerHTML.indexOf("&#10;")>0}var xc=!!q&&wc(!1),Cc=!!q&&wc(!0),kc=$((function(t){var e=co(t);return e&&e.innerHTML})),Sc=Er.prototype.$mount;return Er.prototype.$mount=function(t,e){if((t=t&&co(t))===document.body||t===document.documentElement)return this;var n=this.$options;if(!n.render){var r=n.template;if(r)if("string"==typeof r)"#"===r.charAt(0)&&(r=kc(r));else{if(!r.nodeType)return this;r=r.innerHTML}else t&&(r=function(t){if(t.outerHTML)return t.outerHTML;var e=document.createElement("div");return e.appendChild(t.cloneNode(!0)),e.innerHTML}(t));if(r){var o=$c(r,{outputSourceRange:!1,shouldDecodeNewlines:xc,shouldDecodeNewlinesForHref:Cc,delimiters:n.delimiters,comments:n.comments},this),i=o.render,a=o.staticRenderFns;n.render=i,n.staticRenderFns=a}}return Sc.call(this,t,e)},Er.compile=$c,A(Er,Jn),Er.effect=function(t,e){var n=new Xn(ut,t,E,{sync:!0});e&&(n.update=function(){e((function(){return n.run()}))})},Er}));

// @vuebundler[Lsw_framework_components][4]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/others/vue.draggable/sortable.js
/**!
 * Sortable
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */

(function sortableModule(factory) {
	"use strict";

	if (typeof define === "function" && define.amd) {
		define(factory);
	}
	else if (typeof module != "undefined" && typeof module.exports != "undefined") {
		module.exports = factory();
	}
	else {
		/* jshint sub:true */
		window["Sortable"] = factory();
	}
})(function sortableFactory() {
	"use strict";

	if (typeof window === "undefined" || !window.document) {
		return function sortableError() {
			throw new Error("Sortable.js requires a window with a document");
		};
	}

	var dragEl,
		parentEl,
		ghostEl,
		cloneEl,
		rootEl,
		nextEl,
		lastDownEl,

		scrollEl,
		scrollParentEl,
		scrollCustomFn,

		oldIndex,
		newIndex,

		activeGroup,
		putSortable,

		autoScrolls = [],
		scrolling = false,

		awaitingDragStarted = false,
		ignoreNextClick = false,
		sortables = [],

		pointerElemChangedInterval,
		lastPointerElemX,
		lastPointerElemY,

		tapEvt,
		touchEvt,

		moved,


		lastTarget,
		lastDirection,
		pastFirstInvertThresh = false,
		isCircumstantialInvert = false,
		lastMode, // 'swap' or 'insert'

		targetMoveDistance,

		// For positioning ghost absolutely
		ghostRelativeParent,
		ghostRelativeParentInitialScroll = [], // (left, top)


		forRepaintDummy,
		realDragElRect, // dragEl rect after current animation

		/** @const */
		R_SPACE = /\s+/g,

		expando = 'Sortable' + (new Date).getTime(),

		win = window,
		document = win.document,
		parseInt = win.parseInt,
		setTimeout = win.setTimeout,

		$ = win.jQuery || win.Zepto,
		Polymer = win.Polymer,

		captureMode = {
			capture: false,
			passive: false
		},

		IE11OrLess = !!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie|iemobile)/i),
		Edge = !!navigator.userAgent.match(/Edge/i),
		FireFox = !!navigator.userAgent.match(/firefox/i),
		Safari = !!(navigator.userAgent.match(/safari/i) && !navigator.userAgent.match(/chrome/i) && !navigator.userAgent.match(/android/i)),
		IOS = !!(navigator.userAgent.match(/iP(ad|od|hone)/i)),

		PositionGhostAbsolutely = IOS,

		CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',

		// This will not pass for IE9, because IE9 DnD only works on anchors
		supportDraggable = ('draggable' in document.createElement('div')),

		supportCssPointerEvents = (function() {
			// false when <= IE11
			if (IE11OrLess) {
				return false;
			}
			var el = document.createElement('x');
			el.style.cssText = 'pointer-events:auto';
			return el.style.pointerEvents === 'auto';
		})(),

		_silent = false,
		_alignedSilent = false,

		abs = Math.abs,
		min = Math.min,
		max = Math.max,

		savedInputChecked = [],

		_detectDirection = function(el, options) {
			var elCSS = _css(el),
				elWidth = parseInt(elCSS.width)
					- parseInt(elCSS.paddingLeft)
					- parseInt(elCSS.paddingRight)
					- parseInt(elCSS.borderLeftWidth)
					- parseInt(elCSS.borderRightWidth),
				child1 = _getChild(el, 0, options),
				child2 = _getChild(el, 1, options),
				firstChildCSS = child1 && _css(child1),
				secondChildCSS = child2 && _css(child2),
				firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + _getRect(child1).width,
				secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + _getRect(child2).width;

			if (elCSS.display === 'flex') {
				return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse'
				? 'vertical' : 'horizontal';
			}

			if (elCSS.display === 'grid') {
				return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
			}

			if (child1 && firstChildCSS.float !== 'none') {
				var touchingSideChild2 = firstChildCSS.float === 'left' ? 'left' : 'right';

				return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ?
					'vertical' : 'horizontal';
			}

			return (child1 &&
				(
					firstChildCSS.display === 'block' ||
					firstChildCSS.display === 'flex' ||
					firstChildCSS.display === 'table' ||
					firstChildCSS.display === 'grid' ||
					firstChildWidth >= elWidth &&
					elCSS[CSSFloatProperty] === 'none' ||
					child2 &&
					elCSS[CSSFloatProperty] === 'none' &&
					firstChildWidth + secondChildWidth > elWidth
				) ?
				'vertical' : 'horizontal'
			);
		},

		/**
		 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
		 * @param  {Number} x      X position
		 * @param  {Number} y      Y position
		 * @return {HTMLElement}   Element of the first found nearest Sortable
		 */
		_detectNearestEmptySortable = function(x, y) {
			for (var i = 0; i < sortables.length; i++) {
				if (_lastChild(sortables[i])) continue;

				var rect = _getRect(sortables[i]),
					threshold = sortables[i][expando].options.emptyInsertThreshold,
					insideHorizontally = x >= (rect.left - threshold) && x <= (rect.right + threshold),
					insideVertically = y >= (rect.top - threshold) && y <= (rect.bottom + threshold);

				if (insideHorizontally && insideVertically) {
					return sortables[i];
				}
			}
		},

		_isClientInRowColumn = function(x, y, el, axis, options) {
			var targetRect = _getRect(el),
				targetS1Opp = axis === 'vertical' ? targetRect.left : targetRect.top,
				targetS2Opp = axis === 'vertical' ? targetRect.right : targetRect.bottom,
				mouseOnOppAxis = axis === 'vertical' ? x : y;

			return targetS1Opp < mouseOnOppAxis && mouseOnOppAxis < targetS2Opp;
		},

		_isElInRowColumn = function(el1, el2, axis) {
			var el1Rect = el1 === dragEl && realDragElRect || _getRect(el1),
				el2Rect = el2 === dragEl && realDragElRect || _getRect(el2),
				el1S1Opp = axis === 'vertical' ? el1Rect.left : el1Rect.top,
				el1S2Opp = axis === 'vertical' ? el1Rect.right : el1Rect.bottom,
				el1OppLength = axis === 'vertical' ? el1Rect.width : el1Rect.height,
				el2S1Opp = axis === 'vertical' ? el2Rect.left : el2Rect.top,
				el2S2Opp = axis === 'vertical' ? el2Rect.right : el2Rect.bottom,
				el2OppLength = axis === 'vertical' ? el2Rect.width : el2Rect.height;

			return (
				el1S1Opp === el2S1Opp ||
				el1S2Opp === el2S2Opp ||
				(el1S1Opp + el1OppLength / 2) === (el2S1Opp + el2OppLength / 2)
			);
		},

		_getParentAutoScrollElement = function(el, includeSelf) {
			// skip to window
			if (!el || !el.getBoundingClientRect) return _getWindowScrollingElement();

			var elem = el;
			var gotSelf = false;
			do {
				// we don't need to get elem css if it isn't even overflowing in the first place (performance)
				if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
					var elemCSS = _css(elem);
					if (
						elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') ||
						elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')
					) {
						if (!elem || !elem.getBoundingClientRect || elem === document.body) return _getWindowScrollingElement();

						if (gotSelf || includeSelf) return elem;
						gotSelf = true;
					}
				}
			/* jshint boss:true */
			} while (elem = elem.parentNode);

			return _getWindowScrollingElement();
		},

		_getWindowScrollingElement = function() {
			if (IE11OrLess) {
				return document.documentElement;
			} else {
				return document.scrollingElement;
			}
		},

		_scrollBy = function(el, x, y) {
			el.scrollLeft += x;
			el.scrollTop += y;
		},

		_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl, /**Boolean*/isFallback) {
			// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
			if (options.scroll) {
				var _this = rootEl ? rootEl[expando] : window,
					sens = options.scrollSensitivity,
					speed = options.scrollSpeed,

					x = evt.clientX,
					y = evt.clientY,

					winScroller = _getWindowScrollingElement(),

					scrollThisInstance = false;

				// Detect scrollEl
				if (scrollParentEl !== rootEl) {
					_clearAutoScrolls();

					scrollEl = options.scroll;
					scrollCustomFn = options.scrollFn;

					if (scrollEl === true) {
						scrollEl = _getParentAutoScrollElement(rootEl, true);
						scrollParentEl = scrollEl;
					}
				}


				var layersOut = 0;
				var currentParent = scrollEl;
				do {
					var	el = currentParent,
						rect = _getRect(el),

						top = rect.top,
						bottom = rect.bottom,
						left = rect.left,
						right = rect.right,

						width = rect.width,
						height = rect.height,

						scrollWidth,
						scrollHeight,

						css,

						vx,
						vy,

						canScrollX,
						canScrollY,

						scrollPosX,
						scrollPosY;


					scrollWidth = el.scrollWidth;
					scrollHeight = el.scrollHeight;

					css = _css(el);

					scrollPosX = el.scrollLeft;
					scrollPosY = el.scrollTop;

					if (el === winScroller) {
						canScrollX = width < scrollWidth && (css.overflowX === 'auto' || css.overflowX === 'scroll' || css.overflowX === 'visible');
						canScrollY = height < scrollHeight && (css.overflowY === 'auto' || css.overflowY === 'scroll' || css.overflowY === 'visible');
					} else {
						canScrollX = width < scrollWidth && (css.overflowX === 'auto' || css.overflowX === 'scroll');
						canScrollY = height < scrollHeight && (css.overflowY === 'auto' || css.overflowY === 'scroll');
					}

					vx = canScrollX && (abs(right - x) <= sens && (scrollPosX + width) < scrollWidth) - (abs(left - x) <= sens && !!scrollPosX);

					vy = canScrollY && (abs(bottom - y) <= sens && (scrollPosY + height) < scrollHeight) - (abs(top - y) <= sens && !!scrollPosY);


					if (!autoScrolls[layersOut]) {
						for (var i = 0; i <= layersOut; i++) {
							if (!autoScrolls[i]) {
								autoScrolls[i] = {};
							}
						}
					}

					if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
						autoScrolls[layersOut].el = el;
						autoScrolls[layersOut].vx = vx;
						autoScrolls[layersOut].vy = vy;

						clearInterval(autoScrolls[layersOut].pid);

						if (el && (vx != 0 || vy != 0)) {
							scrollThisInstance = true;
							/* jshint loopfunc:true */
							autoScrolls[layersOut].pid = setInterval((function () {
								// emulate drag over during autoscroll (fallback), emulating native DnD behaviour
								if (isFallback && this.layer === 0) {
									Sortable.active._emulateDragOver(true);
									Sortable.active._onTouchMove(touchEvt, true);
								}
								var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
								var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

								if ('function' === typeof(scrollCustomFn)) {
									if (scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt, touchEvt, autoScrolls[this.layer].el) !== 'continue') {
										return;
									}
								}

								_scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
							}).bind({layer: layersOut}), 24);
						}
					}
					layersOut++;
				} while (options.bubbleScroll && currentParent !== winScroller && (currentParent = _getParentAutoScrollElement(currentParent, false)));
				scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
			}
		}, 30),

		_clearAutoScrolls = function () {
			autoScrolls.forEach(function(autoScroll) {
				clearInterval(autoScroll.pid);
			});
			autoScrolls = [];
		},

		_prepareGroup = function (options) {
			function toFn(value, pull) {
				return function(to, from, dragEl, evt) {
					var sameGroup = to.options.group.name &&
									from.options.group.name &&
									to.options.group.name === from.options.group.name;

					if (value == null && (pull || sameGroup)) {
						// Default pull value
						// Default pull and put value if same group
						return true;
					} else if (value == null || value === false) {
						return false;
					} else if (pull && value === 'clone') {
						return value;
					} else if (typeof value === 'function') {
						return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
					} else {
						var otherGroup = (pull ? to : from).options.group.name;

						return (value === true ||
						(typeof value === 'string' && value === otherGroup) ||
						(value.join && value.indexOf(otherGroup) > -1));
					}
				};
			}

			var group = {};
			var originalGroup = options.group;

			if (!originalGroup || typeof originalGroup != 'object') {
				originalGroup = {name: originalGroup};
			}

			group.name = originalGroup.name;
			group.checkPull = toFn(originalGroup.pull, true);
			group.checkPut = toFn(originalGroup.put);
			group.revertClone = originalGroup.revertClone;

			options.group = group;
		},

		_checkAlignment = function(evt) {
			if (!dragEl || !dragEl.parentNode) return;
			dragEl.parentNode[expando] && dragEl.parentNode[expando]._computeIsAligned(evt);
		},

		_isTrueParentSortable = function(el, target) {
			var trueParent = target;
			while (!trueParent[expando]) {
				trueParent = trueParent.parentNode;
			}

			return el === trueParent;
		},

		_artificalBubble = function(sortable, originalEvt, method) {
			// Artificial IE bubbling
			var nextParent = sortable.parentNode;
			while (nextParent && !nextParent[expando]) {
				nextParent = nextParent.parentNode;
			}

			if (nextParent) {
				nextParent[expando][method](_extend(originalEvt, {
					artificialBubble: true
				}));
			}
		},

		_hideGhostForTarget = function() {
			if (!supportCssPointerEvents && ghostEl) {
				_css(ghostEl, 'display', 'none');
			}
		},

		_unhideGhostForTarget = function() {
			if (!supportCssPointerEvents && ghostEl) {
				_css(ghostEl, 'display', '');
			}
		};


	// #1184 fix - Prevent click event on fallback if dragged but item not changed position
	document.addEventListener('click', function(evt) {
		if (ignoreNextClick) {
			evt.preventDefault();
			evt.stopPropagation && evt.stopPropagation();
			evt.stopImmediatePropagation && evt.stopImmediatePropagation();
			ignoreNextClick = false;
			return false;
		}
	}, true);

	var nearestEmptyInsertDetectEvent = function(evt) {
		evt = evt.touches ? evt.touches[0] : evt;
		if (dragEl) {
			var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

			if (nearest) {
				nearest[expando]._onDragOver({
					clientX: evt.clientX,
					clientY: evt.clientY,
					target: nearest,
					rootEl: nearest
				});
			}
		}
	};
	// We do not want this to be triggered if completed (bubbling canceled), so only define it here
	_on(document, 'dragover', nearestEmptyInsertDetectEvent);
	_on(document, 'mousemove', nearestEmptyInsertDetectEvent);
	_on(document, 'touchmove', nearestEmptyInsertDetectEvent);

	/**
	 * @class  Sortable
	 * @param  {HTMLElement}  el
	 * @param  {Object}       [options]
	 */
	function Sortable(el, options) {
		if (!(el && el.nodeType && el.nodeType === 1)) {
			throw 'Sortable: `el` must be HTMLElement, not ' + {}.toString.call(el);
		}

		this.el = el; // root element
		this.options = options = _extend({}, options);


		// Export instance
		el[expando] = this;

		// Default options
		var defaults = {
			group: null,
			sort: true,
			disabled: false,
			store: null,
			handle: null,
			scroll: true,
			scrollSensitivity: 30,
			scrollSpeed: 10,
			bubbleScroll: true,
			draggable: /[uo]l/i.test(el.nodeName) ? '>li' : '>*',
			swapThreshold: 1, // percentage; 0 <= x <= 1
			invertSwap: false, // invert always
			invertedSwapThreshold: null, // will be set to same as swapThreshold if default
			removeCloneOnHide: true,
			direction: function() {
				return _detectDirection(el, this.options);
			},
			ghostClass: 'sortable-ghost',
			chosenClass: 'sortable-chosen',
			dragClass: 'sortable-drag',
			ignore: 'a, img',
			filter: null,
			preventOnFilter: true,
			animation: 0,
			easing: null,
			setData: function (dataTransfer, dragEl) {
				dataTransfer.setData('Text', dragEl.textContent);
			},
			dropBubble: false,
			dragoverBubble: false,
			dataIdAttr: 'data-id',
			delay: 0,
			touchStartThreshold: parseInt(window.devicePixelRatio, 10) || 1,
			forceFallback: false,
			fallbackClass: 'sortable-fallback',
			fallbackOnBody: false,
			fallbackTolerance: 0,
			fallbackOffset: {x: 0, y: 0},
			supportPointer: Sortable.supportPointer !== false && (
				('PointerEvent' in window) ||
				window.navigator && ('msPointerEnabled' in window.navigator) // microsoft
			),
			emptyInsertThreshold: 5
		};


		// Set default options
		for (var name in defaults) {
			!(name in options) && (options[name] = defaults[name]);
		}

		_prepareGroup(options);

		// Bind all private methods
		for (var fn in this) {
			if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
				this[fn] = this[fn].bind(this);
			}
		}

		// Setup drag mode
		this.nativeDraggable = options.forceFallback ? false : supportDraggable;

		if (this.nativeDraggable) {
			// Touch start threshold cannot be greater than the native dragstart threshold
			this.options.touchStartThreshold = 1;
		}

		// Bind events
		if (options.supportPointer) {
			_on(el, 'pointerdown', this._onTapStart);
		} else {
			_on(el, 'mousedown', this._onTapStart);
			_on(el, 'touchstart', this._onTapStart);
		}

		if (this.nativeDraggable) {
			_on(el, 'dragover', this);
			_on(el, 'dragenter', this);
		}

		sortables.push(this.el);

		// Restore sorting
		options.store && options.store.get && this.sort(options.store.get(this) || []);
	}

	Sortable.prototype = /** @lends Sortable.prototype */ {
		constructor: Sortable,

		_computeIsAligned: function(evt) {
			var target;

			if (ghostEl && !supportCssPointerEvents) {
				_hideGhostForTarget();
				target = document.elementFromPoint(evt.clientX, evt.clientY);
				_unhideGhostForTarget();
			} else {
				target = evt.target;
			}

			target = _closest(target, this.options.draggable, this.el, false);
			if (_alignedSilent) return;
			if (!dragEl || dragEl.parentNode !== this.el) return;

			var children = this.el.children;
			for (var i = 0; i < children.length; i++) {
				// Don't change for target in case it is changed to aligned before onDragOver is fired
				if (_closest(children[i], this.options.draggable, this.el, false) && children[i] !== target) {
					children[i].sortableMouseAligned = _isClientInRowColumn(evt.clientX, evt.clientY, children[i], this._getDirection(evt, null), this.options);
				}
			}
			// Used for nulling last target when not in element, nothing to do with checking if aligned
			if (!_closest(target, this.options.draggable, this.el, true)) {
				lastTarget = null;
			}

			_alignedSilent = true;
			setTimeout(function() {
				_alignedSilent = false;
			}, 30);

		},

		_getDirection: function(evt, target) {
			return (typeof this.options.direction === 'function') ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
		},

		_onTapStart: function (/** Event|TouchEvent */evt) {
			if (!evt.cancelable) return;
			var _this = this,
				el = this.el,
				options = this.options,
				preventOnFilter = options.preventOnFilter,
				type = evt.type,
				touch = evt.touches && evt.touches[0],
				target = (touch || evt).target,
				originalTarget = evt.target.shadowRoot && ((evt.path && evt.path[0]) || (evt.composedPath && evt.composedPath()[0])) || target,
				filter = options.filter,
				startIndex;

			_saveInputCheckedState(el);


			// IE: Calls events in capture mode if event element is nested. This ensures only correct element's _onTapStart goes through.
			// This process is also done in _onDragOver
			if (IE11OrLess && !evt.artificialBubble && !_isTrueParentSortable(el, target)) {
				return;
			}

			// Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
			if (dragEl) {
				return;
			}

			if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
				return; // only left button and enabled
			}

			// cancel dnd if original target is content editable
			if (originalTarget.isContentEditable) {
				return;
			}

			target = _closest(target, options.draggable, el, false);

			if (!target) {
				if (IE11OrLess) {
					_artificalBubble(el, evt, '_onTapStart');
				}
				return;
			}

			if (lastDownEl === target) {
				// Ignoring duplicate `down`
				return;
			}

			// Get the index of the dragged element within its parent
			startIndex = _index(target, options.draggable);

			// Check filter
			if (typeof filter === 'function') {
				if (filter.call(this, evt, target, this)) {
					_dispatchEvent(_this, originalTarget, 'filter', target, el, el, startIndex);
					preventOnFilter && evt.cancelable && evt.preventDefault();
					return; // cancel dnd
				}
			}
			else if (filter) {
				filter = filter.split(',').some(function (criteria) {
					criteria = _closest(originalTarget, criteria.trim(), el, false);

					if (criteria) {
						_dispatchEvent(_this, criteria, 'filter', target, el, el, startIndex);
						return true;
					}
				});

				if (filter) {
					preventOnFilter && evt.cancelable && evt.preventDefault();
					return; // cancel dnd
				}
			}

			if (options.handle && !_closest(originalTarget, options.handle, el, false)) {
				return;
			}

			// Prepare `dragstart`
			this._prepareDragStart(evt, touch, target, startIndex);
		},


		_handleAutoScroll: function(evt, fallback) {
			if (!dragEl || !this.options.scroll) return;
			var x = evt.clientX,
				y = evt.clientY,

				elem = document.elementFromPoint(x, y),
				_this = this;

			// IE does not seem to have native autoscroll,
			// Edge's autoscroll seems too conditional,
			// MACOS Safari does not have autoscroll,
			// Firefox and Chrome are good
			if (fallback || Edge || IE11OrLess || Safari) {
				_autoScroll(evt, _this.options, elem, fallback);

				// Listener for pointer element change
				var ogElemScroller = _getParentAutoScrollElement(elem, true);
				if (
					scrolling &&
					(
						!pointerElemChangedInterval ||
						x !== lastPointerElemX ||
						y !== lastPointerElemY
					)
				) {

					pointerElemChangedInterval && clearInterval(pointerElemChangedInterval);
					// Detect for pointer elem change, emulating native DnD behaviour
					pointerElemChangedInterval = setInterval(function() {
						if (!dragEl) return;
						// could also check if scroll direction on newElem changes due to parent autoscrolling
						var newElem = _getParentAutoScrollElement(document.elementFromPoint(x, y), true);
						if (newElem !== ogElemScroller) {
							ogElemScroller = newElem;
							_clearAutoScrolls();
							_autoScroll(evt, _this.options, ogElemScroller, fallback);
						}
					}, 10);
					lastPointerElemX = x;
					lastPointerElemY = y;
				}

			} else {
				// if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
				if (!_this.options.bubbleScroll || _getParentAutoScrollElement(elem, true) === _getWindowScrollingElement()) {
					_clearAutoScrolls();
					return;
				}
				_autoScroll(evt, _this.options, _getParentAutoScrollElement(elem, false), false);
			}
		},

		_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex) {
			var _this = this,
				el = _this.el,
				options = _this.options,
				ownerDocument = el.ownerDocument,
				dragStartFn;

			if (target && !dragEl && (target.parentNode === el)) {
				rootEl = el;
				dragEl = target;
				parentEl = dragEl.parentNode;
				nextEl = dragEl.nextSibling;
				lastDownEl = target;
				activeGroup = options.group;
				oldIndex = startIndex;

				tapEvt = {
					target: dragEl,
					clientX: (touch || evt).clientX,
					clientY: (touch || evt).clientY
				};

				this._lastX = (touch || evt).clientX;
				this._lastY = (touch || evt).clientY;

				dragEl.style['will-change'] = 'all';
				// undo animation if needed
				dragEl.style.transition = '';
				dragEl.style.transform = '';

				dragStartFn = function () {
					// Delayed drag has been triggered
					// we can re-enable the events: touchmove/mousemove
					_this._disableDelayedDragEvents();

					if (!FireFox && _this.nativeDraggable) {
						dragEl.draggable = true;
					}

					// Bind the events: dragstart/dragend
					_this._triggerDragStart(evt, touch);

					// Drag start event
					_dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, rootEl, oldIndex);

					// Chosen item
					_toggleClass(dragEl, options.chosenClass, true);
				};

				// Disable "draggable"
				options.ignore.split(',').forEach(function (criteria) {
					_find(dragEl, criteria.trim(), _disableDraggable);
				});

				if (options.supportPointer) {
					_on(ownerDocument, 'pointerup', _this._onDrop);
				} else {
					_on(ownerDocument, 'mouseup', _this._onDrop);
					_on(ownerDocument, 'touchend', _this._onDrop);
					_on(ownerDocument, 'touchcancel', _this._onDrop);
				}

				// Make dragEl draggable (must be before delay for FireFox)
				if (FireFox && this.nativeDraggable) {
					this.options.touchStartThreshold = 4;
					dragEl.draggable = true;
				}

				// Delay is impossible for native DnD in Edge or IE
				if (options.delay && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
					// If the user moves the pointer or let go the click or touch
					// before the delay has been reached:
					// disable the delayed drag
					_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchend', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
					_on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
					_on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
					options.supportPointer && _on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);

					_this._dragStartTimer = setTimeout(dragStartFn, options.delay);
				} else {
					dragStartFn();
				}
			}
		},

		_delayedDragTouchMoveHandler: function (/** TouchEvent|PointerEvent **/e) {
			var touch = e.touches ? e.touches[0] : e;
			if (max(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY))
					>= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))
			) {
				this._disableDelayedDrag();
			}
		},

		_disableDelayedDrag: function () {
			dragEl && _disableDraggable(dragEl);
			clearTimeout(this._dragStartTimer);

			this._disableDelayedDragEvents();
		},

		_disableDelayedDragEvents: function () {
			var ownerDocument = this.el.ownerDocument;
			_off(ownerDocument, 'mouseup', this._disableDelayedDrag);
			_off(ownerDocument, 'touchend', this._disableDelayedDrag);
			_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
			_off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
			_off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
			_off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
		},

		_triggerDragStart: function (/** Event */evt, /** Touch */touch) {
			touch = touch || (evt.pointerType == 'touch' ? evt : null);

			if (!this.nativeDraggable || touch) {
				if (this.options.supportPointer) {
					_on(document, 'pointermove', this._onTouchMove);
				} else if (touch) {
					_on(document, 'touchmove', this._onTouchMove);
				} else {
					_on(document, 'mousemove', this._onTouchMove);
				}
			} else {
				_on(dragEl, 'dragend', this);
				_on(rootEl, 'dragstart', this._onDragStart);
			}

			try {
				if (document.selection) {
					// Timeout neccessary for IE9
					_nextTick(function () {
						document.selection.empty();
					});
				} else {
					window.getSelection().removeAllRanges();
				}
			} catch (err) {
			}
		},

		_dragStarted: function (fallback, evt) {
			awaitingDragStarted = false;
			if (rootEl && dragEl) {
				if (this.nativeDraggable) {
					_on(document, 'dragover', this._handleAutoScroll);
					_on(document, 'dragover', _checkAlignment);
				}
				var options = this.options;

				// Apply effect
				!fallback && _toggleClass(dragEl, options.dragClass, false);
				_toggleClass(dragEl, options.ghostClass, true);

				// In case dragging an animated element
				_css(dragEl, 'transform', '');

				Sortable.active = this;

				fallback && this._appendGhost();

				// Drag start event
				_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, rootEl, oldIndex, undefined, evt);
			} else {
				this._nulling();
			}
		},

		_emulateDragOver: function (forAutoScroll) {
			if (touchEvt) {
				if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY && !forAutoScroll) {
					return;
				}
				this._lastX = touchEvt.clientX;
				this._lastY = touchEvt.clientY;

				_hideGhostForTarget();

				var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
				var parent = target;

				while (target && target.shadowRoot) {
					target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
					parent = target;
				}

				if (parent) {
					do {
						if (parent[expando]) {
							var inserted;

							inserted = parent[expando]._onDragOver({
								clientX: touchEvt.clientX,
								clientY: touchEvt.clientY,
								target: target,
								rootEl: parent
							});

							if (inserted && !this.options.dragoverBubble) {
								break;
							}
						}

						target = parent; // store last element
					}
					/* jshint boss:true */
					while (parent = parent.parentNode);
				}
				dragEl.parentNode[expando]._computeIsAligned(touchEvt);

				_unhideGhostForTarget();
			}
		},


		_onTouchMove: function (/**TouchEvent*/evt, forAutoScroll) {
			if (tapEvt) {
				var	options = this.options,
					fallbackTolerance = options.fallbackTolerance,
					fallbackOffset = options.fallbackOffset,
					touch = evt.touches ? evt.touches[0] : evt,
					matrix = ghostEl && _matrix(ghostEl),
					scaleX = ghostEl && matrix && matrix.a,
					scaleY = ghostEl && matrix && matrix.d,
					relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && _getRelativeScrollOffset(ghostRelativeParent),
					dx = ((touch.clientX - tapEvt.clientX)
							+ fallbackOffset.x) / (scaleX || 1)
							+ (relativeScrollOffset ? (relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]) : 0) / (scaleX || 1),
					dy = ((touch.clientY - tapEvt.clientY)
							+ fallbackOffset.y) / (scaleY || 1)
							+ (relativeScrollOffset ? (relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]) : 0) / (scaleY || 1),
					translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';

				// only set the status to dragging, when we are actually dragging
				if (!Sortable.active && !awaitingDragStarted) {
					if (fallbackTolerance &&
						min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance
					) {
						return;
					}
					this._onDragStart(evt, true);
				}

				!forAutoScroll && this._handleAutoScroll(touch, true);

				moved = true;
				touchEvt = touch;

				_css(ghostEl, 'webkitTransform', translate3d);
				_css(ghostEl, 'mozTransform', translate3d);
				_css(ghostEl, 'msTransform', translate3d);
				_css(ghostEl, 'transform', translate3d);

				evt.cancelable && evt.preventDefault();
			}
		},

		_appendGhost: function () {
			// Bug if using scale(): https://stackoverflow.com/questions/2637058
			// Not being adjusted for
			if (!ghostEl) {
				var container = this.options.fallbackOnBody ? document.body : rootEl,
					rect = _getRect(dragEl, true, container, !PositionGhostAbsolutely),
					css = _css(dragEl),
					options = this.options;

				// Position absolutely
				if (PositionGhostAbsolutely) {
					// Get relatively positioned parent
					ghostRelativeParent = container;

					while (
						_css(ghostRelativeParent, 'position') === 'static' &&
						_css(ghostRelativeParent, 'transform') === 'none' &&
						ghostRelativeParent !== document
					) {
						ghostRelativeParent = ghostRelativeParent.parentNode;
					}

					if (ghostRelativeParent !== document) {
						var ghostRelativeParentRect = _getRect(ghostRelativeParent, true);

						rect.top -= ghostRelativeParentRect.top;
						rect.left -= ghostRelativeParentRect.left;
					}

					if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
						if (ghostRelativeParent === document) ghostRelativeParent = _getWindowScrollingElement();

						rect.top += ghostRelativeParent.scrollTop;
						rect.left += ghostRelativeParent.scrollLeft;
					} else {
						ghostRelativeParent = _getWindowScrollingElement();
					}
					ghostRelativeParentInitialScroll = _getRelativeScrollOffset(ghostRelativeParent);
				}


				ghostEl = dragEl.cloneNode(true);

				_toggleClass(ghostEl, options.ghostClass, false);
				_toggleClass(ghostEl, options.fallbackClass, true);
				_toggleClass(ghostEl, options.dragClass, true);

				_css(ghostEl, 'box-sizing', 'border-box');
				_css(ghostEl, 'margin', 0);
				_css(ghostEl, 'top', rect.top);
				_css(ghostEl, 'left', rect.left);
				_css(ghostEl, 'width', rect.width);
				_css(ghostEl, 'height', rect.height);
				_css(ghostEl, 'opacity', '0.8');
				_css(ghostEl, 'position', (PositionGhostAbsolutely ? 'absolute' : 'fixed'));
				_css(ghostEl, 'zIndex', '100000');
				_css(ghostEl, 'pointerEvents', 'none');

				container.appendChild(ghostEl);
			}
		},

		_onDragStart: function (/**Event*/evt, /**boolean*/fallback) {
			var _this = this;
			var dataTransfer = evt.dataTransfer;
			var options = _this.options;

			// Setup clone
			cloneEl = _clone(dragEl);

			cloneEl.draggable = false;
			cloneEl.style['will-change'] = '';

			this._hideClone();

			_toggleClass(cloneEl, _this.options.chosenClass, false);


			// #1143: IFrame support workaround
			_this._cloneId = _nextTick(function () {
				if (!_this.options.removeCloneOnHide) {
					rootEl.insertBefore(cloneEl, dragEl);
				}
				_dispatchEvent(_this, rootEl, 'clone', dragEl);
			});


			!fallback && _toggleClass(dragEl, options.dragClass, true);

			// Set proper drop events
			if (fallback) {
				ignoreNextClick = true;
				_this._loopId = setInterval(_this._emulateDragOver, 50);
			} else {
				// Undo what was set in _prepareDragStart before drag started
				_off(document, 'mouseup', _this._onDrop);
				_off(document, 'touchend', _this._onDrop);
				_off(document, 'touchcancel', _this._onDrop);

				if (dataTransfer) {
					dataTransfer.effectAllowed = 'move';
					options.setData && options.setData.call(_this, dataTransfer, dragEl);
				}

				_on(document, 'drop', _this);

				// #1276 fix:
				_css(dragEl, 'transform', 'translateZ(0)');
			}

			awaitingDragStarted = true;

			_this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
			_on(document, 'selectstart', _this);
			if (Safari) {
				_css(document.body, 'user-select', 'none');
			}
		},


		// Returns true - if no further action is needed (either inserted or another condition)
		_onDragOver: function (/**Event*/evt) {
			var el = this.el,
				target = evt.target,
				dragRect,
				targetRect,
				revert,
				options = this.options,
				group = options.group,
				activeSortable = Sortable.active,
				isOwner = (activeGroup === group),
				canSort = options.sort,
				_this = this;

			if (_silent) return;

			// IE event order fix
			if (IE11OrLess && !evt.rootEl && !evt.artificialBubble && !_isTrueParentSortable(el, target)) {
				return;
			}

			// Return invocation when dragEl is inserted (or completed)
			function completed(insertion) {
				if (insertion) {
					if (isOwner) {
						activeSortable._hideClone();
					} else {
						activeSortable._showClone(_this);
					}

					if (activeSortable) {
						// Set ghost class to new sortable's ghost class
						_toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
						_toggleClass(dragEl, options.ghostClass, true);
					}

					if (putSortable !== _this && _this !== Sortable.active) {
						putSortable = _this;
					} else if (_this === Sortable.active) {
						putSortable = null;
					}

					// Animation
					dragRect && _this._animate(dragRect, dragEl);
					target && targetRect && _this._animate(targetRect, target);
				}


				// Null lastTarget if it is not inside a previously swapped element
				if ((target === dragEl && !dragEl.animated) || (target === el && !target.animated)) {
					lastTarget = null;
				}
				// no bubbling and not fallback
				if (!options.dragoverBubble && !evt.rootEl && target !== document) {
					_this._handleAutoScroll(evt);
					dragEl.parentNode[expando]._computeIsAligned(evt);
				}

				!options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();

				return true;
			}

			// Call when dragEl has been inserted
			function changed() {
				_dispatchEvent(_this, rootEl, 'change', target, el, rootEl, oldIndex, _index(dragEl, options.draggable), evt);
			}


			if (evt.preventDefault !== void 0) {
				evt.cancelable && evt.preventDefault();
			}


			moved = true;

			target = _closest(target, options.draggable, el, true);

			// target is dragEl or target is animated
			if (!!_closest(evt.target, null, dragEl, true) || target.animated) {
				return completed(false);
			}

			if (target !== dragEl) {
				ignoreNextClick = false;
			}

			if (activeSortable && !options.disabled &&
				(isOwner
					? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
					: (
						putSortable === this ||
						(
							(this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&
							group.checkPut(this, activeSortable, dragEl, evt)
						)
					)
				)
			) {
				var axis = this._getDirection(evt, target);

				dragRect = _getRect(dragEl);

				if (revert) {
					this._hideClone();
					parentEl = rootEl; // actualization

					if (nextEl) {
						rootEl.insertBefore(dragEl, nextEl);
					} else {
						rootEl.appendChild(dragEl);
					}

					return completed(true);
				}

				var elLastChild = _lastChild(el);

				if (!elLastChild || _ghostIsLast(evt, axis, el) && !elLastChild.animated) {
					// assign target only if condition is true
					if (elLastChild && el === evt.target) {
						target = elLastChild;
					}

					if (target) {
						targetRect = _getRect(target);
					}

					if (isOwner) {
						activeSortable._hideClone();
					} else {
						activeSortable._showClone(this);
					}

					if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
						el.appendChild(dragEl);
						parentEl = el; // actualization
						realDragElRect = null;

						changed();
						return completed(true);
					}
				}
				else if (target && target !== dragEl && target.parentNode === el) {
					var direction = 0,
						targetBeforeFirstSwap,
						aligned = target.sortableMouseAligned,
						differentLevel = dragEl.parentNode !== el,
						side1 = axis === 'vertical' ? 'top' : 'left',
						scrolledPastTop = _isScrolledPast(target, 'top') || _isScrolledPast(dragEl, 'top'),
						scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;


					if (lastTarget !== target) {
						lastMode = null;
						targetBeforeFirstSwap = _getRect(target)[side1];
						pastFirstInvertThresh = false;
					}

					// Reference: https://www.lucidchart.com/documents/view/10fa0e93-e362-4126-aca2-b709ee56bd8b/0
					if (
						_isElInRowColumn(dragEl, target, axis) && aligned ||
						differentLevel ||
						scrolledPastTop ||
						options.invertSwap ||
						lastMode === 'insert' ||
						// Needed, in the case that we are inside target and inserted because not aligned... aligned will stay false while inside
						// and lastMode will change to 'insert', but we must swap
						lastMode === 'swap'
					) {
						// New target that we will be inside
						if (lastMode !== 'swap') {
							isCircumstantialInvert = options.invertSwap || differentLevel;
						}

						direction = _getSwapDirection(evt, target, axis,
							options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold,
							isCircumstantialInvert,
							lastTarget === target);
						lastMode = 'swap';
					} else {
						// Insert at position
						direction = _getInsertDirection(target);
						lastMode = 'insert';
					}
					if (direction === 0) return completed(false);

					realDragElRect = null;
					lastTarget = target;

					lastDirection = direction;

					targetRect = _getRect(target);

					var nextSibling = target.nextElementSibling,
						after = false;

					after = direction === 1;

					var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

					if (moveVector !== false) {
						if (moveVector === 1 || moveVector === -1) {
							after = (moveVector === 1);
						}

						_silent = true;
						setTimeout(_unsilent, 30);

						if (isOwner) {
							activeSortable._hideClone();
						} else {
							activeSortable._showClone(this);
						}

						if (after && !nextSibling) {
							el.appendChild(dragEl);
						} else {
							target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
						}

						// Undo chrome's scroll adjustment
						if (scrolledPastTop) {
							_scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
						}

						parentEl = dragEl.parentNode; // actualization

						// must be done before animation
						if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
							targetMoveDistance = abs(targetBeforeFirstSwap - _getRect(target)[side1]);
						}
						changed();

						return completed(true);
					}
				}

				if (el.contains(dragEl)) {
					return completed(false);
				}
			}

			if (IE11OrLess && !evt.rootEl) {
				_artificalBubble(el, evt, '_onDragOver');
			}

			return false;
		},

		_animate: function (prevRect, target) {
			var ms = this.options.animation;

			if (ms) {
				var currentRect = _getRect(target);

				if (target === dragEl) {
					realDragElRect = currentRect;
				}

				if (prevRect.nodeType === 1) {
					prevRect = _getRect(prevRect);
				}

				// Check if actually moving position
				if ((prevRect.left + prevRect.width / 2) !== (currentRect.left + currentRect.width / 2)
					|| (prevRect.top + prevRect.height / 2) !== (currentRect.top + currentRect.height / 2)
				) {
					var matrix = _matrix(this.el),
						scaleX = matrix && matrix.a,
						scaleY = matrix && matrix.d;

					_css(target, 'transition', 'none');
					_css(target, 'transform', 'translate3d('
						+ (prevRect.left - currentRect.left) / (scaleX ? scaleX : 1) + 'px,'
						+ (prevRect.top - currentRect.top) / (scaleY ? scaleY : 1) + 'px,0)'
					);

					forRepaintDummy = target.offsetWidth; // repaint
					_css(target, 'transition', 'transform ' + ms + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
					_css(target, 'transform', 'translate3d(0,0,0)');
				}

				(typeof target.animated === 'number') && clearTimeout(target.animated);
				target.animated = setTimeout(function () {
					_css(target, 'transition', '');
					_css(target, 'transform', '');
					target.animated = false;
				}, ms);
			}
		},

		_offUpEvents: function () {
			var ownerDocument = this.el.ownerDocument;

			_off(document, 'touchmove', this._onTouchMove);
			_off(document, 'pointermove', this._onTouchMove);
			_off(ownerDocument, 'mouseup', this._onDrop);
			_off(ownerDocument, 'touchend', this._onDrop);
			_off(ownerDocument, 'pointerup', this._onDrop);
			_off(ownerDocument, 'touchcancel', this._onDrop);
			_off(document, 'selectstart', this);
		},

		_onDrop: function (/**Event*/evt) {
			var el = this.el,
				options = this.options;
			awaitingDragStarted = false;
			scrolling = false;
			isCircumstantialInvert = false;
			pastFirstInvertThresh = false;

			clearInterval(this._loopId);

			clearInterval(pointerElemChangedInterval);
			_clearAutoScrolls();
			_cancelThrottle();

			clearTimeout(this._dragStartTimer);

			_cancelNextTick(this._cloneId);
			_cancelNextTick(this._dragStartId);

			// Unbind events
			_off(document, 'mousemove', this._onTouchMove);


			if (this.nativeDraggable) {
				_off(document, 'drop', this);
				_off(el, 'dragstart', this._onDragStart);
				_off(document, 'dragover', this._handleAutoScroll);
				_off(document, 'dragover', _checkAlignment);
			}

			if (Safari) {
				_css(document.body, 'user-select', '');
			}

			this._offUpEvents();

			if (evt) {
				if (moved) {
					evt.cancelable && evt.preventDefault();
					!options.dropBubble && evt.stopPropagation();
				}

				ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

				if (rootEl === parentEl || (putSortable && putSortable.lastPutMode !== 'clone')) {
					// Remove clone
					cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
				}

				if (dragEl) {
					if (this.nativeDraggable) {
						_off(dragEl, 'dragend', this);
					}

					_disableDraggable(dragEl);
					dragEl.style['will-change'] = '';

					// Remove class's
					_toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
					_toggleClass(dragEl, this.options.chosenClass, false);

					// Drag stop event
					_dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex, null, evt);

					if (rootEl !== parentEl) {
						newIndex = _index(dragEl, options.draggable);

						if (newIndex >= 0) {
							// Add event
							_dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

							// Remove event
							_dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

							// drag from one list and drop into another
							_dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
							_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
						}

						putSortable && putSortable.save();
					}
					else {
						if (dragEl.nextSibling !== nextEl) {
							// Get the index of the dragged element within its parent
							newIndex = _index(dragEl, options.draggable);

							if (newIndex >= 0) {
								// drag & drop within the same list
								_dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
								_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
							}
						}
					}

					if (Sortable.active) {
						/* jshint eqnull:true */
						if (newIndex == null || newIndex === -1) {
							newIndex = oldIndex;
						}
						_dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

						// Save sorting
						this.save();
					}
				}

			}
			this._nulling();
		},

		_nulling: function() {
			rootEl =
			dragEl =
			parentEl =
			ghostEl =
			nextEl =
			cloneEl =
			lastDownEl =

			scrollEl =
			scrollParentEl =
			autoScrolls.length =

			pointerElemChangedInterval =
			lastPointerElemX =
			lastPointerElemY =

			tapEvt =
			touchEvt =

			moved =
			newIndex =
			oldIndex =

			lastTarget =
			lastDirection =

			forRepaintDummy =
			realDragElRect =

			putSortable =
			activeGroup =
			Sortable.active = null;

			savedInputChecked.forEach(function (el) {
				el.checked = true;
			});

			savedInputChecked.length = 0;
		},

		handleEvent: function (/**Event*/evt) {
			switch (evt.type) {
				case 'drop':
				case 'dragend':
					this._onDrop(evt);
					break;

				case 'dragenter':
				case 'dragover':
					if (dragEl) {
						this._onDragOver(evt);
						_globalDragOver(evt);
					}
					break;

				case 'selectstart':
					evt.preventDefault();
					break;
			}
		},


		/**
		 * Serializes the item into an array of string.
		 * @returns {String[]}
		 */
		toArray: function () {
			var order = [],
				el,
				children = this.el.children,
				i = 0,
				n = children.length,
				options = this.options;

			for (; i < n; i++) {
				el = children[i];
				if (_closest(el, options.draggable, this.el, false)) {
					order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
				}
			}

			return order;
		},


		/**
		 * Sorts the elements according to the array.
		 * @param  {String[]}  order  order of the items
		 */
		sort: function (order) {
			var items = {}, rootEl = this.el;

			this.toArray().forEach(function (id, i) {
				var el = rootEl.children[i];

				if (_closest(el, this.options.draggable, rootEl, false)) {
					items[id] = el;
				}
			}, this);

			order.forEach(function (id) {
				if (items[id]) {
					rootEl.removeChild(items[id]);
					rootEl.appendChild(items[id]);
				}
			});
		},


		/**
		 * Save the current sorting
		 */
		save: function () {
			var store = this.options.store;
			store && store.set && store.set(this);
		},


		/**
		 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
		 * @param   {HTMLElement}  el
		 * @param   {String}       [selector]  default: `options.draggable`
		 * @returns {HTMLElement|null}
		 */
		closest: function (el, selector) {
			return _closest(el, selector || this.options.draggable, this.el, false);
		},


		/**
		 * Set/get option
		 * @param   {string} name
		 * @param   {*}      [value]
		 * @returns {*}
		 */
		option: function (name, value) {
			var options = this.options;

			if (value === void 0) {
				return options[name];
			} else {
				options[name] = value;

				if (name === 'group') {
					_prepareGroup(options);
				}
			}
		},


		/**
		 * Destroy
		 */
		destroy: function () {
			var el = this.el;

			el[expando] = null;

			_off(el, 'mousedown', this._onTapStart);
			_off(el, 'touchstart', this._onTapStart);
			_off(el, 'pointerdown', this._onTapStart);

			if (this.nativeDraggable) {
				_off(el, 'dragover', this);
				_off(el, 'dragenter', this);
			}
			// Remove draggable attributes
			Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
				el.removeAttribute('draggable');
			});

			this._onDrop();

			sortables.splice(sortables.indexOf(this.el), 1);

			this.el = el = null;
		},

		_hideClone: function() {
			if (!cloneEl.cloneHidden) {
				_css(cloneEl, 'display', 'none');
				cloneEl.cloneHidden = true;
				if (cloneEl.parentNode && this.options.removeCloneOnHide) {
					cloneEl.parentNode.removeChild(cloneEl);
				}
			}
		},

		_showClone: function(putSortable) {
			if (putSortable.lastPutMode !== 'clone') {
				this._hideClone();
				return;
			}

			if (cloneEl.cloneHidden) {
				// show clone at dragEl or original position
				if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
					rootEl.insertBefore(cloneEl, dragEl);
				} else if (nextEl) {
					rootEl.insertBefore(cloneEl, nextEl);
				} else {
					rootEl.appendChild(cloneEl);
				}

				if (this.options.group.revertClone) {
					this._animate(dragEl, cloneEl);
				}
				_css(cloneEl, 'display', '');
				cloneEl.cloneHidden = false;
			}
		}
	};

	function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
		if (el) {
			ctx = ctx || document;

			do {
				if (
					selector != null &&
					(
						selector[0] === '>' && el.parentNode === ctx && _matches(el, selector.substring(1)) ||
						_matches(el, selector)
					) ||
					includeCTX && el === ctx
				) {
					return el;
				}

				if (el === ctx) break;
				/* jshint boss:true */
			} while (el = _getParentOrHost(el));
		}

		return null;
	}


	function _getParentOrHost(el) {
		return (el.host && el !== document && el.host.nodeType)
			? el.host
			: el.parentNode;
	}


	function _globalDragOver(/**Event*/evt) {
		if (evt.dataTransfer) {
			evt.dataTransfer.dropEffect = 'move';
		}
		evt.cancelable && evt.preventDefault();
	}


	function _on(el, event, fn) {
		el.addEventListener(event, fn, captureMode);
	}


	function _off(el, event, fn) {
		el.removeEventListener(event, fn, captureMode);
	}


	function _toggleClass(el, name, state) {
		if (el && name) {
			if (el.classList) {
				el.classList[state ? 'add' : 'remove'](name);
			}
			else {
				var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
				el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
			}
		}
	}


	function _css(el, prop, val) {
		var style = el && el.style;

		if (style) {
			if (val === void 0) {
				if (document.defaultView && document.defaultView.getComputedStyle) {
					val = document.defaultView.getComputedStyle(el, '');
				}
				else if (el.currentStyle) {
					val = el.currentStyle;
				}

				return prop === void 0 ? val : val[prop];
			}
			else {
				if (!(prop in style) && prop.indexOf('webkit') === -1) {
					prop = '-webkit-' + prop;
				}

				style[prop] = val + (typeof val === 'string' ? '' : 'px');
			}
		}
	}

	function _matrix(el) {
		var appliedTransforms = '';
		do {
			var transform = _css(el, 'transform');

			if (transform && transform !== 'none') {
				appliedTransforms = transform + ' ' + appliedTransforms;
			}
			/* jshint boss:true */
		} while (el = el.parentNode);

		if (window.DOMMatrix) {
			return new DOMMatrix(appliedTransforms);
		} else if (window.WebKitCSSMatrix) {
			return new WebKitCSSMatrix(appliedTransforms);
		} else if (window.CSSMatrix) {
			return new CSSMatrix(appliedTransforms);
		}
	}


	function _find(ctx, tagName, iterator) {
		if (ctx) {
			var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;

			if (iterator) {
				for (; i < n; i++) {
					iterator(list[i], i);
				}
			}

			return list;
		}

		return [];
	}



	function _dispatchEvent(sortable, rootEl, name, targetEl, toEl, fromEl, startIndex, newIndex, originalEvt) {
		sortable = (sortable || rootEl[expando]);
		var evt,
			options = sortable.options,
			onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
		// Support for new CustomEvent feature
		if (window.CustomEvent && !IE11OrLess && !Edge) {
			evt = new CustomEvent(name, {
				bubbles: true,
				cancelable: true
			});
		} else {
			evt = document.createEvent('Event');
			evt.initEvent(name, true, true);
		}

		evt.to = toEl || rootEl;
		evt.from = fromEl || rootEl;
		evt.item = targetEl || rootEl;
		evt.clone = cloneEl;

		evt.oldIndex = startIndex;
		evt.newIndex = newIndex;

		evt.originalEvent = originalEvt;
		evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

		if (rootEl) {
			rootEl.dispatchEvent(evt);
		}

		if (options[onName]) {
			options[onName].call(sortable, evt);
		}
	}


	function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {
		var evt,
			sortable = fromEl[expando],
			onMoveFn = sortable.options.onMove,
			retVal;
		// Support for new CustomEvent feature
		if (window.CustomEvent && !IE11OrLess && !Edge) {
			evt = new CustomEvent('move', {
				bubbles: true,
				cancelable: true
			});
		} else {
			evt = document.createEvent('Event');
			evt.initEvent('move', true, true);
		}

		evt.to = toEl;
		evt.from = fromEl;
		evt.dragged = dragEl;
		evt.draggedRect = dragRect;
		evt.related = targetEl || toEl;
		evt.relatedRect = targetRect || _getRect(toEl);
		evt.willInsertAfter = willInsertAfter;

		evt.originalEvent = originalEvt;

		fromEl.dispatchEvent(evt);

		if (onMoveFn) {
			retVal = onMoveFn.call(sortable, evt, originalEvt);
		}

		return retVal;
	}

	function _disableDraggable(el) {
		el.draggable = false;
	}

	function _unsilent() {
		_silent = false;
	}

	/**
	 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
	 * and non-draggable elements
	 * @param  {HTMLElement} el       The parent element
	 * @param  {Number} childNum      The index of the child
	 * @param  {Object} options       Parent Sortable's options
	 * @return {HTMLElement}          The child at index childNum, or null if not found
	 */
	function _getChild(el, childNum, options) {
		var currentChild = 0,
			i = 0,
			children = el.children;

		while (i < children.length) {
			if (
				children[i].style.display !== 'none' &&
				children[i] !== ghostEl &&
				children[i] !== dragEl &&
				_closest(children[i], options.draggable, el, false)
			) {
				if (currentChild === childNum) {
					return children[i];
				}
				currentChild++;
			}

			i++;
		}
		return null;
	}

	/**
	 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
	 * @param  {HTMLElement} el       Parent element
	 * @return {HTMLElement}          The last child, ignoring ghostEl
	 */
	function _lastChild(el) {
		var last = el.lastElementChild;

		while (last && (last === ghostEl || last.style.display === 'none')) {
			last = last.previousElementSibling;
		}

		return last || null;
	}

	function _ghostIsLast(evt, axis, el) {
		var elRect = _getRect(_lastChild(el)),
			mouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,
			mouseOnOppAxis = axis === 'vertical' ? evt.clientX : evt.clientY,
			targetS2 = axis === 'vertical' ? elRect.bottom : elRect.right,
			targetS1Opp = axis === 'vertical' ? elRect.left : elRect.top,
			targetS2Opp = axis === 'vertical' ? elRect.right : elRect.bottom,
			spacer = 10;

		return (
			axis === 'vertical' ?
				(mouseOnOppAxis > targetS2Opp + spacer || mouseOnOppAxis <= targetS2Opp && mouseOnAxis > targetS2 && mouseOnOppAxis >= targetS1Opp) :
				(mouseOnAxis > targetS2 && mouseOnOppAxis > targetS1Opp || mouseOnAxis <= targetS2 && mouseOnOppAxis > targetS2Opp + spacer)
		);
	}

	function _getSwapDirection(evt, target, axis, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
		var targetRect = _getRect(target),
			mouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,
			targetLength = axis === 'vertical' ? targetRect.height : targetRect.width,
			targetS1 = axis === 'vertical' ? targetRect.top : targetRect.left,
			targetS2 = axis === 'vertical' ? targetRect.bottom : targetRect.right,
			dragRect = _getRect(dragEl),
			invert = false;


		if (!invertSwap) {
			// Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
			if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) { // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
				// check if past first invert threshold on side opposite of lastDirection
				if (!pastFirstInvertThresh &&
					(lastDirection === 1 ?
						(
							mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2
						) :
						(
							mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2
						)
					)
				)
				{
					// past first invert threshold, do not restrict inverted threshold to dragEl shadow
					pastFirstInvertThresh = true;
				}

				if (!pastFirstInvertThresh) {
					var dragS1 = axis === 'vertical' ? dragRect.top : dragRect.left,
						dragS2 = axis === 'vertical' ? dragRect.bottom : dragRect.right;
					// dragEl shadow (target move distance shadow)
					if (
						lastDirection === 1 ?
						(
							mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
						) :
						(
							mouseOnAxis > targetS2 - targetMoveDistance
						)
					)
					{
						return lastDirection * -1;
					}
				} else {
					invert = true;
				}
			} else {
				// Regular
				if (
					mouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold) / 2) &&
					mouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold) / 2)
				) {
					return _getInsertDirection(target);
				}
			}
		}

		invert = invert || invertSwap;

		if (invert) {
			// Invert of regular
			if (
				mouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold / 2) ||
				mouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold / 2)
			)
			{
				return ((mouseOnAxis > targetS1 + targetLength / 2) ? 1 : -1);
			}
		}

		return 0;
	}

	/**
	 * Gets the direction dragEl must be swapped relative to target in order to make it
	 * seem that dragEl has been "inserted" into that element's position
	 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
	 * @return {Number}                   Direction dragEl must be swapped
	 */
	function _getInsertDirection(target) {
		var dragElIndex = _index(dragEl),
			targetIndex = _index(target);

		if (dragElIndex < targetIndex) {
			return 1;
		} else {
			return -1;
		}
	}


	/**
	 * Generate id
	 * @param   {HTMLElement} el
	 * @returns {String}
	 * @private
	 */
	function _generateId(el) {
		var str = el.tagName + el.className + el.src + el.href + el.textContent,
			i = str.length,
			sum = 0;

		while (i--) {
			sum += str.charCodeAt(i);
		}

		return sum.toString(36);
	}

	/**
	 * Returns the index of an element within its parent for a selected set of
	 * elements
	 * @param  {HTMLElement} el
	 * @param  {selector} selector
	 * @return {number}
	 */
	function _index(el, selector) {
		var index = 0;

		if (!el || !el.parentNode) {
			return -1;
		}

		while (el && (el = el.previousElementSibling)) {
			if ((el.nodeName.toUpperCase() !== 'TEMPLATE') && el !== cloneEl) {
				index++;
			}
		}

		return index;
	}

	function _matches(/**HTMLElement*/el, /**String*/selector) {
		if (el) {
			try {
				if (el.matches) {
					return el.matches(selector);
				} else if (el.msMatchesSelector) {
					return el.msMatchesSelector(selector);
				} else if (el.webkitMatchesSelector) {
					return el.webkitMatchesSelector(selector);
				}
			} catch(_) {
				return false;
			}
		}

		return false;
	}

	var _throttleTimeout;
	function _throttle(callback, ms) {
		return function () {
			if (!_throttleTimeout) {
				var args = arguments,
					_this = this;

				_throttleTimeout = setTimeout(function () {
					if (args.length === 1) {
						callback.call(_this, args[0]);
					} else {
						callback.apply(_this, args);
					}

					_throttleTimeout = void 0;
				}, ms);
			}
		};
	}

	function _cancelThrottle() {
		clearTimeout(_throttleTimeout);
		_throttleTimeout = void 0;
	}

	function _extend(dst, src) {
		if (dst && src) {
			for (var key in src) {
				if (src.hasOwnProperty(key)) {
					dst[key] = src[key];
				}
			}
		}

		return dst;
	}

	function _clone(el) {
		if (Polymer && Polymer.dom) {
			return Polymer.dom(el).cloneNode(true);
		}
		else if ($) {
			return $(el).clone(true)[0];
		}
		else {
			return el.cloneNode(true);
		}
	}

	function _saveInputCheckedState(root) {
		savedInputChecked.length = 0;

		var inputs = root.getElementsByTagName('input');
		var idx = inputs.length;

		while (idx--) {
			var el = inputs[idx];
			el.checked && savedInputChecked.push(el);
		}
	}

	function _nextTick(fn) {
		return setTimeout(fn, 0);
	}

	function _cancelNextTick(id) {
		return clearTimeout(id);
	}


	/**
	 * Returns the "bounding client rect" of given element
	 * @param  {HTMLElement} el                The element whose boundingClientRect is wanted
	 * @param  {[HTMLElement]} container       the parent the element will be placed in
	 * @param  {[Boolean]} adjustForTransform  Whether the rect should compensate for parent's transform
	 * @return {Object}                        The boundingClientRect of el
	 */
	function _getRect(el, adjustForTransform, container, adjustForFixed) {
		if (!el.getBoundingClientRect && el !== win) return;

		var elRect,
			top,
			left,
			bottom,
			right,
			height,
			width;

		if (el !== win && el !== _getWindowScrollingElement()) {
			elRect = el.getBoundingClientRect();
			top = elRect.top;
			left = elRect.left;
			bottom = elRect.bottom;
			right = elRect.right;
			height = elRect.height;
			width = elRect.width;
		} else {
			top = 0;
			left = 0;
			bottom = window.innerHeight;
			right = window.innerWidth;
			height = window.innerHeight;
			width = window.innerWidth;
		}

		if (adjustForFixed && el !== win) {
			// Adjust for translate()
			container = container || el.parentNode;

			// solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
			// Not needed on <= IE11
			if (!IE11OrLess) {
				do {
					if (container && container.getBoundingClientRect && _css(container, 'transform') !== 'none') {
						var containerRect = container.getBoundingClientRect();

						// Set relative to edges of padding box of container
						top -= containerRect.top + parseInt(_css(container, 'border-top-width'));
						left -= containerRect.left + parseInt(_css(container, 'border-left-width'));
						bottom = top + elRect.height;
						right = left + elRect.width;

						break;
					}
					/* jshint boss:true */
				} while (container = container.parentNode);
			}
		}

		if (adjustForTransform && el !== win) {
			// Adjust for scale()
			var matrix = _matrix(container || el),
				scaleX = matrix && matrix.a,
				scaleY = matrix && matrix.d;

			if (matrix) {
				top /= scaleY;
				left /= scaleX;

				width /= scaleX;
				height /= scaleY;

				bottom = top + height;
				right = left + width;
			}
		}

		return {
			top: top,
			left: left,
			bottom: bottom,
			right: right,
			width: width,
			height: height
		};
	}


	/**
	 * Checks if a side of an element is scrolled past a side of it's parents
	 * @param  {HTMLElement}  el       The element who's side being scrolled out of view is in question
	 * @param  {String}       side     Side of the element in question ('top', 'left', 'right', 'bottom')
	 * @return {HTMLElement}           The parent scroll element that the el's side is scrolled past, or null if there is no such element
	 */
	function _isScrolledPast(el, side) {
		var parent = _getParentAutoScrollElement(el, true),
			elSide = _getRect(el)[side];

		/* jshint boss:true */
		while (parent) {
			var parentSide = _getRect(parent)[side],
				visible;

			if (side === 'top' || side === 'left') {
				visible = elSide >= parentSide;
			} else {
				visible = elSide <= parentSide;
			}

			if (!visible) return parent;

			if (parent === _getWindowScrollingElement()) break;

			parent = _getParentAutoScrollElement(parent, false);
		}

		return false;
	}

	/**
	 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
	 * The value is returned in real pixels.
	 * @param  {HTMLElement} el
	 * @return {Array}             Offsets in the format of [left, top]
	 */
	function _getRelativeScrollOffset(el) {
		var offsetLeft = 0,
			offsetTop = 0,
			winScroller = _getWindowScrollingElement();

		if (el) {
			do {
				var matrix = _matrix(el),
					scaleX = matrix.a,
					scaleY = matrix.d;

				offsetLeft += el.scrollLeft * scaleX;
				offsetTop += el.scrollTop * scaleY;
			} while (el !== winScroller && (el = el.parentNode));
		}

		return [offsetLeft, offsetTop];
	}

	// Fixed #973:
	_on(document, 'touchmove', function(evt) {
		if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
			evt.preventDefault();
		}
	});


	// Export utils
	Sortable.utils = {
		on: _on,
		off: _off,
		css: _css,
		find: _find,
		is: function (el, selector) {
			return !!_closest(el, selector, el, false);
		},
		extend: _extend,
		throttle: _throttle,
		closest: _closest,
		toggleClass: _toggleClass,
		clone: _clone,
		index: _index,
		nextTick: _nextTick,
		cancelNextTick: _cancelNextTick,
		detectDirection: _detectDirection,
		getChild: _getChild
	};


	/**
	 * Create sortable instance
	 * @param {HTMLElement}  el
	 * @param {Object}      [options]
	 */
	Sortable.create = function (el, options) {
		return new Sortable(el, options);
	};


	// Export
	Sortable.version = '1.8.4';
	return Sortable;
});


// @vuebundler[Lsw_framework_components][5]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/others/vue.draggable/vue.draggable.js
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("sortablejs"));
	else if(typeof define === 'function' && define.amd)
		define(["sortablejs"], factory);
	else if(typeof exports === 'object')
		exports["vuedraggable"] = factory(require("sortablejs"));
	else
		root["vuedraggable"] = factory(root["Sortable"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE_a352__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "02f4":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("4588");
var defined = __webpack_require__("be13");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "0390":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var at = __webpack_require__("02f4")(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),

/***/ "07e3":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "0bfb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__("cb7c");
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "0fc9":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("3a38");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "1654":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__("71c1")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__("30f1")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "1691":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "1af6":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__("63b6");

$export($export.S, 'Array', { isArray: __webpack_require__("9003") });


/***/ }),

/***/ "1bc3":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("f772");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "1ec9":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("f772");
var document = __webpack_require__("e53d").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "20fd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__("d9f6");
var createDesc = __webpack_require__("aebd");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "214f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__("b0c5");
var redefine = __webpack_require__("2aba");
var hide = __webpack_require__("32e9");
var fails = __webpack_require__("79e5");
var defined = __webpack_require__("be13");
var wks = __webpack_require__("2b4c");
var regexpExec = __webpack_require__("520a");

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),

/***/ "230e":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("d3f4");
var document = __webpack_require__("7726").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "23c6":
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__("2d95");
var TAG = __webpack_require__("2b4c")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "241e":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("25eb");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "25eb":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "294c":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "2aba":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7726");
var hide = __webpack_require__("32e9");
var has = __webpack_require__("69a8");
var SRC = __webpack_require__("ca5a")('src');
var $toString = __webpack_require__("fa5b");
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__("8378").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "2b4c":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("5537")('wks');
var uid = __webpack_require__("ca5a");
var Symbol = __webpack_require__("7726").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "2d00":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "2d95":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "2fdb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__("5ca1");
var context = __webpack_require__("d2c8");
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__("5147")(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "30f1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("b8e3");
var $export = __webpack_require__("63b6");
var redefine = __webpack_require__("9138");
var hide = __webpack_require__("35e8");
var Iterators = __webpack_require__("481b");
var $iterCreate = __webpack_require__("8f60");
var setToStringTag = __webpack_require__("45f2");
var getPrototypeOf = __webpack_require__("53e2");
var ITERATOR = __webpack_require__("5168")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "32a6":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__("241e");
var $keys = __webpack_require__("c3a1");

__webpack_require__("ce7e")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "32e9":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("86cc");
var createDesc = __webpack_require__("4630");
module.exports = __webpack_require__("9e1e") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "32fc":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("e53d").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "335c":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("6b4c");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "355d":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "35e8":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("d9f6");
var createDesc = __webpack_require__("aebd");
module.exports = __webpack_require__("8e60") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "36c3":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("335c");
var defined = __webpack_require__("25eb");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "3702":
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__("481b");
var ITERATOR = __webpack_require__("5168")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "3a38":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "40c3":
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__("6b4c");
var TAG = __webpack_require__("5168")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "4588":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "45f2":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("d9f6").f;
var has = __webpack_require__("07e3");
var TAG = __webpack_require__("5168")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "4630":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "469f":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("6c1c");
__webpack_require__("1654");
module.exports = __webpack_require__("7d7b");


/***/ }),

/***/ "481b":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "4aa6":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("dc62");

/***/ }),

/***/ "4bf8":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("be13");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "4ee1":
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__("5168")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "50ed":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "5147":
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__("2b4c")('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),

/***/ "5168":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("dbdb")('wks');
var uid = __webpack_require__("62a0");
var Symbol = __webpack_require__("e53d").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "5176":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("51b6");

/***/ }),

/***/ "51b6":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("a3c3");
module.exports = __webpack_require__("584a").Object.assign;


/***/ }),

/***/ "520a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__("0bfb");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "53e2":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("07e3");
var toObject = __webpack_require__("241e");
var IE_PROTO = __webpack_require__("5559")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "549b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__("d864");
var $export = __webpack_require__("63b6");
var toObject = __webpack_require__("241e");
var call = __webpack_require__("b0dc");
var isArrayIter = __webpack_require__("3702");
var toLength = __webpack_require__("b447");
var createProperty = __webpack_require__("20fd");
var getIterFn = __webpack_require__("7cd6");

$export($export.S + $export.F * !__webpack_require__("4ee1")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "54a1":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("6c1c");
__webpack_require__("1654");
module.exports = __webpack_require__("95d5");


/***/ }),

/***/ "5537":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("8378");
var global = __webpack_require__("7726");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("2d00") ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "5559":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("dbdb")('keys');
var uid = __webpack_require__("62a0");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "584a":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "5b4e":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("36c3");
var toLength = __webpack_require__("b447");
var toAbsoluteIndex = __webpack_require__("0fc9");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "5ca1":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7726");
var core = __webpack_require__("8378");
var hide = __webpack_require__("32e9");
var redefine = __webpack_require__("2aba");
var ctx = __webpack_require__("9b43");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "5d73":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("469f");

/***/ }),

/***/ "5f1b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__("23c6");
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),

/***/ "626a":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("2d95");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "62a0":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "63b6":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("e53d");
var core = __webpack_require__("584a");
var ctx = __webpack_require__("d864");
var hide = __webpack_require__("35e8");
var has = __webpack_require__("07e3");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "6762":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__("5ca1");
var $includes = __webpack_require__("c366")(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__("9c6c")('includes');


/***/ }),

/***/ "6821":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("626a");
var defined = __webpack_require__("be13");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "69a8":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "6a99":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("d3f4");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "6b4c":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "6c1c":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("c367");
var global = __webpack_require__("e53d");
var hide = __webpack_require__("35e8");
var Iterators = __webpack_require__("481b");
var TO_STRING_TAG = __webpack_require__("5168")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "71c1":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("3a38");
var defined = __webpack_require__("25eb");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "7726":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "774e":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("d2d5");

/***/ }),

/***/ "77f1":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("4588");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "794b":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("8e60") && !__webpack_require__("294c")(function () {
  return Object.defineProperty(__webpack_require__("1ec9")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "79aa":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "79e5":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "7cd6":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("40c3");
var ITERATOR = __webpack_require__("5168")('iterator');
var Iterators = __webpack_require__("481b");
module.exports = __webpack_require__("584a").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "7d7b":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("e4ae");
var get = __webpack_require__("7cd6");
module.exports = __webpack_require__("584a").getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),

/***/ "7e90":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("d9f6");
var anObject = __webpack_require__("e4ae");
var getKeys = __webpack_require__("c3a1");

module.exports = __webpack_require__("8e60") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "8378":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "8436":
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "86cc":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("cb7c");
var IE8_DOM_DEFINE = __webpack_require__("c69a");
var toPrimitive = __webpack_require__("6a99");
var dP = Object.defineProperty;

exports.f = __webpack_require__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "8aae":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("32a6");
module.exports = __webpack_require__("584a").Object.keys;


/***/ }),

/***/ "8e60":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("294c")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "8f60":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__("a159");
var descriptor = __webpack_require__("aebd");
var setToStringTag = __webpack_require__("45f2");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("35e8")(IteratorPrototype, __webpack_require__("5168")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "9003":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__("6b4c");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "9138":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("35e8");


/***/ }),

/***/ "9306":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__("c3a1");
var gOPS = __webpack_require__("9aa9");
var pIE = __webpack_require__("355d");
var toObject = __webpack_require__("241e");
var IObject = __webpack_require__("335c");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__("294c")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),

/***/ "9427":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("63b6");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__("a159") });


/***/ }),

/***/ "95d5":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("40c3");
var ITERATOR = __webpack_require__("5168")('iterator');
var Iterators = __webpack_require__("481b");
module.exports = __webpack_require__("584a").isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),

/***/ "9aa9":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "9b43":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("d8e8");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "9c6c":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__("2b4c")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__("32e9")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "9def":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("4588");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "9e1e":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("79e5")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "a159":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("e4ae");
var dPs = __webpack_require__("7e90");
var enumBugKeys = __webpack_require__("1691");
var IE_PROTO = __webpack_require__("5559")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("1ec9")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("32fc").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "a352":
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_a352__;

/***/ }),

/***/ "a3c3":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("63b6");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("9306") });


/***/ }),

/***/ "a481":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__("cb7c");
var toObject = __webpack_require__("4bf8");
var toLength = __webpack_require__("9def");
var toInteger = __webpack_require__("4588");
var advanceStringIndex = __webpack_require__("0390");
var regExpExec = __webpack_require__("5f1b");
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__("214f")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "a4bb":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("8aae");

/***/ }),

/***/ "a745":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("f410");

/***/ }),

/***/ "aae3":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__("d3f4");
var cof = __webpack_require__("2d95");
var MATCH = __webpack_require__("2b4c")('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ "aebd":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "b0c5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpExec = __webpack_require__("520a");
__webpack_require__("5ca1")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),

/***/ "b0dc":
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__("e4ae");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "b447":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("3a38");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "b8e3":
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "be13":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "c366":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("6821");
var toLength = __webpack_require__("9def");
var toAbsoluteIndex = __webpack_require__("77f1");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "c367":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__("8436");
var step = __webpack_require__("50ed");
var Iterators = __webpack_require__("481b");
var toIObject = __webpack_require__("36c3");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__("30f1")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "c3a1":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("e6f3");
var enumBugKeys = __webpack_require__("1691");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "c649":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return insertNodeAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return camelize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return console; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return removeNode; });
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a481");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var F_source_vuedraggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("4aa6");
/* harmony import */ var F_source_vuedraggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(F_source_vuedraggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1__);



function getConsole() {
  if (typeof window !== "undefined") {
    return window.console;
  }

  return global.console;
}

var console = getConsole();

function cached(fn) {
  var cache = F_source_vuedraggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1___default()(null);

  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

var regex = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(regex, function (_, c) {
    return c ? c.toUpperCase() : "";
  });
});

function removeNode(node) {
  if (node.parentElement !== null) {
    node.parentElement.removeChild(node);
  }
}

function insertNodeAt(fatherNode, node, position) {
  var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
  fatherNode.insertBefore(node, refNode);
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "c69a":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("9e1e") && !__webpack_require__("79e5")(function () {
  return Object.defineProperty(__webpack_require__("230e")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "c8bb":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("54a1");

/***/ }),

/***/ "ca5a":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "cb7c":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("d3f4");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "ce7e":
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__("63b6");
var core = __webpack_require__("584a");
var fails = __webpack_require__("294c");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "d2c8":
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__("aae3");
var defined = __webpack_require__("be13");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),

/***/ "d2d5":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("1654");
__webpack_require__("549b");
module.exports = __webpack_require__("584a").Array.from;


/***/ }),

/***/ "d3f4":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "d864":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("79aa");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "d8e8":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "d9f6":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("e4ae");
var IE8_DOM_DEFINE = __webpack_require__("794b");
var toPrimitive = __webpack_require__("1bc3");
var dP = Object.defineProperty;

exports.f = __webpack_require__("8e60") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "dbdb":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("584a");
var global = __webpack_require__("e53d");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("b8e3") ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "dc62":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("9427");
var $Object = __webpack_require__("584a").Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),

/***/ "e4ae":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("f772");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "e53d":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "e6f3":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("07e3");
var toIObject = __webpack_require__("36c3");
var arrayIndexOf = __webpack_require__("5b4e")(false);
var IE_PROTO = __webpack_require__("5559")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "f410":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("1af6");
module.exports = __webpack_require__("584a").Array.isArray;


/***/ }),

/***/ "f559":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__("5ca1");
var toLength = __webpack_require__("9def");
var context = __webpack_require__("d2c8");
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__("5147")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),

/***/ "f772":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "fa5b":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("5537")('native-function-to-string', Function.toString);


/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var setPublicPath_i
  if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
    __webpack_require__.p = setPublicPath_i[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/assign.js
var object_assign = __webpack_require__("5176");
var assign_default = /*#__PURE__*/__webpack_require__.n(object_assign);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js
var es6_string_starts_with = __webpack_require__("f559");

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/keys.js
var keys = __webpack_require__("a4bb");
var keys_default = /*#__PURE__*/__webpack_require__.n(keys);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js
var es7_array_includes = __webpack_require__("6762");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js
var es6_string_includes = __webpack_require__("2fdb");

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/array/is-array.js
var is_array = __webpack_require__("a745");
var is_array_default = /*#__PURE__*/__webpack_require__.n(is_array);

// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/arrayWithHoles.js

function _arrayWithHoles(arr) {
  if (is_array_default()(arr)) return arr;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/get-iterator.js
var get_iterator = __webpack_require__("5d73");
var get_iterator_default = /*#__PURE__*/__webpack_require__.n(get_iterator);

// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/iterableToArrayLimit.js

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = get_iterator_default()(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray.js



function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (is_array_default()(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/array/from.js
var from = __webpack_require__("774e");
var from_default = /*#__PURE__*/__webpack_require__.n(from);

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/is-iterable.js
var is_iterable = __webpack_require__("c8bb");
var is_iterable_default = /*#__PURE__*/__webpack_require__.n(is_iterable);

// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/iterableToArray.js


function _iterableToArray(iter) {
  if (is_iterable_default()(Object(iter)) || Object.prototype.toString.call(iter) === "[object Arguments]") return from_default()(iter);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray.js



function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}
// EXTERNAL MODULE: external {"commonjs":"sortablejs","commonjs2":"sortablejs","amd":"sortablejs","root":"Sortable"}
var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");
var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_);

// EXTERNAL MODULE: ./src/util/helper.js
var helper = __webpack_require__("c649");

// CONCATENATED MODULE: ./src/vuedraggable.js










function buildAttribute(object, propName, value) {
  if (value === undefined) {
    return object;
  }

  object = object || {};
  object[propName] = value;
  return object;
}

function computeVmIndex(vnodes, element) {
  return vnodes.map(function (elt) {
    return elt.elm;
  }).indexOf(element);
}

function _computeIndexes(slots, children, isTransition, footerOffset) {
  if (!slots) {
    return [];
  }

  var elmFromNodes = slots.map(function (elt) {
    return elt.elm;
  });
  var footerIndex = children.length - footerOffset;

  var rawIndexes = _toConsumableArray(children).map(function (elt, idx) {
    return idx >= footerIndex ? elmFromNodes.length : elmFromNodes.indexOf(elt);
  });

  return isTransition ? rawIndexes.filter(function (ind) {
    return ind !== -1;
  }) : rawIndexes;
}

function emit(evtName, evtData) {
  var _this = this;

  this.$nextTick(function () {
    return _this.$emit(evtName.toLowerCase(), evtData);
  });
}

function delegateAndEmit(evtName) {
  var _this2 = this;

  return function (evtData) {
    if (_this2.realList !== null) {
      _this2["onDrag" + evtName](evtData);
    }

    emit.call(_this2, evtName, evtData);
  };
}

function vuedraggable_isTransition(slots) {
  if (!slots || slots.length !== 1) {
    return false;
  }

  var _slots = _slicedToArray(slots, 1),
      componentOptions = _slots[0].componentOptions;

  if (!componentOptions) {
    return false;
  }

  return ["transition-group", "TransitionGroup"].includes(componentOptions.tag);
}

function computeChildrenAndOffsets(children, _ref) {
  var header = _ref.header,
      footer = _ref.footer;
  var headerOffset = 0;
  var footerOffset = 0;

  if (header) {
    headerOffset = header.length;
    children = children ? [].concat(_toConsumableArray(header), _toConsumableArray(children)) : _toConsumableArray(header);
  }

  if (footer) {
    footerOffset = footer.length;
    children = children ? [].concat(_toConsumableArray(children), _toConsumableArray(footer)) : _toConsumableArray(footer);
  }

  return {
    children: children,
    headerOffset: headerOffset,
    footerOffset: footerOffset
  };
}

function getComponentAttributes($attrs, componentData) {
  var attributes = null;

  var update = function update(name, value) {
    attributes = buildAttribute(attributes, name, value);
  };

  var attrs = keys_default()($attrs).filter(function (key) {
    return key === "id" || key.startsWith("data-");
  }).reduce(function (res, key) {
    res[key] = $attrs[key];
    return res;
  }, {});

  update("attrs", attrs);

  if (!componentData) {
    return attributes;
  }

  var on = componentData.on,
      props = componentData.props,
      componentDataAttrs = componentData.attrs;
  update("on", on);
  update("props", props);

  assign_default()(attributes.attrs, componentDataAttrs);

  return attributes;
}

var eventsListened = ["Start", "Add", "Remove", "Update", "End"];
var eventsToEmit = ["Choose", "Sort", "Filter", "Clone"];
var readonlyProperties = ["Move"].concat(eventsListened, eventsToEmit).map(function (evt) {
  return "on" + evt;
});
var draggingElement = null;
var vuedraggable_props = {
  options: Object,
  list: {
    type: Array,
    required: false,
    default: null
  },
  value: {
    type: Array,
    required: false,
    default: null
  },
  noTransitionOnDrag: {
    type: Boolean,
    default: false
  },
  clone: {
    type: Function,
    default: function _default(original) {
      return original;
    }
  },
  element: {
    type: String,
    default: "div"
  },
  tag: {
    type: String,
    default: null
  },
  move: {
    type: Function,
    default: null
  },
  componentData: {
    type: Object,
    required: false,
    default: null
  }
};
var draggableComponent = {
  name: "draggable",
  inheritAttrs: false,
  props: vuedraggable_props,
  data: function data() {
    return {
      transitionMode: false,
      noneFunctionalComponentMode: false,
      init: false
    };
  },
  render: function render(h) {
    var slots = this.$slots.default;
    this.transitionMode = vuedraggable_isTransition(slots);

    var _computeChildrenAndOf = computeChildrenAndOffsets(slots, this.$slots),
        children = _computeChildrenAndOf.children,
        headerOffset = _computeChildrenAndOf.headerOffset,
        footerOffset = _computeChildrenAndOf.footerOffset;

    this.headerOffset = headerOffset;
    this.footerOffset = footerOffset;
    var attributes = getComponentAttributes(this.$attrs, this.componentData);
    return h(this.getTag(), attributes, children);
  },
  created: function created() {
    if (this.list !== null && this.value !== null) {
      helper["b" /* console */].error("Value and list props are mutually exclusive! Please set one or another.");
    }

    if (this.element !== "div") {
      helper["b" /* console */].warn("Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props");
    }

    if (this.options !== undefined) {
      helper["b" /* console */].warn("Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props");
    }
  },
  mounted: function mounted() {
    var _this3 = this;

    this.noneFunctionalComponentMode = this.getTag().toLowerCase() !== this.$el.nodeName.toLowerCase();

    if (this.noneFunctionalComponentMode && this.transitionMode) {
      throw new Error("Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: ".concat(this.getTag()));
    }

    var optionsAdded = {};
    eventsListened.forEach(function (elt) {
      optionsAdded["on" + elt] = delegateAndEmit.call(_this3, elt);
    });
    eventsToEmit.forEach(function (elt) {
      optionsAdded["on" + elt] = emit.bind(_this3, elt);
    });

    var attributes = keys_default()(this.$attrs).reduce(function (res, key) {
      res[Object(helper["a" /* camelize */])(key)] = _this3.$attrs[key];
      return res;
    }, {});

    var options = assign_default()({}, this.options, attributes, optionsAdded, {
      onMove: function onMove(evt, originalEvent) {
        return _this3.onDragMove(evt, originalEvent);
      }
    });

    !("draggable" in options) && (options.draggable = ">*");
    this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(this.rootContainer, options);
    this.computeIndexes();
  },
  beforeDestroy: function beforeDestroy() {
    if (this._sortable !== undefined) this._sortable.destroy();
  },
  computed: {
    rootContainer: function rootContainer() {
      return this.transitionMode ? this.$el.children[0] : this.$el;
    },
    realList: function realList() {
      return this.list ? this.list : this.value;
    }
  },
  watch: {
    options: {
      handler: function handler(newOptionValue) {
        this.updateOptions(newOptionValue);
      },
      deep: true
    },
    $attrs: {
      handler: function handler(newOptionValue) {
        this.updateOptions(newOptionValue);
      },
      deep: true
    },
    realList: function realList() {
      this.computeIndexes();
    }
  },
  methods: {
    getTag: function getTag() {
      return this.tag || this.element;
    },
    updateOptions: function updateOptions(newOptionValue) {
      for (var property in newOptionValue) {
        var value = Object(helper["a" /* camelize */])(property);

        if (readonlyProperties.indexOf(value) === -1) {
          this._sortable.option(value, newOptionValue[property]);
        }
      }
    },
    getChildrenNodes: function getChildrenNodes() {
      if (!this.init) {
        this.noneFunctionalComponentMode = this.noneFunctionalComponentMode && this.$children.length === 1;
        this.init = true;
      }

      if (this.noneFunctionalComponentMode) {
        return this.$children[0].$slots.default;
      }

      var rawNodes = this.$slots.default;
      return this.transitionMode ? rawNodes[0].child.$slots.default : rawNodes;
    },
    computeIndexes: function computeIndexes() {
      var _this4 = this;

      this.$nextTick(function () {
        _this4.visibleIndexes = _computeIndexes(_this4.getChildrenNodes(), _this4.rootContainer.children, _this4.transitionMode, _this4.footerOffset);
      });
    },
    getUnderlyingVm: function getUnderlyingVm(htmlElt) {
      var index = computeVmIndex(this.getChildrenNodes() || [], htmlElt);

      if (index === -1) {
        //Edge case during move callback: related element might be
        //an element different from collection
        return null;
      }

      var element = this.realList[index];
      return {
        index: index,
        element: element
      };
    },
    getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(_ref2) {
      var __vue__ = _ref2.__vue__;

      if (!__vue__ || !__vue__.$options || __vue__.$options._componentTag !== "transition-group") {
        return __vue__;
      }

      return __vue__.$parent;
    },
    emitChanges: function emitChanges(evt) {
      var _this5 = this;

      this.$nextTick(function () {
        _this5.$emit("change", evt);
      });
    },
    alterList: function alterList(onList) {
      if (this.list) {
        onList(this.list);
        return;
      }

      var newList = _toConsumableArray(this.value);

      onList(newList);
      this.$emit("input", newList);
    },
    spliceList: function spliceList() {
      var _arguments = arguments;

      var spliceList = function spliceList(list) {
        return list.splice.apply(list, _toConsumableArray(_arguments));
      };

      this.alterList(spliceList);
    },
    updatePosition: function updatePosition(oldIndex, newIndex) {
      var updatePosition = function updatePosition(list) {
        return list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
      };

      this.alterList(updatePosition);
    },
    getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref3) {
      var to = _ref3.to,
          related = _ref3.related;
      var component = this.getUnderlyingPotencialDraggableComponent(to);

      if (!component) {
        return {
          component: component
        };
      }

      var list = component.realList;
      var context = {
        list: list,
        component: component
      };

      if (to !== related && list && component.getUnderlyingVm) {
        var destination = component.getUnderlyingVm(related);

        if (destination) {
          return assign_default()(destination, context);
        }
      }

      return context;
    },
    getVmIndex: function getVmIndex(domIndex) {
      var indexes = this.visibleIndexes;
      var numberIndexes = indexes.length;
      return domIndex > numberIndexes - 1 ? numberIndexes : indexes[domIndex];
    },
    getComponent: function getComponent() {
      return this.$slots.default[0].componentInstance;
    },
    resetTransitionData: function resetTransitionData(index) {
      if (!this.noTransitionOnDrag || !this.transitionMode) {
        return;
      }

      var nodes = this.getChildrenNodes();
      nodes[index].data = null;
      var transitionContainer = this.getComponent();
      transitionContainer.children = [];
      transitionContainer.kept = undefined;
    },
    onDragStart: function onDragStart(evt) {
      this.context = this.getUnderlyingVm(evt.item);
      evt.item._underlying_vm_ = this.clone(this.context.element);
      draggingElement = evt.item;
    },
    onDragAdd: function onDragAdd(evt) {
      var element = evt.item._underlying_vm_;

      if (element === undefined) {
        return;
      }

      Object(helper["d" /* removeNode */])(evt.item);
      var newIndex = this.getVmIndex(evt.newIndex);
      this.spliceList(newIndex, 0, element);
      this.computeIndexes();
      var added = {
        element: element,
        newIndex: newIndex
      };
      this.emitChanges({
        added: added
      });
    },
    onDragRemove: function onDragRemove(evt) {
      Object(helper["c" /* insertNodeAt */])(this.rootContainer, evt.item, evt.oldIndex);

      if (evt.pullMode === "clone") {
        Object(helper["d" /* removeNode */])(evt.clone);
        return;
      }

      var oldIndex = this.context.index;
      this.spliceList(oldIndex, 1);
      var removed = {
        element: this.context.element,
        oldIndex: oldIndex
      };
      this.resetTransitionData(oldIndex);
      this.emitChanges({
        removed: removed
      });
    },
    onDragUpdate: function onDragUpdate(evt) {
      Object(helper["d" /* removeNode */])(evt.item);
      Object(helper["c" /* insertNodeAt */])(evt.from, evt.item, evt.oldIndex);
      var oldIndex = this.context.index;
      var newIndex = this.getVmIndex(evt.newIndex);
      this.updatePosition(oldIndex, newIndex);
      var moved = {
        element: this.context.element,
        oldIndex: oldIndex,
        newIndex: newIndex
      };
      this.emitChanges({
        moved: moved
      });
    },
    updateProperty: function updateProperty(evt, propertyName) {
      evt.hasOwnProperty(propertyName) && (evt[propertyName] += this.headerOffset);
    },
    computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
      if (!relatedContext.element) {
        return 0;
      }

      var domChildren = _toConsumableArray(evt.to.children).filter(function (el) {
        return el.style["display"] !== "none";
      });

      var currentDOMIndex = domChildren.indexOf(evt.related);
      var currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
      var draggedInList = domChildren.indexOf(draggingElement) !== -1;
      return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
    },
    onDragMove: function onDragMove(evt, originalEvent) {
      var onMove = this.move;

      if (!onMove || !this.realList) {
        return true;
      }

      var relatedContext = this.getRelatedContextFromMoveEvent(evt);
      var draggedContext = this.context;
      var futureIndex = this.computeFutureIndex(relatedContext, evt);

      assign_default()(draggedContext, {
        futureIndex: futureIndex
      });

      var sendEvt = assign_default()({}, evt, {
        relatedContext: relatedContext,
        draggedContext: draggedContext
      });

      return onMove(sendEvt, originalEvent);
    },
    onDragEnd: function onDragEnd() {
      this.computeIndexes();
      draggingElement = null;
    }
  }
};

if (typeof window !== "undefined" && "Vue" in window) {
  window.Vue.component("draggable", draggableComponent);
}

/* harmony default export */ var vuedraggable = (draggableComponent);
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (vuedraggable);



/***/ })

/******/ })["default"];
});

// @vuebundler[Lsw_framework_components][6]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/others/socket.io-client/socket.io-client.js
/*!
 * Socket.IO v4.8.1
 * (c) 2014-2024 Guillermo Rauch
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.io = factory());
})(this, (function () { 'use strict';

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }
  function _construct(t, e, r) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o = [null];
    o.push.apply(o, e);
    var p = new (t.bind.apply(t, o))();
    return r && _setPrototypeOf(p, r.prototype), p;
  }
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var n = 0,
          F = function () {};
        return {
          s: F,
          n: function () {
            return n >= r.length ? {
              done: !0
            } : {
              done: !1,
              value: r[n++]
            };
          },
          e: function (r) {
            throw r;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o,
      a = !0,
      u = !1;
    return {
      s: function () {
        t = t.call(r);
      },
      n: function () {
        var r = t.next();
        return a = r.done, r;
      },
      e: function (r) {
        u = !0, o = r;
      },
      f: function () {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
  }
  function _inheritsLoose(t, o) {
    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
  }
  function _isNativeFunction(t) {
    try {
      return -1 !== Function.toString.call(t).indexOf("[native code]");
    } catch (n) {
      return "function" == typeof t;
    }
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function () {
      return !!t;
    })();
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }
  function _wrapNativeSuper(t) {
    var r = "function" == typeof Map ? new Map() : void 0;
    return _wrapNativeSuper = function (t) {
      if (null === t || !_isNativeFunction(t)) return t;
      if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== r) {
        if (r.has(t)) return r.get(t);
        r.set(t, Wrapper);
      }
      function Wrapper() {
        return _construct(t, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper.prototype = Object.create(t.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), _setPrototypeOf(Wrapper, t);
    }, _wrapNativeSuper(t);
  }

  var PACKET_TYPES = Object.create(null); // no Map = no polyfill
  PACKET_TYPES["open"] = "0";
  PACKET_TYPES["close"] = "1";
  PACKET_TYPES["ping"] = "2";
  PACKET_TYPES["pong"] = "3";
  PACKET_TYPES["message"] = "4";
  PACKET_TYPES["upgrade"] = "5";
  PACKET_TYPES["noop"] = "6";
  var PACKET_TYPES_REVERSE = Object.create(null);
  Object.keys(PACKET_TYPES).forEach(function (key) {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
  });
  var ERROR_PACKET = {
    type: "error",
    data: "parser error"
  };

  var withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
  var withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
  // ArrayBuffer.isView method is not defined in IE10
  var isView$1 = function isView(obj) {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
  };
  var encodePacket = function encodePacket(_ref, supportsBinary, callback) {
    var type = _ref.type,
      data = _ref.data;
    if (withNativeBlob$1 && data instanceof Blob) {
      if (supportsBinary) {
        return callback(data);
      } else {
        return encodeBlobAsBase64(data, callback);
      }
    } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
      if (supportsBinary) {
        return callback(data);
      } else {
        return encodeBlobAsBase64(new Blob([data]), callback);
      }
    }
    // plain string
    return callback(PACKET_TYPES[type] + (data || ""));
  };
  var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {
    var fileReader = new FileReader();
    fileReader.onload = function () {
      var content = fileReader.result.split(",")[1];
      callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data);
  };
  function toArray(data) {
    if (data instanceof Uint8Array) {
      return data;
    } else if (data instanceof ArrayBuffer) {
      return new Uint8Array(data);
    } else {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
  }
  var TEXT_ENCODER;
  function encodePacketToBinary(packet, callback) {
    if (withNativeBlob$1 && packet.data instanceof Blob) {
      return packet.data.arrayBuffer().then(toArray).then(callback);
    } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
      return callback(toArray(packet.data));
    }
    encodePacket(packet, false, function (encoded) {
      if (!TEXT_ENCODER) {
        TEXT_ENCODER = new TextEncoder();
      }
      callback(TEXT_ENCODER.encode(encoded));
    });
  }

  // imported from https://github.com/socketio/base64-arraybuffer
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup$1[chars.charCodeAt(i)] = i;
  }
  var decode$1 = function decode(base64) {
    var bufferLength = base64.length * 0.75,
      len = base64.length,
      i,
      p = 0,
      encoded1,
      encoded2,
      encoded3,
      encoded4;
    if (base64[base64.length - 1] === '=') {
      bufferLength--;
      if (base64[base64.length - 2] === '=') {
        bufferLength--;
      }
    }
    var arraybuffer = new ArrayBuffer(bufferLength),
      bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
      encoded1 = lookup$1[base64.charCodeAt(i)];
      encoded2 = lookup$1[base64.charCodeAt(i + 1)];
      encoded3 = lookup$1[base64.charCodeAt(i + 2)];
      encoded4 = lookup$1[base64.charCodeAt(i + 3)];
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arraybuffer;
  };

  var withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
  var decodePacket = function decodePacket(encodedPacket, binaryType) {
    if (typeof encodedPacket !== "string") {
      return {
        type: "message",
        data: mapBinary(encodedPacket, binaryType)
      };
    }
    var type = encodedPacket.charAt(0);
    if (type === "b") {
      return {
        type: "message",
        data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
      };
    }
    var packetType = PACKET_TYPES_REVERSE[type];
    if (!packetType) {
      return ERROR_PACKET;
    }
    return encodedPacket.length > 1 ? {
      type: PACKET_TYPES_REVERSE[type],
      data: encodedPacket.substring(1)
    } : {
      type: PACKET_TYPES_REVERSE[type]
    };
  };
  var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {
    if (withNativeArrayBuffer$1) {
      var decoded = decode$1(data);
      return mapBinary(decoded, binaryType);
    } else {
      return {
        base64: true,
        data: data
      }; // fallback for old browsers
    }
  };
  var mapBinary = function mapBinary(data, binaryType) {
    switch (binaryType) {
      case "blob":
        if (data instanceof Blob) {
          // from WebSocket + binaryType "blob"
          return data;
        } else {
          // from HTTP long-polling or WebTransport
          return new Blob([data]);
        }
      case "arraybuffer":
      default:
        if (data instanceof ArrayBuffer) {
          // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
          return data;
        } else {
          // from WebTransport (Uint8Array)
          return data.buffer;
        }
    }
  };

  var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
  var encodePayload = function encodePayload(packets, callback) {
    // some packets may be added to the array while encoding, so the initial length must be saved
    var length = packets.length;
    var encodedPackets = new Array(length);
    var count = 0;
    packets.forEach(function (packet, i) {
      // force base64 encoding for binary packets
      encodePacket(packet, false, function (encodedPacket) {
        encodedPackets[i] = encodedPacket;
        if (++count === length) {
          callback(encodedPackets.join(SEPARATOR));
        }
      });
    });
  };
  var decodePayload = function decodePayload(encodedPayload, binaryType) {
    var encodedPackets = encodedPayload.split(SEPARATOR);
    var packets = [];
    for (var i = 0; i < encodedPackets.length; i++) {
      var decodedPacket = decodePacket(encodedPackets[i], binaryType);
      packets.push(decodedPacket);
      if (decodedPacket.type === "error") {
        break;
      }
    }
    return packets;
  };
  function createPacketEncoderStream() {
    return new TransformStream({
      transform: function transform(packet, controller) {
        encodePacketToBinary(packet, function (encodedPacket) {
          var payloadLength = encodedPacket.length;
          var header;
          // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
          if (payloadLength < 126) {
            header = new Uint8Array(1);
            new DataView(header.buffer).setUint8(0, payloadLength);
          } else if (payloadLength < 65536) {
            header = new Uint8Array(3);
            var view = new DataView(header.buffer);
            view.setUint8(0, 126);
            view.setUint16(1, payloadLength);
          } else {
            header = new Uint8Array(9);
            var _view = new DataView(header.buffer);
            _view.setUint8(0, 127);
            _view.setBigUint64(1, BigInt(payloadLength));
          }
          // first bit indicates whether the payload is plain text (0) or binary (1)
          if (packet.data && typeof packet.data !== "string") {
            header[0] |= 0x80;
          }
          controller.enqueue(header);
          controller.enqueue(encodedPacket);
        });
      }
    });
  }
  var TEXT_DECODER;
  function totalLength(chunks) {
    return chunks.reduce(function (acc, chunk) {
      return acc + chunk.length;
    }, 0);
  }
  function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
      return chunks.shift();
    }
    var buffer = new Uint8Array(size);
    var j = 0;
    for (var i = 0; i < size; i++) {
      buffer[i] = chunks[0][j++];
      if (j === chunks[0].length) {
        chunks.shift();
        j = 0;
      }
    }
    if (chunks.length && j < chunks[0].length) {
      chunks[0] = chunks[0].slice(j);
    }
    return buffer;
  }
  function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
      TEXT_DECODER = new TextDecoder();
    }
    var chunks = [];
    var state = 0 /* State.READ_HEADER */;
    var expectedLength = -1;
    var isBinary = false;
    return new TransformStream({
      transform: function transform(chunk, controller) {
        chunks.push(chunk);
        while (true) {
          if (state === 0 /* State.READ_HEADER */) {
            if (totalLength(chunks) < 1) {
              break;
            }
            var header = concatChunks(chunks, 1);
            isBinary = (header[0] & 0x80) === 0x80;
            expectedLength = header[0] & 0x7f;
            if (expectedLength < 126) {
              state = 3 /* State.READ_PAYLOAD */;
            } else if (expectedLength === 126) {
              state = 1 /* State.READ_EXTENDED_LENGTH_16 */;
            } else {
              state = 2 /* State.READ_EXTENDED_LENGTH_64 */;
            }
          } else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {
            if (totalLength(chunks) < 2) {
              break;
            }
            var headerArray = concatChunks(chunks, 2);
            expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
            state = 3 /* State.READ_PAYLOAD */;
          } else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {
            if (totalLength(chunks) < 8) {
              break;
            }
            var _headerArray = concatChunks(chunks, 8);
            var view = new DataView(_headerArray.buffer, _headerArray.byteOffset, _headerArray.length);
            var n = view.getUint32(0);
            if (n > Math.pow(2, 53 - 32) - 1) {
              // the maximum safe integer in JavaScript is 2^53 - 1
              controller.enqueue(ERROR_PACKET);
              break;
            }
            expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
            state = 3 /* State.READ_PAYLOAD */;
          } else {
            if (totalLength(chunks) < expectedLength) {
              break;
            }
            var data = concatChunks(chunks, expectedLength);
            controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
            state = 0 /* State.READ_HEADER */;
          }
          if (expectedLength === 0 || expectedLength > maxPayload) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
        }
      }
    });
  }
  var protocol$1 = 4;

  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */

  function Emitter(obj) {
    if (obj) return mixin(obj);
  }

  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }

  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
    return this;
  };

  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.once = function (event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }
    on.fn = fn;
    this.on(event, on);
    return this;
  };

  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {};

    // all
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }

    // specific event
    var callbacks = this._callbacks['$' + event];
    if (!callbacks) return this;

    // remove all handlers
    if (1 == arguments.length) {
      delete this._callbacks['$' + event];
      return this;
    }

    // remove specific handler
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }

    // Remove event specific arrays for event types that no
    // one is subscribed for to avoid memory leak.
    if (callbacks.length === 0) {
      delete this._callbacks['$' + event];
    }
    return this;
  };

  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */

  Emitter.prototype.emit = function (event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1),
      callbacks = this._callbacks['$' + event];
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }
    return this;
  };

  // alias used for reserved events (protected method)
  Emitter.prototype.emitReserved = Emitter.prototype.emit;

  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */

  Emitter.prototype.listeners = function (event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
  };

  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */

  Emitter.prototype.hasListeners = function (event) {
    return !!this.listeners(event).length;
  };

  var nextTick = function () {
    var isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
      return function (cb) {
        return Promise.resolve().then(cb);
      };
    } else {
      return function (cb, setTimeoutFn) {
        return setTimeoutFn(cb, 0);
      };
    }
  }();
  var globalThisShim = function () {
    if (typeof self !== "undefined") {
      return self;
    } else if (typeof window !== "undefined") {
      return window;
    } else {
      return Function("return this")();
    }
  }();
  var defaultBinaryType = "arraybuffer";
  function createCookieJar() {}

  function pick(obj) {
    for (var _len = arguments.length, attr = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      attr[_key - 1] = arguments[_key];
    }
    return attr.reduce(function (acc, k) {
      if (obj.hasOwnProperty(k)) {
        acc[k] = obj[k];
      }
      return acc;
    }, {});
  }
  // Keep a reference to the real timeout functions so they can be used when overridden
  var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
  var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
  function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
      obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
      obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
    } else {
      obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
      obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
    }
  }
  // base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
  var BASE64_OVERHEAD = 1.33;
  // we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
  function byteLength(obj) {
    if (typeof obj === "string") {
      return utf8Length(obj);
    }
    // arraybuffer or blob
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
  }
  function utf8Length(str) {
    var c = 0,
      length = 0;
    for (var i = 0, l = str.length; i < l; i++) {
      c = str.charCodeAt(i);
      if (c < 0x80) {
        length += 1;
      } else if (c < 0x800) {
        length += 2;
      } else if (c < 0xd800 || c >= 0xe000) {
        length += 3;
      } else {
        i++;
        length += 4;
      }
    }
    return length;
  }
  /**
   * Generates a random 8-characters string.
   */
  function randomString() {
    return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
  }

  // imported from https://github.com/galkn/querystring
  /**
   * Compiles a querystring
   * Returns string representation of the object
   *
   * @param {Object}
   * @api private
   */
  function encode(obj) {
    var str = '';
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (str.length) str += '&';
        str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
      }
    }
    return str;
  }
  /**
   * Parses a simple querystring into an object
   *
   * @param {String} qs
   * @api private
   */
  function decode(qs) {
    var qry = {};
    var pairs = qs.split('&');
    for (var i = 0, l = pairs.length; i < l; i++) {
      var pair = pairs[i].split('=');
      qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
  }

  var TransportError = /*#__PURE__*/function (_Error) {
    function TransportError(reason, description, context) {
      var _this;
      _this = _Error.call(this, reason) || this;
      _this.description = description;
      _this.context = context;
      _this.type = "TransportError";
      return _this;
    }
    _inheritsLoose(TransportError, _Error);
    return TransportError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  var Transport = /*#__PURE__*/function (_Emitter) {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */
    function Transport(opts) {
      var _this2;
      _this2 = _Emitter.call(this) || this;
      _this2.writable = false;
      installTimerFunctions(_this2, opts);
      _this2.opts = opts;
      _this2.query = opts.query;
      _this2.socket = opts.socket;
      _this2.supportsBinary = !opts.forceBase64;
      return _this2;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */
    _inheritsLoose(Transport, _Emitter);
    var _proto = Transport.prototype;
    _proto.onError = function onError(reason, description, context) {
      _Emitter.prototype.emitReserved.call(this, "error", new TransportError(reason, description, context));
      return this;
    }
    /**
     * Opens the transport.
     */;
    _proto.open = function open() {
      this.readyState = "opening";
      this.doOpen();
      return this;
    }
    /**
     * Closes the transport.
     */;
    _proto.close = function close() {
      if (this.readyState === "opening" || this.readyState === "open") {
        this.doClose();
        this.onClose();
      }
      return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */;
    _proto.send = function send(packets) {
      if (this.readyState === "open") {
        this.write(packets);
      }
    }
    /**
     * Called upon open
     *
     * @protected
     */;
    _proto.onOpen = function onOpen() {
      this.readyState = "open";
      this.writable = true;
      _Emitter.prototype.emitReserved.call(this, "open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */;
    _proto.onData = function onData(data) {
      var packet = decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */;
    _proto.onPacket = function onPacket(packet) {
      _Emitter.prototype.emitReserved.call(this, "packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */;
    _proto.onClose = function onClose(details) {
      this.readyState = "closed";
      _Emitter.prototype.emitReserved.call(this, "close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */;
    _proto.pause = function pause(onPause) {};
    _proto.createUri = function createUri(schema) {
      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
    };
    _proto._hostname = function _hostname() {
      var hostname = this.opts.hostname;
      return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    };
    _proto._port = function _port() {
      if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
        return ":" + this.opts.port;
      } else {
        return "";
      }
    };
    _proto._query = function _query(query) {
      var encodedQuery = encode(query);
      return encodedQuery.length ? "?" + encodedQuery : "";
    };
    return Transport;
  }(Emitter);

  var Polling = /*#__PURE__*/function (_Transport) {
    function Polling() {
      var _this;
      _this = _Transport.apply(this, arguments) || this;
      _this._polling = false;
      return _this;
    }
    _inheritsLoose(Polling, _Transport);
    var _proto = Polling.prototype;
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
    _proto.doOpen = function doOpen() {
      this._poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */;
    _proto.pause = function pause(onPause) {
      var _this2 = this;
      this.readyState = "pausing";
      var pause = function pause() {
        _this2.readyState = "paused";
        onPause();
      };
      if (this._polling || !this.writable) {
        var total = 0;
        if (this._polling) {
          total++;
          this.once("pollComplete", function () {
            --total || pause();
          });
        }
        if (!this.writable) {
          total++;
          this.once("drain", function () {
            --total || pause();
          });
        }
      } else {
        pause();
      }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */;
    _proto._poll = function _poll() {
      this._polling = true;
      this.doPoll();
      this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */;
    _proto.onData = function onData(data) {
      var _this3 = this;
      var callback = function callback(packet) {
        // if its the first message we consider the transport open
        if ("opening" === _this3.readyState && packet.type === "open") {
          _this3.onOpen();
        }
        // if its a close packet, we close the ongoing requests
        if ("close" === packet.type) {
          _this3.onClose({
            description: "transport closed by the server"
          });
          return false;
        }
        // otherwise bypass onData and handle the message
        _this3.onPacket(packet);
      };
      // decode payload
      decodePayload(data, this.socket.binaryType).forEach(callback);
      // if an event did not trigger closing
      if ("closed" !== this.readyState) {
        // if we got data we're not polling
        this._polling = false;
        this.emitReserved("pollComplete");
        if ("open" === this.readyState) {
          this._poll();
        }
      }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */;
    _proto.doClose = function doClose() {
      var _this4 = this;
      var close = function close() {
        _this4.write([{
          type: "close"
        }]);
      };
      if ("open" === this.readyState) {
        close();
      } else {
        // in case we're trying to close while
        // handshaking is in progress (GH-164)
        this.once("open", close);
      }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */;
    _proto.write = function write(packets) {
      var _this5 = this;
      this.writable = false;
      encodePayload(packets, function (data) {
        _this5.doWrite(data, function () {
          _this5.writable = true;
          _this5.emitReserved("drain");
        });
      });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */;
    _proto.uri = function uri() {
      var schema = this.opts.secure ? "https" : "http";
      var query = this.query || {};
      // cache busting is forced
      if (false !== this.opts.timestampRequests) {
        query[this.opts.timestampParam] = randomString();
      }
      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }
      return this.createUri(schema, query);
    };
    return _createClass(Polling, [{
      key: "name",
      get: function get() {
        return "polling";
      }
    }]);
  }(Transport);

  // imported from https://github.com/component/has-cors
  var value = false;
  try {
    value = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
  } catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
  }
  var hasCORS = value;

  function empty() {}
  var BaseXHR = /*#__PURE__*/function (_Polling) {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */
    function BaseXHR(opts) {
      var _this;
      _this = _Polling.call(this, opts) || this;
      if (typeof location !== "undefined") {
        var isSSL = "https:" === location.protocol;
        var port = location.port;
        // some user agents have empty `location.port`
        if (!port) {
          port = isSSL ? "443" : "80";
        }
        _this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      }
      return _this;
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
    _inheritsLoose(BaseXHR, _Polling);
    var _proto = BaseXHR.prototype;
    _proto.doWrite = function doWrite(data, fn) {
      var _this2 = this;
      var req = this.request({
        method: "POST",
        data: data
      });
      req.on("success", fn);
      req.on("error", function (xhrStatus, context) {
        _this2.onError("xhr post error", xhrStatus, context);
      });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */;
    _proto.doPoll = function doPoll() {
      var _this3 = this;
      var req = this.request();
      req.on("data", this.onData.bind(this));
      req.on("error", function (xhrStatus, context) {
        _this3.onError("xhr poll error", xhrStatus, context);
      });
      this.pollXhr = req;
    };
    return BaseXHR;
  }(Polling);
  var Request = /*#__PURE__*/function (_Emitter) {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */
    function Request(createRequest, uri, opts) {
      var _this4;
      _this4 = _Emitter.call(this) || this;
      _this4.createRequest = createRequest;
      installTimerFunctions(_this4, opts);
      _this4._opts = opts;
      _this4._method = opts.method || "GET";
      _this4._uri = uri;
      _this4._data = undefined !== opts.data ? opts.data : null;
      _this4._create();
      return _this4;
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */
    _inheritsLoose(Request, _Emitter);
    var _proto2 = Request.prototype;
    _proto2._create = function _create() {
      var _this5 = this;
      var _a;
      var opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
      opts.xdomain = !!this._opts.xd;
      var xhr = this._xhr = this.createRequest(opts);
      try {
        xhr.open(this._method, this._uri, true);
        try {
          if (this._opts.extraHeaders) {
            // @ts-ignore
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (var i in this._opts.extraHeaders) {
              if (this._opts.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
              }
            }
          }
        } catch (e) {}
        if ("POST" === this._method) {
          try {
            xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
          } catch (e) {}
        }
        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e) {}
        (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
        // ie6 check
        if ("withCredentials" in xhr) {
          xhr.withCredentials = this._opts.withCredentials;
        }
        if (this._opts.requestTimeout) {
          xhr.timeout = this._opts.requestTimeout;
        }
        xhr.onreadystatechange = function () {
          var _a;
          if (xhr.readyState === 3) {
            (_a = _this5._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie"));
          }
          if (4 !== xhr.readyState) return;
          if (200 === xhr.status || 1223 === xhr.status) {
            _this5._onLoad();
          } else {
            // make sure the `error` event handler that's user-set
            // does not throw in the same tick and gets caught here
            _this5.setTimeoutFn(function () {
              _this5._onError(typeof xhr.status === "number" ? xhr.status : 0);
            }, 0);
          }
        };
        xhr.send(this._data);
      } catch (e) {
        // Need to defer since .create() is called directly from the constructor
        // and thus the 'error' event can only be only bound *after* this exception
        // occurs.  Therefore, also, we cannot throw here at all.
        this.setTimeoutFn(function () {
          _this5._onError(e);
        }, 0);
        return;
      }
      if (typeof document !== "undefined") {
        this._index = Request.requestsCount++;
        Request.requests[this._index] = this;
      }
    }
    /**
     * Called upon error.
     *
     * @private
     */;
    _proto2._onError = function _onError(err) {
      this.emitReserved("error", err, this._xhr);
      this._cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */;
    _proto2._cleanup = function _cleanup(fromError) {
      if ("undefined" === typeof this._xhr || null === this._xhr) {
        return;
      }
      this._xhr.onreadystatechange = empty;
      if (fromError) {
        try {
          this._xhr.abort();
        } catch (e) {}
      }
      if (typeof document !== "undefined") {
        delete Request.requests[this._index];
      }
      this._xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */;
    _proto2._onLoad = function _onLoad() {
      var data = this._xhr.responseText;
      if (data !== null) {
        this.emitReserved("data", data);
        this.emitReserved("success");
        this._cleanup();
      }
    }
    /**
     * Aborts the request.
     *
     * @package
     */;
    _proto2.abort = function abort() {
      this._cleanup();
    };
    return Request;
  }(Emitter);
  Request.requestsCount = 0;
  Request.requests = {};
  /**
   * Aborts pending requests when unloading the window. This is needed to prevent
   * memory leaks (e.g. when using IE) and to ensure that no spurious error is
   * emitted.
   */
  if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
      // @ts-ignore
      attachEvent("onunload", unloadHandler);
    } else if (typeof addEventListener === "function") {
      var terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
      addEventListener(terminationEvent, unloadHandler, false);
    }
  }
  function unloadHandler() {
    for (var i in Request.requests) {
      if (Request.requests.hasOwnProperty(i)) {
        Request.requests[i].abort();
      }
    }
  }
  var hasXHR2 = function () {
    var xhr = newRequest({
      xdomain: false
    });
    return xhr && xhr.responseType !== null;
  }();
  /**
   * HTTP long-polling based on the built-in `XMLHttpRequest` object.
   *
   * Usage: browser
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
   */
  var XHR = /*#__PURE__*/function (_BaseXHR) {
    function XHR(opts) {
      var _this6;
      _this6 = _BaseXHR.call(this, opts) || this;
      var forceBase64 = opts && opts.forceBase64;
      _this6.supportsBinary = hasXHR2 && !forceBase64;
      return _this6;
    }
    _inheritsLoose(XHR, _BaseXHR);
    var _proto3 = XHR.prototype;
    _proto3.request = function request() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _extends(opts, {
        xd: this.xd
      }, this.opts);
      return new Request(newRequest, this.uri(), opts);
    };
    return XHR;
  }(BaseXHR);
  function newRequest(opts) {
    var xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
      if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
        return new XMLHttpRequest();
      }
    } catch (e) {}
    if (!xdomain) {
      try {
        return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
      } catch (e) {}
    }
  }

  // detect ReactNative environment
  var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
  var BaseWS = /*#__PURE__*/function (_Transport) {
    function BaseWS() {
      return _Transport.apply(this, arguments) || this;
    }
    _inheritsLoose(BaseWS, _Transport);
    var _proto = BaseWS.prototype;
    _proto.doOpen = function doOpen() {
      var uri = this.uri();
      var protocols = this.opts.protocols;
      // React Native only supports the 'headers' option, and will print a warning if anything else is passed
      var opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
      if (this.opts.extraHeaders) {
        opts.headers = this.opts.extraHeaders;
      }
      try {
        this.ws = this.createSocket(uri, protocols, opts);
      } catch (err) {
        return this.emitReserved("error", err);
      }
      this.ws.binaryType = this.socket.binaryType;
      this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */;
    _proto.addEventListeners = function addEventListeners() {
      var _this = this;
      this.ws.onopen = function () {
        if (_this.opts.autoUnref) {
          _this.ws._socket.unref();
        }
        _this.onOpen();
      };
      this.ws.onclose = function (closeEvent) {
        return _this.onClose({
          description: "websocket connection closed",
          context: closeEvent
        });
      };
      this.ws.onmessage = function (ev) {
        return _this.onData(ev.data);
      };
      this.ws.onerror = function (e) {
        return _this.onError("websocket error", e);
      };
    };
    _proto.write = function write(packets) {
      var _this2 = this;
      this.writable = false;
      // encodePacket efficient as it uses WS framing
      // no need for encodePayload
      var _loop = function _loop() {
        var packet = packets[i];
        var lastPacket = i === packets.length - 1;
        encodePacket(packet, _this2.supportsBinary, function (data) {
          // Sometimes the websocket has already been closed but the browser didn't
          // have a chance of informing us about it yet, in that case send will
          // throw an error
          try {
            _this2.doWrite(packet, data);
          } catch (e) {}
          if (lastPacket) {
            // fake drain
            // defer to next tick to allow Socket to clear writeBuffer
            nextTick(function () {
              _this2.writable = true;
              _this2.emitReserved("drain");
            }, _this2.setTimeoutFn);
          }
        });
      };
      for (var i = 0; i < packets.length; i++) {
        _loop();
      }
    };
    _proto.doClose = function doClose() {
      if (typeof this.ws !== "undefined") {
        this.ws.onerror = function () {};
        this.ws.close();
        this.ws = null;
      }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */;
    _proto.uri = function uri() {
      var schema = this.opts.secure ? "wss" : "ws";
      var query = this.query || {};
      // append timestamp to URI
      if (this.opts.timestampRequests) {
        query[this.opts.timestampParam] = randomString();
      }
      // communicate binary support capabilities
      if (!this.supportsBinary) {
        query.b64 = 1;
      }
      return this.createUri(schema, query);
    };
    return _createClass(BaseWS, [{
      key: "name",
      get: function get() {
        return "websocket";
      }
    }]);
  }(Transport);
  var WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
  /**
   * WebSocket transport based on the built-in `WebSocket` object.
   *
   * Usage: browser, Node.js (since v21), Deno, Bun
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
   * @see https://caniuse.com/mdn-api_websocket
   * @see https://nodejs.org/api/globals.html#websocket
   */
  var WS = /*#__PURE__*/function (_BaseWS) {
    function WS() {
      return _BaseWS.apply(this, arguments) || this;
    }
    _inheritsLoose(WS, _BaseWS);
    var _proto2 = WS.prototype;
    _proto2.createSocket = function createSocket(uri, protocols, opts) {
      return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
    };
    _proto2.doWrite = function doWrite(_packet, data) {
      this.ws.send(data);
    };
    return WS;
  }(BaseWS);

  /**
   * WebTransport transport based on the built-in `WebTransport` object.
   *
   * Usage: browser, Node.js (with the `@fails-components/webtransport` package)
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport
   * @see https://caniuse.com/webtransport
   */
  var WT = /*#__PURE__*/function (_Transport) {
    function WT() {
      return _Transport.apply(this, arguments) || this;
    }
    _inheritsLoose(WT, _Transport);
    var _proto = WT.prototype;
    _proto.doOpen = function doOpen() {
      var _this = this;
      try {
        // @ts-ignore
        this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
      } catch (err) {
        return this.emitReserved("error", err);
      }
      this._transport.closed.then(function () {
        _this.onClose();
      })["catch"](function (err) {
        _this.onError("webtransport error", err);
      });
      // note: we could have used async/await, but that would require some additional polyfills
      this._transport.ready.then(function () {
        _this._transport.createBidirectionalStream().then(function (stream) {
          var decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, _this.socket.binaryType);
          var reader = stream.readable.pipeThrough(decoderStream).getReader();
          var encoderStream = createPacketEncoderStream();
          encoderStream.readable.pipeTo(stream.writable);
          _this._writer = encoderStream.writable.getWriter();
          var read = function read() {
            reader.read().then(function (_ref) {
              var done = _ref.done,
                value = _ref.value;
              if (done) {
                return;
              }
              _this.onPacket(value);
              read();
            })["catch"](function (err) {});
          };
          read();
          var packet = {
            type: "open"
          };
          if (_this.query.sid) {
            packet.data = "{\"sid\":\"".concat(_this.query.sid, "\"}");
          }
          _this._writer.write(packet).then(function () {
            return _this.onOpen();
          });
        });
      });
    };
    _proto.write = function write(packets) {
      var _this2 = this;
      this.writable = false;
      var _loop = function _loop() {
        var packet = packets[i];
        var lastPacket = i === packets.length - 1;
        _this2._writer.write(packet).then(function () {
          if (lastPacket) {
            nextTick(function () {
              _this2.writable = true;
              _this2.emitReserved("drain");
            }, _this2.setTimeoutFn);
          }
        });
      };
      for (var i = 0; i < packets.length; i++) {
        _loop();
      }
    };
    _proto.doClose = function doClose() {
      var _a;
      (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
    };
    return _createClass(WT, [{
      key: "name",
      get: function get() {
        return "webtransport";
      }
    }]);
  }(Transport);

  var transports = {
    websocket: WS,
    webtransport: WT,
    polling: XHR
  };

  // imported from https://github.com/galkn/parseuri
  /**
   * Parses a URI
   *
   * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
   *
   * See:
   * - https://developer.mozilla.org/en-US/docs/Web/API/URL
   * - https://caniuse.com/url
   * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
   *
   * History of the parse() method:
   * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
   * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
   * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
   *
   * @author Steven Levithan <stevenlevithan.com> (MIT license)
   * @api private
   */
  var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
  function parse(str) {
    if (str.length > 8000) {
      throw "URI too long";
    }
    var src = str,
      b = str.indexOf('['),
      e = str.indexOf(']');
    if (b != -1 && e != -1) {
      str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }
    var m = re.exec(str || ''),
      uri = {},
      i = 14;
    while (i--) {
      uri[parts[i]] = m[i] || '';
    }
    if (b != -1 && e != -1) {
      uri.source = src;
      uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
      uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
      uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);
    return uri;
  }
  function pathNames(obj, path) {
    var regx = /\/{2,9}/g,
      names = path.replace(regx, "/").split("/");
    if (path.slice(0, 1) == '/' || path.length === 0) {
      names.splice(0, 1);
    }
    if (path.slice(-1) == '/') {
      names.splice(names.length - 1, 1);
    }
    return names;
  }
  function queryKey(uri, query) {
    var data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
      if ($1) {
        data[$1] = $2;
      }
    });
    return data;
  }

  var withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
  var OFFLINE_EVENT_LISTENERS = [];
  if (withEventListeners) {
    // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the
    // script, so we create one single event listener here which will forward the event to the socket instances
    addEventListener("offline", function () {
      OFFLINE_EVENT_LISTENERS.forEach(function (listener) {
        return listener();
      });
    }, false);
  }
  /**
   * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
   * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
   *
   * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that
   * successfully establishes the connection.
   *
   * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
   *
   * @example
   * import { SocketWithoutUpgrade, WebSocket } from "engine.io-client";
   *
   * const socket = new SocketWithoutUpgrade({
   *   transports: [WebSocket]
   * });
   *
   * socket.on("open", () => {
   *   socket.send("hello");
   * });
   *
   * @see SocketWithUpgrade
   * @see Socket
   */
  var SocketWithoutUpgrade = /*#__PURE__*/function (_Emitter) {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */
    function SocketWithoutUpgrade(uri, opts) {
      var _this;
      _this = _Emitter.call(this) || this;
      _this.binaryType = defaultBinaryType;
      _this.writeBuffer = [];
      _this._prevBufferLen = 0;
      _this._pingInterval = -1;
      _this._pingTimeout = -1;
      _this._maxPayload = -1;
      /**
       * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
       * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
       */
      _this._pingTimeoutTime = Infinity;
      if (uri && "object" === _typeof(uri)) {
        opts = uri;
        uri = null;
      }
      if (uri) {
        var parsedUri = parse(uri);
        opts.hostname = parsedUri.host;
        opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
        opts.port = parsedUri.port;
        if (parsedUri.query) opts.query = parsedUri.query;
      } else if (opts.host) {
        opts.hostname = parse(opts.host).host;
      }
      installTimerFunctions(_this, opts);
      _this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
      if (opts.hostname && !opts.port) {
        // if no port is specified manually, use the protocol default
        opts.port = _this.secure ? "443" : "80";
      }
      _this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
      _this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : _this.secure ? "443" : "80");
      _this.transports = [];
      _this._transportsByName = {};
      opts.transports.forEach(function (t) {
        var transportName = t.prototype.name;
        _this.transports.push(transportName);
        _this._transportsByName[transportName] = t;
      });
      _this.opts = _extends({
        path: "/engine.io",
        agent: false,
        withCredentials: false,
        upgrade: true,
        timestampParam: "t",
        rememberUpgrade: false,
        addTrailingSlash: true,
        rejectUnauthorized: true,
        perMessageDeflate: {
          threshold: 1024
        },
        transportOptions: {},
        closeOnBeforeunload: false
      }, opts);
      _this.opts.path = _this.opts.path.replace(/\/$/, "") + (_this.opts.addTrailingSlash ? "/" : "");
      if (typeof _this.opts.query === "string") {
        _this.opts.query = decode(_this.opts.query);
      }
      if (withEventListeners) {
        if (_this.opts.closeOnBeforeunload) {
          // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
          // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
          // closed/reloaded)
          _this._beforeunloadEventListener = function () {
            if (_this.transport) {
              // silently close the transport
              _this.transport.removeAllListeners();
              _this.transport.close();
            }
          };
          addEventListener("beforeunload", _this._beforeunloadEventListener, false);
        }
        if (_this.hostname !== "localhost") {
          _this._offlineEventListener = function () {
            _this._onClose("transport close", {
              description: "network connection lost"
            });
          };
          OFFLINE_EVENT_LISTENERS.push(_this._offlineEventListener);
        }
      }
      if (_this.opts.withCredentials) {
        _this._cookieJar = createCookieJar();
      }
      _this._open();
      return _this;
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */
    _inheritsLoose(SocketWithoutUpgrade, _Emitter);
    var _proto = SocketWithoutUpgrade.prototype;
    _proto.createTransport = function createTransport(name) {
      var query = _extends({}, this.opts.query);
      // append engine.io protocol identifier
      query.EIO = protocol$1;
      // transport name
      query.transport = name;
      // session id if we already have one
      if (this.id) query.sid = this.id;
      var opts = _extends({}, this.opts, {
        query: query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }, this.opts.transportOptions[name]);
      return new this._transportsByName[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */;
    _proto._open = function _open() {
      var _this2 = this;
      if (this.transports.length === 0) {
        // Emit error on next tick so it can be listened to
        this.setTimeoutFn(function () {
          _this2.emitReserved("error", "No transports available");
        }, 0);
        return;
      }
      var transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
      this.readyState = "opening";
      var transport = this.createTransport(transportName);
      transport.open();
      this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */;
    _proto.setTransport = function setTransport(transport) {
      var _this3 = this;
      if (this.transport) {
        this.transport.removeAllListeners();
      }
      // set up transport
      this.transport = transport;
      // set up transport listeners
      transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", function (reason) {
        return _this3._onClose("transport close", reason);
      });
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */;
    _proto.onOpen = function onOpen() {
      this.readyState = "open";
      SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emitReserved("open");
      this.flush();
    }
    /**
     * Handles a packet.
     *
     * @private
     */;
    _proto._onPacket = function _onPacket(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        this.emitReserved("packet", packet);
        // Socket is live - any packet counts
        this.emitReserved("heartbeat");
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "ping":
            this._sendPacket("pong");
            this.emitReserved("ping");
            this.emitReserved("pong");
            this._resetPingTimeout();
            break;
          case "error":
            var err = new Error("server error");
            // @ts-ignore
            err.code = packet.data;
            this._onError(err);
            break;
          case "message":
            this.emitReserved("data", packet.data);
            this.emitReserved("message", packet.data);
            break;
        }
      }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */;
    _proto.onHandshake = function onHandshake(data) {
      this.emitReserved("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this._pingInterval = data.pingInterval;
      this._pingTimeout = data.pingTimeout;
      this._maxPayload = data.maxPayload;
      this.onOpen();
      // In case open handler closes socket
      if ("closed" === this.readyState) return;
      this._resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */;
    _proto._resetPingTimeout = function _resetPingTimeout() {
      var _this4 = this;
      this.clearTimeoutFn(this._pingTimeoutTimer);
      var delay = this._pingInterval + this._pingTimeout;
      this._pingTimeoutTime = Date.now() + delay;
      this._pingTimeoutTimer = this.setTimeoutFn(function () {
        _this4._onClose("ping timeout");
      }, delay);
      if (this.opts.autoUnref) {
        this._pingTimeoutTimer.unref();
      }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */;
    _proto._onDrain = function _onDrain() {
      this.writeBuffer.splice(0, this._prevBufferLen);
      // setting prevBufferLen = 0 is very important
      // for example, when upgrading, upgrade packet is sent over,
      // and a nonzero prevBufferLen could cause problems on `drain`
      this._prevBufferLen = 0;
      if (0 === this.writeBuffer.length) {
        this.emitReserved("drain");
      } else {
        this.flush();
      }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */;
    _proto.flush = function flush() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        var packets = this._getWritablePackets();
        this.transport.send(packets);
        // keep track of current length of writeBuffer
        // splice writeBuffer and callbackBuffer on `drain`
        this._prevBufferLen = packets.length;
        this.emitReserved("flush");
      }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */;
    _proto._getWritablePackets = function _getWritablePackets() {
      var shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
      if (!shouldCheckPayloadSize) {
        return this.writeBuffer;
      }
      var payloadSize = 1; // first packet type
      for (var i = 0; i < this.writeBuffer.length; i++) {
        var data = this.writeBuffer[i].data;
        if (data) {
          payloadSize += byteLength(data);
        }
        if (i > 0 && payloadSize > this._maxPayload) {
          return this.writeBuffer.slice(0, i);
        }
        payloadSize += 2; // separator + packet type
      }
      return this.writeBuffer;
    }
    /**
     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
     *
     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
     * `write()` method then the message would not be buffered by the Socket.IO client.
     *
     * @return {boolean}
     * @private
     */
    /* private */;
    _proto._hasPingExpired = function _hasPingExpired() {
      var _this5 = this;
      if (!this._pingTimeoutTime) return true;
      var hasExpired = Date.now() > this._pingTimeoutTime;
      if (hasExpired) {
        this._pingTimeoutTime = 0;
        nextTick(function () {
          _this5._onClose("ping timeout");
        }, this.setTimeoutFn);
      }
      return hasExpired;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */;
    _proto.write = function write(msg, options, fn) {
      this._sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a message. Alias of {@link Socket#write}.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */;
    _proto.send = function send(msg, options, fn) {
      this._sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */;
    _proto._sendPacket = function _sendPacket(type, data, options, fn) {
      if ("function" === typeof data) {
        fn = data;
        data = undefined;
      }
      if ("function" === typeof options) {
        fn = options;
        options = null;
      }
      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }
      options = options || {};
      options.compress = false !== options.compress;
      var packet = {
        type: type,
        data: data,
        options: options
      };
      this.emitReserved("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn) this.once("flush", fn);
      this.flush();
    }
    /**
     * Closes the connection.
     */;
    _proto.close = function close() {
      var _this6 = this;
      var close = function close() {
        _this6._onClose("forced close");
        _this6.transport.close();
      };
      var cleanupAndClose = function cleanupAndClose() {
        _this6.off("upgrade", cleanupAndClose);
        _this6.off("upgradeError", cleanupAndClose);
        close();
      };
      var waitForUpgrade = function waitForUpgrade() {
        // wait for upgrade to finish since we can't send packets while pausing a transport
        _this6.once("upgrade", cleanupAndClose);
        _this6.once("upgradeError", cleanupAndClose);
      };
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";
        if (this.writeBuffer.length) {
          this.once("drain", function () {
            if (_this6.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */;
    _proto._onError = function _onError(err) {
      SocketWithoutUpgrade.priorWebsocketSuccess = false;
      if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
        this.transports.shift();
        return this._open();
      }
      this.emitReserved("error", err);
      this._onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */;
    _proto._onClose = function _onClose(reason, description) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        // clear timers
        this.clearTimeoutFn(this._pingTimeoutTimer);
        // stop event from firing again for transport
        this.transport.removeAllListeners("close");
        // ensure transport won't stay open
        this.transport.close();
        // ignore further transport communication
        this.transport.removeAllListeners();
        if (withEventListeners) {
          if (this._beforeunloadEventListener) {
            removeEventListener("beforeunload", this._beforeunloadEventListener, false);
          }
          if (this._offlineEventListener) {
            var i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
            if (i !== -1) {
              OFFLINE_EVENT_LISTENERS.splice(i, 1);
            }
          }
        }
        // set ready state
        this.readyState = "closed";
        // clear session id
        this.id = null;
        // emit close event
        this.emitReserved("close", reason, description);
        // clean buffers after, so users can still
        // grab the buffers on `close` event
        this.writeBuffer = [];
        this._prevBufferLen = 0;
      }
    };
    return SocketWithoutUpgrade;
  }(Emitter);
  SocketWithoutUpgrade.protocol = protocol$1;
  /**
   * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
   * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
   *
   * This class comes with an upgrade mechanism, which means that once the connection is established with the first
   * low-level transport, it will try to upgrade to a better transport.
   *
   * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
   *
   * @example
   * import { SocketWithUpgrade, WebSocket } from "engine.io-client";
   *
   * const socket = new SocketWithUpgrade({
   *   transports: [WebSocket]
   * });
   *
   * socket.on("open", () => {
   *   socket.send("hello");
   * });
   *
   * @see SocketWithoutUpgrade
   * @see Socket
   */
  var SocketWithUpgrade = /*#__PURE__*/function (_SocketWithoutUpgrade) {
    function SocketWithUpgrade() {
      var _this7;
      _this7 = _SocketWithoutUpgrade.apply(this, arguments) || this;
      _this7._upgrades = [];
      return _this7;
    }
    _inheritsLoose(SocketWithUpgrade, _SocketWithoutUpgrade);
    var _proto2 = SocketWithUpgrade.prototype;
    _proto2.onOpen = function onOpen() {
      _SocketWithoutUpgrade.prototype.onOpen.call(this);
      if ("open" === this.readyState && this.opts.upgrade) {
        for (var i = 0; i < this._upgrades.length; i++) {
          this._probe(this._upgrades[i]);
        }
      }
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */;
    _proto2._probe = function _probe(name) {
      var _this8 = this;
      var transport = this.createTransport(name);
      var failed = false;
      SocketWithoutUpgrade.priorWebsocketSuccess = false;
      var onTransportOpen = function onTransportOpen() {
        if (failed) return;
        transport.send([{
          type: "ping",
          data: "probe"
        }]);
        transport.once("packet", function (msg) {
          if (failed) return;
          if ("pong" === msg.type && "probe" === msg.data) {
            _this8.upgrading = true;
            _this8.emitReserved("upgrading", transport);
            if (!transport) return;
            SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
            _this8.transport.pause(function () {
              if (failed) return;
              if ("closed" === _this8.readyState) return;
              cleanup();
              _this8.setTransport(transport);
              transport.send([{
                type: "upgrade"
              }]);
              _this8.emitReserved("upgrade", transport);
              transport = null;
              _this8.upgrading = false;
              _this8.flush();
            });
          } else {
            var err = new Error("probe error");
            // @ts-ignore
            err.transport = transport.name;
            _this8.emitReserved("upgradeError", err);
          }
        });
      };
      function freezeTransport() {
        if (failed) return;
        // Any callback called by transport should be ignored since now
        failed = true;
        cleanup();
        transport.close();
        transport = null;
      }
      // Handle any error that happens while probing
      var onerror = function onerror(err) {
        var error = new Error("probe error: " + err);
        // @ts-ignore
        error.transport = transport.name;
        freezeTransport();
        _this8.emitReserved("upgradeError", error);
      };
      function onTransportClose() {
        onerror("transport closed");
      }
      // When the socket is closed while we're probing
      function onclose() {
        onerror("socket closed");
      }
      // When the socket is upgraded while we're probing
      function onupgrade(to) {
        if (transport && to.name !== transport.name) {
          freezeTransport();
        }
      }
      // Remove all listeners on the transport and on self
      var cleanup = function cleanup() {
        transport.removeListener("open", onTransportOpen);
        transport.removeListener("error", onerror);
        transport.removeListener("close", onTransportClose);
        _this8.off("close", onclose);
        _this8.off("upgrading", onupgrade);
      };
      transport.once("open", onTransportOpen);
      transport.once("error", onerror);
      transport.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
        // favor WebTransport
        this.setTimeoutFn(function () {
          if (!failed) {
            transport.open();
          }
        }, 200);
      } else {
        transport.open();
      }
    };
    _proto2.onHandshake = function onHandshake(data) {
      this._upgrades = this._filterUpgrades(data.upgrades);
      _SocketWithoutUpgrade.prototype.onHandshake.call(this, data);
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */;
    _proto2._filterUpgrades = function _filterUpgrades(upgrades) {
      var filteredUpgrades = [];
      for (var i = 0; i < upgrades.length; i++) {
        if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    };
    return SocketWithUpgrade;
  }(SocketWithoutUpgrade);
  /**
   * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
   * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
   *
   * This class comes with an upgrade mechanism, which means that once the connection is established with the first
   * low-level transport, it will try to upgrade to a better transport.
   *
   * @example
   * import { Socket } from "engine.io-client";
   *
   * const socket = new Socket();
   *
   * socket.on("open", () => {
   *   socket.send("hello");
   * });
   *
   * @see SocketWithoutUpgrade
   * @see SocketWithUpgrade
   */
  var Socket$1 = /*#__PURE__*/function (_SocketWithUpgrade) {
    function Socket(uri) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var o = _typeof(uri) === "object" ? uri : opts;
      if (!o.transports || o.transports && typeof o.transports[0] === "string") {
        o.transports = (o.transports || ["polling", "websocket", "webtransport"]).map(function (transportName) {
          return transports[transportName];
        }).filter(function (t) {
          return !!t;
        });
      }
      return _SocketWithUpgrade.call(this, uri, o) || this;
    }
    _inheritsLoose(Socket, _SocketWithUpgrade);
    return Socket;
  }(SocketWithUpgrade);

  Socket$1.protocol;

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var browser = {exports: {}};

  var ms;
  var hasRequiredMs;
  function requireMs() {
    if (hasRequiredMs) return ms;
    hasRequiredMs = 1;
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    ms = function ms(val, options) {
      options = options || {};
      var type = _typeof(val);
      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isFinite(val)) {
        return options["long"] ? fmtLong(val) : fmtShort(val);
      }
      throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'weeks':
        case 'week':
        case 'w':
          return n * w;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
      }
      return ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }
    return ms;
  }

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */

  function setup(env) {
    createDebug.debug = createDebug;
    createDebug["default"] = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach(function (key) {
      createDebug[key] = env[key];
    });

    /**
    * The currently active debug mode names, and names to skip.
    */

    createDebug.names = [];
    createDebug.skips = [];

    /**
    * Map of special "%n" handling functions, for the debug "format" argument.
    *
    * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    */
    createDebug.formatters = {};

    /**
    * Selects a color for a debug namespace
    * @param {String} namespace The namespace string for the debug instance to be colored
    * @return {Number|String} An ANSI color code for the given namespace
    * @api private
    */
    function selectColor(namespace) {
      var hash = 0;
      for (var i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;

    /**
    * Create a debugger with the given `namespace`.
    *
    * @param {String} namespace
    * @return {Function}
    * @api public
    */
    function createDebug(namespace) {
      var prevTime;
      var enableOverride = null;
      var namespacesCache;
      var enabledCache;
      function debug() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        // Disabled?
        if (!debug.enabled) {
          return;
        }
        var self = debug;

        // Set `diff` timestamp
        var curr = Number(new Date());
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== 'string') {
          // Anything else let's inspect with %O
          args.unshift('%O');
        }

        // Apply any `formatters` transformations
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          // If we encounter an escaped % then don't increase the array index
          if (match === '%%') {
            return '%';
          }
          index++;
          var formatter = createDebug.formatters[format];
          if (typeof formatter === 'function') {
            var val = args[index];
            match = formatter.call(self, val);

            // Now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });

        // Apply env-specific formatting (colors, etc.)
        createDebug.formatArgs.call(self, args);
        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

      Object.defineProperty(debug, 'enabled', {
        enumerable: true,
        configurable: false,
        get: function get() {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: function set(v) {
          enableOverride = v;
        }
      });

      // Env-specific initialization logic for debug instances
      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }

    /**
    * Enables a debug mode by namespaces. This can include modes
    * separated by a colon and wildcards.
    *
    * @param {String} namespaces
    * @api public
    */
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          // ignore empty strings
          continue;
        }
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }

    /**
    * Disable debug output.
    *
    * @return {String} namespaces
    * @api public
    */
    function disable() {
      var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
        return '-' + namespace;
      }))).join(',');
      createDebug.enable('');
      return namespaces;
    }

    /**
    * Returns true if the given mode name is enabled, false otherwise.
    *
    * @param {String} name
    * @return {Boolean}
    * @api public
    */
    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }
      var i;
      var len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }

    /**
    * Convert regexp to namespace
    *
    * @param {RegExp} regxep
    * @return {String} namespace
    * @api private
    */
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }

    /**
    * Coerce `val`.
    *
    * @param {Mixed} val
    * @return {Mixed}
    * @api private
    */
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }

    /**
    * XXX DO NOT USE. This is a temporary stub function.
    * XXX It WILL be removed in the next major release.
    */
    function destroy() {
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  var common = setup;

  /* eslint-env browser */
  browser.exports;
  (function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     */

    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = function () {
      var warned = false;
      return function () {
        if (!warned) {
          warned = true;
          console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
      };
    }();

    /**
     * Colors.
     */

    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    // eslint-disable-next-line complexity
    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      }

      // Internet Explorer and Edge do not support colors.
      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }

      // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
      // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
      // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
      // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }
        index++;
        if (match === '%c') {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.debug()` when available.
     * No-op when `console.debug` is not a "function".
     * If `console.debug` is not available, falls back
     * to `console.log`.
     *
     * @api public
     */
    exports.log = console.debug || console.log || function () {};

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
      var r;
      try {
        r = exports.storage.getItem('debug');
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }
      return r;
    }

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }
    module.exports = common(exports);
    var formatters = module.exports.formatters;

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
  })(browser, browser.exports);
  var browserExports = browser.exports;
  var debugModule = /*@__PURE__*/getDefaultExportFromCjs(browserExports);

  var debug$3 = debugModule("socket.io-client:url"); // debug()
  /**
   * URL parser.
   *
   * @param uri - url
   * @param path - the request path of the connection
   * @param loc - An object meant to mimic window.location.
   *        Defaults to window.location.
   * @public
   */
  function url(uri) {
    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    var loc = arguments.length > 2 ? arguments[2] : undefined;
    var obj = uri;
    // default to window.location
    loc = loc || typeof location !== "undefined" && location;
    if (null == uri) uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
      if ("/" === uri.charAt(0)) {
        if ("/" === uri.charAt(1)) {
          uri = loc.protocol + uri;
        } else {
          uri = loc.host + uri;
        }
      }
      if (!/^(https?|wss?):\/\//.test(uri)) {
        debug$3("protocol-less url %s", uri);
        if ("undefined" !== typeof loc) {
          uri = loc.protocol + "//" + uri;
        } else {
          uri = "https://" + uri;
        }
      }
      // parse
      debug$3("parse %s", uri);
      obj = parse(uri);
    }
    // make sure we treat `localhost:80` and `localhost` equally
    if (!obj.port) {
      if (/^(http|ws)$/.test(obj.protocol)) {
        obj.port = "80";
      } else if (/^(http|ws)s$/.test(obj.protocol)) {
        obj.port = "443";
      }
    }
    obj.path = obj.path || "/";
    var ipv6 = obj.host.indexOf(":") !== -1;
    var host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
  }

  var withNativeArrayBuffer = typeof ArrayBuffer === "function";
  var isView = function isView(obj) {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
  };
  var toString = Object.prototype.toString;
  var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
  var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
  /**
   * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
   *
   * @private
   */
  function isBinary(obj) {
    return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
  }
  function hasBinary(obj, toJSON) {
    if (!obj || _typeof(obj) !== "object") {
      return false;
    }
    if (Array.isArray(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (hasBinary(obj[i])) {
          return true;
        }
      }
      return false;
    }
    if (isBinary(obj)) {
      return true;
    }
    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
      return hasBinary(obj.toJSON(), true);
    }
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
        return true;
      }
    }
    return false;
  }

  /**
   * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
   *
   * @param {Object} packet - socket.io event packet
   * @return {Object} with deconstructed packet and list of buffers
   * @public
   */
  function deconstructPacket(packet) {
    var buffers = [];
    var packetData = packet.data;
    var pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return {
      packet: pack,
      buffers: buffers
    };
  }
  function _deconstructPacket(data, buffers) {
    if (!data) return data;
    if (isBinary(data)) {
      var placeholder = {
        _placeholder: true,
        num: buffers.length
      };
      buffers.push(data);
      return placeholder;
    } else if (Array.isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i], buffers);
      }
      return newData;
    } else if (_typeof(data) === "object" && !(data instanceof Date)) {
      var _newData = {};
      for (var key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          _newData[key] = _deconstructPacket(data[key], buffers);
        }
      }
      return _newData;
    }
    return data;
  }
  /**
   * Reconstructs a binary packet from its placeholder packet and buffers
   *
   * @param {Object} packet - event packet with placeholders
   * @param {Array} buffers - binary buffers to put in placeholder positions
   * @return {Object} reconstructed packet
   * @public
   */
  function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments; // no longer useful
    return packet;
  }
  function _reconstructPacket(data, buffers) {
    if (!data) return data;
    if (data && data._placeholder === true) {
      var isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
      if (isIndexValid) {
        return buffers[data.num]; // appropriate buffer (should be natural order anyway)
      } else {
        throw new Error("illegal attachments");
      }
    } else if (Array.isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i], buffers);
      }
    } else if (_typeof(data) === "object") {
      for (var key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          data[key] = _reconstructPacket(data[key], buffers);
        }
      }
    }
    return data;
  }

  /**
   * These strings must not be used as event names, as they have a special meaning.
   */
  var RESERVED_EVENTS$1 = ["connect",
  // used on the client side
  "connect_error",
  // used on the client side
  "disconnect",
  // used on both sides
  "disconnecting",
  // used on the server side
  "newListener",
  // used by the Node.js EventEmitter
  "removeListener" // used by the Node.js EventEmitter
  ];
  /**
   * Protocol version.
   *
   * @public
   */
  var protocol = 5;
  var PacketType;
  (function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
  })(PacketType || (PacketType = {}));
  /**
   * A socket.io Encoder instance
   */
  var Encoder = /*#__PURE__*/function () {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    function Encoder(replacer) {
      this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    var _proto = Encoder.prototype;
    _proto.encode = function encode(obj) {
      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if (hasBinary(obj)) {
          return this.encodeAsBinary({
            type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
            nsp: obj.nsp,
            data: obj.data,
            id: obj.id
          });
        }
      }
      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */;
    _proto.encodeAsString = function encodeAsString(obj) {
      // first is type
      var str = "" + obj.type;
      // attachments if we have them
      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      }
      // if we have a namespace other than `/`
      // we append it followed by a comma `,`
      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      }
      // immediately followed by the id
      if (null != obj.id) {
        str += obj.id;
      }
      // json data
      if (null != obj.data) {
        str += JSON.stringify(obj.data, this.replacer);
      }
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */;
    _proto.encodeAsBinary = function encodeAsBinary(obj) {
      var deconstruction = deconstructPacket(obj);
      var pack = this.encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list
      return buffers; // write all the buffers
    };
    return Encoder;
  }();
  /**
   * A socket.io Decoder instance
   *
   * @return {Object} decoder
   */
  var Decoder = /*#__PURE__*/function (_Emitter) {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    function Decoder(reviver) {
      var _this;
      _this = _Emitter.call(this) || this;
      _this.reviver = reviver;
      return _this;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    _inheritsLoose(Decoder, _Emitter);
    var _proto2 = Decoder.prototype;
    _proto2.add = function add(obj) {
      var packet;
      if (typeof obj === "string") {
        if (this.reconstructor) {
          throw new Error("got plaintext data when reconstructing a packet");
        }
        packet = this.decodeString(obj);
        var isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
        if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
          packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
          // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet);
          // no attachments, labeled binary but no binary data to follow
          if (packet.attachments === 0) {
            _Emitter.prototype.emitReserved.call(this, "decoded", packet);
          }
        } else {
          // non-binary full packet
          _Emitter.prototype.emitReserved.call(this, "decoded", packet);
        }
      } else if (isBinary(obj) || obj.base64) {
        // raw binary data
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            // received final buffer
            this.reconstructor = null;
            _Emitter.prototype.emitReserved.call(this, "decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */;
    _proto2.decodeString = function decodeString(str) {
      var i = 0;
      // look up type
      var p = {
        type: Number(str.charAt(0))
      };
      if (PacketType[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
      }
      // look up attachments if type binary
      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        var start = i + 1;
        while (str.charAt(++i) !== "-" && i != str.length) {}
        var buf = str.substring(start, i);
        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }
        p.attachments = Number(buf);
      }
      // look up namespace (if any)
      if ("/" === str.charAt(i + 1)) {
        var _start = i + 1;
        while (++i) {
          var c = str.charAt(i);
          if ("," === c) break;
          if (i === str.length) break;
        }
        p.nsp = str.substring(_start, i);
      } else {
        p.nsp = "/";
      }
      // look up id
      var next = str.charAt(i + 1);
      if ("" !== next && Number(next) == next) {
        var _start2 = i + 1;
        while (++i) {
          var _c = str.charAt(i);
          if (null == _c || Number(_c) != _c) {
            --i;
            break;
          }
          if (i === str.length) break;
        }
        p.id = Number(str.substring(_start2, i + 1));
      }
      // look up json data
      if (str.charAt(++i)) {
        var payload = this.tryParse(str.substr(i));
        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      return p;
    };
    _proto2.tryParse = function tryParse(str) {
      try {
        return JSON.parse(str, this.reviver);
      } catch (e) {
        return false;
      }
    };
    Decoder.isPayloadValid = function isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return isObject(payload);
        case PacketType.DISCONNECT:
          return payload === undefined;
        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || isObject(payload);
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
    /**
     * Deallocates a parser's resources
     */;
    _proto2.destroy = function destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
        this.reconstructor = null;
      }
    };
    return Decoder;
  }(Emitter);
  /**
   * A manager of a binary event's 'buffer sequence'. Should
   * be constructed whenever a packet of type BINARY_EVENT is
   * decoded.
   *
   * @param {Object} packet
   * @return {BinaryReconstructor} initialized reconstructor
   */
  var BinaryReconstructor = /*#__PURE__*/function () {
    function BinaryReconstructor(packet) {
      this.packet = packet;
      this.buffers = [];
      this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    var _proto3 = BinaryReconstructor.prototype;
    _proto3.takeBinaryData = function takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        // done with buffer list
        var packet = reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */;
    _proto3.finishedReconstruction = function finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    };
    return BinaryReconstructor;
  }();
  function isNamespaceValid(nsp) {
    return typeof nsp === "string";
  }
  // see https://caniuse.com/mdn-javascript_builtins_number_isinteger
  var isInteger = Number.isInteger || function (value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  function isAckIdValid(id) {
    return id === undefined || isInteger(id);
  }
  // see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
  function isObject(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  function isDataValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return payload === undefined || isObject(payload);
      case PacketType.DISCONNECT:
        return payload === undefined;
      case PacketType.EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
        return Array.isArray(payload);
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      default:
        return false;
    }
  }
  function isPacketValid(packet) {
    return isNamespaceValid(packet.nsp) && isAckIdValid(packet.id) && isDataValid(packet.type, packet.data);
  }

  var parser = /*#__PURE__*/Object.freeze({
    __proto__: null,
    protocol: protocol,
    get PacketType () { return PacketType; },
    Encoder: Encoder,
    Decoder: Decoder,
    isPacketValid: isPacketValid
  });

  function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
      obj.off(ev, fn);
    };
  }

  var debug$2 = debugModule("socket.io-client:socket"); // debug()
  /**
   * Internal events.
   * These events can't be emitted by the user.
   */
  var RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1
  });
  /**
   * A Socket is the fundamental class for interacting with the server.
   *
   * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log("connected");
   * });
   *
   * // send an event to the server
   * socket.emit("foo", "bar");
   *
   * socket.on("foobar", () => {
   *   // an event was received from the server
   * });
   *
   * // upon disconnection
   * socket.on("disconnect", (reason) => {
   *   console.log(`disconnected due to ${reason}`);
   * });
   */
  var Socket = /*#__PURE__*/function (_Emitter) {
    /**
     * `Socket` constructor.
     */
    function Socket(io, nsp, opts) {
      var _this;
      _this = _Emitter.call(this) || this;
      /**
       * Whether the socket is currently connected to the server.
       *
       * @example
       * const socket = io();
       *
       * socket.on("connect", () => {
       *   console.log(socket.connected); // true
       * });
       *
       * socket.on("disconnect", () => {
       *   console.log(socket.connected); // false
       * });
       */
      _this.connected = false;
      /**
       * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
       * be transmitted by the server.
       */
      _this.recovered = false;
      /**
       * Buffer for packets received before the CONNECT packet
       */
      _this.receiveBuffer = [];
      /**
       * Buffer for packets that will be sent once the socket is connected
       */
      _this.sendBuffer = [];
      /**
       * The queue of packets to be sent with retry in case of failure.
       *
       * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
       * @private
       */
      _this._queue = [];
      /**
       * A sequence to generate the ID of the {@link QueuedPacket}.
       * @private
       */
      _this._queueSeq = 0;
      _this.ids = 0;
      /**
       * A map containing acknowledgement handlers.
       *
       * The `withError` attribute is used to differentiate handlers that accept an error as first argument:
       *
       * - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
       * - `socket.timeout(5000).emit("test", (err, value) => { ... })`
       * - `const value = await socket.emitWithAck("test")`
       *
       * From those that don't:
       *
       * - `socket.emit("test", (value) => { ... });`
       *
       * In the first case, the handlers will be called with an error when:
       *
       * - the timeout is reached
       * - the socket gets disconnected
       *
       * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
       * an acknowledgement from the server.
       *
       * @private
       */
      _this.acks = {};
      _this.flags = {};
      _this.io = io;
      _this.nsp = nsp;
      if (opts && opts.auth) {
        _this.auth = opts.auth;
      }
      _this._opts = _extends({}, opts);
      if (_this.io._autoConnect) _this.open();
      return _this;
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */
    _inheritsLoose(Socket, _Emitter);
    var _proto = Socket.prototype;
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    _proto.subEvents = function subEvents() {
      if (this.subs) return;
      var io = this.io;
      this.subs = [on(io, "open", this.onopen.bind(this)), on(io, "packet", this.onpacket.bind(this)), on(io, "error", this.onerror.bind(this)), on(io, "close", this.onclose.bind(this))];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */;
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
    _proto.connect = function connect() {
      if (this.connected) return this;
      this.subEvents();
      if (!this.io["_reconnecting"]) this.io.open(); // ensure open
      if ("open" === this.io._readyState) this.onopen();
      return this;
    }
    /**
     * Alias for {@link connect()}.
     */;
    _proto.open = function open() {
      return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */;
    _proto.send = function send() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */;
    _proto.emit = function emit(ev) {
      var _a, _b, _c;
      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
        throw new Error('"' + ev.toString() + '" is a reserved event name');
      }
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      args.unshift(ev);
      if (this._opts.retries && !this.flags.fromQueue && !this.flags["volatile"]) {
        this._addToQueue(args);
        return this;
      }
      var packet = {
        type: PacketType.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = this.flags.compress !== false;
      // event ack callback
      if ("function" === typeof args[args.length - 1]) {
        var id = this.ids++;
        debug$2("emitting packet with ack id %d", id);
        var ack = args.pop();
        this._registerAckCallback(id, ack);
        packet.id = id;
      }
      var isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
      var isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
      var discardPacket = this.flags["volatile"] && !isTransportWritable;
      if (discardPacket) {
        debug$2("discard packet as the transport is not currently writable");
      } else if (isConnected) {
        this.notifyOutgoingListeners(packet);
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }
      this.flags = {};
      return this;
    }
    /**
     * @private
     */;
    _proto._registerAckCallback = function _registerAckCallback(id, ack) {
      var _this2 = this;
      var _a;
      var timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
      if (timeout === undefined) {
        this.acks[id] = ack;
        return;
      }
      // @ts-ignore
      var timer = this.io.setTimeoutFn(function () {
        delete _this2.acks[id];
        for (var i = 0; i < _this2.sendBuffer.length; i++) {
          if (_this2.sendBuffer[i].id === id) {
            debug$2("removing packet with ack id %d from the buffer", id);
            _this2.sendBuffer.splice(i, 1);
          }
        }
        debug$2("event with ack id %d has timed out after %d ms", id, timeout);
        ack.call(_this2, new Error("operation has timed out"));
      }, timeout);
      var fn = function fn() {
        // @ts-ignore
        _this2.io.clearTimeoutFn(timer);
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        ack.apply(_this2, args);
      };
      fn.withError = true;
      this.acks[id] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */;
    _proto.emitWithAck = function emitWithAck(ev) {
      var _this3 = this;
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      return new Promise(function (resolve, reject) {
        var fn = function fn(arg1, arg2) {
          return arg1 ? reject(arg1) : resolve(arg2);
        };
        fn.withError = true;
        args.push(fn);
        _this3.emit.apply(_this3, [ev].concat(args));
      });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */;
    _proto._addToQueue = function _addToQueue(args) {
      var _this4 = this;
      var ack;
      if (typeof args[args.length - 1] === "function") {
        ack = args.pop();
      }
      var packet = {
        id: this._queueSeq++,
        tryCount: 0,
        pending: false,
        args: args,
        flags: _extends({
          fromQueue: true
        }, this.flags)
      };
      args.push(function (err) {
        if (packet !== _this4._queue[0]) {
          // the packet has already been acknowledged
          return;
        }
        var hasError = err !== null;
        if (hasError) {
          if (packet.tryCount > _this4._opts.retries) {
            debug$2("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
            _this4._queue.shift();
            if (ack) {
              ack(err);
            }
          }
        } else {
          debug$2("packet [%d] was successfully sent", packet.id);
          _this4._queue.shift();
          if (ack) {
            for (var _len5 = arguments.length, responseArgs = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
              responseArgs[_key5 - 1] = arguments[_key5];
            }
            ack.apply(void 0, [null].concat(responseArgs));
          }
        }
        packet.pending = false;
        return _this4._drainQueue();
      });
      this._queue.push(packet);
      this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */;
    _proto._drainQueue = function _drainQueue() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      debug$2("draining queue");
      if (!this.connected || this._queue.length === 0) {
        return;
      }
      var packet = this._queue[0];
      if (packet.pending && !force) {
        debug$2("packet [%d] has already been sent and is waiting for an ack", packet.id);
        return;
      }
      packet.pending = true;
      packet.tryCount++;
      debug$2("sending packet [%d] (try n%d)", packet.id, packet.tryCount);
      this.flags = packet.flags;
      this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */;
    _proto.packet = function packet(_packet) {
      _packet.nsp = this.nsp;
      this.io._packet(_packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */;
    _proto.onopen = function onopen() {
      var _this5 = this;
      debug$2("transport is open - connecting");
      if (typeof this.auth == "function") {
        this.auth(function (data) {
          _this5._sendConnectPacket(data);
        });
      } else {
        this._sendConnectPacket(this.auth);
      }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */;
    _proto._sendConnectPacket = function _sendConnectPacket(data) {
      this.packet({
        type: PacketType.CONNECT,
        data: this._pid ? _extends({
          pid: this._pid,
          offset: this._lastOffset
        }, data) : data
      });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */;
    _proto.onerror = function onerror(err) {
      if (!this.connected) {
        this.emitReserved("connect_error", err);
      }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */;
    _proto.onclose = function onclose(reason, description) {
      debug$2("close (%s)", reason);
      this.connected = false;
      delete this.id;
      this.emitReserved("disconnect", reason, description);
      this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */;
    _proto._clearAcks = function _clearAcks() {
      var _this6 = this;
      Object.keys(this.acks).forEach(function (id) {
        var isBuffered = _this6.sendBuffer.some(function (packet) {
          return String(packet.id) === id;
        });
        if (!isBuffered) {
          // note: handlers that do not accept an error as first argument are ignored here
          var ack = _this6.acks[id];
          delete _this6.acks[id];
          if (ack.withError) {
            ack.call(_this6, new Error("socket has been disconnected"));
          }
        }
      });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */;
    _proto.onpacket = function onpacket(packet) {
      var sameNamespace = packet.nsp === this.nsp;
      if (!sameNamespace) return;
      switch (packet.type) {
        case PacketType.CONNECT:
          if (packet.data && packet.data.sid) {
            this.onconnect(packet.data.sid, packet.data.pid);
          } else {
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          }
          break;
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          this.onack(packet);
          break;
        case PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case PacketType.CONNECT_ERROR:
          this.destroy();
          var err = new Error(packet.data.message);
          // @ts-ignore
          err.data = packet.data.data;
          this.emitReserved("connect_error", err);
          break;
      }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */;
    _proto.onevent = function onevent(packet) {
      var args = packet.data || [];
      debug$2("emitting event %j", args);
      if (null != packet.id) {
        debug$2("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }
      if (this.connected) {
        this.emitEvent(args);
      } else {
        this.receiveBuffer.push(Object.freeze(args));
      }
    };
    _proto.emitEvent = function emitEvent(args) {
      if (this._anyListeners && this._anyListeners.length) {
        var listeners = this._anyListeners.slice();
        var _iterator = _createForOfIteratorHelper(listeners),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var listener = _step.value;
            listener.apply(this, args);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      _Emitter.prototype.emit.apply(this, args);
      if (this._pid && args.length && typeof args[args.length - 1] === "string") {
        this._lastOffset = args[args.length - 1];
      }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */;
    _proto.ack = function ack(id) {
      var self = this;
      var sent = false;
      return function () {
        // prevent double callbacks
        if (sent) return;
        sent = true;
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        debug$2("sending ack %j", args);
        self.packet({
          type: PacketType.ACK,
          id: id,
          data: args
        });
      };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */;
    _proto.onack = function onack(packet) {
      var ack = this.acks[packet.id];
      if (typeof ack !== "function") {
        debug$2("bad ack %s", packet.id);
        return;
      }
      delete this.acks[packet.id];
      debug$2("calling ack %s with %j", packet.id, packet.data);
      // @ts-ignore FIXME ack is incorrectly inferred as 'never'
      if (ack.withError) {
        packet.data.unshift(null);
      }
      // @ts-ignore
      ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */;
    _proto.onconnect = function onconnect(id, pid) {
      debug$2("socket connected with id %s", id);
      this.id = id;
      this.recovered = pid && this._pid === pid;
      this._pid = pid; // defined only if connection state recovery is enabled
      this.connected = true;
      this.emitBuffered();
      this.emitReserved("connect");
      this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */;
    _proto.emitBuffered = function emitBuffered() {
      var _this7 = this;
      this.receiveBuffer.forEach(function (args) {
        return _this7.emitEvent(args);
      });
      this.receiveBuffer = [];
      this.sendBuffer.forEach(function (packet) {
        _this7.notifyOutgoingListeners(packet);
        _this7.packet(packet);
      });
      this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */;
    _proto.ondisconnect = function ondisconnect() {
      debug$2("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */;
    _proto.destroy = function destroy() {
      if (this.subs) {
        // clean subscriptions to avoid reconnections
        this.subs.forEach(function (subDestroy) {
          return subDestroy();
        });
        this.subs = undefined;
      }
      this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */;
    _proto.disconnect = function disconnect() {
      if (this.connected) {
        debug$2("performing disconnect (%s)", this.nsp);
        this.packet({
          type: PacketType.DISCONNECT
        });
      }
      // remove socket from pool
      this.destroy();
      if (this.connected) {
        // fire events
        this.onclose("io client disconnect");
      }
      return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */;
    _proto.close = function close() {
      return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */;
    _proto.compress = function compress(_compress) {
      this.flags.compress = _compress;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */;
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
    _proto.timeout = function timeout(_timeout) {
      this.flags.timeout = _timeout;
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */;
    _proto.onAny = function onAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */;
    _proto.prependAny = function prependAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */;
    _proto.offAny = function offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }
      if (listener) {
        var listeners = this._anyListeners;
        for (var i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */;
    _proto.listenersAny = function listenersAny() {
      return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */;
    _proto.onAnyOutgoing = function onAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */;
    _proto.prependAnyOutgoing = function prependAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */;
    _proto.offAnyOutgoing = function offAnyOutgoing(listener) {
      if (!this._anyOutgoingListeners) {
        return this;
      }
      if (listener) {
        var listeners = this._anyOutgoingListeners;
        for (var i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyOutgoingListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */;
    _proto.listenersAnyOutgoing = function listenersAnyOutgoing() {
      return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */;
    _proto.notifyOutgoingListeners = function notifyOutgoingListeners(packet) {
      if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
        var listeners = this._anyOutgoingListeners.slice();
        var _iterator2 = _createForOfIteratorHelper(listeners),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var listener = _step2.value;
            listener.apply(this, packet.data);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    };
    return _createClass(Socket, [{
      key: "disconnected",
      get: function get() {
        return !this.connected;
      }
    }, {
      key: "active",
      get: function get() {
        return !!this.subs;
      }
    }, {
      key: "volatile",
      get: function get() {
        this.flags["volatile"] = true;
        return this;
      }
    }]);
  }(Emitter);

  /**
   * Initialize backoff timer with `opts`.
   *
   * - `min` initial timeout in milliseconds [100]
   * - `max` max timeout [10000]
   * - `jitter` [0]
   * - `factor` [2]
   *
   * @param {Object} opts
   * @api public
   */
  function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
  }
  /**
   * Return the backoff duration.
   *
   * @return {Number}
   * @api public
   */
  Backoff.prototype.duration = function () {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
      var rand = Math.random();
      var deviation = Math.floor(rand * this.jitter * ms);
      ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
  };
  /**
   * Reset the number of attempts.
   *
   * @api public
   */
  Backoff.prototype.reset = function () {
    this.attempts = 0;
  };
  /**
   * Set the minimum duration
   *
   * @api public
   */
  Backoff.prototype.setMin = function (min) {
    this.ms = min;
  };
  /**
   * Set the maximum duration
   *
   * @api public
   */
  Backoff.prototype.setMax = function (max) {
    this.max = max;
  };
  /**
   * Set the jitter
   *
   * @api public
   */
  Backoff.prototype.setJitter = function (jitter) {
    this.jitter = jitter;
  };

  var debug$1 = debugModule("socket.io-client:manager"); // debug()
  var Manager = /*#__PURE__*/function (_Emitter) {
    function Manager(uri, opts) {
      var _this;
      var _a;
      _this = _Emitter.call(this) || this;
      _this.nsps = {};
      _this.subs = [];
      if (uri && "object" === _typeof(uri)) {
        opts = uri;
        uri = undefined;
      }
      opts = opts || {};
      opts.path = opts.path || "/socket.io";
      _this.opts = opts;
      installTimerFunctions(_this, opts);
      _this.reconnection(opts.reconnection !== false);
      _this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      _this.reconnectionDelay(opts.reconnectionDelay || 1000);
      _this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
      _this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
      _this.backoff = new Backoff({
        min: _this.reconnectionDelay(),
        max: _this.reconnectionDelayMax(),
        jitter: _this.randomizationFactor()
      });
      _this.timeout(null == opts.timeout ? 20000 : opts.timeout);
      _this._readyState = "closed";
      _this.uri = uri;
      var _parser = opts.parser || parser;
      _this.encoder = new _parser.Encoder();
      _this.decoder = new _parser.Decoder();
      _this._autoConnect = opts.autoConnect !== false;
      if (_this._autoConnect) _this.open();
      return _this;
    }
    _inheritsLoose(Manager, _Emitter);
    var _proto = Manager.prototype;
    _proto.reconnection = function reconnection(v) {
      if (!arguments.length) return this._reconnection;
      this._reconnection = !!v;
      if (!v) {
        this.skipReconnect = true;
      }
      return this;
    };
    _proto.reconnectionAttempts = function reconnectionAttempts(v) {
      if (v === undefined) return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    };
    _proto.reconnectionDelay = function reconnectionDelay(v) {
      var _a;
      if (v === undefined) return this._reconnectionDelay;
      this._reconnectionDelay = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
      return this;
    };
    _proto.randomizationFactor = function randomizationFactor(v) {
      var _a;
      if (v === undefined) return this._randomizationFactor;
      this._randomizationFactor = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
      return this;
    };
    _proto.reconnectionDelayMax = function reconnectionDelayMax(v) {
      var _a;
      if (v === undefined) return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
      return this;
    };
    _proto.timeout = function timeout(v) {
      if (!arguments.length) return this._timeout;
      this._timeout = v;
      return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */;
    _proto.maybeReconnectOnOpen = function maybeReconnectOnOpen() {
      // Only try to reconnect if it's the first time we're connecting
      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
        // keeps reconnection from firing twice for the same reconnection loop
        this.reconnect();
      }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */;
    _proto.open = function open(fn) {
      var _this2 = this;
      debug$1("readyState %s", this._readyState);
      if (~this._readyState.indexOf("open")) return this;
      debug$1("opening %s", this.uri);
      this.engine = new Socket$1(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this._readyState = "opening";
      this.skipReconnect = false;
      // emit `open`
      var openSubDestroy = on(socket, "open", function () {
        self.onopen();
        fn && fn();
      });
      var onError = function onError(err) {
        debug$1("error");
        _this2.cleanup();
        _this2._readyState = "closed";
        _this2.emitReserved("error", err);
        if (fn) {
          fn(err);
        } else {
          // Only do this if there is no fn to handle the error
          _this2.maybeReconnectOnOpen();
        }
      };
      // emit `error`
      var errorSub = on(socket, "error", onError);
      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug$1("connect attempt will timeout after %d", timeout);
        // set timer
        var timer = this.setTimeoutFn(function () {
          debug$1("connect attempt timed out after %d", timeout);
          openSubDestroy();
          onError(new Error("timeout"));
          socket.close();
        }, timeout);
        if (this.opts.autoUnref) {
          timer.unref();
        }
        this.subs.push(function () {
          _this2.clearTimeoutFn(timer);
        });
      }
      this.subs.push(openSubDestroy);
      this.subs.push(errorSub);
      return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */;
    _proto.connect = function connect(fn) {
      return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */;
    _proto.onopen = function onopen() {
      debug$1("open");
      // clear old subs
      this.cleanup();
      // mark as open
      this._readyState = "open";
      this.emitReserved("open");
      // add new subs
      var socket = this.engine;
      this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)),
      // @ts-ignore
      on(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */;
    _proto.onping = function onping() {
      this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */;
    _proto.ondata = function ondata(data) {
      try {
        this.decoder.add(data);
      } catch (e) {
        this.onclose("parse error", e);
      }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */;
    _proto.ondecoded = function ondecoded(packet) {
      var _this3 = this;
      // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
      nextTick(function () {
        _this3.emitReserved("packet", packet);
      }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */;
    _proto.onerror = function onerror(err) {
      debug$1("error", err);
      this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */;
    _proto.socket = function socket(nsp, opts) {
      var socket = this.nsps[nsp];
      if (!socket) {
        socket = new Socket(this, nsp, opts);
        this.nsps[nsp] = socket;
      } else if (this._autoConnect && !socket.active) {
        socket.connect();
      }
      return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */;
    _proto._destroy = function _destroy(socket) {
      var nsps = Object.keys(this.nsps);
      for (var _i = 0, _nsps = nsps; _i < _nsps.length; _i++) {
        var nsp = _nsps[_i];
        var _socket = this.nsps[nsp];
        if (_socket.active) {
          debug$1("socket %s is still active, skipping close", nsp);
          return;
        }
      }
      this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */;
    _proto._packet = function _packet(packet) {
      debug$1("writing packet %j", packet);
      var encodedPackets = this.encoder.encode(packet);
      for (var i = 0; i < encodedPackets.length; i++) {
        this.engine.write(encodedPackets[i], packet.options);
      }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */;
    _proto.cleanup = function cleanup() {
      debug$1("cleanup");
      this.subs.forEach(function (subDestroy) {
        return subDestroy();
      });
      this.subs.length = 0;
      this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */;
    _proto._close = function _close() {
      debug$1("disconnect");
      this.skipReconnect = true;
      this._reconnecting = false;
      this.onclose("forced close");
    }
    /**
     * Alias for close()
     *
     * @private
     */;
    _proto.disconnect = function disconnect() {
      return this._close();
    }
    /**
     * Called when:
     *
     * - the low-level engine is closed
     * - the parser encountered a badly formatted packet
     * - all sockets are disconnected
     *
     * @private
     */;
    _proto.onclose = function onclose(reason, description) {
      var _a;
      debug$1("closed due to %s", reason);
      this.cleanup();
      (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
      this.backoff.reset();
      this._readyState = "closed";
      this.emitReserved("close", reason, description);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */;
    _proto.reconnect = function reconnect() {
      var _this4 = this;
      if (this._reconnecting || this.skipReconnect) return this;
      var self = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug$1("reconnect failed");
        this.backoff.reset();
        this.emitReserved("reconnect_failed");
        this._reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug$1("will wait %dms before reconnect attempt", delay);
        this._reconnecting = true;
        var timer = this.setTimeoutFn(function () {
          if (self.skipReconnect) return;
          debug$1("attempting reconnect");
          _this4.emitReserved("reconnect_attempt", self.backoff.attempts);
          // check again for the case socket closed in above events
          if (self.skipReconnect) return;
          self.open(function (err) {
            if (err) {
              debug$1("reconnect attempt error");
              self._reconnecting = false;
              self.reconnect();
              _this4.emitReserved("reconnect_error", err);
            } else {
              debug$1("reconnect success");
              self.onreconnect();
            }
          });
        }, delay);
        if (this.opts.autoUnref) {
          timer.unref();
        }
        this.subs.push(function () {
          _this4.clearTimeoutFn(timer);
        });
      }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */;
    _proto.onreconnect = function onreconnect() {
      var attempt = this.backoff.attempts;
      this._reconnecting = false;
      this.backoff.reset();
      this.emitReserved("reconnect", attempt);
    };
    return Manager;
  }(Emitter);

  var debug = debugModule("socket.io-client"); // debug()
  /**
   * Managers cache.
   */
  var cache = {};
  function lookup(uri, opts) {
    if (_typeof(uri) === "object") {
      opts = uri;
      uri = undefined;
    }
    opts = opts || {};
    var parsed = url(uri, opts.path || "/socket.io");
    var source = parsed.source;
    var id = parsed.id;
    var path = parsed.path;
    var sameNamespace = cache[id] && path in cache[id]["nsps"];
    var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
    var io;
    if (newConnection) {
      debug("ignoring socket cache for %s", source);
      io = new Manager(source, opts);
    } else {
      if (!cache[id]) {
        debug("new io instance for %s", source);
        cache[id] = new Manager(source, opts);
      }
      io = cache[id];
    }
    if (parsed.query && !opts.query) {
      opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
  }
  // so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
  // namespace (e.g. `io.connect(...)`), for backward compatibility
  _extends(lookup, {
    Manager: Manager,
    Socket: Socket,
    io: lookup,
    connect: lookup
  });

  return lookup;

}));



// @vuebundler[Lsw_framework_components][7]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-importer/importer.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['Importer'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['Importer'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: Importer class | @section: Lsw Importer API  Importer class
  
  const Importer = class {

    static create(...args) {
      return new this(...args);
    }

    $trace(method, args) {
      if (this.options.trace) {
        const args_resumen = Array.from(args).map((it, index) => {
          return (index + 1) + "=" + typeof it;
        }).join(", ");
        console.log("[TRACE][importer][" + method + "][" + args.length + "][" + args_resumen + "]");
      }
    }

    $error(error, clue = false) {
      let errorText = "";
      errorText += "[ERROR]   " + error.name + "\n";
      errorText += "[MESSAGE] " + error.message + "\n";
      errorText += "[STACK]\n" + error.stack.trim().split("\n").map(line => {
        return "    | " + this.$reverseStackLine(line);
      }).join("\n") + "";
      if (clue) {
        errorText = errorText + "\n[CLUE]\n" + clue + "";
      }
      console.error(errorText);
    }

    $reverseStackLine(text) {
      const index = text.indexOf('@');
      if (index === -1) {
        // Si no hay @, devolvemos el texto completo y una cadena vaca
        return [text, ''];
      }
      return [text.slice(index + 1), " @ ", text.slice(0, index)].join("");
    }

    constructor(total_modules = 0, options_input = {}) {
      const options = Object.assign({}, {
        id: "#intersitial",
        id_loaded: "#intersitial_modules_loaded",
        id_all: "#intersitial_modules_all",
        id_trace: "#intersitial_modules_trace",
        id_loader: "#intersitial_loader",
        id_loader_bar: "#intersitial_loader_bar",
        trace: false,
        update_ui: false,
        update_ui_minimum_milliseconds: 1200,
      }, options_input);
      this.options = options;
      Duplicated_options: {
        this.id = options.id;
        this.id_all = options.id_all;
        this.id_loaded = options.id_loaded;
        this.id_trace = options.id_trace;
        this.id_loader = options.id_loader;
        this.id_loader_bar = options.id_loader_bar;
      }
      this.modules_total = total_modules;
      this.modules_loaded = -1;
      this.modules_loaded_ids = [];
      this.time_of_creation = new Date();
      this.is_loaded = false;
      this.setTotal();
      this.$trace("constructor", arguments);
    }

    $getMillisecondsOfLife() {
      this.$trace("$getMillisecondsOfLife", arguments);
      return this.$formatMilliseconds(new Date() - this.time_of_creation);
    }

    $formatMilliseconds(ms) {
      this.$trace("$formatMilliseconds", arguments);
      return ms.toLocaleString("es-ES");
    }

    setTimeout(timeout) {
      this.$trace("$setTimeout", arguments);
      this.options.update_ui_minimum_milliseconds = timeout;
      return this;
    }

    setTotal(total = undefined) {
      this.$trace("$setTotal", arguments);
      try {
        if (typeof total !== "undefined") {
          this.modules_total = total;
        }
        if (!this.options.update_ui) {
          return;
        }
        const htmlTotal = document.querySelector(this.id_all);
        htmlTotal.textContent = this.modules_total;
        return this;
      } catch (error) {
        console.log(error);
        console.log("[WARN][Importer] Cannot update total modules. Insert " + this.id_all + " to skip this warning.");
      }
    }

    $prependTrace(message) {
      this.$trace("$prependTrace", arguments);
      try {
        if (!this.options.update_ui) {
          return;
        }
        const htmlTrace = document.querySelector(this.id_trace);
        if (htmlTrace.textContent.length) {
          htmlTrace.textContent = "\n" + htmlTrace.textContent;
        }
        htmlTrace.textContent = message + htmlTrace.textContent;
      } catch (error) {
        console.log(error);
        console.log("[WARN][Importer] Cannot append trace. Insert " + this.id_trace + " to skip this warning.");
      }
    }

    $increaseLoadedModules(moduleType = "unknown", moduleId = "unknown") {
      this.$trace("$increaseLoadedModules", arguments);
      try {
        ++this.modules_loaded;
        const isRepeated = this.modules_loaded_ids.indexOf(moduleId) !== -1;
        if (isRepeated) {
          throw new Error("Repeated module load: " + moduleId);
        }
        this.modules_loaded_ids.push(moduleId);
        console.log(`[OK][Importer] Loaded module ${this.modules_loaded} named ${moduleId} as ${moduleType} ${this.$getMillisecondsOfLife()}`);
        if (!this.options.update_ui) {
          return;
        }
        const htmlLoaded = document.querySelector(this.id_loaded);
        htmlLoaded.textContent = this.modules_loaded;
        this.$prependTrace(`Loaded ${moduleType} from ${moduleId}`);
        this.$updateLoaderBar();
        if ((this.modules_loaded + 1) >= this.modules_total) {
          // this.$removeIntersitial();
        }
      } catch (error) {
        if (this.is_loaded) {
          console.log("[CAUTION][Importer] Module out of the count was loaded: type " + moduleType + " from " + moduleId + " [" + this.modules_loaded + " modules loaded].");
        } else {
          console.log(error);
          console.log("[WARN][Importer] Cannot update total modules. Insert " + this.id_loaded + " to skip this warning.");
        }
      }
    }

    $updateLoaderBar() {
      this.$trace("$updateLoaderBar", arguments);
      try {
        if (!this.options.update_ui) {
          return;
        }
        const htmlLoaderBar = document.querySelector(this.id_loader + " " + this.id_loader_bar);
        const percentageCompleted = Math.round((this.modules_loaded / this.modules_total) * 100);
        htmlLoaderBar.style.width = percentageCompleted + "%";
      } catch (error) {
        console.log(error);
        console.log("[WARN][Importer] Cannot update loaded bar. Insert " + this.id_loader_bar + " inside of " + this.id_loader + " to skip this warning.");
      }
    }

    $removeIntersitial() {
      this.$trace("$removeIntersitial", arguments);
      try {
        if (this.is_loaded) {
          return;
        }
        this.is_loaded = true;
        if (!this.options.update_ui) {
          return;
        }
        if (this.options.update_ui_minimum_milliseconds) {
          clearTimeout(this.options.update_ui_minimum_milliseconds_timeout_id);
          this.update_ui_minimum_milliseconds_timeout_id = setTimeout(() => {
            const intersitial = document.querySelector(this.id);
            if (intersitial) {
              intersitial.remove();
            } else {
              console.log("Cannot remove intersitial. Insert " + this.id + " to skip this warning");
            }
          }, this.options.update_ui_minimum_milliseconds);
        } else {
          const intersitial = document.querySelector(this.id);
          intersitial.remove();
        }
      } catch (error) {
        console.log(error);
        console.log("[WARN][Importer] Cannot remove intersitial. Insert " + this.id + " to skip this warning.");
      }
    }

    async scriptSrc(src) {
      this.$trace("scriptSrc", arguments);
      console.log(`[OK][Importer] Loading ${src} as script.src ${this.$getMillisecondsOfLife()}`);
      await new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = src;
        script.onload = () => resolve();
        script.onerror = (e) => reject(e);
        document.head.appendChild(script);
      });
      this.$increaseLoadedModules("script.src", src);
      return;
    }

    async scriptSrcModule(src) {
      this.$trace("scriptSrcModule", arguments);
      console.log(`[OK][Importer] Loading ${src} as script.src.module ${this.$getMillisecondsOfLife()}`);
      await new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = src;
        script.type = "module";
        script.onload = () => resolve();
        script.onerror = (e) => reject(e);
        document.head.appendChild(script);
      });
      this.$increaseLoadedModules("script.src.module", src);
      return;
    }

    async scriptAsync(url, context = {}) {
      this.$trace("scriptAsync", arguments);
      console.log(`[OK][Importer] Loading ${url} as script.async ${this.$getMillisecondsOfLife()}`);
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Failed to fetch script: ${url}`);
      const scriptText = await response.text();
      const AsyncFunction = (async function () { }).constructor;
      let scriptCode = scriptText;
      try {
        const asyncFunction = new AsyncFunction(...Object.keys(context), scriptText);
        scriptCode = asyncFunction.toString();
        const result = await asyncFunction(...Object.values(context));
        return result;
      } catch (error) {
        this.$error(error, `Error evaluating script.async from ${url} in code \n${this.$breakLines(scriptCode)}\n`);
        throw error;
      } finally {
        this.$increaseLoadedModules("script.async", url);
      }
    }

    $wrapInTryCatch(code) {
      let js = "";
      js += `try {\n`;
      js += `${code}\n`;
      js += `} catch(error) {\n`;
      js += `  console.error('Error in script.async execution:');\n`;
      js += `  console.error(error.name);\n`;
      js += `  console.error(error.message);\n`;
      js += `  console.error(error.stack);\n`;
      js += `  throw error;\n`;
      js += `}\n`;
      js = js.replace("***THIS_IS_A_MAGIC_TOKEN_TO_NOT_USE_NEVER_EVER***", JSON.stringify(js));
      return js;
    }

    $padLeft(input, spaces = 2, charc = " ") {
      let out = "" + input;
      while (out.length < spaces) {
        out = charc + out;
      }
      return out;
    }

    $breakLines(code) {
      const lines = code.split(/(\r\n|\r|\n)/g).filter(l => {
        return l !== "\n" && l !== "";
      });
      const maxDigits = (lines.length + "").length + 1;
      let out = "";
      for (let index = 0; index < lines.length; index++) {
        const line = lines[index];
        out += this.$padLeft(index + 1, maxDigits, " ");
        out += " | ";
        out += line;
        out += "\n";
      }
      return out;
    }

    async linkStylesheet(href) {
      this.$trace("linkStylesheet", arguments);
      console.log(`[OK][Importer] Loading ${href} as link.stylesheet.css ${this.$getMillisecondsOfLife()}`);
      await new Promise((resolve, reject) => {
        const link = document.createElement("link");
        link.rel = "stylesheet";
        link.type = "text/css";
        link.href = href;
        link.onload = () => resolve();
        link.onerror = (e) => reject(e);
        document.head.appendChild(link);
      });
      this.$increaseLoadedModules("link.stylesheet.css", href);
      return;
    }

    async text(url) {
      this.$trace("text", arguments);
      console.log(`[OK][Importer] Loading ${url} as text ${this.$getMillisecondsOfLife()}`);
      const response = await fetch(url);
      this.$increaseLoadedModules("text", url);
      if (!response.ok) throw new Error(`Failed to fetch text: ${url}`);
      return await response.text();
    }

    async json(url) {
      this.$trace("json", arguments);
      console.log(`[OK][Importer] Loading ${url} as json ${this.$getMillisecondsOfLife()}`);
      const response = await fetch(url);
      this.$increaseLoadedModules("json", url);
      if (!response.ok) throw new Error(`Failed to fetch json: ${url}`);
      return await response.json();
    }

    async importVueComponent(url) {
      this.$trace("importVueComponent", arguments);
      try {
        const urlJs = url + ".js";
        const urlCss = url + ".css";
        const urlHtml = url + ".html";
        const template = await this.text(urlHtml);
        await this.scriptAsync(urlJs, { $template: template });
        await this.linkStylesheet(urlCss);
        this.$increaseLoadedModules("vue.component", url);
        return;
      } catch (error) {
        console.log(error);
        throw error;
      }
    }

  }

  window.Importer = Importer;
  window.importer = new Importer();
  window.importer.options.update_ui = true;

  return Importer;
  // @code.end: Importer class

});

// @vuebundler[Lsw_framework_components][8]=/home/carlos/Escritorio/lsw-one/src/bootloader/initialization.js
Vue.prototype.$lsw = {};

// @vuebundler[Lsw_framework_components][9]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-error-manager/lsw-error-manager.js


/**
 * 
 * 
 * @$section: Lsw ErrorManager API  LswErrorManager class
 * @type: class
 * @extends: Object
 * @vendor: lsw
 * @namespace: LswErrorManager
 * @source code: La clase est definida as:
 * 
 */
// @code.start: LswErrorManager class | @section: Lsw ErrorManager API  LswErrorManager class

globalThis.ErrorSummary = class {
  constructor(data) {
    Object.assign(this, data);
  }
  toString() {
    return JSON.stringify(this, null, 2);
  }
}

globalThis.Error = class AccumulableError extends Error {
  constructor(...args) {
    super(...args);
    this.$accumulatedErrors = [];
  }
  toString() {
    return JSON.stringify(this, null, 2);
  }
  toJSON() {
    const data = {
      name: this.name || "Error",
      message: this.message || "",
      stack: this.stack ? this.stack.split("\n    at ") : "",
      ...this,
    };
    if (this.$accumulatedErrors && this.$accumulatedErrors.length) {
      data.$accumulatedErrors = this.$accumulatedErrors;
    }
    return data;
  }
  unified() {
    this.message = this.message + "\n" + this.$accumulatedErrors.map((e, i) => (i + 1) + ': ' + e.name + ': ' + e.message).join("\n");
    this.$accumulatedErrors = [];
    return this;
  }
  prependError(error) {
    this.$accumulatedErrors.unshift(error);
    return this;
  }
  appendError(error) {
    this.$accumulatedErrors.push(error);
    return this;
  }
  summarized() {
    let uniqueTraces = [];
    let commonTraces = [];
    // Recopilar las trazas de la pila de errores acumulados
    const allStacks = this.$accumulatedErrors.map(
      (error) => (error.stack ? error.stack.split("\n    at ") : [])
    );
    // Si no hay acumulados, no hay comunes ni nicos
    if (allStacks.length === 0) {
      return new ErrorSummary({
        name: this.name,
        message: this.message,
        stack: this.stack ? this.stack.split("\n").map(line => line.split("@")) : [],
        uniqueTraces: uniqueTraces,
        commonTraces: commonTraces,
      });
    }
    // Identificar trazas comunes
    const firstStack = allStacks[0];
    for (let i = 0; i < firstStack.length; i++) {
      const trace = firstStack[i];
      let isCommon = true;
      for (let j = 1; j < allStacks.length; j++) {
        if (!allStacks[j].includes(trace)) {
          isCommon = false;
          break;
        }
      }
      if (isCommon) {
        commonTraces.push(trace);
      }
    }
    // Identificar trazas nicas
    for (let i = 0; i < allStacks.length; i++) {
      const uniqueForStack = [];
      for (let j = 0; j < allStacks[i].length; j++) {
        const trace = allStacks[i][j];
        if (!commonTraces.includes(trace)) {
          uniqueForStack.push(trace);
        }
      }
      uniqueTraces.push(uniqueForStack);
    }
    return new ErrorSummary({
      ...this,
      name: this.name,
      message: this.message,
      stack: this.stack ? this.stack.split("\n    at ") : [],
      uniqueTraces: uniqueTraces,
      commonTraces: commonTraces,
    });
  }

}

// @code.end: LswErrorManager class


// @vuebundler[Lsw_framework_components][10]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-reloader/reloadable.js
// @code.start: LswReloadable injection | @$section: LswReloader API  LswReloadable injection
const serverUrl = 'http://127.0.0.1';
const serverPort = 3000;

if (process?.env?.NODE_ENV === "test") {
  const socket = io(`${serverUrl}:${serverPort}`);
  socket.on('refrescar', () => {
    console.log('Recibida la seal de refrescar desde el servidor');
    location.reload();
  });
}
// @code.end: LswReloadable injection

// @vuebundler[Lsw_framework_components][11]=/home/carlos/Escritorio/lsw-one/src-instrumented/lsw-framework/src/apis/lsw-ensurer/ensure.instr.js
function cov_2clevwsapt() {
    var path = "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-ensurer/ensure.js";
    var hash = "094ff1bc4e2d2e722fad579c301b0fe44c31886a";
    var global = new Function("return this")();
    var gcv = "__coverage__";
    var coverageData = {
        path: "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-ensurer/ensure.js",
        statementMap: {
            "0": {
                start: {
                    line: 1,
                    column: 0
                },
                end: {
                    line: 581,
                    column: 3
                }
            },
            "1": {
                start: {
                    line: 2,
                    column: 14
                },
                end: {
                    line: 2,
                    column: 23
                }
            },
            "2": {
                start: {
                    line: 3,
                    column: 2
                },
                end: {
                    line: 5,
                    column: 3
                }
            },
            "3": {
                start: {
                    line: 4,
                    column: 4
                },
                end: {
                    line: 4,
                    column: 31
                }
            },
            "4": {
                start: {
                    line: 6,
                    column: 2
                },
                end: {
                    line: 8,
                    column: 3
                }
            },
            "5": {
                start: {
                    line: 7,
                    column: 4
                },
                end: {
                    line: 7,
                    column: 31
                }
            },
            "6": {
                start: {
                    line: 9,
                    column: 2
                },
                end: {
                    line: 11,
                    column: 3
                }
            },
            "7": {
                start: {
                    line: 10,
                    column: 4
                },
                end: {
                    line: 10,
                    column: 25
                }
            },
            "8": {
                start: {
                    line: 29,
                    column: 6
                },
                end: {
                    line: 29,
                    column: 21
                }
            },
            "9": {
                start: {
                    line: 30,
                    column: 6
                },
                end: {
                    line: 30,
                    column: 35
                }
            },
            "10": {
                start: {
                    line: 38,
                    column: 6
                },
                end: {
                    line: 38,
                    column: 31
                }
            },
            "11": {
                start: {
                    line: 42,
                    column: 6
                },
                end: {
                    line: 57,
                    column: 7
                }
            },
            "12": {
                start: {
                    line: 43,
                    column: 8
                },
                end: {
                    line: 56,
                    column: 9
                }
            },
            "13": {
                start: {
                    line: 44,
                    column: 29
                },
                end: {
                    line: 44,
                    column: 48
                }
            },
            "14": {
                start: {
                    line: 45,
                    column: 10
                },
                end: {
                    line: 47,
                    column: 11
                }
            },
            "15": {
                start: {
                    line: 46,
                    column: 12
                },
                end: {
                    line: 46,
                    column: 173
                }
            },
            "16": {
                start: {
                    line: 48,
                    column: 10
                },
                end: {
                    line: 48,
                    column: 42
                }
            },
            "17": {
                start: {
                    line: 49,
                    column: 10
                },
                end: {
                    line: 49,
                    column: 50
                }
            },
            "18": {
                start: {
                    line: 50,
                    column: 15
                },
                end: {
                    line: 56,
                    column: 9
                }
            },
            "19": {
                start: {
                    line: 51,
                    column: 10
                },
                end: {
                    line: 51,
                    column: 44
                }
            },
            "20": {
                start: {
                    line: 52,
                    column: 10
                },
                end: {
                    line: 52,
                    column: 33
                }
            },
            "21": {
                start: {
                    line: 54,
                    column: 10
                },
                end: {
                    line: 54,
                    column: 32
                }
            },
            "22": {
                start: {
                    line: 55,
                    column: 10
                },
                end: {
                    line: 55,
                    column: 33
                }
            },
            "23": {
                start: {
                    line: 58,
                    column: 6
                },
                end: {
                    line: 58,
                    column: 34
                }
            },
            "24": {
                start: {
                    line: 59,
                    column: 6
                },
                end: {
                    line: 59,
                    column: 36
                }
            },
            "25": {
                start: {
                    line: 60,
                    column: 6
                },
                end: {
                    line: 60,
                    column: 29
                }
            },
            "26": {
                start: {
                    line: 63,
                    column: 6
                },
                end: {
                    line: 63,
                    column: 37
                }
            },
            "27": {
                start: {
                    line: 64,
                    column: 6
                },
                end: {
                    line: 64,
                    column: 32
                }
            },
            "28": {
                start: {
                    line: 65,
                    column: 6
                },
                end: {
                    line: 75,
                    column: 7
                }
            },
            "29": {
                start: {
                    line: 66,
                    column: 8
                },
                end: {
                    line: 68,
                    column: 9
                }
            },
            "30": {
                start: {
                    line: 67,
                    column: 10
                },
                end: {
                    line: 67,
                    column: 34
                }
            },
            "31": {
                start: {
                    line: 69,
                    column: 13
                },
                end: {
                    line: 75,
                    column: 7
                }
            },
            "32": {
                start: {
                    line: 70,
                    column: 8
                },
                end: {
                    line: 72,
                    column: 9
                }
            },
            "33": {
                start: {
                    line: 71,
                    column: 10
                },
                end: {
                    line: 71,
                    column: 34
                }
            },
            "34": {
                start: {
                    line: 74,
                    column: 8
                },
                end: {
                    line: 74,
                    column: 98
                }
            },
            "35": {
                start: {
                    line: 76,
                    column: 6
                },
                end: {
                    line: 76,
                    column: 32
                }
            },
            "36": {
                start: {
                    line: 79,
                    column: 6
                },
                end: {
                    line: 79,
                    column: 41
                }
            },
            "37": {
                start: {
                    line: 80,
                    column: 6
                },
                end: {
                    line: 80,
                    column: 32
                }
            },
            "38": {
                start: {
                    line: 81,
                    column: 6
                },
                end: {
                    line: 83,
                    column: 7
                }
            },
            "39": {
                start: {
                    line: 82,
                    column: 8
                },
                end: {
                    line: 82,
                    column: 32
                }
            },
            "40": {
                start: {
                    line: 84,
                    column: 6
                },
                end: {
                    line: 84,
                    column: 32
                }
            },
            "41": {
                start: {
                    line: 87,
                    column: 6
                },
                end: {
                    line: 87,
                    column: 29
                }
            },
            "42": {
                start: {
                    line: 88,
                    column: 6
                },
                end: {
                    line: 88,
                    column: 32
                }
            },
            "43": {
                start: {
                    line: 89,
                    column: 6
                },
                end: {
                    line: 91,
                    column: 7
                }
            },
            "44": {
                start: {
                    line: 90,
                    column: 8
                },
                end: {
                    line: 90,
                    column: 32
                }
            },
            "45": {
                start: {
                    line: 92,
                    column: 6
                },
                end: {
                    line: 92,
                    column: 32
                }
            },
            "46": {
                start: {
                    line: 95,
                    column: 6
                },
                end: {
                    line: 95,
                    column: 33
                }
            },
            "47": {
                start: {
                    line: 96,
                    column: 6
                },
                end: {
                    line: 96,
                    column: 32
                }
            },
            "48": {
                start: {
                    line: 97,
                    column: 6
                },
                end: {
                    line: 99,
                    column: 7
                }
            },
            "49": {
                start: {
                    line: 98,
                    column: 8
                },
                end: {
                    line: 98,
                    column: 32
                }
            },
            "50": {
                start: {
                    line: 100,
                    column: 6
                },
                end: {
                    line: 100,
                    column: 32
                }
            },
            "51": {
                start: {
                    line: 103,
                    column: 6
                },
                end: {
                    line: 103,
                    column: 30
                }
            },
            "52": {
                start: {
                    line: 104,
                    column: 6
                },
                end: {
                    line: 104,
                    column: 32
                }
            },
            "53": {
                start: {
                    line: 105,
                    column: 6
                },
                end: {
                    line: 107,
                    column: 7
                }
            },
            "54": {
                start: {
                    line: 106,
                    column: 8
                },
                end: {
                    line: 106,
                    column: 32
                }
            },
            "55": {
                start: {
                    line: 108,
                    column: 6
                },
                end: {
                    line: 108,
                    column: 32
                }
            },
            "56": {
                start: {
                    line: 111,
                    column: 6
                },
                end: {
                    line: 111,
                    column: 31
                }
            },
            "57": {
                start: {
                    line: 112,
                    column: 6
                },
                end: {
                    line: 112,
                    column: 32
                }
            },
            "58": {
                start: {
                    line: 113,
                    column: 6
                },
                end: {
                    line: 115,
                    column: 7
                }
            },
            "59": {
                start: {
                    line: 114,
                    column: 8
                },
                end: {
                    line: 114,
                    column: 32
                }
            },
            "60": {
                start: {
                    line: 116,
                    column: 6
                },
                end: {
                    line: 116,
                    column: 32
                }
            },
            "61": {
                start: {
                    line: 119,
                    column: 6
                },
                end: {
                    line: 119,
                    column: 33
                }
            },
            "62": {
                start: {
                    line: 120,
                    column: 6
                },
                end: {
                    line: 120,
                    column: 32
                }
            },
            "63": {
                start: {
                    line: 121,
                    column: 6
                },
                end: {
                    line: 126,
                    column: 7
                }
            },
            "64": {
                start: {
                    line: 122,
                    column: 8
                },
                end: {
                    line: 122,
                    column: 35
                }
            },
            "65": {
                start: {
                    line: 123,
                    column: 8
                },
                end: {
                    line: 123,
                    column: 32
                }
            },
            "66": {
                start: {
                    line: 125,
                    column: 8
                },
                end: {
                    line: 125,
                    column: 34
                }
            },
            "67": {
                start: {
                    line: 129,
                    column: 6
                },
                end: {
                    line: 129,
                    column: 38
                }
            },
            "68": {
                start: {
                    line: 130,
                    column: 6
                },
                end: {
                    line: 130,
                    column: 32
                }
            },
            "69": {
                start: {
                    line: 131,
                    column: 6
                },
                end: {
                    line: 136,
                    column: 7
                }
            },
            "70": {
                start: {
                    line: 132,
                    column: 8
                },
                end: {
                    line: 132,
                    column: 29
                }
            },
            "71": {
                start: {
                    line: 133,
                    column: 8
                },
                end: {
                    line: 133,
                    column: 32
                }
            },
            "72": {
                start: {
                    line: 135,
                    column: 8
                },
                end: {
                    line: 135,
                    column: 34
                }
            },
            "73": {
                start: {
                    line: 139,
                    column: 6
                },
                end: {
                    line: 141,
                    column: 7
                }
            },
            "74": {
                start: {
                    line: 140,
                    column: 8
                },
                end: {
                    line: 140,
                    column: 21
                }
            },
            "75": {
                start: {
                    line: 142,
                    column: 6
                },
                end: {
                    line: 142,
                    column: 167
                }
            },
            "76": {
                start: {
                    line: 145,
                    column: 6
                },
                end: {
                    line: 145,
                    column: 47
                }
            },
            "77": {
                start: {
                    line: 148,
                    column: 6
                },
                end: {
                    line: 152,
                    column: 7
                }
            },
            "78": {
                start: {
                    line: 149,
                    column: 8
                },
                end: {
                    line: 149,
                    column: 20
                }
            },
            "79": {
                start: {
                    line: 151,
                    column: 8
                },
                end: {
                    line: 151,
                    column: 20
                }
            },
            "80": {
                start: {
                    line: 156,
                    column: 29
                },
                end: {
                    line: 183,
                    column: 3
                }
            },
            "81": {
                start: {
                    line: 157,
                    column: 17
                },
                end: {
                    line: 157,
                    column: 22
                }
            },
            "82": {
                start: {
                    line: 159,
                    column: 6
                },
                end: {
                    line: 159,
                    column: 42
                }
            },
            "83": {
                start: {
                    line: 162,
                    column: 6
                },
                end: {
                    line: 162,
                    column: 41
                }
            },
            "84": {
                start: {
                    line: 165,
                    column: 6
                },
                end: {
                    line: 165,
                    column: 44
                }
            },
            "85": {
                start: {
                    line: 168,
                    column: 6
                },
                end: {
                    line: 168,
                    column: 43
                }
            },
            "86": {
                start: {
                    line: 171,
                    column: 6
                },
                end: {
                    line: 171,
                    column: 36
                }
            },
            "87": {
                start: {
                    line: 172,
                    column: 6
                },
                end: {
                    line: 172,
                    column: 48
                }
            },
            "88": {
                start: {
                    line: 175,
                    column: 6
                },
                end: {
                    line: 175,
                    column: 63
                }
            },
            "89": {
                start: {
                    line: 178,
                    column: 6
                },
                end: {
                    line: 178,
                    column: 42
                }
            },
            "90": {
                start: {
                    line: 181,
                    column: 6
                },
                end: {
                    line: 181,
                    column: 73
                }
            },
            "91": {
                start: {
                    line: 185,
                    column: 24
                },
                end: {
                    line: 313,
                    column: 3
                }
            },
            "92": {
                start: {
                    line: 187,
                    column: 6
                },
                end: {
                    line: 187,
                    column: 74
                }
            },
            "93": {
                start: {
                    line: 188,
                    column: 6
                },
                end: {
                    line: 188,
                    column: 36
                }
            },
            "94": {
                start: {
                    line: 189,
                    column: 6
                },
                end: {
                    line: 189,
                    column: 88
                }
            },
            "95": {
                start: {
                    line: 189,
                    column: 64
                },
                end: {
                    line: 189,
                    column: 88
                }
            },
            "96": {
                start: {
                    line: 190,
                    column: 6
                },
                end: {
                    line: 190,
                    column: 44
                }
            },
            "97": {
                start: {
                    line: 193,
                    column: 6
                },
                end: {
                    line: 193,
                    column: 74
                }
            },
            "98": {
                start: {
                    line: 194,
                    column: 6
                },
                end: {
                    line: 194,
                    column: 36
                }
            },
            "99": {
                start: {
                    line: 195,
                    column: 6
                },
                end: {
                    line: 195,
                    column: 119
                }
            },
            "100": {
                start: {
                    line: 195,
                    column: 95
                },
                end: {
                    line: 195,
                    column: 119
                }
            },
            "101": {
                start: {
                    line: 196,
                    column: 6
                },
                end: {
                    line: 196,
                    column: 44
                }
            },
            "102": {
                start: {
                    line: 199,
                    column: 6
                },
                end: {
                    line: 199,
                    column: 74
                }
            },
            "103": {
                start: {
                    line: 200,
                    column: 6
                },
                end: {
                    line: 200,
                    column: 36
                }
            },
            "104": {
                start: {
                    line: 201,
                    column: 6
                },
                end: {
                    line: 201,
                    column: 88
                }
            },
            "105": {
                start: {
                    line: 201,
                    column: 64
                },
                end: {
                    line: 201,
                    column: 88
                }
            },
            "106": {
                start: {
                    line: 202,
                    column: 6
                },
                end: {
                    line: 202,
                    column: 44
                }
            },
            "107": {
                start: {
                    line: 205,
                    column: 6
                },
                end: {
                    line: 205,
                    column: 72
                }
            },
            "108": {
                start: {
                    line: 206,
                    column: 6
                },
                end: {
                    line: 206,
                    column: 36
                }
            },
            "109": {
                start: {
                    line: 207,
                    column: 6
                },
                end: {
                    line: 207,
                    column: 84
                }
            },
            "110": {
                start: {
                    line: 207,
                    column: 60
                },
                end: {
                    line: 207,
                    column: 84
                }
            },
            "111": {
                start: {
                    line: 208,
                    column: 6
                },
                end: {
                    line: 208,
                    column: 44
                }
            },
            "112": {
                start: {
                    line: 211,
                    column: 6
                },
                end: {
                    line: 211,
                    column: 77
                }
            },
            "113": {
                start: {
                    line: 212,
                    column: 6
                },
                end: {
                    line: 212,
                    column: 36
                }
            },
            "114": {
                start: {
                    line: 213,
                    column: 6
                },
                end: {
                    line: 213,
                    column: 91
                }
            },
            "115": {
                start: {
                    line: 213,
                    column: 67
                },
                end: {
                    line: 213,
                    column: 91
                }
            },
            "116": {
                start: {
                    line: 214,
                    column: 6
                },
                end: {
                    line: 214,
                    column: 44
                }
            },
            "117": {
                start: {
                    line: 217,
                    column: 6
                },
                end: {
                    line: 217,
                    column: 75
                }
            },
            "118": {
                start: {
                    line: 218,
                    column: 6
                },
                end: {
                    line: 218,
                    column: 36
                }
            },
            "119": {
                start: {
                    line: 219,
                    column: 6
                },
                end: {
                    line: 219,
                    column: 89
                }
            },
            "120": {
                start: {
                    line: 219,
                    column: 65
                },
                end: {
                    line: 219,
                    column: 89
                }
            },
            "121": {
                start: {
                    line: 220,
                    column: 6
                },
                end: {
                    line: 220,
                    column: 44
                }
            },
            "122": {
                start: {
                    line: 223,
                    column: 6
                },
                end: {
                    line: 223,
                    column: 78
                }
            },
            "123": {
                start: {
                    line: 224,
                    column: 6
                },
                end: {
                    line: 224,
                    column: 36
                }
            },
            "124": {
                start: {
                    line: 225,
                    column: 6
                },
                end: {
                    line: 225,
                    column: 88
                }
            },
            "125": {
                start: {
                    line: 225,
                    column: 64
                },
                end: {
                    line: 225,
                    column: 88
                }
            },
            "126": {
                start: {
                    line: 226,
                    column: 6
                },
                end: {
                    line: 226,
                    column: 44
                }
            },
            "127": {
                start: {
                    line: 229,
                    column: 6
                },
                end: {
                    line: 229,
                    column: 73
                }
            },
            "128": {
                start: {
                    line: 230,
                    column: 6
                },
                end: {
                    line: 230,
                    column: 36
                }
            },
            "129": {
                start: {
                    line: 231,
                    column: 6
                },
                end: {
                    line: 231,
                    column: 84
                }
            },
            "130": {
                start: {
                    line: 231,
                    column: 60
                },
                end: {
                    line: 231,
                    column: 84
                }
            },
            "131": {
                start: {
                    line: 232,
                    column: 6
                },
                end: {
                    line: 232,
                    column: 44
                }
            },
            "132": {
                start: {
                    line: 235,
                    column: 6
                },
                end: {
                    line: 235,
                    column: 76
                }
            },
            "133": {
                start: {
                    line: 236,
                    column: 6
                },
                end: {
                    line: 236,
                    column: 36
                }
            },
            "134": {
                start: {
                    line: 237,
                    column: 6
                },
                end: {
                    line: 237,
                    column: 92
                }
            },
            "135": {
                start: {
                    line: 237,
                    column: 68
                },
                end: {
                    line: 237,
                    column: 92
                }
            },
            "136": {
                start: {
                    line: 238,
                    column: 6
                },
                end: {
                    line: 238,
                    column: 44
                }
            },
            "137": {
                start: {
                    line: 241,
                    column: 6
                },
                end: {
                    line: 241,
                    column: 73
                }
            },
            "138": {
                start: {
                    line: 242,
                    column: 6
                },
                end: {
                    line: 242,
                    column: 36
                }
            },
            "139": {
                start: {
                    line: 243,
                    column: 22
                },
                end: {
                    line: 258,
                    column: 10
                }
            },
            "140": {
                start: {
                    line: 244,
                    column: 18
                },
                end: {
                    line: 244,
                    column: 31
                }
            },
            "141": {
                start: {
                    line: 245,
                    column: 8
                },
                end: {
                    line: 257,
                    column: 9
                }
            },
            "142": {
                start: {
                    line: 246,
                    column: 10
                },
                end: {
                    line: 246,
                    column: 32
                }
            },
            "143": {
                start: {
                    line: 247,
                    column: 15
                },
                end: {
                    line: 257,
                    column: 9
                }
            },
            "144": {
                start: {
                    line: 248,
                    column: 10
                },
                end: {
                    line: 248,
                    column: 59
                }
            },
            "145": {
                start: {
                    line: 249,
                    column: 15
                },
                end: {
                    line: 257,
                    column: 9
                }
            },
            "146": {
                start: {
                    line: 250,
                    column: 10
                },
                end: {
                    line: 250,
                    column: 26
                }
            },
            "147": {
                start: {
                    line: 251,
                    column: 15
                },
                end: {
                    line: 257,
                    column: 9
                }
            },
            "148": {
                start: {
                    line: 252,
                    column: 10
                },
                end: {
                    line: 252,
                    column: 25
                }
            },
            "149": {
                start: {
                    line: 253,
                    column: 15
                },
                end: {
                    line: 257,
                    column: 9
                }
            },
            "150": {
                start: {
                    line: 254,
                    column: 10
                },
                end: {
                    line: 254,
                    column: 29
                }
            },
            "151": {
                start: {
                    line: 256,
                    column: 10
                },
                end: {
                    line: 256,
                    column: 22
                }
            },
            "152": {
                start: {
                    line: 259,
                    column: 6
                },
                end: {
                    line: 259,
                    column: 63
                }
            },
            "153": {
                start: {
                    line: 259,
                    column: 39
                },
                end: {
                    line: 259,
                    column: 63
                }
            },
            "154": {
                start: {
                    line: 260,
                    column: 6
                },
                end: {
                    line: 260,
                    column: 44
                }
            },
            "155": {
                start: {
                    line: 263,
                    column: 6
                },
                end: {
                    line: 263,
                    column: 76
                }
            },
            "156": {
                start: {
                    line: 264,
                    column: 6
                },
                end: {
                    line: 264,
                    column: 32
                }
            },
            "157": {
                start: {
                    line: 265,
                    column: 20
                },
                end: {
                    line: 265,
                    column: 43
                }
            },
            "158": {
                start: {
                    line: 266,
                    column: 6
                },
                end: {
                    line: 266,
                    column: 63
                }
            },
            "159": {
                start: {
                    line: 266,
                    column: 39
                },
                end: {
                    line: 266,
                    column: 63
                }
            },
            "160": {
                start: {
                    line: 267,
                    column: 6
                },
                end: {
                    line: 267,
                    column: 44
                }
            },
            "161": {
                start: {
                    line: 270,
                    column: 6
                },
                end: {
                    line: 270,
                    column: 89
                }
            },
            "162": {
                start: {
                    line: 271,
                    column: 6
                },
                end: {
                    line: 271,
                    column: 32
                }
            },
            "163": {
                start: {
                    line: 272,
                    column: 29
                },
                end: {
                    line: 272,
                    column: 51
                }
            },
            "164": {
                start: {
                    line: 273,
                    column: 6
                },
                end: {
                    line: 273,
                    column: 72
                }
            },
            "165": {
                start: {
                    line: 273,
                    column: 48
                },
                end: {
                    line: 273,
                    column: 72
                }
            },
            "166": {
                start: {
                    line: 274,
                    column: 6
                },
                end: {
                    line: 274,
                    column: 44
                }
            },
            "167": {
                start: {
                    line: 277,
                    column: 6
                },
                end: {
                    line: 277,
                    column: 80
                }
            },
            "168": {
                start: {
                    line: 278,
                    column: 6
                },
                end: {
                    line: 278,
                    column: 32
                }
            },
            "169": {
                start: {
                    line: 279,
                    column: 22
                },
                end: {
                    line: 279,
                    column: 43
                }
            },
            "170": {
                start: {
                    line: 280,
                    column: 6
                },
                end: {
                    line: 280,
                    column: 65
                }
            },
            "171": {
                start: {
                    line: 280,
                    column: 41
                },
                end: {
                    line: 280,
                    column: 65
                }
            },
            "172": {
                start: {
                    line: 281,
                    column: 6
                },
                end: {
                    line: 281,
                    column: 44
                }
            },
            "173": {
                start: {
                    line: 284,
                    column: 6
                },
                end: {
                    line: 284,
                    column: 46
                }
            },
            "174": {
                start: {
                    line: 287,
                    column: 6
                },
                end: {
                    line: 287,
                    column: 84
                }
            },
            "175": {
                start: {
                    line: 288,
                    column: 6
                },
                end: {
                    line: 288,
                    column: 32
                }
            },
            "176": {
                start: {
                    line: 289,
                    column: 29
                },
                end: {
                    line: 289,
                    column: 51
                }
            },
            "177": {
                start: {
                    line: 290,
                    column: 6
                },
                end: {
                    line: 290,
                    column: 72
                }
            },
            "178": {
                start: {
                    line: 290,
                    column: 48
                },
                end: {
                    line: 290,
                    column: 72
                }
            },
            "179": {
                start: {
                    line: 291,
                    column: 6
                },
                end: {
                    line: 291,
                    column: 44
                }
            },
            "180": {
                start: {
                    line: 294,
                    column: 6
                },
                end: {
                    line: 294,
                    column: 78
                }
            },
            "181": {
                start: {
                    line: 295,
                    column: 6
                },
                end: {
                    line: 295,
                    column: 32
                }
            },
            "182": {
                start: {
                    line: 296,
                    column: 22
                },
                end: {
                    line: 296,
                    column: 43
                }
            },
            "183": {
                start: {
                    line: 297,
                    column: 6
                },
                end: {
                    line: 297,
                    column: 65
                }
            },
            "184": {
                start: {
                    line: 297,
                    column: 41
                },
                end: {
                    line: 297,
                    column: 65
                }
            },
            "185": {
                start: {
                    line: 298,
                    column: 6
                },
                end: {
                    line: 298,
                    column: 44
                }
            },
            "186": {
                start: {
                    line: 301,
                    column: 6
                },
                end: {
                    line: 301,
                    column: 44
                }
            },
            "187": {
                start: {
                    line: 304,
                    column: 6
                },
                end: {
                    line: 304,
                    column: 74
                }
            },
            "188": {
                start: {
                    line: 305,
                    column: 6
                },
                end: {
                    line: 305,
                    column: 32
                }
            },
            "189": {
                start: {
                    line: 306,
                    column: 6
                },
                end: {
                    line: 308,
                    column: 7
                }
            },
            "190": {
                start: {
                    line: 307,
                    column: 8
                },
                end: {
                    line: 307,
                    column: 114
                }
            },
            "191": {
                start: {
                    line: 309,
                    column: 18
                },
                end: {
                    line: 309,
                    column: 65
                }
            },
            "192": {
                start: {
                    line: 310,
                    column: 6
                },
                end: {
                    line: 310,
                    column: 61
                }
            },
            "193": {
                start: {
                    line: 310,
                    column: 37
                },
                end: {
                    line: 310,
                    column: 61
                }
            },
            "194": {
                start: {
                    line: 311,
                    column: 6
                },
                end: {
                    line: 311,
                    column: 44
                }
            },
            "195": {
                start: {
                    line: 315,
                    column: 27
                },
                end: {
                    line: 317,
                    column: 3
                }
            },
            "196": {
                start: {
                    line: 316,
                    column: 17
                },
                end: {
                    line: 316,
                    column: 21
                }
            },
            "197": {
                start: {
                    line: 319,
                    column: 26
                },
                end: {
                    line: 432,
                    column: 3
                }
            },
            "198": {
                start: {
                    line: 322,
                    column: 6
                },
                end: {
                    line: 322,
                    column: 74
                }
            },
            "199": {
                start: {
                    line: 323,
                    column: 6
                },
                end: {
                    line: 323,
                    column: 31
                }
            },
            "200": {
                start: {
                    line: 324,
                    column: 27
                },
                end: {
                    line: 324,
                    column: 61
                }
            },
            "201": {
                start: {
                    line: 325,
                    column: 6
                },
                end: {
                    line: 325,
                    column: 68
                }
            },
            "202": {
                start: {
                    line: 325,
                    column: 44
                },
                end: {
                    line: 325,
                    column: 68
                }
            },
            "203": {
                start: {
                    line: 326,
                    column: 6
                },
                end: {
                    line: 326,
                    column: 44
                }
            },
            "204": {
                start: {
                    line: 330,
                    column: 6
                },
                end: {
                    line: 330,
                    column: 73
                }
            },
            "205": {
                start: {
                    line: 331,
                    column: 6
                },
                end: {
                    line: 331,
                    column: 31
                }
            },
            "206": {
                start: {
                    line: 332,
                    column: 19
                },
                end: {
                    line: 332,
                    column: 45
                }
            },
            "207": {
                start: {
                    line: 333,
                    column: 21
                },
                end: {
                    line: 333,
                    column: 46
                }
            },
            "208": {
                start: {
                    line: 334,
                    column: 6
                },
                end: {
                    line: 334,
                    column: 62
                }
            },
            "209": {
                start: {
                    line: 334,
                    column: 38
                },
                end: {
                    line: 334,
                    column: 62
                }
            },
            "210": {
                start: {
                    line: 335,
                    column: 6
                },
                end: {
                    line: 335,
                    column: 44
                }
            },
            "211": {
                start: {
                    line: 339,
                    column: 6
                },
                end: {
                    line: 339,
                    column: 75
                }
            },
            "212": {
                start: {
                    line: 340,
                    column: 6
                },
                end: {
                    line: 340,
                    column: 31
                }
            },
            "213": {
                start: {
                    line: 341,
                    column: 21
                },
                end: {
                    line: 341,
                    column: 49
                }
            },
            "214": {
                start: {
                    line: 342,
                    column: 23
                },
                end: {
                    line: 342,
                    column: 50
                }
            },
            "215": {
                start: {
                    line: 343,
                    column: 6
                },
                end: {
                    line: 343,
                    column: 64
                }
            },
            "216": {
                start: {
                    line: 343,
                    column: 40
                },
                end: {
                    line: 343,
                    column: 64
                }
            },
            "217": {
                start: {
                    line: 344,
                    column: 6
                },
                end: {
                    line: 344,
                    column: 44
                }
            },
            "218": {
                start: {
                    line: 348,
                    column: 6
                },
                end: {
                    line: 348,
                    column: 89
                }
            },
            "219": {
                start: {
                    line: 349,
                    column: 6
                },
                end: {
                    line: 349,
                    column: 32
                }
            },
            "220": {
                start: {
                    line: 350,
                    column: 19
                },
                end: {
                    line: 350,
                    column: 45
                }
            },
            "221": {
                start: {
                    line: 351,
                    column: 20
                },
                end: {
                    line: 351,
                    column: 24
                }
            },
            "222": {
                start: {
                    line: 352,
                    column: 6
                },
                end: {
                    line: 359,
                    column: 7
                }
            },
            "223": {
                start: {
                    line: 353,
                    column: 6
                },
                end: {
                    line: 359,
                    column: 7
                }
            },
            "224": {
                start: {
                    line: 353,
                    column: 23
                },
                end: {
                    line: 353,
                    column: 24
                }
            },
            "225": {
                start: {
                    line: 354,
                    column: 20
                },
                end: {
                    line: 354,
                    column: 31
                }
            },
            "226": {
                start: {
                    line: 355,
                    column: 8
                },
                end: {
                    line: 358,
                    column: 9
                }
            },
            "227": {
                start: {
                    line: 356,
                    column: 10
                },
                end: {
                    line: 356,
                    column: 26
                }
            },
            "228": {
                start: {
                    line: 357,
                    column: 10
                },
                end: {
                    line: 357,
                    column: 32
                }
            },
            "229": {
                start: {
                    line: 360,
                    column: 6
                },
                end: {
                    line: 360,
                    column: 63
                }
            },
            "230": {
                start: {
                    line: 360,
                    column: 39
                },
                end: {
                    line: 360,
                    column: 63
                }
            },
            "231": {
                start: {
                    line: 361,
                    column: 6
                },
                end: {
                    line: 361,
                    column: 44
                }
            },
            "232": {
                start: {
                    line: 365,
                    column: 6
                },
                end: {
                    line: 365,
                    column: 74
                }
            },
            "233": {
                start: {
                    line: 366,
                    column: 6
                },
                end: {
                    line: 366,
                    column: 32
                }
            },
            "234": {
                start: {
                    line: 367,
                    column: 19
                },
                end: {
                    line: 367,
                    column: 45
                }
            },
            "235": {
                start: {
                    line: 368,
                    column: 20
                },
                end: {
                    line: 368,
                    column: 24
                }
            },
            "236": {
                start: {
                    line: 369,
                    column: 6
                },
                end: {
                    line: 376,
                    column: 7
                }
            },
            "237": {
                start: {
                    line: 370,
                    column: 6
                },
                end: {
                    line: 376,
                    column: 7
                }
            },
            "238": {
                start: {
                    line: 370,
                    column: 23
                },
                end: {
                    line: 370,
                    column: 24
                }
            },
            "239": {
                start: {
                    line: 371,
                    column: 21
                },
                end: {
                    line: 371,
                    column: 33
                }
            },
            "240": {
                start: {
                    line: 372,
                    column: 8
                },
                end: {
                    line: 375,
                    column: 9
                }
            },
            "241": {
                start: {
                    line: 373,
                    column: 10
                },
                end: {
                    line: 373,
                    column: 26
                }
            },
            "242": {
                start: {
                    line: 374,
                    column: 10
                },
                end: {
                    line: 374,
                    column: 32
                }
            },
            "243": {
                start: {
                    line: 377,
                    column: 6
                },
                end: {
                    line: 377,
                    column: 63
                }
            },
            "244": {
                start: {
                    line: 377,
                    column: 39
                },
                end: {
                    line: 377,
                    column: 63
                }
            },
            "245": {
                start: {
                    line: 378,
                    column: 6
                },
                end: {
                    line: 378,
                    column: 44
                }
            },
            "246": {
                start: {
                    line: 382,
                    column: 6
                },
                end: {
                    line: 382,
                    column: 76
                }
            },
            "247": {
                start: {
                    line: 383,
                    column: 6
                },
                end: {
                    line: 383,
                    column: 32
                }
            },
            "248": {
                start: {
                    line: 384,
                    column: 21
                },
                end: {
                    line: 384,
                    column: 49
                }
            },
            "249": {
                start: {
                    line: 385,
                    column: 22
                },
                end: {
                    line: 385,
                    column: 26
                }
            },
            "250": {
                start: {
                    line: 386,
                    column: 6
                },
                end: {
                    line: 393,
                    column: 7
                }
            },
            "251": {
                start: {
                    line: 387,
                    column: 6
                },
                end: {
                    line: 393,
                    column: 7
                }
            },
            "252": {
                start: {
                    line: 387,
                    column: 23
                },
                end: {
                    line: 387,
                    column: 24
                }
            },
            "253": {
                start: {
                    line: 388,
                    column: 21
                },
                end: {
                    line: 388,
                    column: 33
                }
            },
            "254": {
                start: {
                    line: 389,
                    column: 8
                },
                end: {
                    line: 392,
                    column: 9
                }
            },
            "255": {
                start: {
                    line: 390,
                    column: 10
                },
                end: {
                    line: 390,
                    column: 28
                }
            },
            "256": {
                start: {
                    line: 391,
                    column: 10
                },
                end: {
                    line: 391,
                    column: 32
                }
            },
            "257": {
                start: {
                    line: 394,
                    column: 6
                },
                end: {
                    line: 394,
                    column: 65
                }
            },
            "258": {
                start: {
                    line: 394,
                    column: 41
                },
                end: {
                    line: 394,
                    column: 65
                }
            },
            "259": {
                start: {
                    line: 395,
                    column: 6
                },
                end: {
                    line: 395,
                    column: 44
                }
            },
            "260": {
                start: {
                    line: 399,
                    column: 6
                },
                end: {
                    line: 399,
                    column: 82
                }
            },
            "261": {
                start: {
                    line: 400,
                    column: 6
                },
                end: {
                    line: 400,
                    column: 32
                }
            },
            "262": {
                start: {
                    line: 401,
                    column: 19
                },
                end: {
                    line: 401,
                    column: 45
                }
            },
            "263": {
                start: {
                    line: 402,
                    column: 20
                },
                end: {
                    line: 402,
                    column: 24
                }
            },
            "264": {
                start: {
                    line: 403,
                    column: 6
                },
                end: {
                    line: 410,
                    column: 7
                }
            },
            "265": {
                start: {
                    line: 404,
                    column: 6
                },
                end: {
                    line: 410,
                    column: 7
                }
            },
            "266": {
                start: {
                    line: 404,
                    column: 23
                },
                end: {
                    line: 404,
                    column: 24
                }
            },
            "267": {
                start: {
                    line: 405,
                    column: 20
                },
                end: {
                    line: 405,
                    column: 31
                }
            },
            "268": {
                start: {
                    line: 406,
                    column: 8
                },
                end: {
                    line: 409,
                    column: 9
                }
            },
            "269": {
                start: {
                    line: 407,
                    column: 10
                },
                end: {
                    line: 407,
                    column: 26
                }
            },
            "270": {
                start: {
                    line: 408,
                    column: 10
                },
                end: {
                    line: 408,
                    column: 32
                }
            },
            "271": {
                start: {
                    line: 411,
                    column: 6
                },
                end: {
                    line: 411,
                    column: 63
                }
            },
            "272": {
                start: {
                    line: 411,
                    column: 39
                },
                end: {
                    line: 411,
                    column: 63
                }
            },
            "273": {
                start: {
                    line: 412,
                    column: 6
                },
                end: {
                    line: 412,
                    column: 44
                }
            },
            "274": {
                start: {
                    line: 416,
                    column: 6
                },
                end: {
                    line: 416,
                    column: 84
                }
            },
            "275": {
                start: {
                    line: 417,
                    column: 6
                },
                end: {
                    line: 417,
                    column: 32
                }
            },
            "276": {
                start: {
                    line: 418,
                    column: 21
                },
                end: {
                    line: 418,
                    column: 49
                }
            },
            "277": {
                start: {
                    line: 419,
                    column: 22
                },
                end: {
                    line: 419,
                    column: 26
                }
            },
            "278": {
                start: {
                    line: 420,
                    column: 6
                },
                end: {
                    line: 427,
                    column: 7
                }
            },
            "279": {
                start: {
                    line: 421,
                    column: 6
                },
                end: {
                    line: 427,
                    column: 7
                }
            },
            "280": {
                start: {
                    line: 421,
                    column: 23
                },
                end: {
                    line: 421,
                    column: 24
                }
            },
            "281": {
                start: {
                    line: 422,
                    column: 22
                },
                end: {
                    line: 422,
                    column: 35
                }
            },
            "282": {
                start: {
                    line: 423,
                    column: 8
                },
                end: {
                    line: 426,
                    column: 9
                }
            },
            "283": {
                start: {
                    line: 424,
                    column: 10
                },
                end: {
                    line: 424,
                    column: 28
                }
            },
            "284": {
                start: {
                    line: 425,
                    column: 10
                },
                end: {
                    line: 425,
                    column: 32
                }
            },
            "285": {
                start: {
                    line: 428,
                    column: 6
                },
                end: {
                    line: 428,
                    column: 65
                }
            },
            "286": {
                start: {
                    line: 428,
                    column: 41
                },
                end: {
                    line: 428,
                    column: 65
                }
            },
            "287": {
                start: {
                    line: 429,
                    column: 6
                },
                end: {
                    line: 429,
                    column: 44
                }
            },
            "288": {
                start: {
                    line: 434,
                    column: 29
                },
                end: {
                    line: 436,
                    column: 3
                }
            },
            "289": {
                start: {
                    line: 435,
                    column: 17
                },
                end: {
                    line: 435,
                    column: 21
                }
            },
            "290": {
                start: {
                    line: 438,
                    column: 23
                },
                end: {
                    line: 563,
                    column: 3
                }
            },
            "291": {
                start: {
                    line: 441,
                    column: 6
                },
                end: {
                    line: 441,
                    column: 38
                }
            },
            "292": {
                start: {
                    line: 445,
                    column: 6
                },
                end: {
                    line: 445,
                    column: 40
                }
            },
            "293": {
                start: {
                    line: 449,
                    column: 6
                },
                end: {
                    line: 449,
                    column: 42
                }
            },
            "294": {
                start: {
                    line: 453,
                    column: 6
                },
                end: {
                    line: 456,
                    column: 7
                }
            },
            "295": {
                start: {
                    line: 460,
                    column: 6
                },
                end: {
                    line: 460,
                    column: 37
                }
            },
            "296": {
                start: {
                    line: 464,
                    column: 6
                },
                end: {
                    line: 464,
                    column: 39
                }
            },
            "297": {
                start: {
                    line: 468,
                    column: 6
                },
                end: {
                    line: 472,
                    column: 8
                }
            },
            "298": {
                start: {
                    line: 476,
                    column: 6
                },
                end: {
                    line: 481,
                    column: 9
                }
            },
            "299": {
                start: {
                    line: 485,
                    column: 6
                },
                end: {
                    line: 485,
                    column: 27
                }
            },
            "300": {
                start: {
                    line: 489,
                    column: 6
                },
                end: {
                    line: 495,
                    column: 7
                }
            },
            "301": {
                start: {
                    line: 489,
                    column: 23
                },
                end: {
                    line: 489,
                    column: 24
                }
            },
            "302": {
                start: {
                    line: 490,
                    column: 8
                },
                end: {
                    line: 494,
                    column: 9
                }
            },
            "303": {
                start: {
                    line: 491,
                    column: 10
                },
                end: {
                    line: 491,
                    column: 32
                }
            },
            "304": {
                start: {
                    line: 499,
                    column: 19
                },
                end: {
                    line: 499,
                    column: 23
                }
            },
            "305": {
                start: {
                    line: 500,
                    column: 6
                },
                end: {
                    line: 506,
                    column: 7
                }
            },
            "306": {
                start: {
                    line: 500,
                    column: 23
                },
                end: {
                    line: 500,
                    column: 24
                }
            },
            "307": {
                start: {
                    line: 501,
                    column: 8
                },
                end: {
                    line: 505,
                    column: 9
                }
            },
            "308": {
                start: {
                    line: 502,
                    column: 10
                },
                end: {
                    line: 502,
                    column: 32
                }
            },
            "309": {
                start: {
                    line: 504,
                    column: 10
                },
                end: {
                    line: 504,
                    column: 118
                }
            },
            "310": {
                start: {
                    line: 507,
                    column: 6
                },
                end: {
                    line: 507,
                    column: 20
                }
            },
            "311": {
                start: {
                    line: 511,
                    column: 26
                },
                end: {
                    line: 511,
                    column: 35
                }
            },
            "312": {
                start: {
                    line: 512,
                    column: 21
                },
                end: {
                    line: 512,
                    column: 41
                }
            },
            "313": {
                start: {
                    line: 513,
                    column: 22
                },
                end: {
                    line: 513,
                    column: 101
                }
            },
            "314": {
                start: {
                    line: 514,
                    column: 6
                },
                end: {
                    line: 523,
                    column: 7
                }
            },
            "315": {
                start: {
                    line: 514,
                    column: 20
                },
                end: {
                    line: 514,
                    column: 21
                }
            },
            "316": {
                start: {
                    line: 515,
                    column: 26
                },
                end: {
                    line: 515,
                    column: 39
                }
            },
            "317": {
                start: {
                    line: 516,
                    column: 38
                },
                end: {
                    line: 516,
                    column: 56
                }
            },
            "318": {
                start: {
                    line: 517,
                    column: 8
                },
                end: {
                    line: 522,
                    column: 9
                }
            },
            "319": {
                start: {
                    line: 518,
                    column: 10
                },
                end: {
                    line: 518,
                    column: 34
                }
            },
            "320": {
                start: {
                    line: 519,
                    column: 10
                },
                end: {
                    line: 519,
                    column: 27
                }
            },
            "321": {
                start: {
                    line: 521,
                    column: 10
                },
                end: {
                    line: 521,
                    column: 37
                }
            },
            "322": {
                start: {
                    line: 524,
                    column: 6
                },
                end: {
                    line: 524,
                    column: 30
                }
            },
            "323": {
                start: {
                    line: 528,
                    column: 6
                },
                end: {
                    line: 528,
                    column: 32
                }
            },
            "324": {
                start: {
                    line: 532,
                    column: 6
                },
                end: {
                    line: 532,
                    column: 34
                }
            },
            "325": {
                start: {
                    line: 536,
                    column: 6
                },
                end: {
                    line: 538,
                    column: 9
                }
            },
            "326": {
                start: {
                    line: 542,
                    column: 6
                },
                end: {
                    line: 544,
                    column: 7
                }
            },
            "327": {
                start: {
                    line: 543,
                    column: 8
                },
                end: {
                    line: 543,
                    column: 47
                }
            },
            "328": {
                start: {
                    line: 545,
                    column: 6
                },
                end: {
                    line: 545,
                    column: 18
                }
            },
            "329": {
                start: {
                    line: 549,
                    column: 19
                },
                end: {
                    line: 549,
                    column: 23
                }
            },
            "330": {
                start: {
                    line: 550,
                    column: 6
                },
                end: {
                    line: 555,
                    column: 7
                }
            },
            "331": {
                start: {
                    line: 551,
                    column: 8
                },
                end: {
                    line: 551,
                    column: 19
                }
            },
            "332": {
                start: {
                    line: 552,
                    column: 8
                },
                end: {
                    line: 552,
                    column: 23
                }
            },
            "333": {
                start: {
                    line: 554,
                    column: 8
                },
                end: {
                    line: 554,
                    column: 20
                }
            },
            "334": {
                start: {
                    line: 556,
                    column: 6
                },
                end: {
                    line: 558,
                    column: 7
                }
            },
            "335": {
                start: {
                    line: 557,
                    column: 8
                },
                end: {
                    line: 557,
                    column: 47
                }
            },
            "336": {
                start: {
                    line: 561,
                    column: 28
                },
                end: {
                    line: 561,
                    column: 42
                }
            },
            "337": {
                start: {
                    line: 565,
                    column: 2
                },
                end: {
                    line: 576,
                    column: 3
                }
            },
            "338": {
                start: {
                    line: 566,
                    column: 4
                },
                end: {
                    line: 566,
                    column: 62
                }
            },
            "339": {
                start: {
                    line: 567,
                    column: 4
                },
                end: {
                    line: 567,
                    column: 64
                }
            },
            "340": {
                start: {
                    line: 568,
                    column: 4
                },
                end: {
                    line: 568,
                    column: 63
                }
            },
            "341": {
                start: {
                    line: 569,
                    column: 4
                },
                end: {
                    line: 569,
                    column: 69
                }
            },
            "342": {
                start: {
                    line: 570,
                    column: 4
                },
                end: {
                    line: 570,
                    column: 71
                }
            },
            "343": {
                start: {
                    line: 571,
                    column: 4
                },
                end: {
                    line: 571,
                    column: 69
                }
            },
            "344": {
                start: {
                    line: 572,
                    column: 4
                },
                end: {
                    line: 572,
                    column: 62
                }
            },
            "345": {
                start: {
                    line: 573,
                    column: 4
                },
                end: {
                    line: 573,
                    column: 64
                }
            },
            "346": {
                start: {
                    line: 575,
                    column: 4
                },
                end: {
                    line: 575,
                    column: 46
                }
            },
            "347": {
                start: {
                    line: 578,
                    column: 2
                },
                end: {
                    line: 578,
                    column: 22
                }
            }
        },
        fnMap: {
            "0": {
                name: "(anonymous_0)",
                decl: {
                    start: {
                        line: 1,
                        column: 1
                    },
                    end: {
                        line: 1,
                        column: 2
                    }
                },
                loc: {
                    start: {
                        line: 1,
                        column: 20
                    },
                    end: {
                        line: 12,
                        column: 1
                    }
                },
                line: 1
            },
            "1": {
                name: "(anonymous_1)",
                decl: {
                    start: {
                        line: 12,
                        column: 3
                    },
                    end: {
                        line: 12,
                        column: 4
                    }
                },
                loc: {
                    start: {
                        line: 12,
                        column: 15
                    },
                    end: {
                        line: 581,
                        column: 1
                    }
                },
                line: 12
            },
            "2": {
                name: "(anonymous_2)",
                decl: {
                    start: {
                        line: 28,
                        column: 4
                    },
                    end: {
                        line: 28,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 28,
                        column: 25
                    },
                    end: {
                        line: 31,
                        column: 5
                    }
                },
                line: 28
            },
            "3": {
                name: "(anonymous_3)",
                decl: {
                    start: {
                        line: 37,
                        column: 4
                    },
                    end: {
                        line: 37,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 37,
                        column: 27
                    },
                    end: {
                        line: 39,
                        column: 5
                    }
                },
                line: 37
            },
            "4": {
                name: "(anonymous_4)",
                decl: {
                    start: {
                        line: 41,
                        column: 4
                    },
                    end: {
                        line: 41,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 41,
                        column: 45
                    },
                    end: {
                        line: 61,
                        column: 5
                    }
                },
                line: 41
            },
            "5": {
                name: "(anonymous_5)",
                decl: {
                    start: {
                        line: 62,
                        column: 4
                    },
                    end: {
                        line: 62,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 62,
                        column: 16
                    },
                    end: {
                        line: 77,
                        column: 5
                    }
                },
                line: 62
            },
            "6": {
                name: "(anonymous_6)",
                decl: {
                    start: {
                        line: 78,
                        column: 4
                    },
                    end: {
                        line: 78,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 78,
                        column: 19
                    },
                    end: {
                        line: 85,
                        column: 5
                    }
                },
                line: 78
            },
            "7": {
                name: "(anonymous_7)",
                decl: {
                    start: {
                        line: 86,
                        column: 4
                    },
                    end: {
                        line: 86,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 86,
                        column: 14
                    },
                    end: {
                        line: 93,
                        column: 5
                    }
                },
                line: 86
            },
            "8": {
                name: "(anonymous_8)",
                decl: {
                    start: {
                        line: 94,
                        column: 4
                    },
                    end: {
                        line: 94,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 94,
                        column: 16
                    },
                    end: {
                        line: 101,
                        column: 5
                    }
                },
                line: 94
            },
            "9": {
                name: "(anonymous_9)",
                decl: {
                    start: {
                        line: 102,
                        column: 4
                    },
                    end: {
                        line: 102,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 102,
                        column: 15
                    },
                    end: {
                        line: 109,
                        column: 5
                    }
                },
                line: 102
            },
            "10": {
                name: "(anonymous_10)",
                decl: {
                    start: {
                        line: 110,
                        column: 4
                    },
                    end: {
                        line: 110,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 110,
                        column: 16
                    },
                    end: {
                        line: 117,
                        column: 5
                    }
                },
                line: 110
            },
            "11": {
                name: "(anonymous_11)",
                decl: {
                    start: {
                        line: 118,
                        column: 4
                    },
                    end: {
                        line: 118,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 118,
                        column: 18
                    },
                    end: {
                        line: 127,
                        column: 5
                    }
                },
                line: 118
            },
            "12": {
                name: "(anonymous_12)",
                decl: {
                    start: {
                        line: 128,
                        column: 4
                    },
                    end: {
                        line: 128,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 128,
                        column: 23
                    },
                    end: {
                        line: 137,
                        column: 5
                    }
                },
                line: 128
            },
            "13": {
                name: "(anonymous_13)",
                decl: {
                    start: {
                        line: 138,
                        column: 4
                    },
                    end: {
                        line: 138,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 138,
                        column: 43
                    },
                    end: {
                        line: 143,
                        column: 5
                    }
                },
                line: 138
            },
            "14": {
                name: "(anonymous_14)",
                decl: {
                    start: {
                        line: 144,
                        column: 4
                    },
                    end: {
                        line: 144,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 144,
                        column: 30
                    },
                    end: {
                        line: 146,
                        column: 5
                    }
                },
                line: 144
            },
            "15": {
                name: "(anonymous_15)",
                decl: {
                    start: {
                        line: 147,
                        column: 4
                    },
                    end: {
                        line: 147,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 147,
                        column: 18
                    },
                    end: {
                        line: 153,
                        column: 5
                    }
                },
                line: 147
            },
            "16": {
                name: "(anonymous_16)",
                decl: {
                    start: {
                        line: 158,
                        column: 4
                    },
                    end: {
                        line: 158,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 158,
                        column: 26
                    },
                    end: {
                        line: 160,
                        column: 5
                    }
                },
                line: 158
            },
            "17": {
                name: "(anonymous_17)",
                decl: {
                    start: {
                        line: 161,
                        column: 4
                    },
                    end: {
                        line: 161,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 161,
                        column: 21
                    },
                    end: {
                        line: 163,
                        column: 5
                    }
                },
                line: 161
            },
            "18": {
                name: "(anonymous_18)",
                decl: {
                    start: {
                        line: 164,
                        column: 4
                    },
                    end: {
                        line: 164,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 164,
                        column: 28
                    },
                    end: {
                        line: 166,
                        column: 5
                    }
                },
                line: 164
            },
            "19": {
                name: "(anonymous_19)",
                decl: {
                    start: {
                        line: 167,
                        column: 4
                    },
                    end: {
                        line: 167,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 167,
                        column: 23
                    },
                    end: {
                        line: 169,
                        column: 5
                    }
                },
                line: 167
            },
            "20": {
                name: "(anonymous_20)",
                decl: {
                    start: {
                        line: 170,
                        column: 4
                    },
                    end: {
                        line: 170,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 170,
                        column: 28
                    },
                    end: {
                        line: 173,
                        column: 5
                    }
                },
                line: 170
            },
            "21": {
                name: "(anonymous_21)",
                decl: {
                    start: {
                        line: 174,
                        column: 4
                    },
                    end: {
                        line: 174,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 174,
                        column: 28
                    },
                    end: {
                        line: 176,
                        column: 5
                    }
                },
                line: 174
            },
            "22": {
                name: "(anonymous_22)",
                decl: {
                    start: {
                        line: 177,
                        column: 4
                    },
                    end: {
                        line: 177,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 177,
                        column: 16
                    },
                    end: {
                        line: 179,
                        column: 5
                    }
                },
                line: 177
            },
            "23": {
                name: "(anonymous_23)",
                decl: {
                    start: {
                        line: 180,
                        column: 4
                    },
                    end: {
                        line: 180,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 180,
                        column: 32
                    },
                    end: {
                        line: 182,
                        column: 5
                    }
                },
                line: 180
            },
            "24": {
                name: "(anonymous_24)",
                decl: {
                    start: {
                        line: 186,
                        column: 4
                    },
                    end: {
                        line: 186,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 186,
                        column: 13
                    },
                    end: {
                        line: 191,
                        column: 5
                    }
                },
                line: 186
            },
            "25": {
                name: "(anonymous_25)",
                decl: {
                    start: {
                        line: 192,
                        column: 4
                    },
                    end: {
                        line: 192,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 192,
                        column: 13
                    },
                    end: {
                        line: 197,
                        column: 5
                    }
                },
                line: 192
            },
            "26": {
                name: "(anonymous_26)",
                decl: {
                    start: {
                        line: 198,
                        column: 4
                    },
                    end: {
                        line: 198,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 198,
                        column: 13
                    },
                    end: {
                        line: 203,
                        column: 5
                    }
                },
                line: 198
            },
            "27": {
                name: "(anonymous_27)",
                decl: {
                    start: {
                        line: 204,
                        column: 4
                    },
                    end: {
                        line: 204,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 204,
                        column: 11
                    },
                    end: {
                        line: 209,
                        column: 5
                    }
                },
                line: 204
            },
            "28": {
                name: "(anonymous_28)",
                decl: {
                    start: {
                        line: 210,
                        column: 4
                    },
                    end: {
                        line: 210,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 210,
                        column: 16
                    },
                    end: {
                        line: 215,
                        column: 5
                    }
                },
                line: 210
            },
            "29": {
                name: "(anonymous_29)",
                decl: {
                    start: {
                        line: 216,
                        column: 4
                    },
                    end: {
                        line: 216,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 216,
                        column: 14
                    },
                    end: {
                        line: 221,
                        column: 5
                    }
                },
                line: 216
            },
            "30": {
                name: "(anonymous_30)",
                decl: {
                    start: {
                        line: 222,
                        column: 4
                    },
                    end: {
                        line: 222,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 222,
                        column: 22
                    },
                    end: {
                        line: 227,
                        column: 5
                    }
                },
                line: 222
            },
            "31": {
                name: "(anonymous_31)",
                decl: {
                    start: {
                        line: 228,
                        column: 4
                    },
                    end: {
                        line: 228,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 228,
                        column: 12
                    },
                    end: {
                        line: 233,
                        column: 5
                    }
                },
                line: 228
            },
            "32": {
                name: "(anonymous_32)",
                decl: {
                    start: {
                        line: 234,
                        column: 4
                    },
                    end: {
                        line: 234,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 234,
                        column: 15
                    },
                    end: {
                        line: 239,
                        column: 5
                    }
                },
                line: 234
            },
            "33": {
                name: "(anonymous_33)",
                decl: {
                    start: {
                        line: 240,
                        column: 4
                    },
                    end: {
                        line: 240,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 240,
                        column: 12
                    },
                    end: {
                        line: 261,
                        column: 5
                    }
                },
                line: 240
            },
            "34": {
                name: "(anonymous_34)",
                decl: {
                    start: {
                        line: 243,
                        column: 23
                    },
                    end: {
                        line: 243,
                        column: 24
                    }
                },
                loc: {
                    start: {
                        line: 243,
                        column: 29
                    },
                    end: {
                        line: 258,
                        column: 7
                    }
                },
                line: 243
            },
            "35": {
                name: "(anonymous_35)",
                decl: {
                    start: {
                        line: 262,
                        column: 4
                    },
                    end: {
                        line: 262,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 262,
                        column: 19
                    },
                    end: {
                        line: 268,
                        column: 5
                    }
                },
                line: 262
            },
            "36": {
                name: "(anonymous_36)",
                decl: {
                    start: {
                        line: 269,
                        column: 4
                    },
                    end: {
                        line: 269,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 269,
                        column: 30
                    },
                    end: {
                        line: 275,
                        column: 5
                    }
                },
                line: 269
            },
            "37": {
                name: "(anonymous_37)",
                decl: {
                    start: {
                        line: 276,
                        column: 4
                    },
                    end: {
                        line: 276,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 276,
                        column: 23
                    },
                    end: {
                        line: 282,
                        column: 5
                    }
                },
                line: 276
            },
            "38": {
                name: "(anonymous_38)",
                decl: {
                    start: {
                        line: 283,
                        column: 4
                    },
                    end: {
                        line: 283,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 283,
                        column: 30
                    },
                    end: {
                        line: 285,
                        column: 5
                    }
                },
                line: 283
            },
            "39": {
                name: "(anonymous_39)",
                decl: {
                    start: {
                        line: 286,
                        column: 4
                    },
                    end: {
                        line: 286,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 286,
                        column: 28
                    },
                    end: {
                        line: 292,
                        column: 5
                    }
                },
                line: 286
            },
            "40": {
                name: "(anonymous_40)",
                decl: {
                    start: {
                        line: 293,
                        column: 4
                    },
                    end: {
                        line: 293,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 293,
                        column: 21
                    },
                    end: {
                        line: 299,
                        column: 5
                    }
                },
                line: 293
            },
            "41": {
                name: "(anonymous_41)",
                decl: {
                    start: {
                        line: 300,
                        column: 4
                    },
                    end: {
                        line: 300,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 300,
                        column: 26
                    },
                    end: {
                        line: 302,
                        column: 5
                    }
                },
                line: 300
            },
            "42": {
                name: "(anonymous_42)",
                decl: {
                    start: {
                        line: 303,
                        column: 4
                    },
                    end: {
                        line: 303,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 303,
                        column: 17
                    },
                    end: {
                        line: 312,
                        column: 5
                    }
                },
                line: 303
            },
            "43": {
                name: "(anonymous_43)",
                decl: {
                    start: {
                        line: 321,
                        column: 4
                    },
                    end: {
                        line: 321,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 321,
                        column: 15
                    },
                    end: {
                        line: 327,
                        column: 5
                    }
                },
                line: 321
            },
            "44": {
                name: "(anonymous_44)",
                decl: {
                    start: {
                        line: 329,
                        column: 4
                    },
                    end: {
                        line: 329,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 329,
                        column: 14
                    },
                    end: {
                        line: 336,
                        column: 5
                    }
                },
                line: 329
            },
            "45": {
                name: "(anonymous_45)",
                decl: {
                    start: {
                        line: 338,
                        column: 4
                    },
                    end: {
                        line: 338,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 338,
                        column: 16
                    },
                    end: {
                        line: 345,
                        column: 5
                    }
                },
                line: 338
            },
            "46": {
                name: "(anonymous_46)",
                decl: {
                    start: {
                        line: 347,
                        column: 4
                    },
                    end: {
                        line: 347,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 347,
                        column: 29
                    },
                    end: {
                        line: 362,
                        column: 5
                    }
                },
                line: 347
            },
            "47": {
                name: "(anonymous_47)",
                decl: {
                    start: {
                        line: 364,
                        column: 4
                    },
                    end: {
                        line: 364,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 364,
                        column: 16
                    },
                    end: {
                        line: 379,
                        column: 5
                    }
                },
                line: 364
            },
            "48": {
                name: "(anonymous_48)",
                decl: {
                    start: {
                        line: 381,
                        column: 4
                    },
                    end: {
                        line: 381,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 381,
                        column: 18
                    },
                    end: {
                        line: 396,
                        column: 5
                    }
                },
                line: 381
            },
            "49": {
                name: "(anonymous_49)",
                decl: {
                    start: {
                        line: 398,
                        column: 4
                    },
                    end: {
                        line: 398,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 398,
                        column: 24
                    },
                    end: {
                        line: 413,
                        column: 5
                    }
                },
                line: 398
            },
            "50": {
                name: "(anonymous_50)",
                decl: {
                    start: {
                        line: 415,
                        column: 4
                    },
                    end: {
                        line: 415,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 415,
                        column: 26
                    },
                    end: {
                        line: 430,
                        column: 5
                    }
                },
                line: 415
            },
            "51": {
                name: "(anonymous_51)",
                decl: {
                    start: {
                        line: 440,
                        column: 4
                    },
                    end: {
                        line: 440,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 440,
                        column: 20
                    },
                    end: {
                        line: 442,
                        column: 5
                    }
                },
                line: 440
            },
            "52": {
                name: "(anonymous_52)",
                decl: {
                    start: {
                        line: 444,
                        column: 4
                    },
                    end: {
                        line: 444,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 444,
                        column: 19
                    },
                    end: {
                        line: 446,
                        column: 5
                    }
                },
                line: 444
            },
            "53": {
                name: "(anonymous_53)",
                decl: {
                    start: {
                        line: 448,
                        column: 4
                    },
                    end: {
                        line: 448,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 448,
                        column: 21
                    },
                    end: {
                        line: 450,
                        column: 5
                    }
                },
                line: 448
            },
            "54": {
                name: "(anonymous_54)",
                decl: {
                    start: {
                        line: 452,
                        column: 4
                    },
                    end: {
                        line: 452,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 452,
                        column: 17
                    },
                    end: {
                        line: 457,
                        column: 5
                    }
                },
                line: 452
            },
            "55": {
                name: "(anonymous_55)",
                decl: {
                    start: {
                        line: 459,
                        column: 4
                    },
                    end: {
                        line: 459,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 459,
                        column: 16
                    },
                    end: {
                        line: 461,
                        column: 5
                    }
                },
                line: 459
            },
            "56": {
                name: "(anonymous_56)",
                decl: {
                    start: {
                        line: 463,
                        column: 4
                    },
                    end: {
                        line: 463,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 463,
                        column: 18
                    },
                    end: {
                        line: 465,
                        column: 5
                    }
                },
                line: 463
            },
            "57": {
                name: "(anonymous_57)",
                decl: {
                    start: {
                        line: 467,
                        column: 4
                    },
                    end: {
                        line: 467,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 467,
                        column: 13
                    },
                    end: {
                        line: 473,
                        column: 5
                    }
                },
                line: 467
            },
            "58": {
                name: "(anonymous_58)",
                decl: {
                    start: {
                        line: 475,
                        column: 4
                    },
                    end: {
                        line: 475,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 475,
                        column: 12
                    },
                    end: {
                        line: 482,
                        column: 5
                    }
                },
                line: 475
            },
            "59": {
                name: "(anonymous_59)",
                decl: {
                    start: {
                        line: 484,
                        column: 4
                    },
                    end: {
                        line: 484,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 484,
                        column: 17
                    },
                    end: {
                        line: 486,
                        column: 5
                    }
                },
                line: 484
            },
            "60": {
                name: "(anonymous_60)",
                decl: {
                    start: {
                        line: 488,
                        column: 4
                    },
                    end: {
                        line: 488,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 488,
                        column: 27
                    },
                    end: {
                        line: 496,
                        column: 5
                    }
                },
                line: 488
            },
            "61": {
                name: "(anonymous_61)",
                decl: {
                    start: {
                        line: 498,
                        column: 4
                    },
                    end: {
                        line: 498,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 498,
                        column: 21
                    },
                    end: {
                        line: 508,
                        column: 5
                    }
                },
                line: 498
            },
            "62": {
                name: "(anonymous_62)",
                decl: {
                    start: {
                        line: 510,
                        column: 4
                    },
                    end: {
                        line: 510,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 510,
                        column: 24
                    },
                    end: {
                        line: 525,
                        column: 5
                    }
                },
                line: 510
            },
            "63": {
                name: "(anonymous_63)",
                decl: {
                    start: {
                        line: 527,
                        column: 4
                    },
                    end: {
                        line: 527,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 527,
                        column: 19
                    },
                    end: {
                        line: 529,
                        column: 5
                    }
                },
                line: 527
            },
            "64": {
                name: "(anonymous_64)",
                decl: {
                    start: {
                        line: 531,
                        column: 4
                    },
                    end: {
                        line: 531,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 531,
                        column: 27
                    },
                    end: {
                        line: 533,
                        column: 5
                    }
                },
                line: 531
            },
            "65": {
                name: "(anonymous_65)",
                decl: {
                    start: {
                        line: 535,
                        column: 4
                    },
                    end: {
                        line: 535,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 535,
                        column: 26
                    },
                    end: {
                        line: 539,
                        column: 5
                    }
                },
                line: 535
            },
            "66": {
                name: "(anonymous_66)",
                decl: {
                    start: {
                        line: 541,
                        column: 4
                    },
                    end: {
                        line: 541,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 541,
                        column: 72
                    },
                    end: {
                        line: 546,
                        column: 5
                    }
                },
                line: 541
            },
            "67": {
                name: "(anonymous_67)",
                decl: {
                    start: {
                        line: 548,
                        column: 4
                    },
                    end: {
                        line: 548,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 548,
                        column: 70
                    },
                    end: {
                        line: 559,
                        column: 5
                    }
                },
                line: 548
            }
        },
        branchMap: {
            "0": {
                loc: {
                    start: {
                        line: 3,
                        column: 2
                    },
                    end: {
                        line: 5,
                        column: 3
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 3,
                        column: 2
                    },
                    end: {
                        line: 5,
                        column: 3
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 3
            },
            "1": {
                loc: {
                    start: {
                        line: 6,
                        column: 2
                    },
                    end: {
                        line: 8,
                        column: 3
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 6,
                        column: 2
                    },
                    end: {
                        line: 8,
                        column: 3
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 6
            },
            "2": {
                loc: {
                    start: {
                        line: 9,
                        column: 2
                    },
                    end: {
                        line: 11,
                        column: 3
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 9,
                        column: 2
                    },
                    end: {
                        line: 11,
                        column: 3
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 9
            },
            "3": {
                loc: {
                    start: {
                        line: 41,
                        column: 24
                    },
                    end: {
                        line: 41,
                        column: 43
                    }
                },
                type: "default-arg",
                locations: [{
                    start: {
                        line: 41,
                        column: 42
                    },
                    end: {
                        line: 41,
                        column: 43
                    }
                }],
                line: 41
            },
            "4": {
                loc: {
                    start: {
                        line: 43,
                        column: 8
                    },
                    end: {
                        line: 56,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 43,
                        column: 8
                    },
                    end: {
                        line: 56,
                        column: 9
                    }
                }, {
                    start: {
                        line: 50,
                        column: 15
                    },
                    end: {
                        line: 56,
                        column: 9
                    }
                }],
                line: 43
            },
            "5": {
                loc: {
                    start: {
                        line: 43,
                        column: 12
                    },
                    end: {
                        line: 43,
                        column: 67
                    }
                },
                type: "binary-expr",
                locations: [{
                    start: {
                        line: 43,
                        column: 13
                    },
                    end: {
                        line: 43,
                        column: 34
                    }
                }, {
                    start: {
                        line: 43,
                        column: 40
                    },
                    end: {
                        line: 43,
                        column: 66
                    }
                }],
                line: 43
            },
            "6": {
                loc: {
                    start: {
                        line: 45,
                        column: 10
                    },
                    end: {
                        line: 47,
                        column: 11
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 45,
                        column: 10
                    },
                    end: {
                        line: 47,
                        column: 11
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 45
            },
            "7": {
                loc: {
                    start: {
                        line: 50,
                        column: 15
                    },
                    end: {
                        line: 56,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 50,
                        column: 15
                    },
                    end: {
                        line: 56,
                        column: 9
                    }
                }, {
                    start: {
                        line: 53,
                        column: 15
                    },
                    end: {
                        line: 56,
                        column: 9
                    }
                }],
                line: 50
            },
            "8": {
                loc: {
                    start: {
                        line: 65,
                        column: 6
                    },
                    end: {
                        line: 75,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 65,
                        column: 6
                    },
                    end: {
                        line: 75,
                        column: 7
                    }
                }, {
                    start: {
                        line: 69,
                        column: 13
                    },
                    end: {
                        line: 75,
                        column: 7
                    }
                }],
                line: 65
            },
            "9": {
                loc: {
                    start: {
                        line: 66,
                        column: 8
                    },
                    end: {
                        line: 68,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 66,
                        column: 8
                    },
                    end: {
                        line: 68,
                        column: 9
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 66
            },
            "10": {
                loc: {
                    start: {
                        line: 69,
                        column: 13
                    },
                    end: {
                        line: 75,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 69,
                        column: 13
                    },
                    end: {
                        line: 75,
                        column: 7
                    }
                }, {
                    start: {
                        line: 73,
                        column: 13
                    },
                    end: {
                        line: 75,
                        column: 7
                    }
                }],
                line: 69
            },
            "11": {
                loc: {
                    start: {
                        line: 70,
                        column: 8
                    },
                    end: {
                        line: 72,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 70,
                        column: 8
                    },
                    end: {
                        line: 72,
                        column: 9
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 70
            },
            "12": {
                loc: {
                    start: {
                        line: 81,
                        column: 6
                    },
                    end: {
                        line: 83,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 81,
                        column: 6
                    },
                    end: {
                        line: 83,
                        column: 7
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 81
            },
            "13": {
                loc: {
                    start: {
                        line: 89,
                        column: 6
                    },
                    end: {
                        line: 91,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 89,
                        column: 6
                    },
                    end: {
                        line: 91,
                        column: 7
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 89
            },
            "14": {
                loc: {
                    start: {
                        line: 97,
                        column: 6
                    },
                    end: {
                        line: 99,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 97,
                        column: 6
                    },
                    end: {
                        line: 99,
                        column: 7
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 97
            },
            "15": {
                loc: {
                    start: {
                        line: 105,
                        column: 6
                    },
                    end: {
                        line: 107,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 105,
                        column: 6
                    },
                    end: {
                        line: 107,
                        column: 7
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 105
            },
            "16": {
                loc: {
                    start: {
                        line: 113,
                        column: 6
                    },
                    end: {
                        line: 115,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 113,
                        column: 6
                    },
                    end: {
                        line: 115,
                        column: 7
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 113
            },
            "17": {
                loc: {
                    start: {
                        line: 138,
                        column: 14
                    },
                    end: {
                        line: 138,
                        column: 41
                    }
                },
                type: "default-arg",
                locations: [{
                    start: {
                        line: 138,
                        column: 26
                    },
                    end: {
                        line: 138,
                        column: 41
                    }
                }],
                line: 138
            },
            "18": {
                loc: {
                    start: {
                        line: 139,
                        column: 6
                    },
                    end: {
                        line: 141,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 139,
                        column: 6
                    },
                    end: {
                        line: 141,
                        column: 7
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 139
            },
            "19": {
                loc: {
                    start: {
                        line: 142,
                        column: 92
                    },
                    end: {
                        line: 142,
                        column: 159
                    }
                },
                type: "cond-expr",
                locations: [{
                    start: {
                        line: 142,
                        column: 112
                    },
                    end: {
                        line: 142,
                        column: 155
                    }
                }, {
                    start: {
                        line: 142,
                        column: 157
                    },
                    end: {
                        line: 142,
                        column: 159
                    }
                }],
                line: 142
            },
            "20": {
                loc: {
                    start: {
                        line: 148,
                        column: 6
                    },
                    end: {
                        line: 152,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 148,
                        column: 6
                    },
                    end: {
                        line: 152,
                        column: 7
                    }
                }, {
                    start: {
                        line: 150,
                        column: 13
                    },
                    end: {
                        line: 152,
                        column: 7
                    }
                }],
                line: 148
            },
            "21": {
                loc: {
                    start: {
                        line: 175,
                        column: 13
                    },
                    end: {
                        line: 175,
                        column: 62
                    }
                },
                type: "cond-expr",
                locations: [{
                    start: {
                        line: 175,
                        column: 40
                    },
                    end: {
                        line: 175,
                        column: 50
                    }
                }, {
                    start: {
                        line: 175,
                        column: 53
                    },
                    end: {
                        line: 175,
                        column: 62
                    }
                }],
                line: 175
            },
            "22": {
                loc: {
                    start: {
                        line: 181,
                        column: 42
                    },
                    end: {
                        line: 181,
                        column: 71
                    }
                },
                type: "cond-expr",
                locations: [{
                    start: {
                        line: 181,
                        column: 60
                    },
                    end: {
                        line: 181,
                        column: 66
                    }
                }, {
                    start: {
                        line: 181,
                        column: 69
                    },
                    end: {
                        line: 181,
                        column: 71
                    }
                }],
                line: 181
            },
            "23": {
                loc: {
                    start: {
                        line: 189,
                        column: 6
                    },
                    end: {
                        line: 189,
                        column: 88
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 189,
                        column: 6
                    },
                    end: {
                        line: 189,
                        column: 88
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 189
            },
            "24": {
                loc: {
                    start: {
                        line: 195,
                        column: 6
                    },
                    end: {
                        line: 195,
                        column: 119
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 195,
                        column: 6
                    },
                    end: {
                        line: 195,
                        column: 119
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 195
            },
            "25": {
                loc: {
                    start: {
                        line: 195,
                        column: 10
                    },
                    end: {
                        line: 195,
                        column: 93
                    }
                },
                type: "binary-expr",
                locations: [{
                    start: {
                        line: 195,
                        column: 10
                    },
                    end: {
                        line: 195,
                        column: 62
                    }
                }, {
                    start: {
                        line: 195,
                        column: 66
                    },
                    end: {
                        line: 195,
                        column: 93
                    }
                }],
                line: 195
            },
            "26": {
                loc: {
                    start: {
                        line: 201,
                        column: 6
                    },
                    end: {
                        line: 201,
                        column: 88
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 201,
                        column: 6
                    },
                    end: {
                        line: 201,
                        column: 88
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 201
            },
            "27": {
                loc: {
                    start: {
                        line: 207,
                        column: 6
                    },
                    end: {
                        line: 207,
                        column: 84
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 207,
                        column: 6
                    },
                    end: {
                        line: 207,
                        column: 84
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 207
            },
            "28": {
                loc: {
                    start: {
                        line: 213,
                        column: 6
                    },
                    end: {
                        line: 213,
                        column: 91
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 213,
                        column: 6
                    },
                    end: {
                        line: 213,
                        column: 91
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 213
            },
            "29": {
                loc: {
                    start: {
                        line: 219,
                        column: 6
                    },
                    end: {
                        line: 219,
                        column: 89
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 219,
                        column: 6
                    },
                    end: {
                        line: 219,
                        column: 89
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 219
            },
            "30": {
                loc: {
                    start: {
                        line: 225,
                        column: 6
                    },
                    end: {
                        line: 225,
                        column: 88
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 225,
                        column: 6
                    },
                    end: {
                        line: 225,
                        column: 88
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 225
            },
            "31": {
                loc: {
                    start: {
                        line: 231,
                        column: 6
                    },
                    end: {
                        line: 231,
                        column: 84
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 231,
                        column: 6
                    },
                    end: {
                        line: 231,
                        column: 84
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 231
            },
            "32": {
                loc: {
                    start: {
                        line: 237,
                        column: 6
                    },
                    end: {
                        line: 237,
                        column: 92
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 237,
                        column: 6
                    },
                    end: {
                        line: 237,
                        column: 92
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 237
            },
            "33": {
                loc: {
                    start: {
                        line: 245,
                        column: 8
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 245,
                        column: 8
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                }, {
                    start: {
                        line: 247,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                }],
                line: 245
            },
            "34": {
                loc: {
                    start: {
                        line: 247,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 247,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                }, {
                    start: {
                        line: 249,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                }],
                line: 247
            },
            "35": {
                loc: {
                    start: {
                        line: 248,
                        column: 17
                    },
                    end: {
                        line: 248,
                        column: 58
                    }
                },
                type: "binary-expr",
                locations: [{
                    start: {
                        line: 248,
                        column: 17
                    },
                    end: {
                        line: 248,
                        column: 27
                    }
                }, {
                    start: {
                        line: 248,
                        column: 31
                    },
                    end: {
                        line: 248,
                        column: 58
                    }
                }],
                line: 248
            },
            "36": {
                loc: {
                    start: {
                        line: 249,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 249,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                }, {
                    start: {
                        line: 251,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                }],
                line: 249
            },
            "37": {
                loc: {
                    start: {
                        line: 251,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 251,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                }, {
                    start: {
                        line: 253,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                }],
                line: 251
            },
            "38": {
                loc: {
                    start: {
                        line: 253,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 253,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                }, {
                    start: {
                        line: 255,
                        column: 15
                    },
                    end: {
                        line: 257,
                        column: 9
                    }
                }],
                line: 253
            },
            "39": {
                loc: {
                    start: {
                        line: 259,
                        column: 6
                    },
                    end: {
                        line: 259,
                        column: 63
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 259,
                        column: 6
                    },
                    end: {
                        line: 259,
                        column: 63
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 259
            },
            "40": {
                loc: {
                    start: {
                        line: 266,
                        column: 6
                    },
                    end: {
                        line: 266,
                        column: 63
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 266,
                        column: 6
                    },
                    end: {
                        line: 266,
                        column: 63
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 266
            },
            "41": {
                loc: {
                    start: {
                        line: 273,
                        column: 6
                    },
                    end: {
                        line: 273,
                        column: 72
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 273,
                        column: 6
                    },
                    end: {
                        line: 273,
                        column: 72
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 273
            },
            "42": {
                loc: {
                    start: {
                        line: 280,
                        column: 6
                    },
                    end: {
                        line: 280,
                        column: 65
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 280,
                        column: 6
                    },
                    end: {
                        line: 280,
                        column: 65
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 280
            },
            "43": {
                loc: {
                    start: {
                        line: 290,
                        column: 6
                    },
                    end: {
                        line: 290,
                        column: 72
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 290,
                        column: 6
                    },
                    end: {
                        line: 290,
                        column: 72
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 290
            },
            "44": {
                loc: {
                    start: {
                        line: 297,
                        column: 6
                    },
                    end: {
                        line: 297,
                        column: 65
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 297,
                        column: 6
                    },
                    end: {
                        line: 297,
                        column: 65
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 297
            },
            "45": {
                loc: {
                    start: {
                        line: 306,
                        column: 6
                    },
                    end: {
                        line: 308,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 306,
                        column: 6
                    },
                    end: {
                        line: 308,
                        column: 7
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 306
            },
            "46": {
                loc: {
                    start: {
                        line: 310,
                        column: 6
                    },
                    end: {
                        line: 310,
                        column: 61
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 310,
                        column: 6
                    },
                    end: {
                        line: 310,
                        column: 61
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 310
            },
            "47": {
                loc: {
                    start: {
                        line: 325,
                        column: 6
                    },
                    end: {
                        line: 325,
                        column: 68
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 325,
                        column: 6
                    },
                    end: {
                        line: 325,
                        column: 68
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 325
            },
            "48": {
                loc: {
                    start: {
                        line: 334,
                        column: 6
                    },
                    end: {
                        line: 334,
                        column: 62
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 334,
                        column: 6
                    },
                    end: {
                        line: 334,
                        column: 62
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 334
            },
            "49": {
                loc: {
                    start: {
                        line: 343,
                        column: 6
                    },
                    end: {
                        line: 343,
                        column: 64
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 343,
                        column: 6
                    },
                    end: {
                        line: 343,
                        column: 64
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 343
            },
            "50": {
                loc: {
                    start: {
                        line: 355,
                        column: 8
                    },
                    end: {
                        line: 358,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 355,
                        column: 8
                    },
                    end: {
                        line: 358,
                        column: 9
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 355
            },
            "51": {
                loc: {
                    start: {
                        line: 360,
                        column: 6
                    },
                    end: {
                        line: 360,
                        column: 63
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 360,
                        column: 6
                    },
                    end: {
                        line: 360,
                        column: 63
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 360
            },
            "52": {
                loc: {
                    start: {
                        line: 372,
                        column: 8
                    },
                    end: {
                        line: 375,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 372,
                        column: 8
                    },
                    end: {
                        line: 375,
                        column: 9
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 372
            },
            "53": {
                loc: {
                    start: {
                        line: 377,
                        column: 6
                    },
                    end: {
                        line: 377,
                        column: 63
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 377,
                        column: 6
                    },
                    end: {
                        line: 377,
                        column: 63
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 377
            },
            "54": {
                loc: {
                    start: {
                        line: 389,
                        column: 8
                    },
                    end: {
                        line: 392,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 389,
                        column: 8
                    },
                    end: {
                        line: 392,
                        column: 9
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 389
            },
            "55": {
                loc: {
                    start: {
                        line: 394,
                        column: 6
                    },
                    end: {
                        line: 394,
                        column: 65
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 394,
                        column: 6
                    },
                    end: {
                        line: 394,
                        column: 65
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 394
            },
            "56": {
                loc: {
                    start: {
                        line: 406,
                        column: 8
                    },
                    end: {
                        line: 409,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 406,
                        column: 8
                    },
                    end: {
                        line: 409,
                        column: 9
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 406
            },
            "57": {
                loc: {
                    start: {
                        line: 411,
                        column: 6
                    },
                    end: {
                        line: 411,
                        column: 63
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 411,
                        column: 6
                    },
                    end: {
                        line: 411,
                        column: 63
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 411
            },
            "58": {
                loc: {
                    start: {
                        line: 423,
                        column: 8
                    },
                    end: {
                        line: 426,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 423,
                        column: 8
                    },
                    end: {
                        line: 426,
                        column: 9
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 423
            },
            "59": {
                loc: {
                    start: {
                        line: 428,
                        column: 6
                    },
                    end: {
                        line: 428,
                        column: 65
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 428,
                        column: 6
                    },
                    end: {
                        line: 428,
                        column: 65
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 428
            },
            "60": {
                loc: {
                    start: {
                        line: 488,
                        column: 15
                    },
                    end: {
                        line: 488,
                        column: 25
                    }
                },
                type: "default-arg",
                locations: [{
                    start: {
                        line: 488,
                        column: 24
                    },
                    end: {
                        line: 488,
                        column: 25
                    }
                }],
                line: 488
            },
            "61": {
                loc: {
                    start: {
                        line: 498,
                        column: 9
                    },
                    end: {
                        line: 498,
                        column: 19
                    }
                },
                type: "default-arg",
                locations: [{
                    start: {
                        line: 498,
                        column: 18
                    },
                    end: {
                        line: 498,
                        column: 19
                    }
                }],
                line: 498
            },
            "62": {
                loc: {
                    start: {
                        line: 541,
                        column: 29
                    },
                    end: {
                        line: 541,
                        column: 70
                    }
                },
                type: "default-arg",
                locations: [{
                    start: {
                        line: 541,
                        column: 44
                    },
                    end: {
                        line: 541,
                        column: 70
                    }
                }],
                line: 541
            },
            "63": {
                loc: {
                    start: {
                        line: 542,
                        column: 6
                    },
                    end: {
                        line: 544,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 542,
                        column: 6
                    },
                    end: {
                        line: 544,
                        column: 7
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 542
            },
            "64": {
                loc: {
                    start: {
                        line: 548,
                        column: 27
                    },
                    end: {
                        line: 548,
                        column: 68
                    }
                },
                type: "default-arg",
                locations: [{
                    start: {
                        line: 548,
                        column: 42
                    },
                    end: {
                        line: 548,
                        column: 68
                    }
                }],
                line: 548
            },
            "65": {
                loc: {
                    start: {
                        line: 556,
                        column: 6
                    },
                    end: {
                        line: 558,
                        column: 7
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 556,
                        column: 6
                    },
                    end: {
                        line: 558,
                        column: 7
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 556
            }
        },
        s: {
            "0": 0,
            "1": 0,
            "2": 0,
            "3": 0,
            "4": 0,
            "5": 0,
            "6": 0,
            "7": 0,
            "8": 0,
            "9": 0,
            "10": 0,
            "11": 0,
            "12": 0,
            "13": 0,
            "14": 0,
            "15": 0,
            "16": 0,
            "17": 0,
            "18": 0,
            "19": 0,
            "20": 0,
            "21": 0,
            "22": 0,
            "23": 0,
            "24": 0,
            "25": 0,
            "26": 0,
            "27": 0,
            "28": 0,
            "29": 0,
            "30": 0,
            "31": 0,
            "32": 0,
            "33": 0,
            "34": 0,
            "35": 0,
            "36": 0,
            "37": 0,
            "38": 0,
            "39": 0,
            "40": 0,
            "41": 0,
            "42": 0,
            "43": 0,
            "44": 0,
            "45": 0,
            "46": 0,
            "47": 0,
            "48": 0,
            "49": 0,
            "50": 0,
            "51": 0,
            "52": 0,
            "53": 0,
            "54": 0,
            "55": 0,
            "56": 0,
            "57": 0,
            "58": 0,
            "59": 0,
            "60": 0,
            "61": 0,
            "62": 0,
            "63": 0,
            "64": 0,
            "65": 0,
            "66": 0,
            "67": 0,
            "68": 0,
            "69": 0,
            "70": 0,
            "71": 0,
            "72": 0,
            "73": 0,
            "74": 0,
            "75": 0,
            "76": 0,
            "77": 0,
            "78": 0,
            "79": 0,
            "80": 0,
            "81": 0,
            "82": 0,
            "83": 0,
            "84": 0,
            "85": 0,
            "86": 0,
            "87": 0,
            "88": 0,
            "89": 0,
            "90": 0,
            "91": 0,
            "92": 0,
            "93": 0,
            "94": 0,
            "95": 0,
            "96": 0,
            "97": 0,
            "98": 0,
            "99": 0,
            "100": 0,
            "101": 0,
            "102": 0,
            "103": 0,
            "104": 0,
            "105": 0,
            "106": 0,
            "107": 0,
            "108": 0,
            "109": 0,
            "110": 0,
            "111": 0,
            "112": 0,
            "113": 0,
            "114": 0,
            "115": 0,
            "116": 0,
            "117": 0,
            "118": 0,
            "119": 0,
            "120": 0,
            "121": 0,
            "122": 0,
            "123": 0,
            "124": 0,
            "125": 0,
            "126": 0,
            "127": 0,
            "128": 0,
            "129": 0,
            "130": 0,
            "131": 0,
            "132": 0,
            "133": 0,
            "134": 0,
            "135": 0,
            "136": 0,
            "137": 0,
            "138": 0,
            "139": 0,
            "140": 0,
            "141": 0,
            "142": 0,
            "143": 0,
            "144": 0,
            "145": 0,
            "146": 0,
            "147": 0,
            "148": 0,
            "149": 0,
            "150": 0,
            "151": 0,
            "152": 0,
            "153": 0,
            "154": 0,
            "155": 0,
            "156": 0,
            "157": 0,
            "158": 0,
            "159": 0,
            "160": 0,
            "161": 0,
            "162": 0,
            "163": 0,
            "164": 0,
            "165": 0,
            "166": 0,
            "167": 0,
            "168": 0,
            "169": 0,
            "170": 0,
            "171": 0,
            "172": 0,
            "173": 0,
            "174": 0,
            "175": 0,
            "176": 0,
            "177": 0,
            "178": 0,
            "179": 0,
            "180": 0,
            "181": 0,
            "182": 0,
            "183": 0,
            "184": 0,
            "185": 0,
            "186": 0,
            "187": 0,
            "188": 0,
            "189": 0,
            "190": 0,
            "191": 0,
            "192": 0,
            "193": 0,
            "194": 0,
            "195": 0,
            "196": 0,
            "197": 0,
            "198": 0,
            "199": 0,
            "200": 0,
            "201": 0,
            "202": 0,
            "203": 0,
            "204": 0,
            "205": 0,
            "206": 0,
            "207": 0,
            "208": 0,
            "209": 0,
            "210": 0,
            "211": 0,
            "212": 0,
            "213": 0,
            "214": 0,
            "215": 0,
            "216": 0,
            "217": 0,
            "218": 0,
            "219": 0,
            "220": 0,
            "221": 0,
            "222": 0,
            "223": 0,
            "224": 0,
            "225": 0,
            "226": 0,
            "227": 0,
            "228": 0,
            "229": 0,
            "230": 0,
            "231": 0,
            "232": 0,
            "233": 0,
            "234": 0,
            "235": 0,
            "236": 0,
            "237": 0,
            "238": 0,
            "239": 0,
            "240": 0,
            "241": 0,
            "242": 0,
            "243": 0,
            "244": 0,
            "245": 0,
            "246": 0,
            "247": 0,
            "248": 0,
            "249": 0,
            "250": 0,
            "251": 0,
            "252": 0,
            "253": 0,
            "254": 0,
            "255": 0,
            "256": 0,
            "257": 0,
            "258": 0,
            "259": 0,
            "260": 0,
            "261": 0,
            "262": 0,
            "263": 0,
            "264": 0,
            "265": 0,
            "266": 0,
            "267": 0,
            "268": 0,
            "269": 0,
            "270": 0,
            "271": 0,
            "272": 0,
            "273": 0,
            "274": 0,
            "275": 0,
            "276": 0,
            "277": 0,
            "278": 0,
            "279": 0,
            "280": 0,
            "281": 0,
            "282": 0,
            "283": 0,
            "284": 0,
            "285": 0,
            "286": 0,
            "287": 0,
            "288": 0,
            "289": 0,
            "290": 0,
            "291": 0,
            "292": 0,
            "293": 0,
            "294": 0,
            "295": 0,
            "296": 0,
            "297": 0,
            "298": 0,
            "299": 0,
            "300": 0,
            "301": 0,
            "302": 0,
            "303": 0,
            "304": 0,
            "305": 0,
            "306": 0,
            "307": 0,
            "308": 0,
            "309": 0,
            "310": 0,
            "311": 0,
            "312": 0,
            "313": 0,
            "314": 0,
            "315": 0,
            "316": 0,
            "317": 0,
            "318": 0,
            "319": 0,
            "320": 0,
            "321": 0,
            "322": 0,
            "323": 0,
            "324": 0,
            "325": 0,
            "326": 0,
            "327": 0,
            "328": 0,
            "329": 0,
            "330": 0,
            "331": 0,
            "332": 0,
            "333": 0,
            "334": 0,
            "335": 0,
            "336": 0,
            "337": 0,
            "338": 0,
            "339": 0,
            "340": 0,
            "341": 0,
            "342": 0,
            "343": 0,
            "344": 0,
            "345": 0,
            "346": 0,
            "347": 0
        },
        f: {
            "0": 0,
            "1": 0,
            "2": 0,
            "3": 0,
            "4": 0,
            "5": 0,
            "6": 0,
            "7": 0,
            "8": 0,
            "9": 0,
            "10": 0,
            "11": 0,
            "12": 0,
            "13": 0,
            "14": 0,
            "15": 0,
            "16": 0,
            "17": 0,
            "18": 0,
            "19": 0,
            "20": 0,
            "21": 0,
            "22": 0,
            "23": 0,
            "24": 0,
            "25": 0,
            "26": 0,
            "27": 0,
            "28": 0,
            "29": 0,
            "30": 0,
            "31": 0,
            "32": 0,
            "33": 0,
            "34": 0,
            "35": 0,
            "36": 0,
            "37": 0,
            "38": 0,
            "39": 0,
            "40": 0,
            "41": 0,
            "42": 0,
            "43": 0,
            "44": 0,
            "45": 0,
            "46": 0,
            "47": 0,
            "48": 0,
            "49": 0,
            "50": 0,
            "51": 0,
            "52": 0,
            "53": 0,
            "54": 0,
            "55": 0,
            "56": 0,
            "57": 0,
            "58": 0,
            "59": 0,
            "60": 0,
            "61": 0,
            "62": 0,
            "63": 0,
            "64": 0,
            "65": 0,
            "66": 0,
            "67": 0
        },
        b: {
            "0": [0, 0],
            "1": [0, 0],
            "2": [0, 0],
            "3": [0],
            "4": [0, 0],
            "5": [0, 0],
            "6": [0, 0],
            "7": [0, 0],
            "8": [0, 0],
            "9": [0, 0],
            "10": [0, 0],
            "11": [0, 0],
            "12": [0, 0],
            "13": [0, 0],
            "14": [0, 0],
            "15": [0, 0],
            "16": [0, 0],
            "17": [0],
            "18": [0, 0],
            "19": [0, 0],
            "20": [0, 0],
            "21": [0, 0],
            "22": [0, 0],
            "23": [0, 0],
            "24": [0, 0],
            "25": [0, 0],
            "26": [0, 0],
            "27": [0, 0],
            "28": [0, 0],
            "29": [0, 0],
            "30": [0, 0],
            "31": [0, 0],
            "32": [0, 0],
            "33": [0, 0],
            "34": [0, 0],
            "35": [0, 0],
            "36": [0, 0],
            "37": [0, 0],
            "38": [0, 0],
            "39": [0, 0],
            "40": [0, 0],
            "41": [0, 0],
            "42": [0, 0],
            "43": [0, 0],
            "44": [0, 0],
            "45": [0, 0],
            "46": [0, 0],
            "47": [0, 0],
            "48": [0, 0],
            "49": [0, 0],
            "50": [0, 0],
            "51": [0, 0],
            "52": [0, 0],
            "53": [0, 0],
            "54": [0, 0],
            "55": [0, 0],
            "56": [0, 0],
            "57": [0, 0],
            "58": [0, 0],
            "59": [0, 0],
            "60": [0],
            "61": [0],
            "62": [0],
            "63": [0, 0],
            "64": [0],
            "65": [0, 0]
        },
        _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
        hash: "094ff1bc4e2d2e722fad579c301b0fe44c31886a"
    };
    var coverage = global[gcv] || (global[gcv] = {});
    if (!coverage[path] || coverage[path].hash !== hash) {
        coverage[path] = coverageData;
    }
    var actualCoverage = coverage[path];
    { // @ts-ignore
        cov_2clevwsapt = function() {
            return actualCoverage;
        };
    }
    return actualCoverage;
}
cov_2clevwsapt();
cov_2clevwsapt().s[0]++;
(function(factory) {
    cov_2clevwsapt().f[0]++;
    const mod = (cov_2clevwsapt().s[1]++, factory());
    cov_2clevwsapt().s[2]++;
    if (typeof window !== 'undefined') {
        cov_2clevwsapt().b[0][0]++;
        cov_2clevwsapt().s[3]++;
        window["LswEnsurer"] = mod;
    } else {
        cov_2clevwsapt().b[0][1]++;
    }
    cov_2clevwsapt().s[4]++;
    if (typeof global !== 'undefined') {
        cov_2clevwsapt().b[1][0]++;
        cov_2clevwsapt().s[5]++;
        global["LswEnsurer"] = mod;
    } else {
        cov_2clevwsapt().b[1][1]++;
    }
    cov_2clevwsapt().s[6]++;
    if (typeof module !== 'undefined') {
        cov_2clevwsapt().b[2][0]++;
        cov_2clevwsapt().s[7]++;
        module.exports = mod;
    } else {
        cov_2clevwsapt().b[2][1]++;
    }
})(function() {
    cov_2clevwsapt().f[1]++;
    /**
     * 
     * 
     * @$section: Lsw Ensurer API  LswEnsurer class
     * @type: class
     * @extends: Object
     * @vendor: lsw
     * @namespace: LswEnsurer
     * @source code: La clase est definida as:
     * 
     */ // @code.start: LswEnsurer class | @section: Lsw Ensurer API  LswEnsurer class
    class AssertionError extends Error {
        constructor(...args) {
            cov_2clevwsapt().f[2]++;
            cov_2clevwsapt().s[8]++;
            super(...args);
            cov_2clevwsapt().s[9]++;
            this.name = "AssertionError";
        }
    }
    class Ensurement {
        static create(...args) {
            cov_2clevwsapt().f[3]++;
            cov_2clevwsapt().s[10]++;
            return new this(...args);
        }
        constructor(source, asLabeledObject = (cov_2clevwsapt().b[3][0]++, 0)) {
            cov_2clevwsapt().f[4]++;
            cov_2clevwsapt().s[11]++;
            Resolve_subject: {
                cov_2clevwsapt().s[12]++;
                if ((cov_2clevwsapt().b[5][0]++, asLabeledObject === 1) && (cov_2clevwsapt().b[5][1]++, typeof source === "object")) {
                    cov_2clevwsapt().b[4][0]++;
                    const sourceKeys = (cov_2clevwsapt().s[13]++, Object.keys(source));
                    cov_2clevwsapt().s[14]++;
                    if (sourceKeys.length !== 1) {
                        cov_2clevwsapt().b[6][0]++;
                        cov_2clevwsapt().s[15]++;
                        throw new Error(`The first parameter of $ensure or $check {when $2 is literally 1} must have 1 property (not ${sourceKeys.length}) on Ensurement.constructor`);
                    } else {
                        cov_2clevwsapt().b[6][1]++;
                    }
                    cov_2clevwsapt().s[16]++;
                    this.$subjectId = sourceKeys[0];
                    cov_2clevwsapt().s[17]++;
                    this.$subject = source[this.$subjectId];
                } else {
                    cov_2clevwsapt().b[4][1]++;
                    cov_2clevwsapt().s[18]++;
                    if (typeof asLabeledObject === "string") {
                        cov_2clevwsapt().b[7][0]++;
                        cov_2clevwsapt().s[19]++;
                        this.$subjectId = asLabeledObject;
                        cov_2clevwsapt().s[20]++;
                        this.$subject = source;
                    } else {
                        cov_2clevwsapt().b[7][1]++;
                        cov_2clevwsapt().s[21]++;
                        this.$subjectId = "@";
                        cov_2clevwsapt().s[22]++;
                        this.$subject = source;
                    }
                }
            }
            cov_2clevwsapt().s[23]++;
            this.$operation = undefined;
            cov_2clevwsapt().s[24]++;
            this.$objectation = undefined;
            cov_2clevwsapt().s[25]++;
            this.asBoolean = false;
        }
        type(value) {
            cov_2clevwsapt().f[5]++;
            cov_2clevwsapt().s[26]++;
            this.$operation = "is of type";
            cov_2clevwsapt().s[27]++;
            this.$objectation = value;
            cov_2clevwsapt().s[28]++;
            if (typeof value === "string") {
                cov_2clevwsapt().b[8][0]++;
                cov_2clevwsapt().s[29]++;
                if (typeof this.$subject !== value) {
                    cov_2clevwsapt().b[9][0]++;
                    cov_2clevwsapt().s[30]++;
                    return this.$asFailed();
                } else {
                    cov_2clevwsapt().b[9][1]++;
                }
            } else {
                cov_2clevwsapt().b[8][1]++;
                cov_2clevwsapt().s[31]++;
                if (Array.isArray(value)) {
                    cov_2clevwsapt().b[10][0]++;
                    cov_2clevwsapt().s[32]++;
                    if (value.indexOf(typeof this.$subject) === -1) {
                        cov_2clevwsapt().b[11][0]++;
                        cov_2clevwsapt().s[33]++;
                        return this.$asFailed();
                    } else {
                        cov_2clevwsapt().b[11][1]++;
                    }
                } else {
                    cov_2clevwsapt().b[10][1]++;
                    cov_2clevwsapt().s[34]++;
                    throw new Error(`Bad parameter on $ensure(...).type(?) (${typeof value} not admitted)`);
                }
            }
            cov_2clevwsapt().s[35]++;
            return this.$asResolved();
        }
        notType(value) {
            cov_2clevwsapt().f[6]++;
            cov_2clevwsapt().s[36]++;
            this.$operation = "is not of type";
            cov_2clevwsapt().s[37]++;
            this.$objectation = value;
            cov_2clevwsapt().s[38]++;
            if (typeof this.$subject === value) {
                cov_2clevwsapt().b[12][0]++;
                cov_2clevwsapt().s[39]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[12][1]++;
            }
            cov_2clevwsapt().s[40]++;
            return this.$asResolved();
        }
        is(value) {
            cov_2clevwsapt().f[7]++;
            cov_2clevwsapt().s[41]++;
            this.$operation = "is";
            cov_2clevwsapt().s[42]++;
            this.$objectation = value;
            cov_2clevwsapt().s[43]++;
            if (this.$subject !== value) {
                cov_2clevwsapt().b[13][0]++;
                cov_2clevwsapt().s[44]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[13][1]++;
            }
            cov_2clevwsapt().s[45]++;
            return this.$asResolved();
        }
        isnt(value) {
            cov_2clevwsapt().f[8]++;
            cov_2clevwsapt().s[46]++;
            this.$operation = "is not";
            cov_2clevwsapt().s[47]++;
            this.$objectation = value;
            cov_2clevwsapt().s[48]++;
            if (this.$subject === value) {
                cov_2clevwsapt().b[14][0]++;
                cov_2clevwsapt().s[49]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[14][1]++;
            }
            cov_2clevwsapt().s[50]++;
            return this.$asResolved();
        }
        can(value) {
            cov_2clevwsapt().f[9]++;
            cov_2clevwsapt().s[51]++;
            this.$operation = "can";
            cov_2clevwsapt().s[52]++;
            this.$objectation = value;
            cov_2clevwsapt().s[53]++;
            if (!value(this.$subject)) {
                cov_2clevwsapt().b[15][0]++;
                cov_2clevwsapt().s[54]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[15][1]++;
            }
            cov_2clevwsapt().s[55]++;
            return this.$asResolved();
        }
        cant(value) {
            cov_2clevwsapt().f[10]++;
            cov_2clevwsapt().s[56]++;
            this.$operation = "cant";
            cov_2clevwsapt().s[57]++;
            this.$objectation = value;
            cov_2clevwsapt().s[58]++;
            if (value(this.$subject)) {
                cov_2clevwsapt().b[16][0]++;
                cov_2clevwsapt().s[59]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[16][1]++;
            }
            cov_2clevwsapt().s[60]++;
            return this.$asResolved();
        }
        throws(value) {
            cov_2clevwsapt().f[11]++;
            cov_2clevwsapt().s[61]++;
            this.$operation = "throws";
            cov_2clevwsapt().s[62]++;
            this.$objectation = value;
            cov_2clevwsapt().s[63]++;
            try {
                cov_2clevwsapt().s[64]++;
                objectation(this.$subject);
                cov_2clevwsapt().s[65]++;
                return this.$asFailed();
            } catch (error) {
                cov_2clevwsapt().s[66]++;
                return this.$asResolved();
            }
        }
        doesntThrow(value) {
            cov_2clevwsapt().f[12]++;
            cov_2clevwsapt().s[67]++;
            this.$operation = "doesntThrow";
            cov_2clevwsapt().s[68]++;
            this.$objectation = value;
            cov_2clevwsapt().s[69]++;
            try {
                cov_2clevwsapt().s[70]++;
                value(this.$subject);
                cov_2clevwsapt().s[71]++;
                return this.$asFailed();
            } catch (error) {
                cov_2clevwsapt().s[72]++;
                return this.$asResolved();
            }
        }
        $asFailed(operation = (cov_2clevwsapt().b[17][0]++, this.$operation)) {
            cov_2clevwsapt().f[13]++;
            cov_2clevwsapt().s[73]++;
            if (this.asBoolean) {
                cov_2clevwsapt().b[18][0]++;
                cov_2clevwsapt().s[74]++;
                return false;
            } else {
                cov_2clevwsapt().b[18][1]++;
            }
            cov_2clevwsapt().s[75]++;
            throw new AssertionError("could not ensure " + this.$subjectId + " " + operation + (this.$objectation ? (cov_2clevwsapt().b[19][0]++, " " + this.$getObjectationAsString() + "") : (cov_2clevwsapt().b[19][1]++, "")) + "");
        }
        $getObjectationAsString() {
            cov_2clevwsapt().f[14]++;
            cov_2clevwsapt().s[76]++;
            return JSON.stringify(this.$objectation);
        }
        $asResolved() {
            cov_2clevwsapt().f[15]++;
            cov_2clevwsapt().s[77]++;
            if (this.asBoolean) {
                cov_2clevwsapt().b[20][0]++;
                cov_2clevwsapt().s[78]++;
                return true;
            } else {
                cov_2clevwsapt().b[20][1]++;
                cov_2clevwsapt().s[79]++;
                return this;
            }
        }
    };
    cov_2clevwsapt().s[80]++;
    const BasicToBeInterface = class {
        $isNegated = (cov_2clevwsapt().s[81]++, false);
        set $operation(value) {
            cov_2clevwsapt().f[16]++;
            cov_2clevwsapt().s[82]++;
            this.$ensurement.$operation = value;
        }
        get $operation() {
            cov_2clevwsapt().f[17]++;
            cov_2clevwsapt().s[83]++;
            return this.$ensurement.$operation;
        }
        set $objectation(value) {
            cov_2clevwsapt().f[18]++;
            cov_2clevwsapt().s[84]++;
            this.$ensurement.$objectation = value;
        }
        get $objectation() {
            cov_2clevwsapt().f[19]++;
            cov_2clevwsapt().s[85]++;
            return this.$ensurement.$objectation;
        }
        constructor(ensurement) {
            cov_2clevwsapt().f[20]++;
            cov_2clevwsapt().s[86]++;
            this.$ensurement = ensurement;
            cov_2clevwsapt().s[87]++;
            this.$subject = this.$ensurement.$subject;
        }
        $makeNegable(condition) {
            cov_2clevwsapt().f[21]++;
            cov_2clevwsapt().s[88]++;
            return this.$isNegated === true ? (cov_2clevwsapt().b[21][0]++, !condition) : (cov_2clevwsapt().b[21][1]++, condition);
        }
        $asFailed() {
            cov_2clevwsapt().f[22]++;
            cov_2clevwsapt().s[89]++;
            return this.$ensurement.$asFailed();
        }
        $resolveNegableString(text) {
            cov_2clevwsapt().f[23]++;
            cov_2clevwsapt().s[90]++;
            return text.replace(/\{not\?\} */g, this.$isNegated ? (cov_2clevwsapt().b[22][0]++, "not ") : (cov_2clevwsapt().b[22][1]++, ""));
        }
    };
    cov_2clevwsapt().s[91]++;
    const ToBeInterface = class extends BasicToBeInterface {
        string() {
            cov_2clevwsapt().f[24]++;
            cov_2clevwsapt().s[92]++;
            this.$operation = this.$resolveNegableString("to {not?} be string");
            cov_2clevwsapt().s[93]++;
            this.$objectation = undefined;
            cov_2clevwsapt().s[94]++;
            if (this.$makeNegable(typeof this.$subject !== "string")) {
                cov_2clevwsapt().b[23][0]++;
                cov_2clevwsapt().s[95]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[23][1]++;
            }
            cov_2clevwsapt().s[96]++;
            return this.$ensurement.$asResolved();
        }
        number() {
            cov_2clevwsapt().f[25]++;
            cov_2clevwsapt().s[97]++;
            this.$operation = this.$resolveNegableString("to {not?} be number");
            cov_2clevwsapt().s[98]++;
            this.$objectation = undefined;
            cov_2clevwsapt().s[99]++;
            if ((cov_2clevwsapt().b[25][0]++, this.$makeNegable(typeof this.$subject !== "number")) || (cov_2clevwsapt().b[25][1]++, Number.isNaN(this.$subject))) {
                cov_2clevwsapt().b[24][0]++;
                cov_2clevwsapt().s[100]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[24][1]++;
            }
            cov_2clevwsapt().s[101]++;
            return this.$ensurement.$asResolved();
        }
        object() {
            cov_2clevwsapt().f[26]++;
            cov_2clevwsapt().s[102]++;
            this.$operation = this.$resolveNegableString("to {not?} be object");
            cov_2clevwsapt().s[103]++;
            this.$objectation = undefined;
            cov_2clevwsapt().s[104]++;
            if (this.$makeNegable(typeof this.$subject !== "object")) {
                cov_2clevwsapt().b[26][0]++;
                cov_2clevwsapt().s[105]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[26][1]++;
            }
            cov_2clevwsapt().s[106]++;
            return this.$ensurement.$asResolved();
        }
        null() {
            cov_2clevwsapt().f[27]++;
            cov_2clevwsapt().s[107]++;
            this.$operation = this.$resolveNegableString("to {not?} be null");
            cov_2clevwsapt().s[108]++;
            this.$objectation = undefined;
            cov_2clevwsapt().s[109]++;
            if (this.$makeNegable(typeof this.$subject !== null)) {
                cov_2clevwsapt().b[27][0]++;
                cov_2clevwsapt().s[110]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[27][1]++;
            }
            cov_2clevwsapt().s[111]++;
            return this.$ensurement.$asResolved();
        }
        undefined() {
            cov_2clevwsapt().f[28]++;
            cov_2clevwsapt().s[112]++;
            this.$operation = this.$resolveNegableString("to {not?} be undefined");
            cov_2clevwsapt().s[113]++;
            this.$objectation = undefined;
            cov_2clevwsapt().s[114]++;
            if (this.$makeNegable(typeof this.$subject !== "undefined")) {
                cov_2clevwsapt().b[28][0]++;
                cov_2clevwsapt().s[115]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[28][1]++;
            }
            cov_2clevwsapt().s[116]++;
            return this.$ensurement.$asResolved();
        }
        boolean() {
            cov_2clevwsapt().f[29]++;
            cov_2clevwsapt().s[117]++;
            this.$operation = this.$resolveNegableString("to {not?} be boolean");
            cov_2clevwsapt().s[118]++;
            this.$objectation = undefined;
            cov_2clevwsapt().s[119]++;
            if (this.$makeNegable(typeof this.$subject !== "boolean")) {
                cov_2clevwsapt().b[29][0]++;
                cov_2clevwsapt().s[120]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[29][1]++;
            }
            cov_2clevwsapt().s[121]++;
            return this.$ensurement.$asResolved();
        }
        instanceOf(clazz) {
            cov_2clevwsapt().f[30]++;
            cov_2clevwsapt().s[122]++;
            this.$operation = this.$resolveNegableString("to {not?} be instanceOf");
            cov_2clevwsapt().s[123]++;
            this.$objectation = undefined;
            cov_2clevwsapt().s[124]++;
            if (this.$makeNegable(!(this.$subject instanceof clazz))) {
                cov_2clevwsapt().b[30][0]++;
                cov_2clevwsapt().s[125]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[30][1]++;
            }
            cov_2clevwsapt().s[126]++;
            return this.$ensurement.$asResolved();
        }
        array() {
            cov_2clevwsapt().f[31]++;
            cov_2clevwsapt().s[127]++;
            this.$operation = this.$resolveNegableString("to {not?} be array");
            cov_2clevwsapt().s[128]++;
            this.$objectation = undefined;
            cov_2clevwsapt().s[129]++;
            if (this.$makeNegable(!Array.isArray(this.$subject))) {
                cov_2clevwsapt().b[31][0]++;
                cov_2clevwsapt().s[130]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[31][1]++;
            }
            cov_2clevwsapt().s[131]++;
            return this.$ensurement.$asResolved();
        }

        function() {
            cov_2clevwsapt().f[32]++;
            cov_2clevwsapt().s[132]++;
            this.$operation = this.$resolveNegableString("to {not?} be function");
            cov_2clevwsapt().s[133]++;
            this.$objectation = undefined;
            cov_2clevwsapt().s[134]++;
            if (this.$makeNegable(typeof this.$subject !== "function")) {
                cov_2clevwsapt().b[32][0]++;
                cov_2clevwsapt().s[135]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[32][1]++;
            }
            cov_2clevwsapt().s[136]++;
            return this.$ensurement.$asResolved();
        }
        empty() {
            cov_2clevwsapt().f[33]++;
            cov_2clevwsapt().s[137]++;
            this.$operation = this.$resolveNegableString("to {not?} be empty");
            cov_2clevwsapt().s[138]++;
            this.$objectation = undefined;
            const isEmpty = (cov_2clevwsapt().s[139]++, (() => {
                cov_2clevwsapt().f[34]++;
                const s = (cov_2clevwsapt().s[140]++, this.$subject);
                cov_2clevwsapt().s[141]++;
                if (Array.isArray(s)) {
                    cov_2clevwsapt().b[33][0]++;
                    cov_2clevwsapt().s[142]++;
                    return s.length === 0;
                } else {
                    cov_2clevwsapt().b[33][1]++;
                    cov_2clevwsapt().s[143]++;
                    if (typeof s === "object") {
                        cov_2clevwsapt().b[34][0]++;
                        cov_2clevwsapt().s[144]++;
                        return (cov_2clevwsapt().b[35][0]++, s === null) || (cov_2clevwsapt().b[35][1]++, Object.keys(s).length === 0);
                    } else {
                        cov_2clevwsapt().b[34][1]++;
                        cov_2clevwsapt().s[145]++;
                        if (typeof s === "string") {
                            cov_2clevwsapt().b[36][0]++;
                            cov_2clevwsapt().s[146]++;
                            return s === "";
                        } else {
                            cov_2clevwsapt().b[36][1]++;
                            cov_2clevwsapt().s[147]++;
                            if (typeof s === "number") {
                                cov_2clevwsapt().b[37][0]++;
                                cov_2clevwsapt().s[148]++;
                                return s === 0;
                            } else {
                                cov_2clevwsapt().b[37][1]++;
                                cov_2clevwsapt().s[149]++;
                                if (typeof s === "boolean") {
                                    cov_2clevwsapt().b[38][0]++;
                                    cov_2clevwsapt().s[150]++;
                                    return s === false;
                                } else {
                                    cov_2clevwsapt().b[38][1]++;
                                    cov_2clevwsapt().s[151]++;
                                    return true;
                                }
                            }
                        }
                    }
                }
            })());
            cov_2clevwsapt().s[152]++;
            if (this.$makeNegable(!isEmpty)) {
                cov_2clevwsapt().b[39][0]++;
                cov_2clevwsapt().s[153]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[39][1]++;
            }
            cov_2clevwsapt().s[154]++;
            return this.$ensurement.$asResolved();
        }
        equalTo(value) {
            cov_2clevwsapt().f[35]++;
            cov_2clevwsapt().s[155]++;
            this.$operation = this.$resolveNegableString("to {not?} be equal to");
            cov_2clevwsapt().s[156]++;
            this.$objectation = value;
            let isEqual = (cov_2clevwsapt().s[157]++, this.$subject === value);
            cov_2clevwsapt().s[158]++;
            if (this.$makeNegable(!isEqual)) {
                cov_2clevwsapt().b[40][0]++;
                cov_2clevwsapt().s[159]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[40][1]++;
            }
            cov_2clevwsapt().s[160]++;
            return this.$ensurement.$asResolved();
        }
        equalOrGreaterThan(value) {
            cov_2clevwsapt().f[36]++;
            cov_2clevwsapt().s[161]++;
            this.$operation = this.$resolveNegableString("to {not?} be equal or greater than");
            cov_2clevwsapt().s[162]++;
            this.$objectation = value;
            let isGreaterOrEqual = (cov_2clevwsapt().s[163]++, this.$subject >= value);
            cov_2clevwsapt().s[164]++;
            if (this.$makeNegable(!isGreaterOrEqual)) {
                cov_2clevwsapt().b[41][0]++;
                cov_2clevwsapt().s[165]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[41][1]++;
            }
            cov_2clevwsapt().s[166]++;
            return this.$ensurement.$asResolved();
        }
        greaterThan(value) {
            cov_2clevwsapt().f[37]++;
            cov_2clevwsapt().s[167]++;
            this.$operation = this.$resolveNegableString("to {not?} be greater than");
            cov_2clevwsapt().s[168]++;
            this.$objectation = value;
            let isGreater = (cov_2clevwsapt().s[169]++, this.$subject > value);
            cov_2clevwsapt().s[170]++;
            if (this.$makeNegable(!isGreater)) {
                cov_2clevwsapt().b[42][0]++;
                cov_2clevwsapt().s[171]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[42][1]++;
            }
            cov_2clevwsapt().s[172]++;
            return this.$ensurement.$asResolved();
        }
        greaterOrEqualTo(...args) {
            cov_2clevwsapt().f[38]++;
            cov_2clevwsapt().s[173]++;
            return this.equalOrGreaterThan(...args);
        }
        equalOrLowerThan(value) {
            cov_2clevwsapt().f[39]++;
            cov_2clevwsapt().s[174]++;
            this.$operation = this.$resolveNegableString("to {not?} equal or lower than");
            cov_2clevwsapt().s[175]++;
            this.$objectation = value;
            let isGreaterOrEqual = (cov_2clevwsapt().s[176]++, this.$subject <= value);
            cov_2clevwsapt().s[177]++;
            if (this.$makeNegable(!isGreaterOrEqual)) {
                cov_2clevwsapt().b[43][0]++;
                cov_2clevwsapt().s[178]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[43][1]++;
            }
            cov_2clevwsapt().s[179]++;
            return this.$ensurement.$asResolved();
        }
        lowerThan(value) {
            cov_2clevwsapt().f[40]++;
            cov_2clevwsapt().s[180]++;
            this.$operation = this.$resolveNegableString("to {not?} be lower than");
            cov_2clevwsapt().s[181]++;
            this.$objectation = value;
            let isGreater = (cov_2clevwsapt().s[182]++, this.$subject < value);
            cov_2clevwsapt().s[183]++;
            if (this.$makeNegable(!isGreater)) {
                cov_2clevwsapt().b[44][0]++;
                cov_2clevwsapt().s[184]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[44][1]++;
            }
            cov_2clevwsapt().s[185]++;
            return this.$ensurement.$asResolved();
        }
        lowerOrEqualTo(value) {
            cov_2clevwsapt().f[41]++;
            cov_2clevwsapt().s[186]++;
            return this.equalOrLowerThan(...args);
        }
        oneOf(value) {
            cov_2clevwsapt().f[42]++;
            cov_2clevwsapt().s[187]++;
            this.$operation = this.$resolveNegableString("to {not?} be one of");
            cov_2clevwsapt().s[188]++;
            this.$objectation = value;
            cov_2clevwsapt().s[189]++;
            if (!Array.isArray(value)) {
                cov_2clevwsapt().b[45][0]++;
                cov_2clevwsapt().s[190]++;
                throw new Error(`Required on $ensure(...).to.be.oneOf(!) to provide an array on ToBeInterface.oneOf`);
            } else {
                cov_2clevwsapt().b[45][1]++;
            }
            let isOne = (cov_2clevwsapt().s[191]++, this.$objectation.indexOf(this.$subject) !== -1);
            cov_2clevwsapt().s[192]++;
            if (this.$makeNegable(!isOne)) {
                cov_2clevwsapt().b[46][0]++;
                cov_2clevwsapt().s[193]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[46][1]++;
            }
            cov_2clevwsapt().s[194]++;
            return this.$ensurement.$asResolved();
        }
    };
    cov_2clevwsapt().s[195]++;
    const ToNotBeInterface = class extends ToBeInterface {
        $isNegated = (cov_2clevwsapt().s[196]++, true);
    };
    cov_2clevwsapt().s[197]++;
    const ToHaveInterface = class extends BasicToBeInterface {
        text(prop) {
            cov_2clevwsapt().f[43]++;
            cov_2clevwsapt().s[198]++;
            this.$operation = this.$resolveNegableString("to {not?} have text");
            cov_2clevwsapt().s[199]++;
            this.$objectation = prop;
            const hasSubstring = (cov_2clevwsapt().s[200]++, this.$subject.indexOf(prop) !== -1);
            cov_2clevwsapt().s[201]++;
            if (this.$makeNegable(!hasSubstring)) {
                cov_2clevwsapt().b[47][0]++;
                cov_2clevwsapt().s[202]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[47][1]++;
            }
            cov_2clevwsapt().s[203]++;
            return this.$ensurement.$asResolved();
        }
        key(prop) {
            cov_2clevwsapt().f[44]++;
            cov_2clevwsapt().s[204]++;
            this.$operation = this.$resolveNegableString("to {not?} have key");
            cov_2clevwsapt().s[205]++;
            this.$objectation = prop;
            const keys = (cov_2clevwsapt().s[206]++, Object.keys(this.$subject));
            const hasKey = (cov_2clevwsapt().s[207]++, keys.indexOf(prop) !== -1);
            cov_2clevwsapt().s[208]++;
            if (this.$makeNegable(!hasKey)) {
                cov_2clevwsapt().b[48][0]++;
                cov_2clevwsapt().s[209]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[48][1]++;
            }
            cov_2clevwsapt().s[210]++;
            return this.$ensurement.$asResolved();
        }
        value(prop) {
            cov_2clevwsapt().f[45]++;
            cov_2clevwsapt().s[211]++;
            this.$operation = this.$resolveNegableString("to {not?} have value");
            cov_2clevwsapt().s[212]++;
            this.$objectation = prop;
            const values = (cov_2clevwsapt().s[213]++, Object.values(this.$subject));
            const hasValue = (cov_2clevwsapt().s[214]++, values.indexOf(prop) !== -1);
            cov_2clevwsapt().s[215]++;
            if (this.$makeNegable(!hasValue)) {
                cov_2clevwsapt().b[49][0]++;
                cov_2clevwsapt().s[216]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[49][1]++;
            }
            cov_2clevwsapt().s[217]++;
            return this.$ensurement.$asResolved();
        }
        onlyPotentialKeys(props) {
            cov_2clevwsapt().f[46]++;
            cov_2clevwsapt().s[218]++;
            this.$operation = this.$resolveNegableString("to {not?} have only potential keys");
            cov_2clevwsapt().s[219]++;
            this.$objectation = props;
            const keys = (cov_2clevwsapt().s[220]++, Object.keys(this.$subject));
            let hasOnly = (cov_2clevwsapt().s[221]++, true);
            cov_2clevwsapt().s[222]++;
            cov_2clevwsapt().s[223]++;
            Iterating_props: for (let index = (cov_2clevwsapt().s[224]++, 0); index < keys.length; index++) {
                const key = (cov_2clevwsapt().s[225]++, keys[index]);
                cov_2clevwsapt().s[226]++;
                if (props.indexOf(key) === -1) {
                    cov_2clevwsapt().b[50][0]++;
                    cov_2clevwsapt().s[227]++;
                    hasOnly = false;
                    cov_2clevwsapt().s[228]++;
                    break Iterating_props;
                } else {
                    cov_2clevwsapt().b[50][1]++;
                }
            }
            cov_2clevwsapt().s[229]++;
            if (this.$makeNegable(!hasOnly)) {
                cov_2clevwsapt().b[51][0]++;
                cov_2clevwsapt().s[230]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[51][1]++;
            }
            cov_2clevwsapt().s[231]++;
            return this.$ensurement.$asResolved();
        }
        keys(props) {
            cov_2clevwsapt().f[47]++;
            cov_2clevwsapt().s[232]++;
            this.$operation = this.$resolveNegableString("to {not?} have keys");
            cov_2clevwsapt().s[233]++;
            this.$objectation = props;
            const keys = (cov_2clevwsapt().s[234]++, Object.keys(this.$subject));
            let hasKeys = (cov_2clevwsapt().s[235]++, true);
            cov_2clevwsapt().s[236]++;
            cov_2clevwsapt().s[237]++;
            Iterating_props: for (let index = (cov_2clevwsapt().s[238]++, 0); index < props.length; index++) {
                const prop = (cov_2clevwsapt().s[239]++, props[index]);
                cov_2clevwsapt().s[240]++;
                if (keys.indexOf(prop) === -1) {
                    cov_2clevwsapt().b[52][0]++;
                    cov_2clevwsapt().s[241]++;
                    hasKeys = false;
                    cov_2clevwsapt().s[242]++;
                    break Iterating_props;
                } else {
                    cov_2clevwsapt().b[52][1]++;
                }
            }
            cov_2clevwsapt().s[243]++;
            if (this.$makeNegable(!hasKeys)) {
                cov_2clevwsapt().b[53][0]++;
                cov_2clevwsapt().s[244]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[53][1]++;
            }
            cov_2clevwsapt().s[245]++;
            return this.$ensurement.$asResolved();
        }
        values(props) {
            cov_2clevwsapt().f[48]++;
            cov_2clevwsapt().s[246]++;
            this.$operation = this.$resolveNegableString("to {not?} have values");
            cov_2clevwsapt().s[247]++;
            this.$objectation = props;
            const values = (cov_2clevwsapt().s[248]++, Object.values(this.$subject));
            let hasValues = (cov_2clevwsapt().s[249]++, true);
            cov_2clevwsapt().s[250]++;
            cov_2clevwsapt().s[251]++;
            Iterating_props: for (let index = (cov_2clevwsapt().s[252]++, 0); index < props.length; index++) {
                const prop = (cov_2clevwsapt().s[253]++, props[index]);
                cov_2clevwsapt().s[254]++;
                if (values.indexOf(prop) === -1) {
                    cov_2clevwsapt().b[54][0]++;
                    cov_2clevwsapt().s[255]++;
                    hasValues = false;
                    cov_2clevwsapt().s[256]++;
                    break Iterating_props;
                } else {
                    cov_2clevwsapt().b[54][1]++;
                }
            }
            cov_2clevwsapt().s[257]++;
            if (this.$makeNegable(!hasValues)) {
                cov_2clevwsapt().b[55][0]++;
                cov_2clevwsapt().s[258]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[55][1]++;
            }
            cov_2clevwsapt().s[259]++;
            return this.$ensurement.$asResolved();
        }
        uniquelyKeys(props) {
            cov_2clevwsapt().f[49]++;
            cov_2clevwsapt().s[260]++;
            this.$operation = this.$resolveNegableString("to {not?} have uniquelyKeys");
            cov_2clevwsapt().s[261]++;
            this.$objectation = props;
            const keys = (cov_2clevwsapt().s[262]++, Object.keys(this.$subject));
            let hasKeys = (cov_2clevwsapt().s[263]++, true);
            cov_2clevwsapt().s[264]++;
            cov_2clevwsapt().s[265]++;
            Iterating_props: for (let index = (cov_2clevwsapt().s[266]++, 0); index < keys.length; index++) {
                const key = (cov_2clevwsapt().s[267]++, keys[index]);
                cov_2clevwsapt().s[268]++;
                if (props.indexOf(key) === -1) {
                    cov_2clevwsapt().b[56][0]++;
                    cov_2clevwsapt().s[269]++;
                    hasKeys = false;
                    cov_2clevwsapt().s[270]++;
                    break Iterating_props;
                } else {
                    cov_2clevwsapt().b[56][1]++;
                }
            }
            cov_2clevwsapt().s[271]++;
            if (this.$makeNegable(!hasKeys)) {
                cov_2clevwsapt().b[57][0]++;
                cov_2clevwsapt().s[272]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[57][1]++;
            }
            cov_2clevwsapt().s[273]++;
            return this.$ensurement.$asResolved();
        }
        uniquelyValues(props) {
            cov_2clevwsapt().f[50]++;
            cov_2clevwsapt().s[274]++;
            this.$operation = this.$resolveNegableString("to {not?} have uniquelyValues");
            cov_2clevwsapt().s[275]++;
            this.$objectation = props;
            const values = (cov_2clevwsapt().s[276]++, Object.values(this.$subject));
            let hasValues = (cov_2clevwsapt().s[277]++, true);
            cov_2clevwsapt().s[278]++;
            cov_2clevwsapt().s[279]++;
            Iterating_props: for (let index = (cov_2clevwsapt().s[280]++, 0); index < values.length; index++) {
                const value = (cov_2clevwsapt().s[281]++, values[index]);
                cov_2clevwsapt().s[282]++;
                if (props.indexOf(value) === -1) {
                    cov_2clevwsapt().b[58][0]++;
                    cov_2clevwsapt().s[283]++;
                    hasValues = false;
                    cov_2clevwsapt().s[284]++;
                    break Iterating_props;
                } else {
                    cov_2clevwsapt().b[58][1]++;
                }
            }
            cov_2clevwsapt().s[285]++;
            if (this.$makeNegable(!hasValues)) {
                cov_2clevwsapt().b[59][0]++;
                cov_2clevwsapt().s[286]++;
                return this.$asFailed();
            } else {
                cov_2clevwsapt().b[59][1]++;
            }
            cov_2clevwsapt().s[287]++;
            return this.$ensurement.$asResolved();
        }
    };
    cov_2clevwsapt().s[288]++;
    const ToNotHaveInterface = class extends ToHaveInterface {
        $isNegated = (cov_2clevwsapt().s[289]++, true);
    };
    cov_2clevwsapt().s[290]++;
    const EnsurementV1 = class extends Ensurement {
        selfExtend(obj) {
            cov_2clevwsapt().f[51]++;
            cov_2clevwsapt().s[291]++;
            return Object.assign(this, obj);
        }
        get $toNotBe() {
            cov_2clevwsapt().f[52]++;
            cov_2clevwsapt().s[292]++;
            return new ToNotBeInterface(this);
        }
        get $toNotHave() {
            cov_2clevwsapt().f[53]++;
            cov_2clevwsapt().s[293]++;
            return new ToNotHaveInterface(this);
        }
        get $toNot() {
            cov_2clevwsapt().f[54]++;
            cov_2clevwsapt().s[294]++;
            return {
                be: this.$toNotBe,
                have: this.$toNotHave
            };
        }
        get $toBe() {
            cov_2clevwsapt().f[55]++;
            cov_2clevwsapt().s[295]++;
            return new ToBeInterface(this);
        }
        get $toHave() {
            cov_2clevwsapt().f[56]++;
            cov_2clevwsapt().s[296]++;
            return new ToHaveInterface(this);
        }
        get to() {
            cov_2clevwsapt().f[57]++;
            cov_2clevwsapt().s[297]++;
            return {
                be: this.$toBe,
                have: this.$toHave,
                not: this.$toNot
            };
        }
        its(id) {
            cov_2clevwsapt().f[58]++;
            cov_2clevwsapt().s[298]++;
            return this.constructor.create({
                [id]: this.$subject[id]
            }, 1).selfExtend({
                $parent: this,
                asBoolean: this.asBoolean
            });
        }
        getSubject() {
            cov_2clevwsapt().f[59]++;
            cov_2clevwsapt().s[299]++;
            return this.$subject;
        }
        safelyBack(levels = (cov_2clevwsapt().b[60][0]++, 1)) {
            cov_2clevwsapt().f[60]++;
            cov_2clevwsapt().s[300]++;
            for (let index = (cov_2clevwsapt().s[301]++, 0); index < levels; index++) {
                cov_2clevwsapt().s[302]++;
                try {
                    cov_2clevwsapt().s[303]++;
                    parent = this.$parent;
                } catch (error) { // @OK.
                }
            }
        }
        back(levels = (cov_2clevwsapt().b[61][0]++, 1)) {
            cov_2clevwsapt().f[61]++;
            let parent = (cov_2clevwsapt().s[304]++, this);
            cov_2clevwsapt().s[305]++;
            for (let index = (cov_2clevwsapt().s[306]++, 0); index < levels; index++) {
                cov_2clevwsapt().s[307]++;
                try {
                    cov_2clevwsapt().s[308]++;
                    parent = this.$parent;
                } catch (error) {
                    cov_2clevwsapt().s[309]++;
                    throw new Error(`Ensurement could not go back reaching parent on level ${index} on ensure(...).back`);
                }
            }
            cov_2clevwsapt().s[310]++;
            return parent;
        }
        static $or(options) {
            cov_2clevwsapt().f[62]++;
            let correctOption = (cov_2clevwsapt().s[311]++, undefined);
            const allIds = (cov_2clevwsapt().s[312]++, Object.keys(options));
            const orError = (cov_2clevwsapt().s[313]++, new Error(`could not ensure or group with options: ${allIds.join(", ")}`));
            cov_2clevwsapt().s[314]++;
            for (let index = (cov_2clevwsapt().s[315]++, 0); index < allIds.length; index++) {
                const currentId = (cov_2clevwsapt().s[316]++, allIds[index]);
                const currentOptionCallback = (cov_2clevwsapt().s[317]++, options[currentId]);
                cov_2clevwsapt().s[318]++;
                try {
                    cov_2clevwsapt().s[319]++;
                    currentOptionCallback();
                    cov_2clevwsapt().s[320]++;
                    return currentId;
                } catch (error) {
                    cov_2clevwsapt().s[321]++;
                    orError.appendError(error);
                }
            }
            cov_2clevwsapt().s[322]++;
            throw orError.unified();
        }
        static id(obj) {
            cov_2clevwsapt().f[63]++;
            cov_2clevwsapt().s[323]++;
            return this.create(obj, 1);
        }
        static ensure(...args) {
            cov_2clevwsapt().f[64]++;
            cov_2clevwsapt().s[324]++;
            return this.create(...args);
        }
        static check(...args) {
            cov_2clevwsapt().f[65]++;
            cov_2clevwsapt().s[325]++;
            return this.create(...args).selfExtend({
                asBoolean: true
            });
        }
        static assert(condition, errorMessage = (cov_2clevwsapt().b[62][0]++, "Assertion error happened")) {
            cov_2clevwsapt().f[66]++;
            cov_2clevwsapt().s[326]++;
            if (!condition) {
                cov_2clevwsapt().b[63][0]++;
                cov_2clevwsapt().s[327]++;
                throw new AssertionError(errorMessage);
            } else {
                cov_2clevwsapt().b[63][1]++;
            }
            cov_2clevwsapt().s[328]++;
            return true;
        }
        static fails(callback, errorMessage = (cov_2clevwsapt().b[64][0]++, "Assertion error happened")) {
            cov_2clevwsapt().f[67]++;
            let passes = (cov_2clevwsapt().s[329]++, true);
            cov_2clevwsapt().s[330]++;
            try {
                cov_2clevwsapt().s[331]++;
                callback();
                cov_2clevwsapt().s[332]++;
                passes = false;
            } catch (error) {
                cov_2clevwsapt().s[333]++;
                return true;
            }
            cov_2clevwsapt().s[334]++;
            if (!passes) {
                cov_2clevwsapt().b[65][0]++;
                cov_2clevwsapt().s[335]++;
                throw new AssertionError(errorMessage);
            } else {
                cov_2clevwsapt().b[65][1]++;
            }
        }
        static AssertionError = (cov_2clevwsapt().s[336]++, AssertionError);
    };
    cov_2clevwsapt().s[337]++;
    Export_to_globals: {
        cov_2clevwsapt().s[338]++;globalThis.$fails = EnsurementV1.fails.bind(EnsurementV1);cov_2clevwsapt().s[339]++;globalThis.$ensure = EnsurementV1.ensure.bind(EnsurementV1);cov_2clevwsapt().s[340]++;globalThis.$ensure.id = EnsurementV1.id.bind(EnsurementV1);cov_2clevwsapt().s[341]++;globalThis.$ensure.check = EnsurementV1.check.bind(EnsurementV1);cov_2clevwsapt().s[342]++;globalThis.$ensure.assert = EnsurementV1.assert.bind(EnsurementV1);cov_2clevwsapt().s[343]++;globalThis.$ensure.fails = EnsurementV1.fails.bind(EnsurementV1);cov_2clevwsapt().s[344]++;globalThis.$check = EnsurementV1.check.bind(EnsurementV1);cov_2clevwsapt().s[345]++;globalThis.$assert = EnsurementV1.assert.bind(EnsurementV1); // globalThis.AssertionError = AssertionError;
        cov_2clevwsapt().s[346]++;globalThis.$ensure.$or = EnsurementV1.$or;
    }
    cov_2clevwsapt().s[347]++;
    return EnsurementV1; // @code.end: LswEnsurer class
});

// @vuebundler[Lsw_framework_components][12]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-constants/lsw-constants.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswConstants'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswConstants'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswConstants class | @section: Lsw Constants API  LswConstants class

  const LswConstants = class {

    static THROW_ERROR = {};
    static global = new this();

    constructor() {
      this.$values = {};
    }

    define(key, value) {
      if(key in this.$values) {
        throw new Error(`Cannot override constant ${key} on LswConstants.define`);
      }
      this.$values[key] = value;
    }

    pick(key, defaultValue = LswConstants.THROW_ERROR) {
      if(!(key in this.$values)) {
        if(defaultValue === LswConstants.THROW_ERROR) {
          console.log("[!] Known keys only:", Object.keys(this.$values));
          throw new Error(`Could not find constant ${key} on LswConstants.pick`);
        }
      }
      return this.$values[key] || defaultValue;
    }

  };
  
  return LswConstants;

  // @code.end: LswConstants class

});

// @vuebundler[Lsw_framework_components][13]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-constants/global-constants.js
LswConstants.global.define("rutiner.md", `

Aprovecha para poner algo guapo aqu.

Y se te ir recordando.

`.trim());

LswConstants.global.define("/kernel/settings/rutiner.config.env", `

timeout=0h 3min
  
`.trim());


LswConstants.global.define("randomizables.env", `

nmeros = 1
conceptos = 1
ideas = 1
interfaces grficas = 1
patrones = 1
arquitectura de la realidad = 1
arquitectura del yo = 1
lenguajes formales = 1
cocina = 1
nutricin = 1
qumica = 1
nutricin = 1
qumica = 1
fsica = 1
matemticas = 1
geometra = 1
canvas = 1
perspectiva = 1
medicina = 1
biologa = 1
fisiologa = 1
musculacin = 1
flexibilidad = 1
emociones = 1
actividad fsica = 1
optimizacin de ram = 1
autocontrol = 1
autobservacin = 1
autoanlisis = 1
meditacin = 1
relajacin = 1
paisajismo = 1
dibujo 3d = 1
perspectiva = 1
geometra = 1
mates = 1
dibujo artstico = 1
anime = 1
abstracto = 1
esquemista = 1
conceptualista = 1
reflexin = 1
dilogo interno = 1

`.trim());

LswConstants.global.define("backgrounds.env", `

assets/images/montania1.png
assets/images/playa1.png
assets/images/playa2.png

`.trim());

LswConstants.global.define("automessages.env", `

S tu propia luz.
Lo conseguiremos.
Todo se andar.
Sigamos adelante.
En algn momento encontraremos la luz.

`.trim());


LswConstants.global.define("categorias.tri", `

rbol de categoras [] {
  Biologa [] {
    Vegetal [] {}
    Animal [] {}
    Social [] {}
  }
  Medicina [] {
    Fisiologa [] {}
    Nutricin [] {}
  }
  Qumica [] {}
  Fsica [] {}
  Matemticas [] {
    Programacin [] {}
    Lgica abstracta [] {}
  }
  Arte [] {}
}

`.trim());


LswConstants.global.define("report/inicio.js", `

const conceptos = await lsw.database.selectMany("Concepto");
const acciones = await lsw.database.selectMany("Accion");
const acciones_virtuales = await lsw.database.selectMany("Accion_virtual");
const propagadores = await lsw.database.selectMany("Propagador_de_concepto");
const prototipos = await lsw.database.selectMany("Propagador_prototipo");
const acumulaciones_objeto = acciones_virtuales.reduce((out, it) => {
  if(!(it.en_concepto in out)) {
    out[it.en_concepto] = 0;
  }
  out[it.en_concepto] += (LswTimer.utils.fromDurationstringToMilliseconds(it.tiene_duracion) || 0);
  return out;
}, {});
const acumulaciones = Object.keys(acumulaciones_objeto).sort((k1, k2) => {
  const c1 = acumulaciones_objeto[k1];
  const c2 = acumulaciones_objeto[k2];
  return c2 > c1 ? 1 : -1;
}).map(id => {
  const ms = acumulaciones_objeto[id];
  return {
    nombre: id,
    total: LswTimer.utils.fromMillisecondsToDurationstring(ms)
  };
});

return {
  "Acumulaciones virtuales": acumulaciones,
  "Conceptos": conceptos,
  "Acciones": acciones,
  "Acciones virtuales": acciones_virtuales,
  "Propagadores": propagadores,
  "Propagadores prototipo": prototipos,
};

`.trim());

LswConstants.global.define("boot.proto", `

inc /kernel/agenda/proto/concepto
inc /kernel/agenda/proto/funcion
inc /kernel/agenda/proto/relacion

def desayunar, comer, cenar

fun unEjemplo: param1, param2 {
  console.log("Solo un ejemplo.");
}

rel desayunar
  > consumir * 1
  > abstenerse * 0
  >> unEjemplo: 500, 1000

`.trim());

LswConstants.global.define("boot.js", `

// Cuidadito con este script que te cargas la app
// y luego tienes que borrar la cach para volver a tenerla.
        
`.trim());

LswConstants.global.define("multiplicador.js", `

fun multiplicador: contexto {
  const {
    accion,
    propagador_de_concepto
  } = contexto;
  return {
    tiene_duracion: LswTimer.utils.multiplyDuration(
      accion.tiene_duracion,
      propagador_de_concepto.tiene_parametros_extra
    )
  };
}
        
`.trim());

LswConstants.global.define("user.env", `

app.username=usuario
app.clock_message=
        
`.trim());

/*
LswConstants.global.define("/kernel/settings/goals/factory/fisico-3-veces.js", `

return LswGoals.minTimesToday("actividad fsica", 3);

`.trim());

LswConstants.global.define("/kernel/settings/goals/factory/fisico-4h.js", `

return LswGoals.minDurationToday("actividad fsica", "4h");

`.trim());
//*/

LswConstants.global.define("/kernel/settings/goals.env", `

actividad fsica | > 3 | !1
actividad fsica | > 4h | !2
programar | > 6h | !3

`.trim());

LswConstants.global.define("/kernel/goals/goals.week", `

*-*:

* {
  req actividad fsica >3h !10
  req actividad intelectual >3h !10
  req aprender algo > 1h !10
  req crear algo > 2h !10
}

sab {
  set 22:00 = puesta de sol
}

dom {
  set 10:00 = tiempo de reflexin semanal
}

  
  `.trim());

LswConstants.global.define("/kernel/settings/trackables.env", `

Sky castle

`.trim());

LswConstants.global.define("/kernel/editor/validators/js.js", `

  await LswLazyLoads.loadBeautifier();

  return ;
    
  `.trim());

LswConstants.global.define("/kernel/apps/example/load.js", `

return {
  label: " Example of app",
  event: () => {
    lsw.toasts.debug({ message: "hi from custom app!" });
  }
};
  
`.trim());

LswConstants.global.define("/kernel/android/boot.js", `
  
/*
// Inject your local android api from here:
lsw.fs.evaluateAsJavascriptFileOrReturn("/kernel/android/api/load.js");
//*/

`.trim());

// @vuebundler[Lsw_framework_components][14]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-lazy-loader/lsw-lazy-loader.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswLazyLoader'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswLazyLoader'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswLazyLoader class | @section: Lsw LazyLoader API  LswLazyLoader class

  const UnsolvedLazyLoadModule = class {

    static create(...args) {
      return new this(...args);
    }

  };

  const LswLazyLoader = class {

    static UnsolvedLazyLoadModule = UnsolvedLazyLoadModule;

    static global = new this();

    constructor() {
      this.$loads = {};
      this.$alias = {};
    }

    register(options = {}) {
      const url = options.url;
      this.$loads[url] = Object.assign({}, {
        alias: false,
        scope: Vue.prototype.$lsw,
        getter: options.getter || Vue.prototype.$noop,
        confirmer: options.confirmer || Vue.prototype.$noop,
        confirmation: true,
        once: false,
        onceDone: false,
      }, options);
      if (this.$loads[url].alias) {
        this.$alias[this.$loads[url].alias] = url;
      }
    }

    $solveAlias(urlOrAlias) {
      const hasAlias = urlOrAlias in this.$alias;
      if (hasAlias) {
        return this.$alias[urlOrAlias];
      }
      return urlOrAlias;
    }

    $softRegister(url, options = {}) {
      if (!this.hasLoaded(url)) {
        this.register(url, options);
      }
    }

    hasLoaded(url) {
      return url in this.$loads;
    }

    $loadLocally(url) {
      const options = this.$loads[url] || {};
      const _getter = options.getter || Vue.prototype.$noop;
      const _confirmer = options.confirmer || Vue.prototype.$noop;
      const _confirmation = options.confirmation || Vue.prototype.$noop;
      const _once = options.once || false;
      const _onceDone = options.onceDone || false;
      const currentGetterValue = (() => {
        try {
          return _getter();
        } catch (error) {
          return undefined;
        }
      })();
      Kick_by_getter: {
        const hasGetterOk = typeof currentGetterValue !== "undefined";
        if (hasGetterOk) {
          return currentGetterValue;
        }
      }
      Kick_by_confirmer: {
        const currentConfirmerValue = _confirmer();
        const hasConfirmerOk = currentConfirmerValue === true;
        if (hasConfirmerOk) {
          return _confirmation;
        }
      }
      Kick_by_once_flag: {
        if(_once) {
          if(_onceDone) {
            return;
          }
        }
      }
      this.$loads[url].onceDone = true;
      return this.constructor.UnsolvedLazyLoadModule.create(url);
    }

    loadScriptAsync(url) {
      const value = this.$loadLocally(url);
      if (!(value instanceof this.constructor.UnsolvedLazyLoadModule)) {
        return value;
      }
      this.$softRegister(url, {});
      const options = this.$loads[url];
      const _scope = options.scope || Vue.prototype.$lsw;
      return importer.scriptAsync(url, _scope);
    }

    loadScriptSrc(url) {
      const value = this.$loadLocally(url);
      if (!(value instanceof this.constructor.UnsolvedLazyLoadModule)) {
        return value;
      }
      this.$softRegister(url, {});
      const options = this.$loads[url];
      const _scope = options.scope || Vue.prototype.$lsw;
      return importer.scriptSrc(url, _scope);
    }

    loadScriptSrcModule(url) {
      const value = this.$loadLocally(url);
      if (!(value instanceof this.constructor.UnsolvedLazyLoadModule)) {
        return value;
      }
      this.$softRegister(url, {});
      const options = this.$loads[url];
      const _scope = options.scope || Vue.prototype.$lsw;
      return importer.scriptSrcModule(url, _scope);
    }

    loadLinkStylesheet(url) {
      const value = this.$loadLocally(url);
      if (!(value instanceof this.constructor.UnsolvedLazyLoadModule)) {
        return value;
      }
      this.$softRegister(url, {});
      const options = this.$loads[url];
      const _scope = options.scope || Vue.prototype.$lsw;
      return importer.linkStylesheet(url);
    }

    load(aliasOrUrl) {
      const url = this.$solveAlias(aliasOrUrl);
      const value = this.$loadLocally(url);
      if (!(value instanceof this.constructor.UnsolvedLazyLoadModule)) {
        return value;
      }
      this.$softRegister(url, {});
      const options = this.$loads[url];
      const _scope = options.scope || Vue.prototype.$lsw;
      const _type = options.type || "scriptSrc";
      if (!(_type in importer)) {
        throw new Error(`Required type from ${url} options to be a known method for $importer on LswLazyLoader.load`);
      }
      return importer[_type](url, _scope);
    }

  };

  return LswLazyLoader;

  // @code.end: LswLazyLoader class

});

// @vuebundler[Lsw_framework_components][15]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-lazy-loader/lazy-loads.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswLazyLoads'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswLazyLoads'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswLazyLoads class | @section: Lsw LazyLoader API  LswLazyLoads class
  
  LswLazyLoader.global.register({
    alias: "highlight.js:global",
    url: "assets/lib/highlight/highlight.js",
    confirmer: () => typeof hljs !== "undefined",
    getter: () => hljs,
    type: "scriptSrc",
  });
  
  LswLazyLoader.global.register({
    alias: "highlight.js:themes:default",
    url: "assets/lib/highlight/styles/default.min.css",
    type: "linkStylesheet",
    once: true,
  });
  
  LswLazyLoader.global.register({
    alias: "highlight.js:themes:monokai",
    url: "assets/lib/highlight/styles/monokai.min.css",
    type: "linkStylesheet",
    once: true,
  });
  
  LswLazyLoader.global.register({
    alias: "pegjs",
    url: "assets/lib/pegjs/pegjs.js",
    type: "scriptSrc",
    once: true,
    confirmer: () => typeof pegjs !== "undefined",
  });
  
  LswLazyLoader.global.register({
    alias: "beautifier",
    url: "assets/lib/beautifier/beautifier.js",
    type: "scriptSrc",
    once: true,
    confirmer: () => typeof beautifier !== "undefined",
  });
  
  LswLazyLoader.global.register({
    alias: "babel",
    url: "assets/lib/babel/babel.js",
    type: "scriptSrc",
    once: true,
    confirmer: () => typeof Babel !== "undefined",
  });
  
  LswLazyLoader.global.register({
    alias: "eruda",
    url: "assets/lib/eruda/eruda.js",
    type: "scriptSrc",
    once: true,
    confirmer: () => typeof eruda !== "undefined",
  });
  
  LswLazyLoader.global.register({
    alias: "jmespath",
    url: "assets/lib/jmespath/jmespath.min.js",
    type: "scriptSrc",
    once: true,
    confirmer: () => typeof jmespath !== "undefined",
  });
  
  LswLazyLoader.global.register({
    alias: "jquery",
    url: "assets/lib/jquery/jquery-v3.7.1.js",
    type: "scriptSrc",
    once: true,
    confirmer: () => typeof jQuery !== "undefined",
  });
  
  LswLazyLoader.global.register({
    alias: "qunit.js",
    url: "assets/lib/qunit/qunit.js",
    type: "scriptSrc",
    once: true,
    confirmer: () => typeof QUnit !== "undefined",
  });

  LswLazyLoader.global.register({
    alias: "qunit.css",
    url: "assets/lib/qunit/qunit.css",
    type: "linkStylesheet",
    once: true,
    confirmer: () => typeof QUnit !== "undefined",
  });

  LswLazyLoader.global.register({
    alias: "ejs",
    url: "assets/lib/ejs/ejs.js",
    type: "scriptSrc",
    once: true,
    confirmer: () => typeof ejs !== "undefined",
  });

  class LswLazyLoads {

    static loadHighlightJs() {
      return Promise.all([
        LswLazyLoader.global.load("highlight.js:global"),
        // LswLazyLoader.global.load("highlight.js:themes:default"),
        LswLazyLoader.global.load("highlight.js:themes:monokai"),
      ]).then(() => {
        hljs.highlightAll();
      });
    }

    static loadPegjs() {
      return LswLazyLoader.global.load("pegjs");
    }

    static loadBeautifier() {
      return LswLazyLoader.global.load("beautifier");
    }

    static loadHtml2Pdf() {
      return LswLazyLoader.global.load("html2pdf");
    }

    static loadBabel() {
      return LswLazyLoader.global.load("babel");
    }

    static loadEruda() {
      return LswLazyLoader.global.load("eruda");
    }

    static loadJmespath() {
      return LswLazyLoader.global.load("jmespath");
    }

    static loadJquery() {
      return LswLazyLoader.global.load("jquery");
    }

    static loadQunit() {
      return Promise.all([
        LswLazyLoader.global.load("jquery"),
        LswLazyLoader.global.load("qunit.css"),
        LswLazyLoader.global.load("qunit.js"),
      ]);
    }

    static loadEjs() {
      return LswLazyLoader.global.load("ejs");
    }

  };

  return LswLazyLoads;

  // @code.end: LswLazyLoads class

});


// @vuebundler[Lsw_framework_components][16]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-tree-parser/tripilang.parser.js
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root) {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { Tripilang: peg$parseTripilang },
        peg$startRuleFunction  = peg$parseTripilang,

        peg$c0 = function(tree) { return tree },
        peg$c1 = "@",
        peg$c2 = peg$literalExpectation("@", false),
        peg$c3 = function(token_1, decorator) { return decorator },
        peg$c4 = function(token_1, definition, idAndOrLink, subtree) { return { ...idAndOrLink, definition: definition || undefined, subtree: subtree || undefined } },
        peg$c5 = function(token_1, identification) { return identification },
        peg$c6 = function(link) { return { link: link || undefined } },
        peg$c7 = function(id) { return { id: id || undefined } },
        peg$c8 = function(id, link) { return { id: id || undefined, link: link || undefined } },
        peg$c9 = function(id) { return id },
        peg$c10 = "[",
        peg$c11 = peg$literalExpectation("[", false),
        peg$c12 = "]",
        peg$c13 = peg$literalExpectation("]", false),
        peg$c14 = function(token_1, link, token_2) { return link },
        peg$c15 = peg$anyExpectation(),
        peg$c16 = function() { return text().trim() },
        peg$c17 = "{",
        peg$c18 = peg$literalExpectation("{", false),
        peg$c19 = "}",
        peg$c20 = peg$literalExpectation("}", false),
        peg$c21 = function(token_1, content, token_2) { return content },
        peg$c22 = function() {},
        peg$c23 = "\r\n",
        peg$c24 = peg$literalExpectation("\r\n", false),
        peg$c25 = "\r",
        peg$c26 = peg$literalExpectation("\r", false),
        peg$c27 = "\n",
        peg$c28 = peg$literalExpectation("\n", false),
        peg$c29 = "\t",
        peg$c30 = peg$literalExpectation("\t", false),
        peg$c31 = " ",
        peg$c32 = peg$literalExpectation(" ", false),
        peg$c33 = function(value) { return value; },
        peg$c34 = function(tp, vl) { return tp ? { ...tp, $value: vl } : vl; },
        peg$c35 = /^[A-Za-z$_]/,
        peg$c36 = peg$classExpectation([["A", "Z"], ["a", "z"], "$", "_"], false, false),
        peg$c37 = /^[A-Za-z0-9$_]/,
        peg$c38 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "$", "_"], false, false),
        peg$c39 = function() { return text() },
        peg$c40 = ".",
        peg$c41 = peg$literalExpectation(".", false),
        peg$c42 = function(noun) { return "." + noun },
        peg$c43 = "/",
        peg$c44 = peg$literalExpectation("/", false),
        peg$c45 = function(noun) { return "/" + noun },
        peg$c46 = function(first, others) { return [first].concat(others || []).join("") },
        peg$c47 = "|",
        peg$c48 = peg$literalExpectation("|", false),
        peg$c49 = function(token1, otherType) { return otherType },
        peg$c50 = function(jspath, fallbacks) {
              return {
                $type: [jspath].concat(fallbacks || []),
              };
            },
        peg$c51 = function(members) {
              return members !== null ? members : {};
            },
        peg$c52 = ",",
        peg$c53 = peg$literalExpectation(",", false),
        peg$c54 = function(head, tail) {
              const result = { [head.key]: head.value };
              tail.forEach((item) => {
                const subitem = item[3];
                const { key, value } = subitem;
                result[key] = value;
              });
              return result;
            },
        peg$c55 = ":",
        peg$c56 = peg$literalExpectation(":", false),
        peg$c57 = function(key, value) {
              return { key, value };
            },
        peg$c58 = function(elements) {
              return elements !== null ? elements : [];
            },
        peg$c59 = function(head, tail) {
              return [head, ...tail.map(e => e[3])];
            },
        peg$c60 = "\"",
        peg$c61 = peg$literalExpectation("\"", false),
        peg$c62 = function(chars) {
              return chars;
            },
        peg$c63 = "\\\"",
        peg$c64 = peg$literalExpectation("\\\"", false),
        peg$c65 = function(chars) { return text(); },
        peg$c66 = "-",
        peg$c67 = peg$literalExpectation("-", false),
        peg$c68 = /^[0-9]/,
        peg$c69 = peg$classExpectation([["0", "9"]], false, false),
        peg$c70 = /^[eE]/,
        peg$c71 = peg$classExpectation(["e", "E"], false, false),
        peg$c72 = /^[\-+]/,
        peg$c73 = peg$classExpectation(["-", "+"], false, false),
        peg$c74 = function(value) {
              return parseFloat(value);
            },
        peg$c75 = "true",
        peg$c76 = peg$literalExpectation("true", false),
        peg$c77 = function() { return true; },
        peg$c78 = "false",
        peg$c79 = peg$literalExpectation("false", false),
        peg$c80 = function() { return false; },
        peg$c81 = "null",
        peg$c82 = peg$literalExpectation("null", false),
        peg$c83 = function() { return null; },
        peg$c84 = peg$otherExpectation("whitespace"),
        peg$c85 = /^[ \t\n\r]/,
        peg$c86 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parseTripilang() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseTree();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTree() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseTreepart();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNode_decorator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      s3 = peg$parse_();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parse_();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 64) {
          s3 = peg$c1;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c2); }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseObject();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c3(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTreepart() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNode_decorator();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseTreepart_identification();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseSubtree();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c4(s1, s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTreepart_identification() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseTreepart_identification_by_link();
        if (s2 === peg$FAILED) {
          s2 = peg$parseTreepart_identification_by_id_and_link();
          if (s2 === peg$FAILED) {
            s2 = peg$parseTreepart_identification_by_id();
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c5(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTreepart_identification_by_link() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseTreepart_link();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c6(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseTreepart_identification_by_id() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseTreepart_id();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c7(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseTreepart_identification_by_id_and_link() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseTreepart_id();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseTreepart_link();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c8(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTreepart_id() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseNegate_link_and_subtree();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c9(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseTreepart_link() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      s3 = peg$parse_();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parse_();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 91) {
          s3 = peg$c10;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c11); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNegate_close_square_bracket();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s5 = peg$c12;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c13); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c14(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNegate_close_square_bracket() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parseSPECIAL_TOKENS();
      if (s4 === peg$FAILED) {
        s4 = peg$parseEOF();
        if (s4 === peg$FAILED) {
          s4 = peg$parseEOL();
        }
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c15); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parseSPECIAL_TOKENS();
          if (s4 === peg$FAILED) {
            s4 = peg$parseEOF();
            if (s4 === peg$FAILED) {
              s4 = peg$parseEOL();
            }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c15); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c16();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseNegate_link_and_subtree() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parseSPECIAL_TOKENS();
      if (s4 === peg$FAILED) {
        s4 = peg$parseEOF();
        if (s4 === peg$FAILED) {
          s4 = peg$parseEOL();
        }
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c15); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parseSPECIAL_TOKENS();
          if (s4 === peg$FAILED) {
            s4 = peg$parseEOF();
            if (s4 === peg$FAILED) {
              s4 = peg$parseEOL();
            }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c15); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c16();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseSPECIAL_TOKENS() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 91) {
        s0 = peg$c10;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c11); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c17;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 125) {
            s0 = peg$c19;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c20); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s0 = peg$c12;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c13); }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseSubtree() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      s3 = peg$parse_();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parse_();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 123) {
          s3 = peg$c17;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseTreeparts();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c19;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c20); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c21(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTreeparts() {
      var s0, s1;

      s0 = [];
      s1 = peg$parseTreepart();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parseTreepart();
        }
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseEOL() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parse___();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c22();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseEOF() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c15); }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c22();
      }
      s0 = s1;

      return s0;
    }

    function peg$parse___() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c23) {
        s0 = peg$c23;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c24); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c25;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c27;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c28); }
          }
        }
      }

      return s0;
    }

    function peg$parse__() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 9) {
        s0 = peg$c29;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 32) {
          s0 = peg$c31;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c32); }
        }
      }

      return s0;
    }

    function peg$parse_() {
      var s0;

      s0 = peg$parse___();
      if (s0 === peg$FAILED) {
        s0 = peg$parse__();
      }

      return s0;
    }

    function peg$parseJsontyped_syntax() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseANYSPACE();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseValue();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseANYSPACE();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseValue() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseType_def_by_js_property();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseANYSPACE();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseValue_untyped();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c34(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseJs_noun() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (peg$c35.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c37.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c37.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c39();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseJs_noun_predotted() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c40;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c41); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_noun();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c42(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseJs_noun_preslashed() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 47) {
        s1 = peg$c43;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c44); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_noun();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c45(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseJs_path() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseJs_noun();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseJs_noun_predotted();
        if (s3 === peg$FAILED) {
          s3 = peg$parseJs_noun_preslashed();
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseJs_noun_predotted();
          if (s3 === peg$FAILED) {
            s3 = peg$parseJs_noun_preslashed();
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c46(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseJs_path_fallback() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 124) {
          s3 = peg$c47;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_path();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c49(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseType_def_by_js_property() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 64) {
        s1 = peg$c1;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c2); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_path();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseJs_path_fallback();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseJs_path_fallback();
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c50(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseValue_untyped() {
      var s0;

      s0 = peg$parseObject();
      if (s0 === peg$FAILED) {
        s0 = peg$parseArray();
        if (s0 === peg$FAILED) {
          s0 = peg$parseString();
          if (s0 === peg$FAILED) {
            s0 = peg$parseNumber();
            if (s0 === peg$FAILED) {
              s0 = peg$parseBoolean();
              if (s0 === peg$FAILED) {
                s0 = peg$parseNull();
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseObject() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c17;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c18); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseANYSPACE();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMemberList();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseANYSPACE();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s5 = peg$c19;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c20); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c51(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMemberList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseMember();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseANYSPACE();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c52;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c53); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseANYSPACE();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseMember();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseANYSPACE();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c52;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c53); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseANYSPACE();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseMember();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c54(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMember() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseString();
      if (s1 === peg$FAILED) {
        s1 = peg$parseJs_noun();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseANYSPACE();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c55;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c56); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseANYSPACE();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseValue();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c57(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseArray() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c10;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c11); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseANYSPACE();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseElementList();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseANYSPACE();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s5 = peg$c12;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c13); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c58(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseElementList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseValue();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseANYSPACE();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c52;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c53); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseANYSPACE();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseValue();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseANYSPACE();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c52;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c53); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseANYSPACE();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseValue();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c59(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseString() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c60;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDoubleQuotedString();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c60;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c61); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c62(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDoubleQuotedString() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      if (input.substr(peg$currPos, 2) === peg$c63) {
        s2 = peg$c63;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c64); }
      }
      if (s2 === peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 34) {
          s4 = peg$c60;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c61); }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c15); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (input.substr(peg$currPos, 2) === peg$c63) {
          s2 = peg$c63;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c64); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 34) {
            s4 = peg$c60;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c61); }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c15); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c65(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseNumber() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s3 = peg$c66;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        if (peg$c68.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c69); }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c68.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c69); }
            }
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s6 = peg$c40;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c41); }
          }
          if (s6 !== peg$FAILED) {
            s7 = [];
            if (peg$c68.test(input.charAt(peg$currPos))) {
              s8 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c69); }
            }
            if (s8 !== peg$FAILED) {
              while (s8 !== peg$FAILED) {
                s7.push(s8);
                if (peg$c68.test(input.charAt(peg$currPos))) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c69); }
                }
              }
            } else {
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            if (peg$c70.test(input.charAt(peg$currPos))) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c71); }
            }
            if (s7 !== peg$FAILED) {
              if (peg$c72.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c73); }
              }
              if (s8 === peg$FAILED) {
                s8 = null;
              }
              if (s8 !== peg$FAILED) {
                s9 = [];
                if (peg$c68.test(input.charAt(peg$currPos))) {
                  s10 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s10 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c69); }
                }
                if (s10 !== peg$FAILED) {
                  while (s10 !== peg$FAILED) {
                    s9.push(s10);
                    if (peg$c68.test(input.charAt(peg$currPos))) {
                      s10 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c69); }
                    }
                  }
                } else {
                  s9 = peg$FAILED;
                }
                if (s9 !== peg$FAILED) {
                  s7 = [s7, s8, s9];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            if (s6 !== peg$FAILED) {
              s3 = [s3, s4, s5, s6];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c74(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseBoolean() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c75) {
        s1 = peg$c75;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c76); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c77();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c78) {
          s1 = peg$c78;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c79); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c80();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseNull() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c81) {
        s1 = peg$c81;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c83();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseANYSPACE() {
      var s0, s1;

      peg$silentFails++;
      s0 = [];
      if (peg$c85.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c86); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c85.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c86); }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c84); }
      }

      return s0;
    }


      // Funcin auxiliar para convertir cadenas con escapes
      function unescapeString(str) {
        return JSON.parse(str);
      }


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  root.TripilangParser = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})(globalThis);

// @vuebundler[Lsw_framework_components][17]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-tree-parser/lsw-tree-parser.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswTreeParser'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswTreeParser'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  return TripilangParser;

});

// @vuebundler[Lsw_framework_components][18]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-tester/lsw-tester.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswTester'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswTester'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswTester API | @$section: LswTester API  LswTester classes and functions
  const LswAssertion = class {

    static create(...args) {
      return new this(...args);
    }

    $trace(method) {
      this.$tester.$trace(method);
    }

    constructor(tester, submodule, result = undefined, message = undefined) {
      this.$tester = tester;
      this.$module = submodule;
      this.$moduleId = submodule.id;
      this.$result = result;
      this.$message = message;
    }

    as(message = undefined) {
      this.$trace("LswAssertion.as");
      this.$message = message;
      return this;
    }

    that(result = undefined) {
      this.$trace("LswAssertion.that");
      this.$result = result;
      if(this.$result === true) {
        this.$tester.hookedBy("onSuccessAssertion", { tester: this.$tester, value: this.$module, assertionText: this.$message, assertionResult: this.$result });
      } else {
        this.$tester.hookedBy("onErrorAssertion", { tester: this.$tester, value: this.$module, assertionText: this.$message, assertionResult: this.$result });
      }
    }

  };

  const createAssert = (tester, submodule) => {
    return LswAssertion.create(tester, submodule);
  };

  const LswTester_BasicLayer = class {

    async innerLoad() {
      this.$trace("LswTester.innerLoad");
      return this.innerLoadTest(this.$composition, [], null);
    }

    innerCheckIsNotTyped(val, path) {
      this.$trace("LswTester.innerCheckIsNotTyped");
      if (typeof val.fromType === "string") {
        throw new Error(`Required test on index ${path.join(".")} to not have property fromType resolved on LswTester.innerCheckIsNotTyped`);
      }
    }

    innerTypeAsUrl(val, path) {
      this.$trace("LswTester.innerTypeAsUrl");
      this.innerCheckIsNotTyped(val, path);
      val.fromType = "url";
    }

    innerTypeAsFile(val, path) {
      this.$trace("LswTester.innerTypeAsFile");
      this.innerCheckIsNotTyped(val, path);
      val.fromType = "file";
    }

    innerTypeAsId(val, path) {
      this.$trace("LswTester.innerTypeAsId");
      this.innerCheckIsNotTyped(val, path);
      val.fromType = "id";
    }

    innerTypeAsCallback(val, path) {
      this.$trace("LswTester.innerTypeAsCallback");
      this.innerCheckIsNotTyped(val, path);
      val.fromType = "callback";
    }

    innerTypeAsCollection(val, path) {
      this.$trace("LswTester.innerTypeAsCollection");
      this.innerCheckIsNotTyped(val, path);
      val.fromType = "collection";
    }

    addDefinition(test, pathToTest = false) {
      this.$trace("LswTester.addDefinition");
      if (pathToTest) {
        test.path = pathToTest;
      }
      if (test.id in this.$definitions) {
        throw new Error(`Required property id in test on index ${pathToTest.join(".")} to be a non-duplicated id for this.$definitions on LswTester.addDefinition`);
      }
      this.$definitions[test.id] = test.path;
    }

    innerLoadTest(val, path, parent = null, parentIndex = []) {
      this.$trace("LswTester.innerLoadTest");
      this.addDefinition(val, path);
      if (val.fromUrl) {
        this.innerTypeAsUrl(val, path);
      }
      if (val.fromFile) {
        this.innerTypeAsFile(val, path);
      }
      if (val.fromId) {
        this.innerTypeAsId(val, path);
      }
      if (val.fromCallback) {
        this.innerTypeAsCallback(val, path);
      }
      if (val.fromCollection) {
        this.innerTypeAsCollection(val, path);
        for (let index = 0; index < val.fromCollection.length; index++) {
          const subval = val.fromCollection[index];
          this.innerLoadTest(subval, path.concat(["fromCollection", index]), val, path);
        }
      }
    }

    async innerRun() {
      this.$trace("LswTester.innerRun");
      this.hookedBy("onStartTester", []);
      let results = new Error(`Tester ${this.$composition.id} was not started yet`);
      try {
        results = await this.innerRunTests(this.$composition, [], null, [], []);
        this.hookedBy("onSuccessTester", [results]);
      } catch (error) {
        this.hookedBy("onErrorTester", [error]);
        results = results.concat([error]);
      } finally {
        this.hookedBy("onEndTester", [results]);
        return results;
      }
    }

    innerHandleCallback(val, path, parent, parentIndex, accumulated) {
      this.$trace("LswTester.innerHandleCallback");
      return val.fromCallback.call(this, {
        tester: this,
        test: val,
        testPath: path,
        assert: createAssert(this, val),
      });
    }

    innerHandleUrl(val, path, parent, parentIndex, accumulated) {
      this.$trace("LswTester.innerHandleUrl");
      return importer.scriptAsync(val.fromUrl, {
        $tester: this,
        $test: val,
        $testPath: path,
        $testParent: parent,
        $testParentPath: parentIndex,
        $accumulated: accumulated,
        assert: createAssert(this, val),
      });
    }

    innerHandleFile(val, path, parent, parentIndex, accumulated) {
      this.$trace("LswTester.innerHandleFile");
      return Vue.prototype.$lsw.fs.evaluateAsJavascriptFile(val.fromFile);
    }

    async innerRunTests(val, path, parent = null, parentIndex = [], accumulated = []) {
      this.$trace("LswTester.innerRunTests");
      this.hookedBy("onStartModule", { tester:this, value:val, path, parent, parentIndex, accumulated });
      let reported = undefined;
      RunningTest: {
        try {
          Manage_bad_inputs: {
            if (typeof val !== "object") {
              throw new Error(`[ERROR: LswTester complain x004006] Required type of test ${typeof val} on index ${path.join(".")} to be an object on LswTester.innerRunTests in order to process module as test by LswTester instance`);
            }
            if (val === null) {
              break RunningTest;
            }
            if (!val.id) {
              throw new Error(`[ERROR: LswTester complain x004001] Required test ${typeof val} on index ${path.join(".")} to have property id on LswTester.innerRunTests in order to process module as test by LswTester instance`);
            }
            if (typeof val.id !== "string") {
              throw new Error(`[ERROR: LswTester complain x004002] Required test ${typeof val} on index ${path.join(".")} to have a string on property id on LswTester.innerRunTests in order to process module as test by LswTester instance`);
            }
            if (typeof val.fromType !== "string") {
              throw new Error(`[ERROR: LswTester complain x004003] Required test ${typeof val} on index ${path.join(".")} to have a string on property fromType on LswTester.innerRunTests in order to process module as test by LswTester instance. This indicates that the previous step LswTester.innerLoad DID NOT (while it SHOULD, or SHOULD HAVE arised an error otherwise) mark this test module as a known type`);
            }
            const validTypes = ["url", "file", "collection", "callback"];
            if (validTypes.indexOf(val.fromType) === -1) {
              throw new Error(`[ERROR: LswTester complain x004008] Required test ${typeof val} on index ${path.join(".")} to have property fromType with a valid type instead of ${val.fromType} on LswTester.innerRunTests in order to process module as test by LswTester instance. This indicates that the previous step LswTester.innerLoad DID NOT (while it SHOULD, or SHOULD HAVE arised an error otherwise) mark this test module as a known type`);
            }
          }
          if (val.fromType === "url") {
            reported = await this.innerHandleUrl(val, path, parent, parentIndex, accumulated);
          } else if (val.fromType === "callback") {
            reported = await this.innerHandleCallback(val, path, parent, parentIndex, accumulated);
          } else if (val.fromType === "file") {
            reported = await this.innerHandleFile(val, path, parent, parentIndex, accumulated);
          } else if (val.fromType === "collection") {
            const collection = val.fromCollection;
            reported = [];
            for (let index = 0; index < collection.length; index++) {
              const item = collection[index];
              try {
                const result = await this.innerRunTests(item, path.concat(["fromCollection", index]), val, path, accumulated);
                reported.push(result);
              } catch (error) {
                if (this.$options.continueOnErrors === false) {
                  throw error;
                }
              }
            }
          }
          this.hookedBy("onSuccessModule", { tester:this, value:val, path, parent, parentIndex, accumulated });
        } catch (error) {
          this.$trace(`Error on test artifact ${val.id} located at ${path.join(".")} on LswTester instance`);
          if (this.$options.printErrors === true) {
            console.error(error);
          }
          this.hookedBy("onErrorModule", { tester:this, value:val, error, path, parent, parentIndex, accumulated });
          if (this.$options.continueOnErrors === false) {
            throw error;
          } else {
            reported = error;
          }
        }
      }
      this.hookedBy("onEndModule", { tester:this, value:val, path, parent, parentIndex, accumulated, reported });
      if (path.length === 0) {
        this.$result = reported
      }
      return reported;
    }

  }

  const LswTester = class extends LswTester_BasicLayer {

    static Assertion = LswAssertion;

    static createAssertion(...args) {
      return new this.Assertion(...args);
    }

    static create(...args) {
      return new this(...args);
    }

    $trace(method) {
      if (this.$options.trace) {
        console.log(`[trace][lsw-tester][${method}]`);
      }
    }

    static defaultOptions = {
      trace: false,
      continueOnErrors: false,
      printErrors: true,
      onAnything: false,
      onStartTester: false,
      onEndTester: false,
      onSuccessTester: false,
      onErrorTester: false,
      onStartModule: false,
      onFinishModule: false,
      onSuccessModule: false,
      onErrorModule: false,
      onSuccessAssertion: false,
      onErrorAssertion: false,
    };

    static noop() { }

    constructor() {
      super();
      this.reset();
    }

    reset() {
      this.$isLoaded = false;
      this.$isExecuted = false;
      this.$definitions = {};
      this.$options = Object.assign({}, this.constructor.defaultOptions);
      this.$composition = undefined;
    }

    hookedBy(callbackId, uniqueParameter = {}) {
      this.$trace("LswTester.hookedBy");
      const isAnyEventCallback = typeof this.$options.onAnything === "function";
      if (isAnyEventCallback) {
        this.$options.onAnything.call(this, { eventType: callbackId }, uniqueParameter);
      }
      const isCallback = typeof this.$options[callbackId] === "function";
      if (!isCallback) {
        return false;
      }
      return this.$options[callbackId].call(this, uniqueParameter);
    }

    define(composition = {}) {
      this.$trace("LswTester.define");
      if (typeof this.$composition !== "undefined") {
        throw new Error("Required property $composition to not be defined before on LswTester.define");
      }
      this.$composition = composition;
      return this;
    }

    options(options) {
      this.$trace("LswTester.options");
      this.$options = Object.assign({}, this.constructor.defaultOptions, options);
      return this;
    }

    onAnything(callback) {
      this.$trace("LswTester.onAnything");
      this.$options.onAnything = callback;
      return this;
    }

    onStartTester(callback) {
      this.$trace("LswTester.onStartTester");
      this.$options.onStartTester = callback;
      return this;
    }

    onEndTester(callback) {
      this.$trace("LswTester.onEndTester");
      this.$options.onEndTester = callback;
      return this;
    }

    onSuccessTester(callback) {
      this.$trace("LswTester.onSuccessTester");
      this.$options.onSuccessTester = callback;
      return this;
    }

    onErrorTester(callback) {
      this.$trace("LswTester.onErrorTester");
      this.$options.onErrorTester = callback;
      return this;
    }

    onStartModule(callback) {
      this.$trace("LswTester.onStartModule");
      this.$options.onStartModule = callback;
      return this;
    }

    onFinishModule(callback) {
      this.$trace("LswTester.onFinishModule");
      this.$options.onFinishModule = callback;
      return this;
    }

    onSuccessModule(callback) {
      this.$trace("LswTester.onSuccessModule");
      this.$options.onSuccessModule = callback;
      return this;
    }

    onErrorModule(callback) {
      this.$trace("LswTester.onErrorModule");
      this.$options.onErrorModule = callback;
      return this;
    }

    onSuccessAssertion(callback) {
      this.$trace("LswTester.onSuccessAssertion");
      this.$options.onSuccessAssertion = callback;
      return this;
    }

    onErrorAssertion(callback) {
      this.$trace("LswTester.onErrorAssertion");
      this.$options.onErrorAssertion = callback;
      return this;
    }

    async load() {
      this.$trace("LswTester.load");
      try {
        await this.innerLoad();
        this.$isLoaded = true;
        return this;
      } catch (error) {
        console.error("[!] Failed LswTester on load phase with:", error);
        throw error;
      }
    }

    async run(skipLoad = false) {
      this.$trace("LswTester.run");
      try {
        if(!skipLoad) {
          await this.load();
        }
        await this.innerRun();
        this.$isExecuted = true;
      } catch (error) {
        console.error("[!] Failed LswTester on run phase with:", error);
        throw error;
      } finally {
        return this;
      }
    }

    getStatus() {
      this.$trace("LswTester.getStatus");
      return this.$composition;
    }

  };

  LswTester.global = LswTester.create();
  // @code.end: LswTester API

  return LswTester;

});

// @vuebundler[Lsw_framework_components][19]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-dom.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswDom'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswDom'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  

  /**
   * 
   * 
   * @$section: Lsw Dom API  LswDom class
   * @type: class
   * @extends: Object
   * @vendor: lsw
   * @namespace: LswDom
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: LswDom class | @section: Lsw Dom API  LswDom class
  const LswDom = class {

    static collectLeaves(originalCollection, selectorSequence = []) {
      $ensure(originalCollection).type("object");
      $ensure(selectorSequence).type("object").to.be.array();
      let collection = Array.isArray(originalCollection) ? originalCollection : [originalCollection];
      const mapperFactory = selector => element => {
        return [].concat(element.querySelectorAll(selector));
      };
      for(let indexSelector=0; indexSelector<selectorSequence.length; indexSelector++) {
        const selector = selectorSequence[indexSelector];
        const subnodes = collection.map(mapperFactory(selector)).flat();
        collection = [].concat(subnodes);
      }
      return collection;
    }

    static getClosestParent(originalElement, selector) {
      $ensure(originalElement).type("object").to.be.instanceOf(HTMLElement);
      $ensure(selector).type("string");
      let element = originalElement.parentElement;
      while(element && (element !== document)) {
        if(element.matches(selector)) {
          return element;
        }
        element = element.parentElement;
      }
      return null;
    }

    static getClosestChildren(originalElement, selector) {
      $ensure(originalElement).type("object").to.be.instanceOf(HTMLElement);
      $ensure(selector).type("string");
      return [...originalElement.querySelectorAll(selector)].filter(element => {
        return this.getClosestParent(element, selector) === originalElement;
      });
    }

    static querySelectorFirst(selector, matchingText = false, originalElement = document) {
      const all = originalElement.querySelectorAll(selector);
      const matched = Array.from(all).filter(element => {
        return element.textContent.trim().toLowerCase() === matchingText.toLowerCase();
      });
      return matched.length ? matched[0] : null;
    }

    static findVue(selector, matchingText = false, base = document) {
      const all = base.querySelectorAll(selector);
      const matched = Array.from(all).filter(element => {
        if(!matchingText) {
          return true;
        }
        return element.textContent.trim().toLowerCase() === matchingText.toLowerCase();
      });
      return matched.length ? matched[0].__vue__ : null;
    }

    static waitForMilliseconds(ms) {
      return new Promise((resolve, reject) => {
        setTimeout(resolve, ms);
      });
    }

    static extractPlaintextFromHtmltext(htmlText) {
      const el1 = document.createElement("div");
      el1.innerHTML = htmlText;
      return el1.textContent;
    }

    static findCssRulesContaining(selector) {
      const matchingRules = [];
      for (const styleSheet of document.styleSheets) {
        let rules;
        try {
          rules = styleSheet.cssRules || styleSheet.rules;
        } catch (e) {
          // Evita errores por CORS en hojas de estilo externas
          continue;
        }
        if (!rules) continue;
        for (const rule of rules) {
          if (rule.selectorText && rule.selectorText.includes(selector)) {
            matchingRules.push(rule);
          }
        }
      }
      return matchingRules;
    }

    static hasCssRulesContaining(selector) {
      const matchingRules = [];
      for (const styleSheet of document.styleSheets) {
        let rules;
        try {
          rules = styleSheet.cssRules || styleSheet.rules;
        } catch (e) {
          // Evita errores por CORS en hojas de estilo externas
          continue;
        }
        if (!rules) continue;
        for (const rule of rules) {
          if (rule.selectorText && rule.selectorText.includes(selector)) {
            return true;
          }
        }
      }
      return false;
    }

  };
  // @code.end: LswDom class

  return LswDom;

});

// @vuebundler[Lsw_framework_components][20]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-dom-irruptor.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswDomIrruptor'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswDomIrruptor'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswDomIrruptor class | @section: Lsw Dom Irruptor API  LswDomIrruptor class
  const LswDomIrruptor = class {

    static async aniadirNota() {
      LswDom.querySelectorFirst(".home_bottom_panel > button", "+ ").click();
    }
    static async verNotas() {
      LswDom.querySelectorFirst(".home_mobile_off_panel > .mobile_off_panel_cell", "").click();
    }
    static async abrirHomepage() {
      LswDom.querySelectorFirst(".main_topbar_button", "").click();
    }
    static async calendario() {
      LswDom.querySelectorFirst(".home_mobile_off_panel > .mobile_off_panel_cell", "").click();
    }
    static async abrirCalendario() {
      LswDom.querySelectorFirst(".main_topbar_button", "").click();
    }
    static async reportesDeCalendario() {
      LswDom.querySelectorFirst(".home_mobile_off_panel > .mobile_off_panel_cell", "").click();
      await LswDom.waitForMilliseconds(200);
      LswDom.querySelectorFirst("button.nowrap", "").click();
      await LswDom.waitForMilliseconds(200);
      LswDom.querySelectorFirst("button", " Iniciar conductometra").click();
      
    }
    static async abrirNavegacionRapida() {
      LswDom.querySelectorFirst(".main_topbar_button", "").click();
    }
    static async abrirBinarios() {
      LswDom.querySelectorFirst(".main_topbar_button", "").click();
      await LswDom.waitForMilliseconds(200);
      LswDom.querySelectorFirst(".lista_apps div", " Binarios").click();
    }
    static async abrirBaseDeDatos() {
      LswDom.querySelectorFirst(".main_topbar_button", "").click();
      await LswDom.waitForMilliseconds(200);
      LswDom.querySelectorFirst("div", " Base de datos").click();
    }
    static async abrirBaseDeDatosPorTabla(tabla) {
      LswDom.querySelectorFirst(".main_topbar_button", "").click();
      await LswDom.waitForMilliseconds(200);
      LswDom.querySelectorFirst("div", " Base de datos").click();
      await LswDom.waitForMilliseconds(200);
      LswDom.querySelectorFirst("span.table_name", tabla).click();
    }
    static async abrirBaseDeDatosPorNuevoDatoDeTabla(tabla) {
      this.abrirBaseDeDatosPorTabla(tabla);
      await LswDom.waitForMilliseconds(500);
      LswDom.querySelectorFirst("button", "").click();
    }
    static async abrirAccionesVirtuales() {
      await this.abrirBaseDeDatos();
      await LswDom.waitForMilliseconds(200);
      LswDom.querySelectorFirst("button", "Accion_virtual").click();
    }
    static async abrirTareasPosterioresDeNavegacionRapida() {
      LswDom.querySelectorFirst(".lista_apps button", " Tareas posteriores").click();
    }
    static async abrirRecords() {
      this.abrirTareasPosterioresDeNavegacionRapida();
      await LswDom.waitForMilliseconds(500);
      LswDom.querySelectorFirst("button", "").click();
    }
    static async configuraciones() {
      LswDom.querySelectorFirst("#windows_pivot_button", "").click();
      await LswDom.waitForMilliseconds(200);
      LswDom.querySelectorFirst("button.main_tab_topbar_button", "").click();
    }
    static async abrirConfiguraciones() {
      LswDom.querySelectorFirst("#windows_pivot_button", "").click();
      await LswDom.waitForMilliseconds(200);
      LswDom.querySelectorFirst("button.main_tab_topbar_button", "").click();
    }
    static async abrirFicheros() {
      LswDom.querySelectorFirst("#windows_pivot_button", "").click();
      await LswDom.waitForMilliseconds(200);
      LswDom.querySelectorFirst("button.main_tab_topbar_button", "").click();
    }
    static async abrirWiki() {
      LswDom.querySelectorFirst(".mobile_off_panel_cell", "").click();
    }
    static async abrirWikiArticulos() {
      await this.abrirWiki();
      await LswDom.waitForMilliseconds();
      Abrir_articulos: {
        await LswDom.waitForMilliseconds(200);
        LswDom.querySelectorFirst(".lsw_wiki button.supermini", "").click();
        return;
      }
    }
    static async abrirWikiLibros() {
      await this.abrirWiki();
      await LswDom.waitForMilliseconds();
      Abrir_libros: {
        await LswDom.waitForMilliseconds(200);
        LswDom.querySelectorFirst(".lsw_wiki button.supermini", "").click();
      }
    }
    static async abrirWeekPlanner() {
      await this.abrirCalendario();
      Abrir_planificador: {
        await LswDom.waitForMilliseconds(1000);
        LswDom.querySelectorFirst("button", "7").click();
      }
    }
    static async abrirAcciones() {
      await this.abrirBaseDeDatos();
      Abrir_planificador: {
        await LswDom.waitForMilliseconds(1000);
        LswDom.querySelectorFirst("button", "7").click();
      }
    }
    
    static async abrirNuevaFeature() {
      await this.abrirHomepage();
      Abrir_planificador: {
        await LswDom.waitForMilliseconds(1000);
        LswDom.querySelectorFirst("div", " Nueva feature").click();
      }
    }

    static async abrirJsInspector() {
      await this.abrirHomepage();
      Abrir_inspector: {
        await LswDom.waitForMilliseconds(1000);
        LswDom.querySelectorFirst("div", " Inspector de JS").click();
      }
    }

    static async abrirTestsDeAplicacion() {
      await this.abrirHomepage();
      Abrir_tests: {
        await LswDom.waitForMilliseconds(200);
        LswDom.querySelectorFirst("div", " Tests de aplicacin").click();
      }
    }

    static async arrancarTestsDeAplicacion() {
      await this.abrirTestsDeAplicacion();
      Abrir_tests: {
        await LswDom.waitForMilliseconds(200);
        LswDom.querySelectorFirst("button", "").click();
      }
    }

    static async getRutinerTimeout() {
      const rutinerConfig = await Vue.prototype.$lsw.fs.evaluateAsDotenvFileOrReturn("/kernel/settings/rutiner.config.env", []);
      LswTimer.utils.fromDurationstringToMilliseconds(rutinerConfig.timeout);
      return rutinerConfig.timeout;
    }

    static async setRutinerTimeout(durationstring) {
      LswTimer.utils.fromDurationstringToMilliseconds(durationstring);
      await Vue.prototype.$lsw.fs.write_file("/kernel/settings/rutiner.config.env", "timeout=" + durationstring);
    }

    static async configurarRutinerTimeout() {
      const currentTimeout = await LswDomIrruptor.getRutinerTimeout();
      const duracion = await Vue.prototype.$lsw.dialogs.open({
        title: "Configurar frecuencia de mensaje rutinario",
        template: `
          <div class="pad_1" v-xform.form="{ onSubmit }" ref="formulario">
            <div class="pad_bottom_1">Especifica la duracin preferida:</div>
            <lsw-duration-control :settings="{name:'duracion',initialValue}" />
            <hr/>
            <div class="flex_row centered pad_1">
              <div class="flex_100"></div>
              <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="submitForm">Aceptar</button>
              </div>
              <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: {
          data: {
            initialValue: currentTimeout,
          },
          methods: {
            onSubmit(formdata) {
              return this.accept(formdata.duracion);
            },
            async submitForm() {
              this.$trace("Dialogs.configurar-frecuencia-rutiner.methods.submitForm");
              return await this.$refs.formulario.$xform.submit();
            }
          },
        }
      });
      if(duracion === -1) {
        return;
      }
      if(typeof duracion !== "string") {
        console.log("duracion", duracion);
      }
      const milliseconds = LswTimer.utils.fromDurationstringToMilliseconds(duracion);
      return await LswDomIrruptor.setRutinerTimeout(duracion);
    }

  }

  return LswDomIrruptor;
  // @code.end: LswDomIrruptor class

});

// @vuebundler[Lsw_framework_components][21]=/home/carlos/Escritorio/lsw-one/src-instrumented/lsw-framework/src/apis/lsw-dom/lsw-vue2.instr.js
function cov_2gk0e7d2ep() {
    var path = "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-vue2.js";
    var hash = "ac2cc2946cf46004d61805ec9cc560964c59a48c";
    var global = new Function("return this")();
    var gcv = "__coverage__";
    var coverageData = {
        path: "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-vue2.js",
        statementMap: {
            "0": {
                start: {
                    line: 1,
                    column: 0
                },
                end: {
                    line: 56,
                    column: 3
                }
            },
            "1": {
                start: {
                    line: 2,
                    column: 14
                },
                end: {
                    line: 2,
                    column: 23
                }
            },
            "2": {
                start: {
                    line: 3,
                    column: 2
                },
                end: {
                    line: 5,
                    column: 3
                }
            },
            "3": {
                start: {
                    line: 4,
                    column: 4
                },
                end: {
                    line: 4,
                    column: 28
                }
            },
            "4": {
                start: {
                    line: 6,
                    column: 2
                },
                end: {
                    line: 8,
                    column: 3
                }
            },
            "5": {
                start: {
                    line: 7,
                    column: 4
                },
                end: {
                    line: 7,
                    column: 28
                }
            },
            "6": {
                start: {
                    line: 9,
                    column: 2
                },
                end: {
                    line: 11,
                    column: 3
                }
            },
            "7": {
                start: {
                    line: 10,
                    column: 4
                },
                end: {
                    line: 10,
                    column: 25
                }
            },
            "8": {
                start: {
                    line: 26,
                    column: 18
                },
                end: {
                    line: 51,
                    column: 3
                }
            },
            "9": {
                start: {
                    line: 29,
                    column: 6
                },
                end: {
                    line: 29,
                    column: 40
                }
            },
            "10": {
                start: {
                    line: 30,
                    column: 6
                },
                end: {
                    line: 30,
                    column: 47
                }
            },
            "11": {
                start: {
                    line: 31,
                    column: 21
                },
                end: {
                    line: 31,
                    column: 30
                }
            },
            "12": {
                start: {
                    line: 32,
                    column: 6
                },
                end: {
                    line: 38,
                    column: 48
                }
            },
            "13": {
                start: {
                    line: 33,
                    column: 8
                },
                end: {
                    line: 33,
                    column: 36
                }
            },
            "14": {
                start: {
                    line: 34,
                    column: 24
                },
                end: {
                    line: 34,
                    column: 48
                }
            },
            "15": {
                start: {
                    line: 35,
                    column: 8
                },
                end: {
                    line: 37,
                    column: 9
                }
            },
            "16": {
                start: {
                    line: 36,
                    column: 10
                },
                end: {
                    line: 36,
                    column: 26
                }
            },
            "17": {
                start: {
                    line: 39,
                    column: 6
                },
                end: {
                    line: 39,
                    column: 23
                }
            },
            "18": {
                start: {
                    line: 43,
                    column: 32
                },
                end: {
                    line: 43,
                    column: 64
                }
            },
            "19": {
                start: {
                    line: 44,
                    column: 6
                },
                end: {
                    line: 44,
                    column: 77
                }
            },
            "20": {
                start: {
                    line: 45,
                    column: 6
                },
                end: {
                    line: 45,
                    column: 81
                }
            },
            "21": {
                start: {
                    line: 46,
                    column: 6
                },
                end: {
                    line: 46,
                    column: 77
                }
            },
            "22": {
                start: {
                    line: 47,
                    column: 6
                },
                end: {
                    line: 47,
                    column: 83
                }
            },
            "23": {
                start: {
                    line: 48,
                    column: 6
                },
                end: {
                    line: 48,
                    column: 31
                }
            },
            "24": {
                start: {
                    line: 54,
                    column: 2
                },
                end: {
                    line: 54,
                    column: 17
                }
            }
        },
        fnMap: {
            "0": {
                name: "(anonymous_0)",
                decl: {
                    start: {
                        line: 1,
                        column: 1
                    },
                    end: {
                        line: 1,
                        column: 2
                    }
                },
                loc: {
                    start: {
                        line: 1,
                        column: 20
                    },
                    end: {
                        line: 12,
                        column: 1
                    }
                },
                line: 1
            },
            "1": {
                name: "(anonymous_1)",
                decl: {
                    start: {
                        line: 12,
                        column: 3
                    },
                    end: {
                        line: 12,
                        column: 4
                    }
                },
                loc: {
                    start: {
                        line: 12,
                        column: 15
                    },
                    end: {
                        line: 56,
                        column: 1
                    }
                },
                line: 12
            },
            "2": {
                name: "(anonymous_2)",
                decl: {
                    start: {
                        line: 28,
                        column: 4
                    },
                    end: {
                        line: 28,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 28,
                        column: 55
                    },
                    end: {
                        line: 40,
                        column: 5
                    }
                },
                line: 28
            },
            "3": {
                name: "(anonymous_3)",
                decl: {
                    start: {
                        line: 42,
                        column: 4
                    },
                    end: {
                        line: 42,
                        column: 5
                    }
                },
                loc: {
                    start: {
                        line: 42,
                        column: 47
                    },
                    end: {
                        line: 49,
                        column: 5
                    }
                },
                line: 42
            }
        },
        branchMap: {
            "0": {
                loc: {
                    start: {
                        line: 3,
                        column: 2
                    },
                    end: {
                        line: 5,
                        column: 3
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 3,
                        column: 2
                    },
                    end: {
                        line: 5,
                        column: 3
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 3
            },
            "1": {
                loc: {
                    start: {
                        line: 6,
                        column: 2
                    },
                    end: {
                        line: 8,
                        column: 3
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 6,
                        column: 2
                    },
                    end: {
                        line: 8,
                        column: 3
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 6
            },
            "2": {
                loc: {
                    start: {
                        line: 9,
                        column: 2
                    },
                    end: {
                        line: 11,
                        column: 3
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 9,
                        column: 2
                    },
                    end: {
                        line: 11,
                        column: 3
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 9
            },
            "3": {
                loc: {
                    start: {
                        line: 35,
                        column: 8
                    },
                    end: {
                        line: 37,
                        column: 9
                    }
                },
                type: "if",
                locations: [{
                    start: {
                        line: 35,
                        column: 8
                    },
                    end: {
                        line: 37,
                        column: 9
                    }
                }, {
                    start: {
                        line: undefined,
                        column: undefined
                    },
                    end: {
                        line: undefined,
                        column: undefined
                    }
                }],
                line: 35
            },
            "4": {
                loc: {
                    start: {
                        line: 42,
                        column: 27
                    },
                    end: {
                        line: 42,
                        column: 45
                    }
                },
                type: "default-arg",
                locations: [{
                    start: {
                        line: 42,
                        column: 43
                    },
                    end: {
                        line: 42,
                        column: 45
                    }
                }],
                line: 42
            },
            "5": {
                loc: {
                    start: {
                        line: 44,
                        column: 50
                    },
                    end: {
                        line: 44,
                        column: 75
                    }
                },
                type: "binary-expr",
                locations: [{
                    start: {
                        line: 44,
                        column: 50
                    },
                    end: {
                        line: 44,
                        column: 69
                    }
                }, {
                    start: {
                        line: 44,
                        column: 73
                    },
                    end: {
                        line: 44,
                        column: 75
                    }
                }],
                line: 44
            },
            "6": {
                loc: {
                    start: {
                        line: 45,
                        column: 52
                    },
                    end: {
                        line: 45,
                        column: 79
                    }
                },
                type: "binary-expr",
                locations: [{
                    start: {
                        line: 45,
                        column: 52
                    },
                    end: {
                        line: 45,
                        column: 73
                    }
                }, {
                    start: {
                        line: 45,
                        column: 77
                    },
                    end: {
                        line: 45,
                        column: 79
                    }
                }],
                line: 45
            },
            "7": {
                loc: {
                    start: {
                        line: 46,
                        column: 50
                    },
                    end: {
                        line: 46,
                        column: 75
                    }
                },
                type: "binary-expr",
                locations: [{
                    start: {
                        line: 46,
                        column: 50
                    },
                    end: {
                        line: 46,
                        column: 69
                    }
                }, {
                    start: {
                        line: 46,
                        column: 73
                    },
                    end: {
                        line: 46,
                        column: 75
                    }
                }],
                line: 46
            },
            "8": {
                loc: {
                    start: {
                        line: 47,
                        column: 53
                    },
                    end: {
                        line: 47,
                        column: 81
                    }
                },
                type: "binary-expr",
                locations: [{
                    start: {
                        line: 47,
                        column: 53
                    },
                    end: {
                        line: 47,
                        column: 75
                    }
                }, {
                    start: {
                        line: 47,
                        column: 79
                    },
                    end: {
                        line: 47,
                        column: 81
                    }
                }],
                line: 47
            }
        },
        s: {
            "0": 0,
            "1": 0,
            "2": 0,
            "3": 0,
            "4": 0,
            "5": 0,
            "6": 0,
            "7": 0,
            "8": 0,
            "9": 0,
            "10": 0,
            "11": 0,
            "12": 0,
            "13": 0,
            "14": 0,
            "15": 0,
            "16": 0,
            "17": 0,
            "18": 0,
            "19": 0,
            "20": 0,
            "21": 0,
            "22": 0,
            "23": 0,
            "24": 0
        },
        f: {
            "0": 0,
            "1": 0,
            "2": 0,
            "3": 0
        },
        b: {
            "0": [0, 0],
            "1": [0, 0],
            "2": [0, 0],
            "3": [0, 0],
            "4": [0],
            "5": [0, 0],
            "6": [0, 0],
            "7": [0, 0],
            "8": [0, 0]
        },
        _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
        hash: "ac2cc2946cf46004d61805ec9cc560964c59a48c"
    };
    var coverage = global[gcv] || (global[gcv] = {});
    if (!coverage[path] || coverage[path].hash !== hash) {
        coverage[path] = coverageData;
    }
    var actualCoverage = coverage[path];
    { // @ts-ignore
        cov_2gk0e7d2ep = function() {
            return actualCoverage;
        };
    }
    return actualCoverage;
}
cov_2gk0e7d2ep();
cov_2gk0e7d2ep().s[0]++;
(function(factory) {
    cov_2gk0e7d2ep().f[0]++;
    const mod = (cov_2gk0e7d2ep().s[1]++, factory());
    cov_2gk0e7d2ep().s[2]++;
    if (typeof window !== 'undefined') {
        cov_2gk0e7d2ep().b[0][0]++;
        cov_2gk0e7d2ep().s[3]++;
        window['LswVue2'] = mod;
    } else {
        cov_2gk0e7d2ep().b[0][1]++;
    }
    cov_2gk0e7d2ep().s[4]++;
    if (typeof global !== 'undefined') {
        cov_2gk0e7d2ep().b[1][0]++;
        cov_2gk0e7d2ep().s[5]++;
        global['LswVue2'] = mod;
    } else {
        cov_2gk0e7d2ep().b[1][1]++;
    }
    cov_2gk0e7d2ep().s[6]++;
    if (typeof module !== 'undefined') {
        cov_2gk0e7d2ep().b[2][0]++;
        cov_2gk0e7d2ep().s[7]++;
        module.exports = mod;
    } else {
        cov_2gk0e7d2ep().b[2][1]++;
    }
})(function() {
    cov_2gk0e7d2ep().f[1]++;
    cov_2gk0e7d2ep().s[8]++;
    /**
     * 
     * 
     * @$section: Lsw Vue2 API  LswVue2 class
     * @type: class
     * @extends: Object
     * @vendor: lsw
     * @namespace: LswVue2
     * @source code: La clase est definida as:
     * 
     */ // @code.start: LswVue2 class | @section: Lsw Vue2 API  LswVue2 class
    const LswVue2 = class {
        static getClosestParent(component, filterCallback) {
            cov_2gk0e7d2ep().f[2]++;
            cov_2gk0e7d2ep().s[9]++;
            $ensure(component).type("object");
            cov_2gk0e7d2ep().s[10]++;
            $ensure(filterCallback).type("function");
            let parentOf = (cov_2gk0e7d2ep().s[11]++, component);
            cov_2gk0e7d2ep().s[12]++;
            do {
                cov_2gk0e7d2ep().s[13]++;
                parentOf = parentOf.$parent;
                const isValid = (cov_2gk0e7d2ep().s[14]++, filterCallback(parentOf));
                cov_2gk0e7d2ep().s[15]++;
                if (isValid) {
                    cov_2gk0e7d2ep().b[3][0]++;
                    cov_2gk0e7d2ep().s[16]++;
                    return parentOf;
                } else {
                    cov_2gk0e7d2ep().b[3][1]++;
                }
            } while (typeof parentOf !== "undefined");
            cov_2gk0e7d2ep().s[17]++;
            return undefined;
        }
        static extendComponent(baseComponent = (cov_2gk0e7d2ep().b[4][0]++, {})) {
            cov_2gk0e7d2ep().f[3]++;
            const extendedComponent = (cov_2gk0e7d2ep().s[18]++, Object.assign({}, baseComponent));
            cov_2gk0e7d2ep().s[19]++;
            extendedComponent.props = Object.assign({}, (cov_2gk0e7d2ep().b[5][0]++, baseComponent.props) || (cov_2gk0e7d2ep().b[5][1]++, {}));
            cov_2gk0e7d2ep().s[20]++;
            extendedComponent.methods = Object.assign({}, (cov_2gk0e7d2ep().b[6][0]++, baseComponent.methods) || (cov_2gk0e7d2ep().b[6][1]++, {}));
            cov_2gk0e7d2ep().s[21]++;
            extendedComponent.watch = Object.assign({}, (cov_2gk0e7d2ep().b[7][0]++, baseComponent.watch) || (cov_2gk0e7d2ep().b[7][1]++, {}));
            cov_2gk0e7d2ep().s[22]++;
            extendedComponent.computed = Object.assign({}, (cov_2gk0e7d2ep().b[8][0]++, baseComponent.computed) || (cov_2gk0e7d2ep().b[8][1]++, {}));
            cov_2gk0e7d2ep().s[23]++;
            return extendedComponent;
        }
    }; // @code.end: LswVue2 class
    cov_2gk0e7d2ep().s[24]++;
    return LswVue2;
});

// @vuebundler[Lsw_framework_components][22]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxifier/proxifier.unbundled.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswProxifier'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswProxifier'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  /**
   * 
   * 
   * @$section: LswProxifier API  LswProxifier class
   * @type: class
   * @extends: Object
   * @vendor: lsw
   * @namespace: LswProxifier
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: LswProxifier class | @$section: LswProxifier API  LswProxifier class
  class BaseClass {
    initialize(...args) {
      const promise = this.onInitialize(...args);
      if (promise instanceof Promise) {
        return promise.then(output => {
          return this;
        });
      }
      return this;
    }
    onInitialize() {
      return this;
    }
  }

  const AbstractProxy = class {
    constructor(value) {
      this.value = value;
    }
  }
  class AbstractVirtualizer extends AbstractProxy {}
  class AbstractSchemaEntity extends AbstractProxy {
    static toObject() {
      return {
        entityId: this.getEntityId(),
        name: this.getName(),
        version: this.getVersion(),
        properties: this.getProperties(),
        externalProperties: this.getExternalProperties(),
        methods: this.getMethods(),
        virtualizerId: this.getVirtualizerId(),
        formSettings: this.getFormSettings(),
        extraAttributes: this.getExtraAttributes(),
      };
    }
    static getEntityId() {
      throw new Error(`Required method getEntityId to be overriden by AbstractSchemaEntity inherited class on AbstractSchemaEntity.getEntityId`);
    }
    static getName() {
      throw new Error(`Required method getName to be overriden by AbstractSchemaEntity inherited class on AbstractSchemaEntity.getName`);
    }
    static getVersion() {
      throw new Error(`Required method getVersion to be overriden by AbstractSchemaEntity inherited class on AbstractSchemaEntity.getVersion`);
    }
    static getProperties() {
      throw new Error(`Required method getProperties to be overriden by AbstractSchemaEntity inherited class on AbstractSchemaEntity.getProperties`);
    }
    static getExternalProperties() {
      return {};
    }
    static getMethods() {
      throw new Error(`Required method getMethods to be overriden by AbstractSchemaEntity inherited class on AbstractSchemaEntity.getMethods`);
    }
    static getVirtualizerId() {
      throw new Error(`Required method getVirtualizerId to be overriden by AbstractSchemaEntity inherited class on AbstractSchemaEntity.getVirtualizerId`);
    }
    static getFormSettings() {
      throw new Error(`Required method getFormSettings to be overriden by AbstractSchemaEntity inherited class on AbstractSchemaEntity.getFormSettings`);
    }
    static getExtraAttributes() {
      throw new Error(`Required method getExtraAttributes to be overriden by AbstractSchemaEntity inherited class on AbstractSchemaEntity.getExtraAttributes`);
    }
  }
  class AbstractItem { }
  class AbstractList {
    constructor(value) {
      this.value = Array.isArray(value) ? value : [];
    }
    forEach(callback) {
      this.value.forEach(callback);
      return this;
    }
    filter(callback) {
      this.value = this.value.filter(callback);
      return this;
    }
    map(callback) {
      this.value = this.value.map(callback);
      return this;
    }
    reduce(callback, initialValue = []) {
      this.value = this.value.reduce(callback, initialValue);
      return this;
    }
    modify(callback) {
      this.value = callback(this.value);
      return this;
    }
    concat(...lists) {
      this.value = this.value.concat(...lists);
      return this;
    }
    onlyProp(prop) {
      this.value = this.value.map(it => it[prop]);
      return this;
    }
    onlyProps(props) {
      this.value = this.value.map(it => {
        const out = {};
        props.forEach(prop => {
          out[prop] = it[prop];
        });
        return out;
      });
      return this;
    }
    removeProp(prop) {
      return this.removeProps([prop]);
    }
    removeProps(props) {
      this.value = this.value.map(it => {
        const out = {};
        const keys = Object.keys(it).filter(prop => {
          return props.indexOf(prop) === -1;
        });
        keys.forEach(key => {
          out[key] = it[key];
        });
        return out;
      });
      return this;
    }
    deduplicate() {
      const out = [];
      this.value.forEach(it => {
        if (out.indexOf(it) === -1) {
          out.push(it);
        }
      });
      this.value = out;
      return this;
    }
    sort(callback) {
      this.value = this.value.sort(callback);
      return this;
    }
  };

  class LswProxifier {
    static create(...args) {
      return new this(...args);
    }
    AbstractProxy = AbstractProxy;
    AbstractSchemaEntity = AbstractSchemaEntity;
    AbstractVirtualizer = AbstractVirtualizer;
    AbstractItem = AbstractItem;
    AbstractList = AbstractList;
    constructor(mainInjection = {}) {
      this.$definitions = {};
      this.$mainInjection = mainInjection;
      this.$splitterChar = "@";
    }
    define(name, classesDef) {
      if(!(name in this.$definitions)) {
        this.$definitions[name] = {};
      }
      if(typeof classesDef !== "object") {
        throw new Error(`Required parameter classesDef to be a class on LswProxifier.define`)
      }
      const classesIds = Object.keys(classesDef);
      for(let index=0; index<classesIds.length; index++) {
        const classId = classesIds[index];
        const classDef = classesDef[classId];
        if(typeof classDef !== "function") {
          throw new Error(`Required proxy class ${classId} to be a class on LswProxifier.define`)
        }
      }
      Object.assign(this.$definitions[name], classesDef);
    }
    find(selector) {
      const [name, aspectId = false] = selector.split(this.$splitterChar);
      if(!(name in this.$definitions)) {
        throw new Error(`Could not find proxy classes from name ${name} on LswProxifier.find`);
      }
      if(!aspectId) {
        return this.$definitions[name];
      }
      if(!(aspectId in this.$definitions[name])) {
        throw new Error(`Could not find proxy aspect ${aspectId} from class ${name} on LswProxifier.find`);
      }
      return this.$definitions[name][aspectId];
    }
    getFactory() {
      return this.proxify.bind(this);
    }
    proxify(obj) {
      return {
        as: (typeSelector = "", proxyExtraArguments = []) => {
          if(typeof typeSelector !== "string") {
            throw new Error(`Required parameter typeSelector to be a string on proxify(@).as(@)`);
          }
          const [definitionId, aspectId = "Item"] = typeSelector.split(this.$splitterChar);
          if(!(definitionId in this.$definitions)) {
            throw new Error(`Required parameter definitionId [${definitionId}] to exist in proxifier.$definitions but it does not on proxify(@).as(@)`);
          }
          if(!(aspectId in this.$definitions[definitionId])) {
            throw new Error(`Required parameter aspectId [${aspectId}] to exist in proxifier.$definitions[${JSON.stringify(definitionId)}] but it does not on proxify(@).as(@)`);
          }
          const proxyClass = this.$definitions[definitionId][aspectId];
          const proxyInstance = new proxyClass(obj, ...proxyExtraArguments);
          if(typeof this.$mainInjection === "function") {
            this.$mainInjection(proxyInstance, proxyClass);
          } else if(typeof this.$mainInjection === "object") {
            Object.assign(proxyInstance, this.$mainInjection);
          }
          return proxyInstance;
        }
      };
    }
  };

  LswProxifier.default = LswProxifier;

  globalThis.$proxifier = LswProxifier.create();
  // @code.end: LswProxifier class

  return LswProxifier;

});

// @vuebundler[Lsw_framework_components][23]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-randomizer/lsw-randomizer.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswRandomizer'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswRandomizer'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {


  /**
   * 
   * 
   * @$section: LswRandomizer API  LswRandomizer class
   * @type: class
   * @extends: Object
   * @vendor: lsw
   * @namespace: LswRandomizer
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: LswRandomizer class | @$section: LswRandomizer API  LswRandomizer class
  const LswRandomizer = class {

    static $defaultAlphabet = "abcdefghijklmnopqrstuvwxyz";

    static getRandomIntegerBetween(start = 0, end = 100) {
      const min = Math.ceil(Math.min(start, end));
      const max = Math.floor(Math.max(start, end));
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    static getRandomString(len, alphabet = this.$defaultAlphabet) {
      let out = "";
      while (out.length < len) {
        out += alphabet[Math.floor(Math.random() * alphabet.length)];
      }
      return out;
    }

    static getRandomItem(list) {
      return list[Math.floor(Math.random() * list.length)];
    }

    static getRandomObject(totalProps = [0, 10], listOf = false) {
      let randomProps = totalProps;
      if (Array.isArray(totalProps)) {
        randomProps = this.getRandomIntegerBetween(...totalProps);
      }
      const buildRandomObject = () => {
        const randomObject = {};
        while (Object.keys(randomObject).length < randomProps) {
          const key = this.getRandomString(5);
          const value = this.getRandomString(10);
          randomObject[key] = value;
        }
        return randomObject;
      };
      if (listOf === false) {
        return buildRandomObject();
      }
      const randomList = [];
      for(let index=0; index<listOf; index++) {
        const randomObject = buildRandomObject();
        randomList.push(randomObject);
      }
      return randomList;
    }

  }

  return LswRandomizer;
  // @code.end: LswRandomizer class

});

// @vuebundler[Lsw_framework_components][24]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-agenda-randomizer/lsw-agenda-randomizer.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswAgendaRandomizer'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswAgendaRandomizer'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  class LswAgendaRandomizer {

    static isTracing = false;

    static trace(method, args = [], extras = false) {
      if (this.isTracing) {
        console.log(`[trace] LswAgendaRandomizer.${method}: ${Array.from(args).length}`);
        console.log(`[trace] Extra parameters:`, extras);
      }
    }

    static elegirMixto(pesos, rangoDePeso = 1.0) {
      const claves = Object.keys(pesos);
      if (claves.length === 0) return null;
      
      const usarPeso = false;

      if (usarPeso) {
        // @TODO: esto no est valiendo ahora mismo.
      } else {
        // Eleccin uniforme entre claves
        const indice = Math.floor(Math.random() * claves.length);
        return claves[indice];
      }
    }
    

    static generar(reglas = {}, accionesPrevias = [], horaInicio = new Date(), duracionMinima = "20min", horaFinal = new Date(), tasaDePeso = 0.6) {
      this.trace("generar", arguments);
      const ahora = new Date(horaInicio);
      ahora.setSeconds(0, 0); // limpia segundos y ms
    
      const inicio = new Date(ahora.getFullYear(), ahora.getMonth(), ahora.getDate(), horaInicio.getHours(), 0, 0, 0);
      const finDelDia = new Date(ahora.getFullYear(), ahora.getMonth(), ahora.getDate(), horaFinal.getHours(), 59, 59, 999);
      const duracionMilisegundos = this._duracionAMilisegundos(duracionMinima);
    
      const acciones = [];
    
      let cursor = new Date(inicio);
      while (cursor <= finDelDia) {
        console.log("cursor:", LswTimer.utils.fromDateToDatestring(cursor));
        
        const concepto = this.elegirMixto(reglas, tasaDePeso);
        acciones.push({
          en_concepto: concepto,
          tiene_estado: "pendiente",
          tiene_inicio: this._formatearFecha(cursor),
          tiene_duracion: duracionMinima,
          tiene_parametros: "",
          tiene_resultados: "",
          tiene_comentarios: "",
          id: this._generarIdUnico()
        });
        cursor = new Date(cursor.getTime() + duracionMilisegundos);
      }
    
      return acciones;
    }    

    static generarComplejo(reglas = {}, accionesPrevias = [], horaActual = new Date(), duracionMinima = "10min") {
      this.trace("generarComplejo", arguments);
      $ensure({ reglas }, 1).to.be.object();
      $ensure({ accionesPrevias }, 1).to.be.array();
      $ensure({ horaActual }, 1).to.be.instanceOf(Date);
      const ahora = new Date(horaActual);
      ahora.setMinutes(0);
      const acciones = accionesPrevias.map(this._normalizarAccion.bind(this));
      const accionesPosibles = Object.keys(reglas);
      const accionesGeneradas = [];
      const finDelDia = new Date(ahora.getFullYear(), ahora.getMonth(), ahora.getDate(), 23, 59, 59, 999);
      let horaCursor = new Date(ahora);
      horaCursor.setMinutes(0);
      const tamanoBloqueMs = this._duracionAMilisegundos(duracionMinima);
      const totalBloques = Math.floor((finDelDia - ahora) / tamanoBloqueMs);
      const { usados, metas } = this._bloquesPorConcepto(reglas, acciones, totalBloques);

      while (horaCursor <= finDelDia) {
        const conceptosOrdenados = accionesPosibles
          .slice()
          .sort((a, b) => (metas[b] - usados[b]) - (metas[a] - usados[a]));

        let accionGenerada = false;

        for (const concepto of conceptosOrdenados) {
          const regla = reglas[concepto];
          const ultima = this._ultimaAccionDe(concepto, acciones.concat(accionesGeneradas));
          const puede = this._evaluarRegla(horaCursor, concepto, regla, ultima, acciones.concat(accionesGeneradas));

          if (puede && metas[concepto] > usados[concepto]) {
            const duracion = this._obtenerDuracionMinima(regla, duracionMinima);
            const nuevaAccion = {
              en_concepto: concepto,
              tiene_estado: "pendiente",
              tiene_inicio: this._formatearFecha(horaCursor),
              tiene_duracion: duracion,
              tiene_parametros: "",
              tiene_resultados: "",
              tiene_comentarios: "",
              id: this._generarIdUnico()
            };
            accionesGeneradas.push(nuevaAccion);
            const bloquesUsados = Math.round(this._duracionAMilisegundos(duracion) / 600000);
            usados[concepto] += bloquesUsados;
            horaCursor = this._avanzarTiempo(horaCursor, duracion);
            accionGenerada = true;
            break;
          }
        }

        if (!accionGenerada) {
          horaCursor = this._avanzarTiempo(horaCursor, "12min");
        }
      }

      return accionesGeneradas;
    }

    static _normalizarAccion(accion) {
      this.trace("_normalizarAccion", arguments);
      return {
        ...accion,
        _inicio: new Date(accion.tiene_inicio),
        _duracionMilisegundos: this._duracionAMilisegundos(accion.tiene_duracion)
      };
    }

    static _ultimaAccionDe(concepto, lista) {
      this.trace("_ultimaAccionDe", arguments);
      return [...lista]
        .filter(a => a.en_concepto === concepto)
        .sort((a, b) => b._inicio - a._inicio)[0];
    }

    static _evaluarRegla(hora, concepto, regla, ultima, generadas) {
      this.trace("_evaluarRegla", arguments);
      const reglas = Array.isArray(regla) ? regla : [regla];
      for (const r of reglas) {
        if (r.nunca_despues_de) {
          const ultimaOtra = this._ultimaAccionDe(r.nunca_despues_de, generadas);
          if (ultimaOtra && hora - ultimaOtra._inicio < this._duracionAMilisegundos(r.durante)) {
            return false;
          }
        }
        if (r.cada && ultima) {
          const msMin = this._duracionAMilisegundos(r.cada);
          if (hora - ultima._inicio < msMin) {
            return false;
          }
        }
      }
      return true;
    }

    static _obtenerDuracionMinima(regla, duracionPorDefecto = "12min") {
      this.trace("_obtenerDuracionMinima", arguments);
      const reglas = Array.isArray(regla) ? regla : [regla];
      for (const r of reglas) {
        if (r.minimo) return r.minimo;
      }
      return duracionPorDefecto;
    }

    static _duracionAMilisegundos(str) {
      this.trace("_duracionAMilisegundos", arguments, [str]);
      const partes = str.match(/((\d+)\s*h)?\s*((\d+)\s*min)?/i);
      const horas = partes?.[2] ? parseInt(partes[2]) : 0;
      const minutos = partes?.[4] ? parseInt(partes[4]) : 0;
      return (horas * 60 + minutos) * 60 * 1000;
    }

    static _avanzarTiempo(date, duracionStr) {
      this.trace("_avanzarTiempo", arguments, [date, duracionStr]);
      const ms = this._duracionAMilisegundos(duracionStr);
      date.setTime(date.getTime() + ms);
      return new Date(date);
    }

    static _formatearFecha(date) {
      this.trace("_formatearFecha", arguments);
      return LswTimer.utils.fromDateToDatestring(date);
    }

    static _generarIdUnico() {
      this.trace("_generarIdUnico", arguments);
      return Math.floor(Math.random() * 1e9);
    }

    static _bloquesPorConcepto(reglas, accionesTotales, bloquesDisponibles) {
      const porciones = {};
      let total = 0;

      for (const concepto in reglas) {
        const r = Array.isArray(reglas[concepto]) ? reglas[concepto] : [reglas[concepto]];
        const p = r.find(x => x.porcion)?.porcion || 0;
        porciones[concepto] = p;
        total += p;
      }

      const usados = {};
      for (const concepto in reglas) {
        usados[concepto] = accionesTotales
          .filter(a => a.en_concepto === concepto)
          .reduce((suma, a) => suma + Math.round(a._duracionMilisegundos / 600000), 0); // bloques de 10min
      }

      const metas = {};
      for (const concepto in reglas) {
        metas[concepto] = total
          ? Math.round((porciones[concepto] / total) * bloquesDisponibles)
          : 0;
      }

      return { usados, metas };
    }
  }

  return LswAgendaRandomizer;

});

// @vuebundler[Lsw_framework_components][25]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-agenda-randomizer/lsw-agenda-randomizer-reglas.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswAgendaRandomizerReglas'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswAgendaRandomizerReglas'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  const reglas = {
    "Trackeo de nmeros de conducta/agenda": [{ porcion: 500 }],
    "Trackeo de conceptos/relaciones": [{ porcion: 500 }],
    "Trackeo de ideas/notas": [{ porcion: 1 }],
    "Programacin de interfaces grficas": [{ porcion: 500 }],
    "Arquitectura por patrones": [{ porcion: 200 }],
    "Arquitectura de la realidad": [{ porcion: 200 }],
    "Arquitectura del yo": [{ porcion: 200 }],
    "Lenguajes formales": [{ porcion: 1 }],
    "Investigacin de cocina/nutricin/qumica": [{ porcion: 200 }],
    "Investigacin de nutricin": [{ porcion: 1 }],
    "Investigacin de qumica": [{ porcion: 1 }],
    "Investigacin de fsica": [{ porcion: 1 }],
    "Investigacin de matemticas": [{ porcion: 1 }],
    "Investigacin de geometra": [{ porcion: 1 }],
    "Investigacin de canvas/perspectiva": [{ porcion: 1 }],
    "Investigacin de medicina/biologa/fisiologa": [{ porcion: 100 }],
    "Investigacin de musculacin/flexibilidad": [{ porcion: 100 }],
    "Investigacin de las emociones": [{ porcion: 100 }],
    "Cocinar/Comer": [{ cada: "6h", minimo: "1h" }],
    "Pasarlo bien con la perrillo": [{ cada: "6h", minimo: "1h" }],
    "Cuidados de plantas": [{ porcion: 1 }],
    "Cuidados del hogar": [{ porcion: 1 }],
    "Actividad fsica": [{ porcion: 500 }, { nunca_despues_de: "comer", durante: "2h" }, { cada: "24h", minimo: "20min" }],
    "Optimizacin de RAM": [{ porcion: 500 }],
    "Autocontrol/Autobservacin/Autoanlisis": [{ porcion: 500 }],
    "Meditacin/Relajacin": [{ porcion: 500 }],
    "Paisajismo": [{ cada: "3h", minimo: "20min" }],
    "Dibujo 3D/Perspectiva/Geometra/Mates": [{ porcion: 1 }],
    "Dibujo artstico/anime/abstracto/esquemista/conceptualista": [{ porcion: 1 }],
    "Reflexin/Dilogo interno": [{ porcion: 500 }],
  };

  return reglas;

});

// @vuebundler[Lsw_framework_components][26]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-circuiter/async-circuit.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswCircuiter'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswCircuiter'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  /**
   * 
   * 
   * @$section: Lsw Circuiter API  LswCircuiter class

   * @type: class
   * @extends: Object
   * @vendor: lsw
   * @namespace: LswCircuiter
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: LswCircuiter class | @$section: Lsw Circuiter API  LswCircuiter class
  class AsyncCircuit {

    static create(...args) {
      return new this(...args);
    }

    constructor() {
      this.middlewares = [];
    }

    hook(callback) {
      this.middlewares.push(callback);
      return this;
    }

    prehook(callback) {
      this.middlewares.unshift(callback);
      return this;
    }

    unhook(callback) {
      const pos = this.middlewares.indexOf(callback);
      if(pos !== -1) {
        this.middlewares.splice(pos, 1);
      }
      return this;
    }

    // Funcin principal para parsear el rbol
    parse(node) {
      // Si el nodo es un array (ejecutar en paralelo)
      if (Array.isArray(node)) {
        const code = node.map(cb => this.parse(cb)).join(',');
        return `Promise.all([${code}])`; // Convertimos todo en un Promise.all
      }

      // Si es un objeto con $type y $callbacks
      if (node && typeof node === 'object') {
        Inject_middlewares: {
          for(let index__middleware=0; index__middleware<this.middlewares.length; index__middleware++) {
            const middleware = this.middlewares[index__middleware];
            const result = middleware(node);
          }
        }
        const { $type, $callbacks } = node;
        const callbacks = $callbacks.map(cb => (typeof cb === 'function' ? `(${cb.toString()})()` : this.parse(cb)));
        // Dependiendo del tipo, generamos el cdigo adecuado
        switch ($type) {
          case 'parallel':
            return `Promise.all([\n  ${callbacks.join(',')}\n  ])`; // Ejecutar en paralelo
          case 'serie':
            return `(async () => {\n  ${callbacks.map(cb => `await ${cb}`).join('; ')}\n  })()`; // Ejecutar en serie
          case 'race':
            return `Promise.race([\n  ${callbacks.join(',')}\n  ])`; // Ejecutar en carrera
          case 'sync':
            return `(() => {\n  ${callbacks.join(';\n  ')};\n  return Promise.resolve();\n  })()`; // Ejecutar sncrono
          default:
            throw new Error(`Required property $type to be one known but found ${$type} on this.parse`);
        }
      }

      // Si el nodo es una funcin, la transformamos directamente
      if (typeof node === 'function') {
        return `(${node.toString()})()`; // Convertimos la funcin en una llamada inmediata
      }

      throw new Error(`Required argument node to be of known type but found ${typeof $type} on this.parse`);
    }

    // Mtodo que ejecuta el cdigo generado por eval
    async execute(node, externalScope = {}) {
      const code = this.parse(node);
      const AsyncFunction = (async function() {}).constructor;
      const argKeys = Object.keys(externalScope).join(", ");
      const argValues = Object.values(externalScope);
      const asyncFunction = new AsyncFunction(argKeys, code);
      return await asyncFunction(...argValues); // Ejecutamos el cdigo generado con eval
    }
  }
  // @code.end: LswCircuiter class

  return AsyncCircuit;
});


// @vuebundler[Lsw_framework_components][27]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-commander/url-command.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['URLCommand'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['URLCommand'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  const isOnlyConsecutiveNumbers = function (queryParams) {
    const queryKeysSource = Object.keys(queryParams);
    const queryKeys = queryKeysSource.map(key => "" + key);
    const output = [];
    for (let index = 0; index < queryKeys.length; index++) {
      if (queryKeys.indexOf("" + index) === -1) {
        return false;
      }
      if (queryParams[index]) {
        output.push(queryParams[index]);
      } else {
        output.push(queryParams["" + index]);
      }
    }
    return output;
  };

  /**
   * 
   * 
   * @$section: Lsw Commander API  LswCommander class

   * @type: class
   * @extends: Object
   * @vendor: lsw
   * @namespace: LswCommander
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: LswCommander class | @$section: Lsw Commander API  LswCommander class
  const LswCommander = class {

    static from(...args) {
      return new this(...args);
    }

    onRun(callback, args) {
      try {
        let output = undefined;
        if (typeof this.$beforeRun === "function") {
          this.$beforeRun(...args);
        }
        output = callback(...args);
        if (typeof this.$afterRun === "function") {
          this.$afterRun(...args);
        }
        return output;
      } catch (error) {
        if (typeof this.$onError === "function") {
          const output = this.$onError(error);
          if (typeof output !== "undefined") {
            return output;
          }
        }
        throw error;
      }
    }

    constructor(handlers) {
      this.$handlers = handlers;
      this.$beforeRun = undefined;
      this.$afterRun = undefined;
      this.$onError = undefined;
      this.command = (url, queryParamsExtender = {}) => {
        if (!url) throw new Error("URL is required");
        if (typeof url !== "string") throw new Error("URL must be a string");
        if (typeof this.$handlers !== "object" || this.$handlers === null) {
          throw new Error("Handlers must be a valid object");
        }
        const [path, queryString] = url.split("?");
        const queryParams = queryString ? Object.fromEntries(new URLSearchParams(queryString).entries()) : {};
        Object.assign(queryParams, queryParamsExtender);
        const pathParts = path.split("/").filter(Boolean);
        let currentHandler = this.$handlers;
        for (const part of pathParts) {
          if (currentHandler[part] === undefined) {
            throw new Error(`Handler for path "${path}" not found`);
          }
          currentHandler = currentHandler[part];
        }
        if (typeof currentHandler !== "function") {
          throw new Error(`Handler at path "${path}" is not a function`);
        }
        const isSpreadable = isOnlyConsecutiveNumbers(queryParams);
        if (isSpreadable && isSpreadable.length) {
          return this.onRun(currentHandler, isSpreadable);
        } else if (queryParams.argumentsOrder) {
          const args = [];
          const argKeys = queryParams.argumentsOrder.split(",").map(arg => arg.trim());
          for (let index = 0; index < argKeys.length; index++) {
            const argKey = argKeys[index];
            const argValue = queryParams[argKey] || null;
            args.push(argValue);
          }
          return this.onRun(currentHandler, args);
        } else {
          return this.onRun(currentHandler, [queryParams]);
        }
      };
    }
    get run() {
      return this.command;
    }
    beforeRun(callback) {
      if (typeof callback !== "function") {
        throw new Error("Required parameter callback to be a function on beforeRun");
      }
      this.$beforeRun = callback;
    }
    afterRun(callback) {
      if (typeof callback !== "function") {
        throw new Error("Required parameter callback to be a function on afterRun");
      }
      this.$afterRun = callback;
    }
    onError(callback) {
      if (typeof callback !== "function") {
        throw new Error("Required parameter callback to be a function on onError");
      }
      this.$onError = callback;
    }
  };
  // @code.end: LswCommander class
  
  return LswCommander;
});



// @vuebundler[Lsw_framework_components][28]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-trigger/triggers-class.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['TriggersClass'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['TriggersClass'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswTriggers API | @$section: LswTriggers API  LswTriggers classes and functions
  // exported to TriggersClass
  class TriggersClass {

    static globMatch(patterns, list) {
      const matches = new Set();

      const regexes = patterns.map(pattern => {
        let regexPattern = pattern
          .replace(/[-/\\^$+?.()|[\]{}]/g, "\\$&") // Escapa caracteres especiales
          .replace(/\\\*/g, ".*")                 // '*' => cualquier cosa
        return new RegExp(`^${regexPattern}$`);
      });
      for (const item of list) {
        for (const regex of regexes) {
          if (regex.test(item)) {
            matches.add(item);
            break;
          }
        }
      }

      return Array.from(matches);
    }

    static create(...args) {
      return new this(...args);
    }

    all = {};

    findTriggerCollectionByEventAndId(event, id) {
      return LswLifecycle.hooks.all[event].filter(trigger => trigger.id === id);
    }

    register(triggerNamePattern, triggerIdentifier, triggerCallback, triggerConfigurations = {}) {
      const { priority = 0 } = triggerConfigurations; // Default priority is 0
      if (!this.all[triggerNamePattern]) {
        this.all[triggerNamePattern] = [];
      }
      
      this.all[triggerNamePattern].push({
        id: triggerIdentifier,
        callback: triggerCallback,
        priority,
      });
    }

    async emit(triggerName, parameters = {}) {
      const matchedTriggers = [];
      const allPatterns = Object.keys(this.all);

      // Encuentra patrones que coincidan con el nombre del evento
      const matchedPatterns = this.constructor.globMatch(allPatterns, [triggerName]);

      // Agrega todos los eventos coincidentes a la lista de disparos
      for (const pattern of matchedPatterns) {
        matchedTriggers.push(...this.all[pattern]);
      }

      // Ordena por prioridad descendente
      matchedTriggers.sort((a, b) => b.priority - a.priority);

      // Ejecuta los callbacks en orden
      const output = [];
      for (const trigger of matchedTriggers) {
        const result = await trigger.callback(parameters);
        output.push(result);
      }

      return output;
    }

    unregister(triggerIdentifier) {
      for (const pattern in this.all) {
        this.all[pattern] = this.all[pattern].filter(
          (trigger) => trigger.id !== triggerIdentifier
        );
        if (this.all[pattern].length === 0) {
          delete this.all[pattern]; // Limpia patrones vacos
        }
      }
    }

  }

  TriggersClass.default = TriggersClass;

  return TriggersClass;
  // @code.end: LswTriggers API

});

// @vuebundler[Lsw_framework_components][29]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database/browsie.unbundled.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window["Browsie"] = mod;
  }
  if (typeof global !== 'undefined') {
    // global["Browsie"] = mod;
  }
  if (typeof module !== 'undefined') {
    // module.exports = mod;
  }
})(function () {


  /**
   * 
   * 
   * @$section: Lsw Database API  LswDatabase class
   * @type: class
   * @extends: Object
   * @vendor: lsw
   * @namespace: LswDatabase
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: LswDatabase class | @section: Lsw Database API  LswDatabase class
  class BrowsieCheckersAPI {

    static mustBeString(obj, method = "Browsie.mustBeString", id = "?") {
      if (typeof obj !== "string") {
        throw new Error(`Required ${id} to be a string on ${method}`);
      }
    }

    static mustBeArray(obj, method = "Browsie.mustBeArray", id = "?") {
      if (!Array.isArray(obj)) {
        throw new Error(`Required ${id} to be an array on ${method}`);
      }
    }

    static mustBeObject(obj, method = "Browsie.mustBeObject", id = "?") {
      if (typeof obj !== "object") {
        throw new Error(`Required ${id} to be an object on ${method}`);
      }
    }

    static mustBeGreaterThan(obj, comparison = 0, method = "Browsie.mustBeObject", id = "?") {
      if (obj <= comparison) {
        throw new Error(`Required ${id} to be greater than ${comparison} on ${method}`);
      }
    }
  }

  class BrowsieStaticAPI extends BrowsieCheckersAPI {

    static openedConnections = [];

    static _trace = true;

    static trace(methodName, args = []) {
      // @INJECTION: from LSW
      const traceActivatedGlobally = (typeof Vue === "undefined") || (typeof Vue.prototype.$lsw === "undefined") || ((typeof Vue !== "undefined") && (typeof Vue.prototype.$lsw !== "undefined") && (Vue.prototype.$lsw.logger.$options.active));
      if (this._trace && traceActivatedGlobally) {
        console.log("[browsie][" + methodName + "]", args.length + " args: " + Array.from(args).map(arg => typeof (arg)).join(", "));
      }
    }

    static async listDatabases() {
      this.trace("Browsie.listDatabases", arguments);
      try {
        const databases = await indexedDB.databases();
        console.log('Bases de datos disponibles:', databases);
        return databases;
      } catch (error) {
        console.error('Error al obtener las bases de datos:', error);
      }
    }

    static createDatabase(dbName, schemaDefinition = null, version = 1, versionUpgrades = {}) {
      this.trace("Browsie.createDatabase", arguments);
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, version);
        request.onsuccess = () => {
          console.log(`[SUCCESS] Database "${dbName}" created/opened successfully.`);
          request.result.close();
          resolve(request.result);
        };
        request.onerror = (error) => {
          console.error(`[ERROR] Failed to create/open database "${dbName}":`, error);
          reject(error);
        };
        request.onupgradeneeded = async (event) => {
          const db = event.target.result;
          console.log(`[UPGRADE] Upgrading database "${dbName}" from version ${event.oldVersion} to ${version}.`);
          // Si hay una definicin de esquema inicial, crear los almacenes e ndices
          if (schemaDefinition && event.oldVersion === 0) {
            console.log("[SCHEMA] Applying initial schema definition.");
            Object.keys(schemaDefinition).forEach((storeName) => {
              if (!db.objectStoreNames.contains(storeName)) {
                const objectStore = db.createObjectStore(storeName, {
                  keyPath: "id",
                  autoIncrement: true,
                });
                if (!Array.isArray(schemaDefinition[storeName])) {
                  console.log(schemaDefinition);
                  throw new Error(`Required property schemaDefinition.${storeName} to be an array on LswDatabase.createDatabase`);
                }
                schemaDefinition[storeName].forEach((index) => {
                  const indexName = index.replace(/^\!/, "");
                  objectStore.createIndex(indexName, indexName, {
                    unique: index.startsWith("!")
                  });
                });
              }
            });
          }
          // Aplicar las transformaciones de esquema para cada versin
          for (let v = event.oldVersion + 1; v <= version; v++) {
            if (versionUpgrades[v]) {
              console.log(`[VERSION ${v}] Applying upgrade function.`);
              await versionUpgrades[v](db);
            } else {
              console.log(`[VERSION ${v}] No upgrade function defined.`);
            }
          }
        };
      });
    }

    static async exportDatabase(dbName) {
      this.trace("Browsie.exportDatabase", arguments);
      const schema = await this.getSchema(dbName);
      const storeIds = Object.keys(schema);
      const allData = {};
      for(let indexStore=0; indexStore<storeIds.length; indexStore++) {
        const storeId = storeIds[indexStore];
        const storeData = await this.getAllDataFromStore(dbName, storeId);
        allData[storeId] = storeData;
      }
      return allData;
    }

    static async importToDatabase(dbName, storesData = {}) {
      this.trace("Browsie.importToDatabase", arguments);
      const storeIds = Object.keys(storesData);
      const connection = await this.open(dbName);
      for(let indexStore=0; indexStore<storeIds.length; indexStore++) {
        const storeId = storeIds[indexStore];
        const allData = storesData[storeId];
        console.log(`[*] Importing store ${storeId}`);
        await connection.insertMany(storeId, allData);
      }
    }

    // Obtener todos los datos de un store
    static async getAllDataFromStore(dbName, storeName) {
      this.trace("Browsie.getAllDataFromStore", arguments);
      return await new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName);

        request.onsuccess = (event) => {
          const db = event.target.result;
          const transaction = db.transaction(storeName, 'readonly');
          const store = transaction.objectStore(storeName);

          const getAllRequest = store.getAll();
          getAllRequest.onsuccess = () => resolve(getAllRequest.result);
          getAllRequest.onerror = () => {
            db.close();
            reject(new Error('Error al obtener los datos del store'));
          };
        };

        request.onerror = () => {
          reject(new Error('Error al abrir la base de datos'));
        };
      });
    }

    // Insertar datos en un store
    static async insertDataIntoStore(dbName, storeName, data) {
      this.trace("Browsie.insertDataIntoStore", arguments);
      return await new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName);

        request.onsuccess = (event) => {
          const db = event.target.result;
          const transaction = db.transaction(storeName, 'readwrite');
          const store = transaction.objectStore(storeName);

          data.forEach(item => store.add(item));

          transaction.oncomplete = () => resolve();
          transaction.onerror = () => {
            db.close();
            reject(new Error('Error al insertar los datos en el store'));
          };
        };

        request.onerror = () => {
          reject(new Error('Error al abrir la base de datos'));
        };
      });
    }

    // Eliminar una base de datos
    static deleteDatabase(dbName) {
      this.trace("Browsie.deleteDatabase", arguments);
      return new Promise((resolve, reject) => {
        const request = indexedDB.deleteDatabase(dbName);

        request.onblocked = () => {
          // db.close();
          reject(new Error("Error al eliminar la base de datos porque est bloqueada"));
        };
        request.onsuccess = () => resolve();
        request.onerror = () => {
          // db.close();
          reject(new Error('Error al eliminar la base de datos'));
        };
      }).then(() => {
        console.log(`[!] Base de datos ${dbName} eliminada correctamente.`);
      });
    }

    static async getSchema(dbName) {
      this.trace("Browsie.getSchema", arguments);
      let db = undefined;
      try {
        // Abrir la base de datos en modo solo lectura
        const request = indexedDB.open(dbName);

        db = await new Promise((resolve, reject) => {
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = () => {
            reject(new Error('Error al abrir la base de datos'));
          };
        });

        // Construir el esquema a partir de los almacenes
        const schema = {};
        const objectStoreNames = Array.from(db.objectStoreNames); // Lista de stores

        objectStoreNames.forEach(storeName => {
          const transaction = db.transaction(storeName, 'readonly');
          const store = transaction.objectStore(storeName);

          const storeInfo = {
            keyPath: store.keyPath,
            autoIncrement: store.autoIncrement,
            indexes: []
          };

          // Recorrer los ndices del store
          const indexNames = Array.from(store.indexNames); // Lista de ndices
          indexNames.forEach(indexName => {
            const index = store.index(indexName);
            storeInfo.indexes.push({
              name: index.name,
              keyPath: index.keyPath,
              unique: index.unique,
              multiEntry: index.multiEntry
            });
          });

          schema[storeName] = storeInfo;
        });

        return schema;
      } catch (error) {
        console.error('Error al obtener el esquema:', error);
        throw error;
      } finally {
        if (db) {
          db.close();
        }
      }
    }

    static async pickRow(databaseId, tableId, rowId) {
      this.trace("Browsie.pickRow", arguments);
      $ensure(databaseId).type("string");
      $ensure(tableId).type("string");
      $ensure(rowId).type("number");
      let connection = undefined;
      try {
        connection = await this.open(databaseId);
        const rows = await connection.selectMany(tableId, v => v.id === rowId);
        if (rows.length === 1) {
          return rows[0];
        } else if (rows.length === 0) {
          return undefined;
        }
      } catch (error) {
        throw error;
      } finally {
        try {
          await connection.close();
        } catch (error) {
          console.log("Could not close connection on picking row");
        }
      }
    }

  }

  class BrowsieTriggersAPI extends BrowsieStaticAPI {

    static globMatch = TriggersClass.globMatch;

    triggers = new TriggersClass();

  }


  class BrowsieCrudAPI extends BrowsieTriggersAPI {

    static async open(...args) {
      this.trace("Browsie.open", arguments);
      const db = new this(...args);
      await db.open();
      return db;
    }

    // Constructor que abre la base de datos
    constructor(dbName, trace = false) {
      super();
      this.$dbName = dbName;
      this.$db = null;
      this.$innerSchema = null;
      this._trace = trace;
    }

    getInnerSchema() {
      this.constructor.trace("browsie.getInnerSchema", arguments);
      return this.$innerSchema;
    }

    setInnerSchema(innerSchema) {
      this.constructor.trace("browsie.setInnerSchema", arguments);
      if (!(innerSchema instanceof LswSchema)) {
        throw new Error(`Required parameter innerSchema to be an instance of LswSchema on browsie.setInnerSchema`);
      }
      this.$innerSchema = innerSchema;
    }

    // Abre la base de datos
    open() {
      this.constructor.trace("browsie.open", arguments);
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.$dbName);

        request.onsuccess = () => {
          this.$db = request.result;
          resolve(this.$db);
        };
        request.onerror = (error) => reject(this._expandError(error, `Error on browsie.open operation over database ${this.$dbName}: `));
      });
    }

    close(...args) {
      this.constructor.trace("browsie.close", arguments);
      return this.$db.close(...args);
    }

    // Mtodo para seleccionar 1 elemento de un store con un filtro
    select(store, filter = {}) {
      this.constructor.trace("browsie.select", arguments);
      this.triggers.emit(`crud.select.one.${store}`, { store, filter });
      return new Promise((resolve, reject) => {
        const transaction = this.$db.transaction(store, 'readonly');
        const objectStore = transaction.objectStore(store);
        const request = objectStore.getAll();
        request.onsuccess = () => {
          const result = request.result.filter(item => {
            return Object.keys(filter).every(key => item[key] === filter[key]);
          });
          resolve(result);
        };
        request.onerror = (error) => reject(this._expandError(error, `Error on browsie.select operation over store ${store}: `));
      });
    }

    // Mtodo para insertar un solo item en un store
    insert(store, item) {
      this.constructor.trace("browsie.insert", arguments);
      this.triggers.emit(`crud.insert.one.${store}`, { store, item });
      return new Promise((resolve, reject) => {
        const transaction = this.$db.transaction(store, 'readwrite');
        const objectStore = transaction.objectStore(store);
        const request = objectStore.add(item);

        request.onsuccess = () => resolve(request.result);
        request.onerror = (error) => reject(this._expandError(error, `Error on browsie.insert operation over store ${store}: `));
      });
    }

    // Mtodo para actualizar un item en un store
    update(store, id, item) {
      this.constructor.trace("browsie.update", arguments);
      this.triggers.emit(`crud.update.one.${store}`, { store, id, item });
      return new Promise((resolve, reject) => {
        const transaction = this.$db.transaction(store, 'readwrite');
        const objectStore = transaction.objectStore(store);
        const request = objectStore.put({ ...item, id });

        request.onsuccess = () => resolve(request.result);
        request.onerror = (error) => reject(this._expandError(error, `Error on browsie.update operation over store ${store}: `));
      });
    }

    // Mtodo tipo upsert: que cambia solo los campos que le proporcionas (hace entre 1 y 2 queries)
    async overwrite(store, idOrItem, item) {
      this.constructor.trace("browsie.overwrite", arguments);
      this.triggers.emit(`crud.overwrite.one.${store}`, { store, idOrItem, item });
      const isId = (typeof idOrItem === "string") || (typeof idOrItem === "number");
      const isItem = typeof idOrItem === "object";
      let previousItem = undefined;
      if (isItem) {
        previousItem = idOrItem;
      } else if (isId) {
        const matches = await this.select(store, it => it.id === idOrItem);
        if (matches.length === 0) {
          throw new Error(`Zero rows on overwrite operator. Cannot overwrite a row that does not exist on browsie.overwrite`);
        } else if (matches.length > 1) {
          throw new Error(`Multiple rows on overwrite operation. Cannot overwrite multiple rows. Ensure store ${store} is using index id as unique value to complete this operation`);
        }
        previousItem = matches[0];
      } else {
        throw new Error(`Required parameter idOrItem to be a string or an object on browsie.overwrite`);
      }
      const newItem = Object.assign({}, previousItem, item);
      return await this.update(store, newItem.id, newItem);
    }

    // Mtodo para eliminar un item de un store por ID
    delete(store, id) {
      this.constructor.trace("browsie.delete", arguments);
      this._ensureIntegrity(store, id);
      this.triggers.emit(`crud.delete.one.${store}`, { store, id });
      return new Promise((resolve, reject) => {
        const transaction = this.$db.transaction(store, 'readwrite');
        const objectStore = transaction.objectStore(store);
        const request = objectStore.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = (error) => reject(this._expandError(error, `Error on browsie.delete operation over store ${store}: `));
      });
    }

    _getSchemaEntityByStoreName(store) {
      this.constructor.trace("browsie._ensureIntegrity", arguments);
      const innerSchema = this.getInnerSchema().$schema;
      const tableIds = Object.keys(innerSchema.hasTables);
      Iterating_tables:
      for (let indexTables = 0; indexTables < tableIds.length; indexTables++) {
        const tableId = tableIds[indexTables];
        if (tableId === store) {
          return innerSchema.hasTables[tableId];
        }
      }
      return undefined;
    }

    _ensureIntegrity(store, id) {
      this.constructor.trace("browsie._ensureIntegrity", arguments);
      const innerSchema = this.getInnerSchema().$schema;
      const tableIds = Object.keys(innerSchema.hasTables);
      const sourceEntity = innerSchema.hasTables[store];
      const sourceEntityId = sourceEntity.hasEntityId;
      const boundColumns = [];
      Iterating_tables:
      for (let indexTables = 0; indexTables < tableIds.length; indexTables++) {
        const tableId = tableIds[indexTables];
        const tableData = innerSchema.hasTables[tableId];
        const columnIds = Object.keys(tableData.hasColumns);
        Iterating_columns:
        for (let indexColumns = 0; indexColumns < columnIds.length; indexColumns++) {
          const columnId = columnIds[indexColumns];
          const columnData = tableData.hasColumns[columnId];
          When_it_has_references: {
            if (!columnData.refersTo) {
              break When_it_has_references;
            }
            const { entity: schemaEntityId, property: entityColumnId, constraint = true } = columnData.refersTo;
            if (!constraint) {
              break When_it_has_references;
            }
            const isSameEntity = schemaEntityId === sourceEntityId;
            if (!isSameEntity) {
              break When_it_has_references;
            }
            boundColumns.push({
              source: [store, entityColumnId],
              mustCheck: [tableId, columnId]
            });
          }
        }
      }
      console.log(`BOUND COLUMNS to ${store}:`, boundColumns);
    }

    _expandError(errorObject, baseMessage = false) {
      this.constructor.trace("browsie._expandError", arguments);
      let error = errorObject;
      if (errorObject instanceof Error) {
        error = errorObject;
      } else if (errorObject.target && errorObject.target.error) {
        error = errorObject.target.error;
      } else {
        error = new Error(errorObject);
      }
      if (baseMessage) {
        const errorTemp = new Error(error.message ?? error);
        Object.assign(errorTemp, error);
        errorTemp.message = baseMessage + errorTemp.message;
        error = errorTemp;
      }
      return error;
    }

    // Mtodo para seleccionar elementos de un store con un filtro
    select(store, filter) {
      this.constructor.trace("browsie.select", arguments);
      this.triggers.emit(`crud.select.one.${store}`, { store, filter });
      return new Promise((resolve, reject) => {
        const transaction = this.$db.transaction(store, 'readonly');
        const objectStore = transaction.objectStore(store);
        const request = objectStore.getAll();

        request.onsuccess = () => {
          const result = request.result.filter(item => {
            try {
              return filter(item);
            } catch (error) {
              console.error("Error arised from filter callback on browsie.select");
              return false;
            }
          });
          resolve(result);
        };
        request.onerror = (error) => reject(this._expandError(error, `Error on browsie.select operation over store ${store}: `));
      });
    }

    selectMany(store, filterFn = i => true) {
      this.constructor.trace("browsie.selectMany", arguments);
      this.triggers.emit(`crud.select.many.${store}`, { store, filterFn });
      return new Promise((resolve, reject) => {
        const transaction = this.$db.transaction(store, 'readonly');
        const objectStore = transaction.objectStore(store);
        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria
        const results = [];
        request.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            let isAccepted = undefined;
            try {
              isAccepted = filterFn(cursor.value);
            } catch (error) {
              console.error(`Silent error arised from filter callback on browsie.selectMany against store ${store}`, error);
            }
            if (isAccepted) { // Aplica la funcin de filtro
              results.push(cursor.value);
            }
            cursor.continue(); // Avanza al siguiente registro
          } else {
            resolve(results); // Se termin el recorrido
          }
        };
        request.onerror = (error) =>
          reject(this._expandError(error, `Error on browsie.selectMany operation over store ${store}: `));
      });
    }

    // Mtodo para insertar varios items en un store
    insertMany(store, items) {
      this.constructor.trace("browsie.insertMany", arguments);
      this.triggers.emit(`crud.insert.many.${store}`, { store, items });
      this.constructor.mustBeString(store, "insertMany", "arguments[0]");
      this.constructor.mustBeArray(items, "insertMany", "arguments[1]");
      return new Promise((resolve, reject) => {
        if (items.length === 0) {
          return resolve(false);
        }
        const transaction = this.$db.transaction(store, 'readwrite');
        const objectStore = transaction.objectStore(store);
        let insertedCount = 0;
        items.forEach(item => {
          const request = objectStore.add(item);
          request.onsuccess = () => {
            insertedCount++;
            if (insertedCount === items.length) resolve();
          };
          request.onerror = (error) => reject(this._expandError(error, `Error on browsie.insertMany operation over store ${store} inserting ${items.length} items: `));
        });
      });
    }

    // Mtodo para actualizar varios items en un store
    updateMany(store, filter, item) {
      this.constructor.trace("browsie.updateMany", arguments);
      this.triggers.emit(`crud.update.many.${store}`, { store, filter, item });
      return new Promise((resolve, reject) => {
        const transaction = this.$db.transaction(store, 'readwrite');
        const objectStore = transaction.objectStore(store);
        const request = objectStore.openCursor();
        let updatedCount = 0;
        request.onsuccess = () => {
          const cursor = request.result;
          if (cursor) {
            if (Object.keys(filter).every(key => cursor.value[key] === filter[key])) {
              const updatedItem = { ...cursor.value, ...item };
              const updateRequest = cursor.update(updatedItem);
              updateRequest.onsuccess = () => {
                updatedCount++;
                if (updatedCount === cursor.value.length) resolve();
              };
            }
            cursor.continue();
          }
        };

        request.onerror = (error) => reject(this._expandError(error, `Error on browsie.updateMany operation over store ${store}: `));
      });
    }

    // Mtodo a tipo upsertAll para llenar los valores pero dejar los que no
    async overwriteMany(store, filter, item) {
      this.constructor.trace("browsie.overwriteMany", arguments);
      this.triggers.emit(`crud.overwrite.many.${store}`, { store, filter, item });
      const allMatches = await this.selectMany(store, filter);
      const allResults = [];
      for (let indexRow = 0; indexRow < allMatches.length; indexRow++) {
        const row = allMatches[indexRow];
        const result = await this.overwrite(store, row, item);
        allResults.push(result);
      }
      return allResults;
    }

    // Mtodo para eliminar varios items de un store segn un filtro
    deleteMany(store, filterCallback) {
      this.constructor.trace("browsie.deleteMany", arguments);
      this.triggers.emit(`crud.delete.many.${store}`, { store, filterCallback });
      return new Promise((resolve, reject) => {
        const transaction = this.$db.transaction(store, 'readwrite');
        const objectStore = transaction.objectStore(store);
        const request = objectStore.openCursor();
        let deletedCount = 0;
        request.onsuccess = () => {
          const cursor = request.result;
          if (!cursor) {
            return resolve();
          }
          const isAccepted = filterCallback(cursor.value);
          if (isAccepted) {
            const deleteRequest = cursor.delete();
            deleteRequest.onsuccess = () => {
              deletedCount++;
              if (deletedCount === cursor.value.length) {
                return resolve();
              }
            };
            deleteRequest.onerror = (error) => reject(this._expandError(error, `Error on browsie.deleteMany operation over store ${store} and id ${cursor.value.id}: `));
          }
          cursor.continue();
        };
        request.onerror = (error) => reject(this._expandError(error, `Error on browsie.deleteMany operation over store ${store}: `));
      });
    }
  }

  // @TOCONTINUEFROM
  class BrowsieMigration {

    static from(...args) {
      return new this(...args);
    }

    static createTable(arg) {
      return this.from({
        operation: "createTable",
        parameters: arg
      });
    }

    static renameTable(arg) {
      return this.from({
        operation: "renameTable",
        parameters: arg
      });
    }

    static deleteTable(arg) {
      return this.from({
        operation: "deleteTable",
        parameters: arg
      });
    }

    static createColumn(arg) {
      return this.from({
        operation: "createColumn",
        parameters: arg
      });
    }

    static renameColumn(arg) {
      return this.from({
        operation: "renameColumn",
        parameters: arg
      });
    }

    static deleteColumn(arg) {
      return this.from({
        operation: "deleteColumn",
        parameters: arg
      });
    }

    constructor(options = {}) {
      LswDatabase.trace("LswDatabaseMigration.constructor");
      const { operation, parameters } = options;
      this.$validateOperation(operation);
      this.$validateParameters(parameters);
      this.operation = operation;
      this.parameters = parameters;
      this.config = {
        temporaryDatabase: this.parameters.fromDatabase + "_" + this.$getRandomString(5),
      };
      this.migrated = false;
    }

    $getRandomString(len = 10) {
      LswDatabase.trace("LswDatabaseMigration.$getRandomString");
      const alphabet = "abcdefghijklmnopqrstuvwxyz".split("");
      let out = "";
      while (out.length < len) {
        out += alphabet[Math.floor(Math.random() * alphabet.length)];
      }
      return out;
    };

    $validateOperation(operation) {
      LswDatabase.trace("LswDatabaseMigration.$validateOperation");
      if (["createTable", "renameTable", "deleteTable", "createColumn", "renameColumn", "deleteColumn", "cloneDatabase", "moveDatabase"].indexOf(operation) === -1) {
        throw new Error("Required operation to be a valid operation on LswDatabaseMigration.$validateOperation");
      }
    }

    $validateParameters(parameters) {
      LswDatabase.trace("LswDatabaseMigration.$validateParameters");
      if (typeof parameters !== "object") {
        throw new Error("Required parameters to be an object on LswDatabaseMigration.$validateParameters");
      }
    }

    async $$transferBackTemporaryDatabase() {
      await LswDatabase.deleteDatabase(this.parameters.fromDatabase);
      await this.$replicateSchema({
        fromDatabase: this.config.temporaryDatabase,
        toDatabase: this.parameters.fromDatabase,
      });
      await this.$populateDatabase({
        fromDatabase: this.config.temporaryDatabase,
        toDatabase: this.parameters.fromDatabase,
      });
      await LswDatabase.deleteDatabase(this.config.temporaryDatabase);
    }

    commit() {
      LswDatabase.trace("LswDatabaseMigration.commit");
      return this["$$" + this.operation].call(this).finally(() => {
        this.migrated = true;
      });
    }

    $validateCreateTableParameters() {
      LswDatabase.trace("LswDatabaseMigration.$validateCreateTableParameters");
      if (typeof this.parameters.fromDatabase !== "string") {
        throw new Error("Required parameters.fromDatabase to be a string on LswDatabaseMigration.$validateCreateTableParameters");
      }
      if (typeof this.parameters.table !== "string") {
        throw new Error("Required parameters.table to be a string on LswDatabaseMigration.$validateCreateTableParameters");
      }
      if (typeof this.parameters.tableDefinition !== "object") {
        throw new Error("Required parameters.tableDefinition to be an object on LswDatabaseMigration.$validateCreateTableParameters");
      }
    }

    async $$cloneDatabase() {
      LswDatabase.trace("LswDatabaseMigration.$$cloneDatabase");
      await this.$replicateSchema({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.parameters.toDatabase,
      });
      await this.$populateDatabase({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.parameters.toDatabase,
      });
    }

    async $$moveDatabase() {
      LswDatabase.trace("LswDatabaseMigration.$$moveDatabase");
      await this.$replicateSchema({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.parameters.toDatabase,
      });
      await this.$populateDatabase({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.parameters.toDatabase,
      });
      await LswDatabase.deleteDatabase(this.parameters.fromDatabase);
    }

    async $$createTable() {
      LswDatabase.trace("LswDatabaseMigration.$$createTable");
      this.$validateCreateTableParameters();
      await this.$replicateSchema({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        onAlterSchema: schema => {
          schema[this.parameters.table] = this.parameters.tableDefinition;
          return schema;
        },
      });
      await this.$populateDatabase({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        onMapTableId: false,
        onMapColumnId: false,
      });
      await this.$$transferBackTemporaryDatabase();
    }

    $validateDeleteTableParameters() {
      LswDatabase.trace("LswDatabaseMigration.$validateDeleteTableParameters");
      if (typeof this.parameters.fromDatabase !== "string") {
        throw new Error("Required parameters.fromDatabase to be a string on LswDatabaseMigration.$validateDeleteTableParameters");
      }
      if (typeof this.parameters.table !== "string") {
        throw new Error("Required parameters.table to be a string on LswDatabaseMigration.$validateDeleteTableParameters");
      }
    }

    async $$deleteTable() {
      LswDatabase.trace("LswDatabaseMigration.$$deleteTable");
      this.$validateDeleteTableParameters();
      await this.$replicateSchema({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        onAlterSchema: schema => {
          delete schema[this.parameters.table];
          return schema;
        },
      });
      await this.$populateDatabase({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        onMapTableId: false,
        onMapColumnId: false,
      });
      await this.$$transferBackTemporaryDatabase();
    }

    $validateRenameTableParameters() {
      LswDatabase.trace("LswDatabaseMigration.$validateRenameTableParameters");
      if (typeof this.parameters.fromDatabase !== "string") {
        throw new Error("Required parameters.fromDatabase to be a string on LswDatabaseMigration.$validateDeleteTableParameters");
      }
      if (typeof this.parameters.tableSource !== "string") {
        throw new Error("Required parameters.tableSource to be a string on LswDatabaseMigration.$validateDeleteTableParameters");
      }
      if (typeof this.parameters.tableDestination !== "string") {
        throw new Error("Required parameters.tableDestination to be a string on LswDatabaseMigration.$validateDeleteTableParameters");
      }
    }

    async $$renameTable() {
      LswDatabase.trace("LswDatabaseMigration.$$renameTable");
      this.$validateRenameTableParameters();
      const currentSchema = await LswDatabase.getSchema(this.parameters.fromDatabase);
      await this.$replicateSchema({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        onAlterSchema: schema => {
          delete schema[this.parameters.tableSource];
          const tableInput = this.$adaptSchemaTableAsSchemaDefinition(currentSchema[this.parameters.tableSource]);
          schema[this.parameters.tableDestination] = tableInput;
          return schema;
        },
      });
      await this.$populateDatabase({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        onMapTableId: tableId => {
          return this.parameters.tableDestination;
        },
        onMapColumnId: false,
      });
      await this.$$transferBackTemporaryDatabase();
    }

    $validateCreateColumnParameters() {
      LswDatabase.trace("LswDatabaseMigration.$validateCreateColumnParameters");
      if (typeof this.parameters.fromDatabase !== "string") {
        throw new Error("Required parameters.fromDatabase to be a string on LswDatabaseMigration.$validateCreateColumnParameters");
      }
      if (typeof this.parameters.table !== "string") {
        throw new Error("Required parameters.table to be a string on LswDatabaseMigration.$validateCreateColumnParameters");
      }
      if (typeof this.parameters.column !== "string") {
        throw new Error("Required parameters.column to be a string on LswDatabaseMigration.$validateCreateColumnParameters");
      }
      if (typeof this.parameters.columnDefinition !== "object") {
        throw new Error("Required parameters.columnDefinition to be an object on LswDatabaseMigration.$validateCreateColumnParameters");
      }
    }

    async $$createColumn() {
      LswDatabase.trace("LswDatabaseMigration.$$createColumn");
      this.$validateCreateColumnParameters();
      const isUnique = !!this.parameters.columnDefinition.isUnique;
      const columnSymbol = `${isUnique ? "!" : ""}${this.parameters.column}`;
      await this.$replicateSchema({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        table: this.parameters.table,
        onAlterSchema: schema => {
          schema[this.parameters.table].push(columnSymbol);
          return schema;
        },
      });
      await this.$populateDatabase({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        onMapTableId: false,
        onMapColumnId: false,
      });
      await this.$$transferBackTemporaryDatabase();
    }

    $validateDeleteColumnParameters() {
      LswDatabase.trace("LswDatabaseMigration.$validateDeleteColumnParameters");
      if (typeof this.parameters.fromDatabase !== "string") {
        throw new Error("Required parameters.fromDatabase to be a string on LswDatabaseMigration.$validateDeleteColumnParameters");
      }
      if (typeof this.parameters.table !== "string") {
        throw new Error("Required parameters.table to be a string on LswDatabaseMigration.$validateDeleteColumnParameters");
      }
      if (typeof this.parameters.column !== "string") {
        throw new Error("Required parameters.column to be a string on LswDatabaseMigration.$validateDeleteColumnParameters");
      }
    }

    async $$deleteColumn() {
      LswDatabase.trace("LswDatabaseMigration.$$deleteColumn");
      this.$validateDeleteColumnParameters();
      await this.$replicateSchema({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        onAlterSchema: schema => {
          console.log(schema);
          const columnPosition = schema[this.parameters.table].indexOf(this.parameters.column);
          schema[this.parameters.table].splice(columnPosition, 1);
          return schema;
        },
      });
      await this.$populateDatabase({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        // !@TOCONFIGURE: $$deleteColumn needs a specific hook (or none).
        onMapTableId: false,
        onMapColumnId: false,
      });
      await this.$$transferBackTemporaryDatabase();
    }

    $validateRenameColumnParameters() {
      LswDatabase.trace("LswDatabaseMigration.$validateRenameColumnParameters");
      if (typeof this.parameters.fromDatabase !== "string") {
        throw new Error("Required parameters.fromDatabase to be a string on LswDatabaseMigration.$validateRenameColumnParameters");
      }
      if (typeof this.parameters.table !== "string") {
        throw new Error("Required parameters.table to be a string on LswDatabaseMigration.$validateRenameColumnParameters");
      }
      if (typeof this.parameters.columnSource !== "string") {
        throw new Error("Required parameters.columnSource to be a string on LswDatabaseMigration.$validateRenameColumnParameters");
      }
      if (typeof this.parameters.columnDestination !== "string") {
        throw new Error("Required parameters.columnDestination to be a string on LswDatabaseMigration.$validateRenameColumnParameters");
      }
    }

    async $$renameColumn() {
      LswDatabase.trace("LswDatabaseMigration.$$renameColumn");
      this.$validateRenameColumnParameters();
      await this.$replicateSchema({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        onAlterSchema: schema => {
          console.log(schema);
          const columnPosition = schema[this.parameters.table].indexOf(this.parameters.columnSource);
          schema[this.parameters.table].splice(columnPosition, 1);
          schema[this.parameters.table].push(this.parameters.columnDestination);
          return schema;
        },
      });
      await this.$populateDatabase({
        fromDatabase: this.parameters.fromDatabase,
        toDatabase: this.config.temporaryDatabase,
        onMapTableId: false,
        onMapColumnId: (columnId) => {
          return columnId;
        },
      });
      await this.$$transferBackTemporaryDatabase();
    }

    $adaptSchemaAsSchemaDefinition(schemaDefinition) {
      const output = {};
      const tableIds = Object.keys(schemaDefinition);
      for (let index = 0; index < tableIds.length; index++) {
        const storeId = tableIds[index];
        const tableDefinition = schemaDefinition[storeId];
        const columns = tableDefinition.indexes;
        if (!(storeId in output)) {
          output[storeId] = [];
        }
        for (let indexColumn = 0; indexColumn < columns.length; indexColumn++) {
          const column = columns[indexColumn];
          const columnId = column.name;
          const columnInput = this.$adaptSchemaColumnAsSchemaDefinition(column, columnId);
          output[storeId].push(columnInput);
        }
      }
      return output;
    }

    $adaptSchemaTableAsSchemaDefinition(tableDefinition) {
      const output = [];
      const columns = tableDefinition.indexes;
      for (let indexColumn = 0; indexColumn < columns.length; indexColumn++) {
        const column = columns[indexColumn];
        const columnId = column.name;
        const columnInput = this.$adaptSchemaColumnAsSchemaDefinition(column, columnId);
        output.push(columnInput);
      }
      return output;
    }

    $adaptSchemaColumnAsSchemaDefinition(column, columnId) {
      if (column.unique) {
        return "!" + columnId;
      } else {
        return columnId;
      }
    }

    async $replicateSchema(scenario) {
      LswDatabase.trace("LswDatabaseMigration.$replicateSchema");
      const { fromDatabase, toDatabase, onAlterSchema } = scenario;
      console.log(` Replicating database from ${fromDatabase} to ${toDatabase} on LswDatabaseMigration.$replicateSchema`);
      const schemaDefinition = await LswDatabase.getSchema(fromDatabase);
      const schemaInput = this.$adaptSchemaAsSchemaDefinition(schemaDefinition);
      let alteredSchema = schemaInput;
      if (onAlterSchema) {
        alteredSchema = onAlterSchema(schemaInput);
        if (typeof alteredSchema === "undefined") {
          throw new Error("Required onAlterSchema to return an object on LswDatabaseMigration.$replicateSchema")
        }
      }
      console.log("Replicated schema:", alteredSchema);
      await LswDatabase.createDatabase(toDatabase, alteredSchema);
    }

    async $populateDatabase(scenario) {
      LswDatabase.trace("LswDatabaseMigration.$populateDatabase");
      const { fromDatabase, toDatabase, onMapTableId = false, onMapColumnId = false } = scenario;
      console.log(` Populating database from ${fromDatabase} to ${toDatabase} on LswDatabaseMigration.$populateDatabase`);
      const schemaDefinition = await LswDatabase.getSchema(fromDatabase);
      const tableIds = Object.keys(schemaDefinition);
      let fromConnection = undefined;
      let toConnection = undefined;
      let indexTable = 0;
      let indexColumn = 0;
      let tableId = undefined;
      let alteredTableId = undefined;
      try {
        fromConnection = new LswDatabase(fromDatabase);
        toConnection = new LswDatabase(toDatabase);
        await fromConnection.open();
        await toConnection.open();
        for (indexTable = 0; indexTable < tableIds.length; indexTable++) {
          tableId = tableIds[indexTable];
          console.log("table:", tableId);
          Transfering_tables: {
            console.log(` Transfering table ${tableId} on LswDatabaseMigration.$populateDatabase`);
            let allRows = await fromConnection.selectMany(tableId, v => true);
            console.log("[*] Getting table id");
            alteredTableId = tableId;
            if (onMapTableId) {
              alteredTableId = onMapTableId(tableId);
            }
            console.log("[*] Getting column id");
            if (onMapColumnId) {
              allRows = allRows.reduce((output, row) => {
                const allKeys = Object.keys(row);
                const alteredRow = {};
                for (let indexKeys = 0; indexKeys < allKeys.length; indexKeys++) {
                  console.log("column:", indexKeys);
                  const columnId = allKeys[indexKeys];
                  const alteredColumnId = onMapColumnId(columnId, tableId, alteredTableId, {
                    fromConnection,
                    toConnection
                  }) || columnId;
                  alteredRow[alteredColumnId] = row[columnId];
                }
                output.push(alteredRow);
                return output;
              }, []);
            }
            console.log("[*] Got:", alteredTableId, allRows);
            await toConnection.insertMany(alteredTableId, allRows);
            console.log("What??? 444")
          }
        }
      } catch (error) {
        console.log(` Error while populating database on table ${tableId || "-"} (alias ${alteredTableId}):`, error);
      } finally {
        try {
          await fromConnection.close();
        } catch (error) {
          console.log(error);
        }
        try {
          await toConnection.close();
        } catch (error) {
          console.log(error);
        }
        console.log(`[*] Database ${toDatabase} population finished successfully.`);
      }
    }

  }

  class LswDatabaseMigration extends BrowsieMigration {

  }

  LswDatabaseMigration.default = LswDatabaseMigration;
  window.LswDatabaseMigration = LswDatabaseMigration;
  window.BrowsieMigration = BrowsieMigration;

  class BrowsieMigrable extends BrowsieCrudAPI {

    static migration = LswDatabaseMigration;

  }

  window.Browsie = BrowsieMigrable;
  Browsie.default = BrowsieMigrable;

  /* Extended API */

  class LswDatabase extends BrowsieMigrable {

    class = this.constructor;

  }

  LswDatabase.default = LswDatabase;
  window.LswDatabase = LswDatabase;
  // @code.end: LswDatabase class

  return LswDatabase;

});

// @vuebundler[Lsw_framework_components][30]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database-query-language/browsie-script.js
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root) {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { Start: peg$parseStart },
        peg$startRuleFunction  = peg$parseStart,

        peg$c0 = function(sentence) { return sentence; },
        peg$c1 = function(value, appends) { return { $type:"value", value, appends } },
        peg$c2 = "#",
        peg$c3 = peg$literalExpectation("#", false),
        peg$c4 = function() { return { $type: "injected parameter", value: text() } },
        peg$c5 = "?",
        peg$c6 = peg$literalExpectation("?", false),
        peg$c7 = function(token1, table, filters, token2) { return { $action: "select", table, filters } },
        peg$c8 = "+",
        peg$c9 = peg$literalExpectation("+", false),
        peg$c10 = function(token1, table, token2, data) { return { $action: "insert", data } },
        peg$c11 = "=",
        peg$c12 = peg$literalExpectation("=", false),
        peg$c13 = function(token1, table, filters, token3, value) { return { $action: "update", table, filters, value } },
        peg$c14 = "-",
        peg$c15 = peg$literalExpectation("-", false),
        peg$c16 = function(token1, table, token2, filters) { return { $action: "delete", table, filters } },
        peg$c17 = ":",
        peg$c18 = peg$literalExpectation(":", false),
        peg$c19 = function(token1, filter) { return filter },
        peg$c20 = function(src, ops) { return { $type: "logical and/or operator", src, ops } },
        peg$c21 = function(op, dst) { return { op, dst } },
        peg$c22 = "!",
        peg$c23 = peg$literalExpectation("!", false),
        peg$c24 = function(negated, rule) { return negated ? { $type: "negation", negated, rule } : rule },
        peg$c25 = "(",
        peg$c26 = peg$literalExpectation("(", false),
        peg$c27 = ")",
        peg$c28 = peg$literalExpectation(")", false),
        peg$c29 = function(rule) { return { $type: "agroupation", rule } },
        peg$c30 = "and",
        peg$c31 = peg$literalExpectation("and", false),
        peg$c32 = "&",
        peg$c33 = peg$literalExpectation("&", false),
        peg$c34 = "or",
        peg$c35 = peg$literalExpectation("or", false),
        peg$c36 = "|",
        peg$c37 = peg$literalExpectation("|", false),
        peg$c38 = function(column, operation) { return [column, ...operation] },
        peg$c39 = function(op, ob) { return [op, ob] },
        peg$c40 = "is null",
        peg$c41 = peg$literalExpectation("is null", false),
        peg$c42 = "is not null",
        peg$c43 = peg$literalExpectation("is not null", false),
        peg$c44 = function() { return [text()]},
        peg$c45 = "<",
        peg$c46 = peg$literalExpectation("<", false),
        peg$c47 = "<=",
        peg$c48 = peg$literalExpectation("<=", false),
        peg$c49 = ">",
        peg$c50 = peg$literalExpectation(">", false),
        peg$c51 = ">=",
        peg$c52 = peg$literalExpectation(">=", false),
        peg$c53 = "!=",
        peg$c54 = peg$literalExpectation("!=", false),
        peg$c55 = "is in",
        peg$c56 = peg$literalExpectation("is in", false),
        peg$c57 = "is not in",
        peg$c58 = peg$literalExpectation("is not in", false),
        peg$c59 = function(token1, name, token2, parameters, token3) { return { $type: "filter appendment", name, parameters } },
        peg$c60 = ">>",
        peg$c61 = peg$literalExpectation(">>", false),
        peg$c62 = function(token1, name) { return { $type: "export appendment", name } },
        peg$c63 = ">>>",
        peg$c64 = peg$literalExpectation(">>>", false),
        peg$c65 = function(token1, name) { return { $type: "return appendment", name } },
        peg$c66 = "*",
        peg$c67 = peg$literalExpectation("*", false),
        peg$c68 = function(token1, name) { return { $type: "multiply appendment", name } },
        peg$c69 = function(first, others) { return [first].concat(others) },
        peg$c70 = ",",
        peg$c71 = peg$literalExpectation(",", false),
        peg$c72 = function(token1, param) { return param },
        peg$c73 = /^[0-9]/,
        peg$c74 = peg$classExpectation([["0", "9"]], false, false),
        peg$c75 = function() { return parseInt(text()) },
        peg$c76 = "{{",
        peg$c77 = peg$literalExpectation("{{", false),
        peg$c78 = "}}",
        peg$c79 = peg$literalExpectation("}}", false),
        peg$c80 = function(code) { return { $type: "js", code } },
        peg$c81 = peg$anyExpectation(),
        peg$c82 = function() { return text() },
        peg$c83 = function(tp, vl) { return tp ? { ...tp, $value: vl } : vl; },
        peg$c84 = /^[A-Za-z$_]/,
        peg$c85 = peg$classExpectation([["A", "Z"], ["a", "z"], "$", "_"], false, false),
        peg$c86 = /^[A-Za-z0-9$_]/,
        peg$c87 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "$", "_"], false, false),
        peg$c88 = ".",
        peg$c89 = peg$literalExpectation(".", false),
        peg$c90 = function(noun) { return noun },
        peg$c91 = "[",
        peg$c92 = peg$literalExpectation("[", false),
        peg$c93 = "]",
        peg$c94 = peg$literalExpectation("]", false),
        peg$c95 = function(first, others) { return { $type: "js-path", path: [first].concat(others || []) } },
        peg$c96 = "@",
        peg$c97 = peg$literalExpectation("@", false),
        peg$c98 = function(jspath) {
              return {
                $protocol: jspath,
              };
            },
        peg$c99 = "//",
        peg$c100 = peg$literalExpectation("//", false),
        peg$c101 = "/",
        peg$c102 = peg$literalExpectation("/", false),
        peg$c103 = function(protocol, host, path, query, fragment) {
              return {
                $protocol: protocol,
                $host: host,
                $path: path || "/",
                $query: query || null,
                $fragment: fragment || null
              };
            },
        peg$c104 = /^[A-Za-z]/,
        peg$c105 = peg$classExpectation([["A", "Z"], ["a", "z"]], false, false),
        peg$c106 = /^[A-Za-z0-9+\-.]/,
        peg$c107 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "+", "-", "."], false, false),
        peg$c108 = function(protocol) {
              return text().slice(0, -1); // Remueve el ":" del final
            },
        peg$c109 = /^[A-Za-z0-9\-._~%]/,
        peg$c110 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "-", ".", "_", "~", "%"], false, false),
        peg$c111 = function(host) {
              return host.join("");
            },
        peg$c112 = /^[A-Za-z0-9\-._~%!$&'()*+,;=:@\/]/,
        peg$c113 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "-", ".", "_", "~", "%", "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "=", ":", "@", "/"], false, false),
        peg$c114 = function(path) {
              return text().substr(1);
            },
        peg$c115 = function(params) {
              return params;
            },
        peg$c116 = function(head, tail) {
              return [head, ...tail.map(item => item[1])];
            },
        peg$c117 = function(key, value) {
              return { key: key.join(""), value: value.join("") };
            },
        peg$c118 = function(id) {
              return id.join("");
            },
        peg$c119 = "{",
        peg$c120 = peg$literalExpectation("{", false),
        peg$c121 = "}",
        peg$c122 = peg$literalExpectation("}", false),
        peg$c123 = function(members) {
              return members !== null ? members : {};
            },
        peg$c124 = function(head, tail) {
              const result = { [head.key]: head.value };
              tail.forEach((item) => {
                const subitem = item[3];
                const { key, value } = subitem;
                result[key] = value;
              });
              return result;
            },
        peg$c125 = function(key, value) {
              return { key, value };
            },
        peg$c126 = function(elements) {
              return elements !== null ? elements : [];
            },
        peg$c127 = function(head, tail) {
              return [head, ...tail.map(e => e[3])];
            },
        peg$c128 = "\"",
        peg$c129 = peg$literalExpectation("\"", false),
        peg$c130 = function(chars) {
              return chars;
            },
        peg$c131 = "\\\"",
        peg$c132 = peg$literalExpectation("\\\"", false),
        peg$c133 = function(chars) { return text(); },
        peg$c134 = /^[eE]/,
        peg$c135 = peg$classExpectation(["e", "E"], false, false),
        peg$c136 = /^[\-+]/,
        peg$c137 = peg$classExpectation(["-", "+"], false, false),
        peg$c138 = function(value) {
              return parseFloat(value);
            },
        peg$c139 = "true",
        peg$c140 = peg$literalExpectation("true", false),
        peg$c141 = function() { return true; },
        peg$c142 = "false",
        peg$c143 = peg$literalExpectation("false", false),
        peg$c144 = function() { return false; },
        peg$c145 = "null",
        peg$c146 = peg$literalExpectation("null", false),
        peg$c147 = function() { return null; },
        peg$c148 = peg$otherExpectation("whitespace"),
        peg$c149 = /^[ \t\n\r]/,
        peg$c150 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parseStart() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseValue_appended();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseValue_appended() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseJson_value();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseValue_appendment();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseValue_appendment();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseValue_appendment() {
      var s0;

      s0 = peg$parseSubsentence_return();
      if (s0 === peg$FAILED) {
        s0 = peg$parseSubsentence_export();
        if (s0 === peg$FAILED) {
          s0 = peg$parseSubsentence_filter();
          if (s0 === peg$FAILED) {
            s0 = peg$parseSubsentence_multiply();
          }
        }
      }

      return s0;
    }

    function peg$parseInjected_parameter() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c2;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_noun();
        if (s2 === peg$FAILED) {
          s2 = peg$parseInteger();
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c4();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSelect_group() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_noun();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseWhere_filters_precolons();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 63) {
                s6 = peg$c5;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c6); }
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c7(s1, s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseInsert_group() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_noun();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 43) {
              s5 = peg$c8;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c9); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseValue_appended();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseUpdate_group() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_noun();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseWhere_filters_precolons();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s6 = peg$c11;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c12); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseValue_appended();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c13(s1, s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDelete_group() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_noun();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s5 = peg$c14;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c15); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseWhere_filters();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s1, s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseWhere_filters_precolons() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s3 = peg$c17;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseWhere_filters();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c19(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseWhere_filters() {
      var s0;

      s0 = peg$parseInteger();
      if (s0 === peg$FAILED) {
        s0 = peg$parseString();
        if (s0 === peg$FAILED) {
          s0 = peg$parseWhere_rule_4();
          if (s0 === peg$FAILED) {
            s0 = peg$parseJs_block();
            if (s0 === peg$FAILED) {
              s0 = peg$parseInjected_parameter();
            }
          }
        }
      }

      return s0;
    }

    function peg$parseWhere_rule_4() {
      var s0;

      s0 = peg$parseWhere_rule_3();
      if (s0 === peg$FAILED) {
        s0 = peg$parseWhere_rule_2();
      }

      return s0;
    }

    function peg$parseWhere_rule_3() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseWhere_rule_2();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseWhere_rule_3_continuation();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseWhere_rule_3_continuation();
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c20(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseWhere_rule_3_continuation() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseToken_and_or_operator();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseWhere_rule_2();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c21(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseWhere_rule_2() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 33) {
          s2 = peg$c22;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c23); }
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseWhere_rule_1();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c24(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseWhere_rule_1() {
      var s0;

      s0 = peg$parseWhere_rule_0();
      if (s0 === peg$FAILED) {
        s0 = peg$parseWhere_rule_pure();
      }

      return s0;
    }

    function peg$parseWhere_rule_0() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 40) {
          s2 = peg$c25;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseWhere_rule_4();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s6 = peg$c27;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c28); }
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c29(s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseToken_and_or_operator() {
      var s0;

      s0 = peg$parseToken_and_operator();
      if (s0 === peg$FAILED) {
        s0 = peg$parseToken_or_operator();
      }

      return s0;
    }

    function peg$parseToken_and_operator() {
      var s0;

      if (input.substr(peg$currPos, 3) === peg$c30) {
        s0 = peg$c30;
        peg$currPos += 3;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c31); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 38) {
          s0 = peg$c32;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c33); }
        }
      }

      return s0;
    }

    function peg$parseToken_or_operator() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c34) {
        s0 = peg$c34;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c35); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c36;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
      }

      return s0;
    }

    function peg$parseWhere_rule_pure() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_noun();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseColumn_operation();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c38(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseColumn_operation() {
      var s0;

      s0 = peg$parseColumn_operator_1();
      if (s0 === peg$FAILED) {
        s0 = peg$parseColumn_operation_2();
      }

      return s0;
    }

    function peg$parseColumn_operation_2() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseColumn_operator_2();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseJson_value();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c39(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseColumn_operator_1() {
      var s0, s1;

      if (input.substr(peg$currPos, 7) === peg$c40) {
        s0 = peg$c40;
        peg$currPos += 7;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c41); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 11) === peg$c42) {
          s1 = peg$c42;
          peg$currPos += 11;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c43); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c44();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseColumn_operator_2() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 60) {
        s0 = peg$c45;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c46); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c47) {
          s0 = peg$c47;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 62) {
            s0 = peg$c49;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c50); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c51) {
              s0 = peg$c51;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s0 = peg$c11;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c12); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c53) {
                  s0 = peg$c53;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c54); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c55) {
                    s0 = peg$c55;
                    peg$currPos += 5;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c56); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 9) === peg$c57) {
                      s0 = peg$c57;
                      peg$currPos += 9;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c58); }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseSubsentence_filter() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s3 = peg$c49;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c50); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_path();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s5 = peg$c25;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c26); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseList_of_function_parameters();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s7 = peg$c27;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c28); }
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c59(s1, s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSubsentence_export() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c60) {
          s3 = peg$c60;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c61); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFunction_parameter();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c62(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSubsentence_return() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c63) {
          s3 = peg$c63;
          peg$currPos += 3;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c64); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFunction_parameter();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c65(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSubsentence_multiply() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 42) {
          s3 = peg$c66;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c67); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFunction_parameter();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c68(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseList_of_function_parameters() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseFunction_parameter();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseFunction_parameter_precoma();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseFunction_parameter_precoma();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c69(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFunction_parameter() {
      var s0;

      s0 = peg$parseValue_appended();
      if (s0 === peg$FAILED) {
        s0 = peg$parseJs_path();
      }

      return s0;
    }

    function peg$parseFunction_parameter_precoma() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s3 = peg$c70;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c71); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFunction_parameter();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c72(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseInteger() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c73.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c74); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c73.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c74); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c75();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseJs_block() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c76) {
        s1 = peg$c76;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c77); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_block_content();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c78) {
            s3 = peg$c78;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c79); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c80(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseJs_block_content() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      if (input.substr(peg$currPos, 2) === peg$c78) {
        s4 = peg$c78;
        peg$currPos += 2;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c79); }
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c81); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c78) {
          s4 = peg$c78;
          peg$currPos += 2;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c79); }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c81); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c82();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseJson_value() {
      var s0;

      s0 = peg$parseJson_value_pure();
      if (s0 === peg$FAILED) {
        s0 = peg$parseJs_block();
        if (s0 === peg$FAILED) {
          s0 = peg$parseUpdate_group();
          if (s0 === peg$FAILED) {
            s0 = peg$parseSelect_group();
            if (s0 === peg$FAILED) {
              s0 = peg$parseInsert_group();
              if (s0 === peg$FAILED) {
                s0 = peg$parseDelete_group();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseInjected_parameter();
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseJson_value_pure() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseType_def();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseValue_untyped();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c83(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseType_def() {
      var s0;

      s0 = peg$parseType_def_by_request();
      if (s0 === peg$FAILED) {
        s0 = peg$parseType_def_by_js_property();
      }

      return s0;
    }

    function peg$parseJs_noun() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (peg$c84.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c85); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c86.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c87); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c86.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c82();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseJs_noun_predotted() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c88;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c89); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_noun();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c90(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseJs_noun_accessed() {
      var s0;

      s0 = peg$parseJs_noun_predotted();
      if (s0 === peg$FAILED) {
        s0 = peg$parseJs_noun_accessed_by_squarebrackets();
      }

      return s0;
    }

    function peg$parseJs_noun_accessed_by_squarebrackets() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c91;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c92); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseString();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s3 = peg$c93;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c94); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c90(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseJs_path() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseJs_noun();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseJs_noun_accessed();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseJs_noun_accessed();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c95(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseType_def_by_js_property() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 64) {
        s1 = peg$c96;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c97); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJs_path();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c98(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseType_def_by_request() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 64) {
        s1 = peg$c96;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c97); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseType_protocol();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c99) {
            s3 = peg$c99;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c100); }
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s4 = peg$c101;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c102); }
            }
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseHost();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsePath();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseQuery_string();
                  if (s7 === peg$FAILED) {
                    s7 = null;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseFragment();
                    if (s8 === peg$FAILED) {
                      s8 = null;
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c103(s2, s5, s6, s7, s8);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseType_protocol() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (peg$c104.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c105); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c106.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c107); }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c106.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c107); }
          }
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c17;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c108(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseHost() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c109.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c110); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c109.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c110); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c111(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsePath() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 47) {
        s2 = peg$c101;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c102); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c112.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c113); }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c112.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c113); }
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c114(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseQuery_string() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 63) {
        s1 = peg$c5;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseQuery_param_list();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c115(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseQuery_param_list() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseQuery_param();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
          s4 = peg$c32;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c33); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseQuery_param();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 38) {
            s4 = peg$c32;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c33); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseQuery_param();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c116(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseQuery_param() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c109.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c110); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c109.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c110); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s2 = peg$c11;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c109.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c110); }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c109.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c110); }
              }
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c117(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFragment() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c2;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c112.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c113); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c112.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c113); }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c118(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseValue_untyped() {
      var s0;

      s0 = peg$parseObject();
      if (s0 === peg$FAILED) {
        s0 = peg$parseArray();
        if (s0 === peg$FAILED) {
          s0 = peg$parseString();
          if (s0 === peg$FAILED) {
            s0 = peg$parseNumber();
            if (s0 === peg$FAILED) {
              s0 = peg$parseBoolean();
              if (s0 === peg$FAILED) {
                s0 = peg$parseNull();
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseObject() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c119;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c120); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMemberList();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s5 = peg$c121;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c122); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c123(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMemberList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseMember();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c70;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c71); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseMember();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c70;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c71); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseMember();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c124(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMember_key() {
      var s0;

      s0 = peg$parseString();
      if (s0 === peg$FAILED) {
        s0 = peg$parseJs_noun();
      }

      return s0;
    }

    function peg$parseMember() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseMember_key();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c17;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseValue_appended();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c125(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseArray() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c91;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c92); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseElementList();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s5 = peg$c93;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c94); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c126(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseElementList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseValue_appended();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c70;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c71); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseValue_appended();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c70;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c71); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseValue_appended();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c127(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseString() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c128;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c129); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDoubleQuotedString();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c128;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c129); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c130(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDoubleQuotedString() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      if (input.substr(peg$currPos, 2) === peg$c131) {
        s2 = peg$c131;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c132); }
      }
      if (s2 === peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 34) {
          s4 = peg$c128;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c129); }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c81); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (input.substr(peg$currPos, 2) === peg$c131) {
          s2 = peg$c131;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c132); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 34) {
            s4 = peg$c128;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c129); }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c81); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c133(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseNumber() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s3 = peg$c14;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c15); }
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        if (peg$c73.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c74); }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c73.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c74); }
            }
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s6 = peg$c88;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c89); }
          }
          if (s6 !== peg$FAILED) {
            s7 = [];
            if (peg$c73.test(input.charAt(peg$currPos))) {
              s8 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c74); }
            }
            if (s8 !== peg$FAILED) {
              while (s8 !== peg$FAILED) {
                s7.push(s8);
                if (peg$c73.test(input.charAt(peg$currPos))) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c74); }
                }
              }
            } else {
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            if (peg$c134.test(input.charAt(peg$currPos))) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c135); }
            }
            if (s7 !== peg$FAILED) {
              if (peg$c136.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c137); }
              }
              if (s8 === peg$FAILED) {
                s8 = null;
              }
              if (s8 !== peg$FAILED) {
                s9 = [];
                if (peg$c73.test(input.charAt(peg$currPos))) {
                  s10 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s10 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c74); }
                }
                if (s10 !== peg$FAILED) {
                  while (s10 !== peg$FAILED) {
                    s9.push(s10);
                    if (peg$c73.test(input.charAt(peg$currPos))) {
                      s10 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c74); }
                    }
                  }
                } else {
                  s9 = peg$FAILED;
                }
                if (s9 !== peg$FAILED) {
                  s7 = [s7, s8, s9];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            if (s6 !== peg$FAILED) {
              s3 = [s3, s4, s5, s6];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c138(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseBoolean() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c139) {
        s1 = peg$c139;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c140); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c141();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c142) {
          s1 = peg$c142;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c143); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c144();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseNull() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c145) {
        s1 = peg$c145;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c146); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c147();
      }
      s0 = s1;

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      peg$silentFails++;
      s0 = [];
      if (peg$c149.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c150); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c149.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c150); }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c148); }
      }

      return s0;
    }


      // Funcin auxiliar para convertir cadenas con escapes
      function unescapeString(str) {
        return JSON.parse(str);
      }


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  root.BrowsieScript = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})(typeof window !== 'undefined' ? window : global);


// @vuebundler[Lsw_framework_components][31]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database-query-language/lsw-database-query-language.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswDatabaseQueryLanguage'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswDatabaseQueryLanguage'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  const LswDatabaseQueryLanguage = class {

    static parser = BrowsieScript;

    static toJavaScript(browsieScriptCode) {
      try {
        const ast = this.parser.parse(browsieScriptCode);
        console.log(ast);
        let js = "";
        js += "";
        js = ast;
        console.log(js);
        return js;
      } catch (error) {
        console.log("[!] Error on LswDatabaseQueryLanguage.toJavaScript when parsing input");
        console.log(error);
        throw error;
      }
    }

  }
  
  return LswDatabaseQueryLanguage;

});

// @vuebundler[Lsw_framework_components][32]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-logger/superlogger.unbundled.js
(function (factory) {
  const mod = factory();
  /* istanbul ignore next */
  if (typeof window !== 'undefined') {
    window['Superlogger'] = mod;
  }
  /* istanbul ignore next */
  if (typeof global !== 'undefined') {
    global['Superlogger'] = mod;
  }
  /* istanbul ignore next */
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  /**
   * 
   * 
   * @$section: LswLogger API  Superlogger API   Superlogger class
   * @type: class
   * @extends: Object
   * @vendor: lsw
   * @namespace: Superlogger
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: Superlogger class | @$section: LswLogger API  Superlogger API   Superlogger class
  const Superlogger = class {

    static create(id, options) {
      return new this(id, options);
    }

    static levels = {
      trace: 4,
      debug: 3,
      log: 2,
      warn: 1,
      error: 0,
    };

    static defaultOptions = {
      // active: true,
      active: false,
      level: "trace"
    };

    static loggers = {};

    static alphabet = "abcdefghijklmnopqrstuvwxyz";

    static generateRandomString(len /* istanbul ignore next */  = 5) {
      let out = "";
      while(out.length < len) {
        out += this.alphabet[Math.floor(Math.random() * this.alphabet.length - 1)];
      }
      return out;
    }

    constructor(idInput = false, options = {}) {
      const id = idInput || this.constructor.generateRandomString(10);
      if (typeof id !== "string") {
        throw new Error("Required parameter id to be a string on Superlogger.constructor");
      }
      if (id in this.constructor.loggers) {
        throw new Error("Required parameter id to be a unique string on Superlogger.constructor");
      }
      if (typeof options !== "object") {
        throw new Error("Required parameter options to be an object on Superlogger.constructor");
      }
      this.$id = id;
      this.$options = Object.assign({}, this.constructor.defaultOptions, options);
      this.$source = undefined;
      this.$events = {};
      this.$callbacks = {
        before: undefined,
        after: undefined,
      };
      this.resetEvents();
      this.resetCallbacks();
      this.constructor.loggers[id] = this;
    }

    activate() {
      this.$options.active = true;
    }

    deactivate() {
      this.$options.active = false;
    }

    setSource(source) {
      this.source = source;
    }

    setLevel(level) {
      if (!(level in this.constructor.levels)) {
        throw new Error("Required parameter level to be a recognized level on Superlogger.setLevel");
      }
      this.$options.level = this.constructor.levels[level];
    }

    setEvent(id, callback) {
      this.$events[id] = callback;
    }

    resetEvents() {
      this.$events = {
        trace: undefined,
        debug: undefined,
        log: undefined,
        warn: undefined,
        error: undefined,
      };
    }

    setBefore(callback) {
      this.$callbacks.before = callback;
    }

    setAfter(callback) {
      this.$callbacks.after = callback;
    }

    resetCallbacks() {
      this.$callbacks = {
        after: undefined,
        before: undefined,
      };
    }

    replacerFactory() {
      const visited = new WeakMap();
      return (key, value) => {
        if (typeof value === "function") {
          return "[Function] " + value.toString();
        }
        if (typeof value === "object" && value !== null) {
          if (visited.has(value)) {
            return "[Circular]";
          }
          visited.set(value, true);
        } else /* istanbul ignore else */ {}
        return value;
      }
    }

    stringifyForDebugging(obj) {
      return JSON.stringify(obj, this.replacerFactory(), 2);
    }

    stringifyForTracing(obj) {
      if(typeof obj === "object") {
        if(obj._isVue) {
          return "[Vue instance::" + obj.$options.name + "]";
        } else if(obj === window) {
          return "[Window instance]";
        }
      }
      return JSON.stringify(obj, this.replacerFactory(), 2);
    }

    $emit(event, args) {
      if(!(event in this.$events)) {
        return "void::event not defined";
      }
      const callback = this.$events[event];
      if(typeof callback === "undefined") {
        return "void::callback not defined";
      }
      return callback(this, args);
    }

    $log(levelId, elements, methodId = false) {
      if(!(levelId in this.constructor.levels)) {
        throw new Error("Required parameter levelId to be an identified level on Superlogger.$log");
      }
      const level = this.constructor.levels[levelId];
      if (!this.$options.active) {
        return "void::currently active=false state";
      }
      if (this.$options.level < level) {
        return "void::level of tracing out of bounds";
      }
      let message = `[${this.$id}][${levelId}]`;
      if (methodId !== false) {
        message += `[${methodId}]`;
      }
      for (let index = 0; index < elements.length; index++) {
        const element = elements[index];
        const stringification = typeof element === "string" ? element : this.stringifyForTracing(element);
        message += " " + stringification;
      }
      Event_triggering: {
        if(typeof this.$callbacks.before !== "undefined") {
          this.$callbacks.before(message, this, levelId, elements, methodId);
        }
        console.log(message);
        if(typeof this.$callbacks.after !== "undefined") {
          this.$callbacks.after(message, this, levelId, elements, methodId);
        }
        this.$emit(levelId, {elements, methodId});
      }
    }

    trace(methodId, ...data) {
      return this.$log("trace", data, methodId);
    }

    debug(...data) {
      return this.$log("debug", data);
    }

    log(...data) {
      return this.$log("log", data);
    }

    warn(...data) {
      return this.$log("warn", data);
    }

    error(...data) {
      return this.$log("error", data);
    }

  };
  // @code.end: Superlogger class

  return Superlogger;
});

// @vuebundler[Lsw_framework_components][33]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-returner/controlled-function.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['ControlledFunction'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['ControlledFunction'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: ControlledFunction global | @$section: LswControlledFunction API  ControlledFunction API  ControlledFunction classes
  const ReturnControl = class {
    constructor(value) {
      this.value = value;
    }
  };

  const MutateControl = class {
    constructor(mutator = {}) {
      this.mutator = mutator;
    }
  };

  const ReturnController = class {
    static create(...args) {
      return new this(...args);
    }

    constructor() {
      this.results = new Map();
      this.functions = new Map();
      this.middlewares = [];
      this.properties = new Map();
    }

    prehook(middleware) {
      this.middlewares.unshift(middleware);
      return this;
    }

    hook(middleware) {
      this.middlewares.push(middleware);
      return this;
    }

    unhook(middleware) {
      this.middlewares = this.middlewares.filter(m => m !== middleware);
      return this;
    }

    prop(properties = {}) {
      Object.assign(this.properties, properties);
      return this;
    }

    hasProp(id) {
      return this.properties.has(id);
    }

    getProp(id, defaultValue = undefined) {
      if (!this.properties.has(id)) {
        return defaultValue;
      }
      return this.properties.get(id);
    }

    setProp(id, value) {
      this.properties.set(id, value);
      return this;
    }

    load(functions) {
      this.functions = new Map(Object.entries(functions));
      return this;
    }

    solved(name) {
      return this.results.get(name);
    }

    pipe(outputName, functionNames, parameters = []) {
      for (let fnName of functionNames) {
        const fnCallback = this.functions.get(fnName);
        if (fnCallback) {
          const result = fnCallback(...parameters);
          if (this.processResult(result, outputName)) {
            return this.solved(outputName);
          }
        }
        for (const middleware of this.middlewares) {
          const result = middleware(this);
          if (this.processResult(result, outputName)) {
            return this.solved(outputName);
          }
        }
      }
      return null;
    }

    processResult(result, outputName) {
      if (result instanceof ReturnControl) {
        this.results.set(outputName, result.value);
        return true;
      } else if (result instanceof MutateControl) {
        const mutator = result.mutator;
        if (typeof mutator === "function") {
          const mutatorResult = mutator(this);
          if (typeof mutatorResult === "object") {
            Object.assign(this.properties, mutatorResult);
          } else if (mutatorResult !== undefined) {
            throw new Error(
              `MutateControl's function mutator must return an object or undefined, found: ${typeof mutatorResult}`
            );
          }
        } else if (typeof mutator === "object") {
          Object.assign(this, mutator);
        } else {
          throw new Error(
            `MutateControl's mutator must be a function or object, found: ${typeof mutator}`
          );
        }
      }
      return false;
    }

    reset() {
      this.results.clear();
      this.properties.clear();
      return this;
    }
  };

  const ControlledFunction = {
    MutateControl,
    ReturnControl,
    ReturnController,
  };

  ControlledFunction.default = ControlledFunction;

  return ControlledFunction;
  // @code.end: ControlledFunction global

});


// @vuebundler[Lsw_framework_components][34]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-store/dist/store.unbundled.js
(function (factory) {

  const mod = factory();

  if (typeof window !== "undefined") {
    window.UniversalStore = mod;
  }
  if (typeof global !== "undefined") {
    global.UniversalStore = mod;
  }
  if (typeof module !== "undefined") {
    module.exports = mod;
  }

})(function () {
const Store = class {

  static create(...args) {
    return new this(...args);
  }

  constructor(initialState = {}, path_to_store = "original_store.json") {
    this.$store = initialState;
    this.$storePath = path_to_store;
    this.events = {};
  }

  _triggerParentEvents(event, path, value) {
    const originalPath = path.join(".");
    if (this.events[originalPath]) {
      this.events[originalPath].forEach((callback) => {
        return callback(event, path, value);
      });
    }
    while (path.length > 0) {
      path.pop();
      const parentPath = path.join(".");
      if (this.events[parentPath]) {
        this.events[parentPath].forEach((callback) => {
          const value = this.get(path);
          return callback(event, path, value);
        });
      }
    }
  }

  get(path = []) {
    return path.reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : undefined), this.$store);
  }

  set(path, value) {
    if (!Array.isArray(path) || path.length === 0) {
      throw new Error("La ruta debe ser un array de strings no vaco.");
    }
    const lastKey = path.pop();
    const target = path.reduce((acc, key) => {
      if (!acc[key]) acc[key] = {};
      return acc[key];
    }, this.$store);
    target[lastKey] = value;
    path.push(lastKey);
    this._triggerParentEvents("set", path, value);
  }

  watch(path, callback) {
    const key = path.join(".");
    if (!this.events[key]) {
      this.events[key] = [];
    }
    this.events[key].push(callback);
  }

  unwatch(path, callback) {
    const key = path.join(".");
    if (this.events[key]) {
      this.events[key] = this.events[key].filter((cb) => {
        return cb !== callback;
      });
      if (this.events[key].length === 0) {
        delete this.events[key];
      }
    }
  }

  delete(path) {
    if (!Array.isArray(path) || path.length === 0) {
      throw new Error("La ruta debe ser un array de strings no vaco.");
    }
    const lastKey = path.pop();
    const target = this.get(path);
    if (target && target.hasOwnProperty(lastKey)) {
      delete target[lastKey];
      this._triggerParentEvents("delete", path);
    }
  }

  push(path, value) {
    const array = this.get(path);
    if (Array.isArray(array)) {
      array.push(value);
      this._triggerParentEvents("push", path, array);
    }
  }

  pop(path) {
    const array = this.get(path);
    if (Array.isArray(array)) {
      const value = array.pop();
      this._triggerParentEvents("pop", path, array);
      return value;
    }
  }

  unshift(path, value) {
    const array = this.get(path);
    if (Array.isArray(array)) {
      array.unshift(value);
      this._triggerParentEvents("unshift", path, array);
    }
  }

  shift(path) {
    const array = this.get(path);
    if (Array.isArray(array)) {
      const value = array.shift();
      this._triggerParentEvents("shift", path, array);
      return value;
    }
  }

  add(path, key, value) {
    const object = this.get(path);
    if (object && typeof object === 'object' && !Array.isArray(object)) {
      object[key] = value;
      this._triggerParentEvents("add", path, object);
    }
  }

  remove(path, key) {
    const object = this.get(path);
    if (object && typeof object === 'object' && !Array.isArray(object)) {
      delete object[key];
      this._triggerParentEvents("remove", path, object);
    }
  }

  splice(path, start, deleteCount, ...items) {
    const array = this.get(path);
    if (Array.isArray(array)) {
      const result = array.splice(start, deleteCount, ...items);
      this._triggerParentEvents("splice", path, array);
      return result;
    }
  }

  extend(path, newProps) {
    const object = this.get(path);
    if (object && typeof object === 'object' && !Array.isArray(object)) {
      Object.assign(object, newProps);
      this._triggerParentEvents("extend", path, object);
    }
  }

  multiextend(...extensions) {
    for(let index=0; index<extensions.length; index++) {
      const {
        selector,
        value: targetValue,
        mode,
        modifier
      } = extensions[index];
      this.modify(selector, currentValue => {
        let lastValue = currentValue;
        Set_value: {
          if(mode === "assign") {
            lastValue = Object.assign(currentValue, targetValue);
          } else if(mode === "default") {
            lastValue = Object.assign({}, targetValue, currentValue);
          } else if(mode === "set") {
            lastValue = targetValue;
          } else if(mode === "concat") {
            lastValue = currentValue.concat(targetValue);
          }
        }
        Run_modifier: {
          if(modifier) {
            const result = modifier(lastValue);
            if(typeof result !== "undefined") {
              return result;
            }
          }
          return lastValue;
        }
      });
    }
  }

  modify(path, modifier) {
    const currentValue = this.get(path);
    const newValue = modifier(currentValue);
    const isNotSame = newValue !== currentValue;
    const isNotUndefined = typeof newValue !== "undefined";
    if (isNotUndefined && isNotSame) {
      this.set(path, newValue);
    }
  }

  hydrate(file) {
    const ufs = UFS_manager.create(this.$storePath);
    this.$store = JSON.parse(ufs.read_file(file));
  }

  dehydrate(file) {
    const ufs = UFS_manager.create(this.$storePath);
    ufs.write_file(file, JSON.stringify(this.$store));
  }

};

Store.default = Store;

return Store;
});


// @vuebundler[Lsw_framework_components][35]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-timer/lsw-timer.bundled.js
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root) {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { Inicio: peg$parseInicio },
        peg$startRuleFunction  = peg$parseInicio,

        peg$c0 = function(primero, otras) {
              return [primero].concat(otras || []);
            },
        peg$c1 = ",",
        peg$c2 = peg$literalExpectation(",", false),
        peg$c3 = function(tiempo) {
              return tiempo;
            },
        peg$c4 = "-",
        peg$c5 = peg$literalExpectation("-", false),
        peg$c6 = function(inicio, fin) {
              return { tipo: "Rango", inicio, fin };
            },
        peg$c7 = "+",
        peg$c8 = peg$literalExpectation("+", false),
        peg$c9 = " ",
        peg$c10 = peg$literalExpectation(" ", false),
        peg$c11 = function(fecha, hora) {
              delete fecha.tipo;
              delete hora.tipo;
              return { tipo: "FechaHora", ...fecha, ...hora };
            },
        peg$c12 = "/",
        peg$c13 = peg$literalExpectation("/", false),
        peg$c14 = function(anio, mes, dia) {
              return { tipo: "SoloFecha", anio, mes, dia };
            },
        peg$c15 = ":",
        peg$c16 = peg$literalExpectation(":", false),
        peg$c17 = ".",
        peg$c18 = peg$literalExpectation(".", false),
        peg$c19 = function(hora, minuto, segundo, milisegundo) {
              return { tipo: "Hora", hora, minuto, segundo, milisegundo };
            },
        peg$c20 = function(hora, minuto, segundo) {
              return { tipo: "Hora", hora, minuto, segundo, milisegundo: 0 };
            },
        peg$c21 = function(hora, minuto) {
              return { tipo: "Hora", hora, minuto, segundo: 0, milisegundo: 0 };
            },
        peg$c22 = function(partes) {
              return { tipo: "Duracion", ...recomponer_objeto(partes) };
            },
        peg$c23 = function(valor, unidad) {
              return { valor, unidad };
            },
        peg$c24 = "y",
        peg$c25 = peg$literalExpectation("y", false),
        peg$c26 = function() { return "anios"; },
        peg$c27 = "mon",
        peg$c28 = peg$literalExpectation("mon", false),
        peg$c29 = function() { return "meses"; },
        peg$c30 = "d",
        peg$c31 = peg$literalExpectation("d", false),
        peg$c32 = function() { return "dias"; },
        peg$c33 = "h",
        peg$c34 = peg$literalExpectation("h", false),
        peg$c35 = function() { return "horas"; },
        peg$c36 = "min",
        peg$c37 = peg$literalExpectation("min", false),
        peg$c38 = function() { return "minutos"; },
        peg$c39 = "s",
        peg$c40 = peg$literalExpectation("s", false),
        peg$c41 = function() { return "segundos"; },
        peg$c42 = "ms",
        peg$c43 = peg$literalExpectation("ms", false),
        peg$c44 = function() { return "milisegundos"; },
        peg$c45 = /^[0-9]/,
        peg$c46 = peg$classExpectation([["0", "9"]], false, false),
        peg$c47 = function() { return parseInt(text(), 10); },
        peg$c48 = /^[0-1]/,
        peg$c49 = peg$classExpectation([["0", "1"]], false, false),
        peg$c50 = /^[0-3]/,
        peg$c51 = peg$classExpectation([["0", "3"]], false, false),
        peg$c52 = /^[0-2]/,
        peg$c53 = peg$classExpectation([["0", "2"]], false, false),
        peg$c54 = /^[0-5]/,
        peg$c55 = peg$classExpectation([["0", "5"]], false, false),
        peg$c56 = "\t",
        peg$c57 = peg$literalExpectation("\t", false),

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parseInicio() {
      var s0;

      s0 = peg$parseLista();

      return s0;
    }

    function peg$parseLista() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseUnidadDeTiempo();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseOtraUnidadDeTiempo();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseOtraUnidadDeTiempo();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseOtraUnidadDeTiempo() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c2); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseUnidadDeTiempo();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c3(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseUnidadDeTiempo() {
      var s0;

      s0 = peg$parseDuracion();
      if (s0 === peg$FAILED) {
        s0 = peg$parseRango();
        if (s0 === peg$FAILED) {
          s0 = peg$parseMomento();
        }
      }

      return s0;
    }

    function peg$parseRango() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseMomento();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s2 = peg$c4;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c5); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMomento();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMomento() {
      var s0;

      s0 = peg$parseFechaHora();
      if (s0 === peg$FAILED) {
        s0 = peg$parseSoloFecha();
        if (s0 === peg$FAILED) {
          s0 = peg$parseHora();
        }
      }

      return s0;
    }

    function peg$parseFechaHora() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseSoloFecha();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s2 = peg$c7;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 32) {
            s2 = peg$c9;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c10); }
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseHora();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c11(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSoloFecha() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseAnio();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s2 = peg$c12;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c13); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMes();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s4 = peg$c12;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c13); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDia();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c14(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseHora() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseHoraExacta();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s2 = peg$c15;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c16); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMinuto();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c15;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseSegundo();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s6 = peg$c17;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c18); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseMilisegundo();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c19(s1, s3, s5, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseHoraExacta();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c15;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c16); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseMinuto();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s4 = peg$c15;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c16); }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseSegundo();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c20(s1, s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseHoraExacta();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c15;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseMinuto();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c21(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parseDuracion() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseParteDuracion();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseParteDuracion();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c22(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseParteDuracion() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNumero();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseUnidad();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c23(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseUnidad() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 121) {
        s1 = peg$c24;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c26();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c27) {
          s1 = peg$c27;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c29();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 100) {
            s1 = peg$c30;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c31); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c32();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 104) {
              s1 = peg$c33;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c34); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 3) === peg$c36) {
                s1 = peg$c36;
                peg$currPos += 3;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c37); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c38();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 115) {
                  s1 = peg$c39;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c40); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c41();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c42) {
                    s1 = peg$c42;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c43); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c44();
                  }
                  s0 = s1;
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseAnio() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (peg$c45.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c46); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
        if (s2 !== peg$FAILED) {
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c46); }
          }
          if (s3 !== peg$FAILED) {
            if (peg$c45.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c46); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c47();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMes() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c48.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c49); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c47();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDia() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c50.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c47();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseHoraExacta() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c52.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c47();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMinuto() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c54.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c47();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSegundo() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c54.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c47();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMilisegundo() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (peg$c45.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c46); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c46); }
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c47();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNumero() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c45.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c46); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c46); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c47();
      }
      s0 = s1;

      return s0;
    }

    function peg$parse_() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 32) {
        s0 = peg$c9;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c10); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 9) {
          s0 = peg$c56;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c57); }
        }
      }

      return s0;
    }


      const recomponer_objeto = function(partes) {
        let objeto = {};
        for(let i=0; i<partes.length; i++) {
          const parte = partes[i];
          objeto[parte.unidad] = parte.valor;
        }
        return objeto;
      };


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  root.Timeformat_parser = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})(typeof window === 'undefined' ? global : window);

(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswTimer'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswTimer'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswTimer API | @$section: LswTimer API  LswTimer classes and functions
  // exported to LswTimer
  const LswTimer = {
    utils: {},
    parser: Timeformat_parser,
  };

  LswTimer.utils.formatHour = function (horaInput, minutoInput) {
    const hora = ("" + horaInput).padStart(2, '0');
    const minuto = ("" + minutoInput).padStart(2, '0');
    return `${hora}:${minuto}`;
  };

  LswTimer.utils.formatDatestringFromDate = function (dateObject, setUntilDay = false, setMeridian = false, setSeconds = false, setOnlyHour = false, setMilliseconds = false) {
    if (typeof dateObject === "undefined") {
      return undefined;
    }
    const anio = ("" + (dateObject.getFullYear() ?? 0)).padStart(4, '0');
    const mes = ("" + ((dateObject.getMonth() ?? 0) + 1)).padStart(2, '0');
    const dia = ("" + (dateObject.getDate() ?? 0)).padStart(2, '0');
    if (setUntilDay) {
      return `${anio}/${mes}/${dia}`;
    }
    const hora = ("" + (dateObject.getHours() ?? 0)).padStart(2, '0');
    const minuto = ("" + (dateObject.getMinutes() ?? 0)).padStart(2, '0');
    const segundo = setSeconds ? ("" + (dateObject.getSeconds() ?? 0)).padStart(2, '0') : false;
    let milisegundo = false;
    if(setMilliseconds) {
      milisegundo = dateObject.getMilliseconds();
    }
    const laHora = `${hora}:${minuto}${typeof segundo !== "boolean" ? (':' + segundo) : ''}${milisegundo ? '.' + milisegundo : ''}${setMeridian ? hora >= 12 ? 'pm' : 'am' : ''}`;
    if (setOnlyHour) {
      return laHora;
    }
    return `${anio}/${mes}/${dia} ${laHora}`;
  };

  LswTimer.utils.fromDateToDatestring = LswTimer.utils.formatDatestringFromDate;

  LswTimer.utils.getDateFromMomentoText = function (momentoText, setMeridian = false) {
    const momentoBrute = Timeformat_parser.parse(momentoText)[0];
    const date = new Date();
    if (momentoBrute.anio) {
      date.setFullYear(momentoBrute.anio);
      if (momentoBrute.mes === 0) {
        throw new Error("Cannot set mes to 0 in momento text on LswTimer.utils.getDateFromMomentoText");
      }
      date.setMonth((momentoBrute.mes - 1) || 0);
      date.setDate(momentoBrute.dia || 0);
    }
    date.setHours(momentoBrute.hora || 0);
    date.setMinutes(momentoBrute.minuto || 0);
    date.setSeconds(momentoBrute.segundo || 0);
    date.setMilliseconds(0);
    return date;
  };

  LswTimer.utils.fromDatestringToDate = LswTimer.utils.getDateFromMomentoText;

  LswTimer.utils.formatDatetimeFromMomento = function (momentoBrute, setMeridian = false) {
    const momento = LswTimer.utils.toPlainObject(momentoBrute);
    const anio = ("" + (momento.anio ?? 0)).padStart(4, '0');
    const mes = ("" + (momento.mes ?? 0)).padStart(2, '0');
    const dia = ("" + (momento.dia ?? 0)).padStart(2, '0');
    const hora = ("" + (momento.hora ?? 0)).padStart(2, '0');
    const minuto = ("" + (momento.minuto ?? 0)).padStart(2, '0');
    return `${anio}/${mes}/${dia} ${hora}:${minuto}${setMeridian ? hora >= 12 ? 'pm' : 'am' : ''}`;
  };

  LswTimer.utils.formatHourFromMomento = function (momentoBrute, setMeridian = false) {
    const momento = LswTimer.utils.toPlainObject(momentoBrute);
    const hora = ("" + (momento.hora ?? 0)).padStart(2, '0');
    const minuto = ("" + (momento.minuto ?? 0)).padStart(2, '0');
    return `${hora}:${minuto}${setMeridian ? hora >= 12 ? 'pm' : 'am' : ''}`;
  };

  LswTimer.utils.formatHourFromMomentoCode = function (momentoCode, setMeridian = false) {
    const momentoBruteList = Timeformat_parser.parse(momentoCode);
    const momentoBrute = momentoBruteList[0];
    const momento = LswTimer.utils.toPlainObject(momentoBrute);
    const hora = ("" + (momento.hora ?? 0)).padStart(2, '0');
    const minuto = ("" + (momento.minuto ?? 0)).padStart(2, '0');
    return `${hora}:${minuto}${setMeridian ? hora >= 12 ? 'pm' : 'am' : ''}`;
  };

  LswTimer.utils.addDuracionToMomento = function (momentoBrute, duracion) {
    const momentoFinal = {};
    const duracionParsed = Timeformat_parser.parse(duracion)[0];
    const props = ["anio", "mes", "dia", "hora", "minuto", "segundo"];
    const propsInDuracion = ["anios", "meses", "dias", "horas", "minutos", "segundos"];
    for (let index = 0; index < props.length; index++) {
      const prop = props[index];
      const propInDuracion = propsInDuracion[index];
      const base = momentoBrute[prop] ?? 0;
      const aggregated = duracionParsed[propInDuracion] ?? 0;
      momentoFinal[prop] = base + aggregated;
    }
    return momentoFinal;
  };

  LswTimer.utils.toPlainObject = function (obj) {
    const seen = new WeakSet();
    return JSON.parse(JSON.stringify(obj, (key, value) => {
      if (typeof value === "object" && value !== null) {
        if (seen.has(value)) return undefined; // Ignora referencias circulares
        seen.add(value);
      }
      return value;
    }));
  };

  LswTimer.utils.isDurationOrThrow = function (text) {
    const errorMessage = "It must be a duration only, like 0y 0mon 0d 0h 0min 0s 0ms";
    try {
      const ast = Timeformat_parser.parse(text);
      const mainExpression = ast[0];
      if (mainExpression.tipo !== "Duracion") {
        throw new Error(`Expression of type ${mainExpression.tipo} is not valid. ${errorMessage}`);
      }
    } catch (error) {
      throw new Error(errorMessage);
    }
    return true;
  };

  LswTimer.utils.isDatetimeOrThrow = function (text) {
    const errorMessage = "It must be a datetime only, like 2025/01/01 00:00";
    try {
      const ast = Timeformat_parser.parse(text);
      const mainExpression = ast[0];
      if (mainExpression.tipo !== "FechaHora") {
        throw new Error(errorMessage);
      }
    } catch (error) {
      throw new Error(errorMessage);
    }
    return true;
  };

  LswTimer.utils.isDateOrThrow = function (text) {
    const errorMessage = "It must be a date only, like 2025/01/01";
    try {
      const ast = Timeformat_parser.parse(text);
      const mainExpression = ast[0];
      if (mainExpression.tipo !== "SoloFecha") {
        throw new Error(errorMessage);
      }
    } catch (error) {
      throw new Error(errorMessage);
    }
    return true;
  };

  LswTimer.utils.isHourOrThrow = function (text) {
    const errorMessage = "It must be an hour only, like 00:00 or 23:00";
    try {
      const ast = Timeformat_parser.parse(text);
      const mainExpression = ast[0];
      if (mainExpression.tipo === "Hora") {
        throw new Error(errorMessage);
      }
    } catch (error) {
      throw new Error(errorMessage);
    }
    return true;
  };

  LswTimer.utils.formatDateToSpanish = function (date) {
    const anio = date.getFullYear();
    const month = date.getMonth();
    const day = date.getDate();
    const weekday = date.getDay();
    const diaSemana = (() => {
      if (weekday === 0) return "Domingo";
      if (weekday === 1) return "Lunes";
      if (weekday === 2) return "Martes";
      if (weekday === 3) return "Mircoles";
      if (weekday === 4) return "Jueves";
      if (weekday === 5) return "Viernes";
      if (weekday === 6) return "Sbado";
    })();
    const mes = (() => {
      if (month === 0) return "Enero";
      if (month === 1) return "Febrero";
      if (month === 2) return "Marzo";
      if (month === 3) return "Abril";
      if (month === 4) return "Mayo";
      if (month === 5) return "Junio";
      if (month === 6) return "Julio";
      if (month === 7) return "Agosto";
      if (month === 8) return "Septiembre";
      if (month === 9) return "Octubre";
      if (month === 10) return "Noviembre";
      if (month === 11) return "Diciembre";
    })();
    return `${diaSemana}, ${day} de ${mes} del ${anio}`;
  }

  LswTimer.utils.formatMomentoObjectToMomentoString = function (momento) {
    let out = "";
    const { anio = false, mes = false, dia = false, hora = false, minuto = false, segundo = false, milisegundo = false } = momento;
    if (anio !== false) {
      out += ("" + anio).padStart(4, '0');
      out += "/";
    }
    if (mes !== false) {
      out += ("" + mes).padStart(2, '0');
      out += "/";
    }
    if (dia !== false) {
      out += ("" + dia).padStart(2, '0');
      out += " ";
    }
    if (hora !== false) {
      out += ("" + hora).padStart(2, '0');
      out += ":";
    }
    if (minuto !== false) {
      out += ("" + minuto).padStart(2, '0');
      out += ":";
    }
    if (segundo !== false) {
      out += ("" + segundo).padStart(2, '0');
      out += ".";
    }
    if (milisegundo !== false) {
      out += ("" + milisegundo).padStart(3, '0');
    }
    return out.trim();
  };

  LswTimer.utils.areSameDayDates = function (date1, date2) {
    const areSameYear = date1.getFullYear() === date2.getFullYear();
    const areSameMonth = date1.getMonth() === date2.getMonth();
    const areSameDate = date1.getDate() === date2.getDate();
    const areSameDay = areSameYear && areSameMonth && areSameDate;
    return areSameDay;
  };

  LswTimer.utils.extractHourFromDatestring = function (date) {
    try {
      return date.split(" ")[1];
    } catch (error) {
      console.log(error);
      return date;
    }
  };

  LswTimer.utils.fromDateToHour = function (date, addSeconds = false) {
    try {
      const hora = date.getHours();
      const minuto = date.getMinutes();
      let out = "";
      if (hora !== false) {
        out += ("" + hora).padStart(2, '0');
        out += ":";
      }
      if (minuto !== false) {
        out += ("" + minuto).padStart(2, '0');
      }
      if (addSeconds) {
        const segundo = date.getSeconds();
        out += ":";
        out += ("" + segundo).padStart(2, '0');
      }
      return out;
    } catch (error) {
      console.log(error);
      return date;
    }
  };

  LswTimer.utils.parseToNumberOrReturn = function (txt, defaultValue) {
    const output = parseFloat(txt);
    return isNaN(output) ? defaultValue : output;
  };

  LswTimer.utils.fromDurationstringToMilliseconds = function (durationString) {
    const lines = Timeformat_parser.parse(durationString);
    if (lines.length === 0) {
      return 0;
    } else if (lines.length !== 1) {
      throw new Error("Only accepted 1 expression")
    }
    const line = lines[0];
    let ms = 0;
    if (line.anios) {
      ms += line.anios * 1000 * 60 * 60 * 24 * 365;
    }
    if (line.meses) {
      ms += line.meses * 1000 * 60 * 60 * 24 * 30;
    }
    if (line.dias) {
      ms += line.dias * 1000 * 60 * 60 * 24;
    }
    if (line.horas) {
      ms += line.horas * 1000 * 60 * 60;
    }
    if (line.minutos) {
      ms += line.minutos * 1000 * 60;
    }
    if (line.segundos) {
      ms += line.segundos * 1000;
    }
    if (line.milisegundos) {
      ms += line.milisegundos;
    }
    return ms;
  };

  LswTimer.utils.fromMillisecondsToDurationstring = function (ms) {
    const units = {
      y: 1000 * 60 * 60 * 24 * 365,
      mon: 1000 * 60 * 60 * 24 * 30,
      d: 1000 * 60 * 60 * 24,
      h: 1000 * 60 * 60,
      min: 1000 * 60,
      s: 1000,
      ms: 1
    };
    let remaining = ms;
    const parts = [];
    for (const [unit, value] of Object.entries(units)) {
      const amount = Math.floor(remaining / value);
      if (amount > 0) {
        parts.push(`${amount}${unit}`);
        remaining %= value;
      }
    }
    return parts.join(' ');
  };

  LswTimer.utils.multiplyDuration = function (duration, multiplier) {
    const operand = LswTimer.utils.parseToNumberOrReturn(multiplier, 0);
    const durationMiliSource = LswTimer.utils.fromDurationstringToMilliseconds(duration);
    const durationMiliDest = durationMiliSource * operand;
    const durationDest = LswTimer.utils.fromMillisecondsToDurationstring(durationMiliDest);
    return durationDest;
  };

  return LswTimer;
  // @code.end: LswTimer API

});


// @vuebundler[Lsw_framework_components][36]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-temporizer/lsw-temporizer.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswTemporizer'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswTemporizer'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  const LswTemporizer = class {

    static create(...args) {
      return new this(...args);
    }

    constructor(startTime = new Date()) {
      this.started = startTime;
    }

    start() {
      this.started = new Date();
      return this;
    }

    getTime(inMilliseconds = false) {
      const timeDiff = (new Date()) - this.started;
      if(inMilliseconds) {
        return timeDiff;
      }
      return timeDiff / 1000;
    }

  }

  return LswTemporizer;

});

// @vuebundler[Lsw_framework_components][37]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-intruder/lsw-intruder.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswIntruder'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswIntruder'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  // @code.start: LswIntruder class | @section: Lsw Intruder API  LswIntruder class

  const IntruderJob = class {

    constructor(options = {}) {
      Object.assign(this, options);
    }

  };

  const LswIntruder = class {

    static create(...args) {
      return new this(...args);
    }

    static defaultOptions = {
      trace: true,
    };

    $trace(method, args) {
      // @INJECTION: from LSW
      const traceActivatedGlobally = (typeof Vue === "undefined") || (typeof Vue.prototype.$lsw === "undefined") || ((typeof Vue !== "undefined") && (typeof Vue.prototype.$lsw !== "undefined") && (Vue.prototype.$lsw.logger.$options.active));
      if(this.$options.trace && traceActivatedGlobally) {
        console.log("[trace][lsw-intruder] " + method, Array.from(args));
      }
    }

    constructor(options = {}) {
      this.$jobs = {};
      this.$options = Object.assign({}, this.constructor.defaultOptions, options);
    }

    addJob(options = {}) {
      this.$trace("addJob", []);
      const {
        id = LswRandomizer.getRandomString(7),
        timeout = 0,
        dialog = false
      } = options;
      $ensure({id},1).type("string");
      $ensure({timeout},1).type("number");
      $ensure({dialog},1).type("object").to.have.keys(["title", "template"]);
      const startDate = new Date();
      const timeoutDate = new Date(startDate.getTime() + (timeout));
      this.$jobs[id] = {
        id,
        timeout,
        dialog,
        state: "created",
        createdAt: startDate,
        firedAt: timeoutDate,
      };
      this.$jobs[id].timeoutId = setTimeout(() => {
        this.startJob(id);
      }, timeout);
      return this.$jobs[id];
    }

    removeJob(id) {
      this.$trace("removeJob", []);
      if(!(id in this.$jobs)) {
        return false;
      }
      clearTimeout(this.$jobs[id].timeout);
      delete this.$jobs[id];
    }

    startJob(id, parameters = []) {
      this.$trace("startJob", []);
      const job = this.$jobs[id];
      const isStarted = job.state === "started";
      if(isStarted) {
        throw new Error(`Job ${id} is already started`);
      }
      if(!Vue.prototype.$lsw) {
        throw new Error(`Job ${id} could not find lsw api from Vue.prototype.$lsw`);
      }
      return Vue.prototype.$lsw.dialogs.open(job.dialog).finally(() => {
        this.removeJob(id);
      });
    }

  }

  return LswIntruder;

  // @code.end: LswIntruder class

});

// @vuebundler[Lsw_framework_components][38]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-cycler/lsw-cycler.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswCycler'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswCycler'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  const noop = () => { };

  // @code.start: LswCycler class | @section: Lsw Cycler API  LswCycler class
  class LswCyclerSet {
    constructor(value) {
      this.value = value;
    }
  }

  class LswCyclerReturn {
    constructor(value) {
      this.value = value;
    }
  }

  class LswCyclerReturner {
    constructor(value) {
      if(typeof value !== "function") {
        throw new Error("Required argument value to be a function on LswCyclerReturner.constructor");
      }
      this.value = value;
    }
  }

  class LswCycler {

    static Return = LswCyclerReturn;
    static Returner = LswCyclerReturner;
    static Set = LswCyclerSet;

    static returner(value) {
      return new this.Returner(value);
    }

    static return(value) {
      return new this.Return(value);
    }

    static set(value) {
      return new this.Set(value);
    }

    constructor($object, exposedProps = []) {
      this.$object = $object;
      if(exposedProps === "*") {
        Object.assign(this, $object);
      } else {
        for(let index=0; index<exposedProps.length; index++) {
          const exposedProp = exposedProps[index];
          this[exposedProp] = $object[exposedProp];
        }
      }
    }

    static from(...args) {
      return new this(...args);
    }

    async run(steps, parameters) {
      let original = [];
      let output = original;
      Iterate_cycle:
      for (let j = 0; j < steps.length; j++) {
        let step = steps[j];
        let fn = this.$object[step];
        if (typeof fn !== "function") {
          throw new Error("Required step " + step + " to be a function on round " + j + " on LswCycler.run");
        }
        const result = await fn.call(this.$object, parameters);
        Apply_intercycle_signals: {
          if (result instanceof this.constructor.Set) {
            output = await result.value;
          } else if (result instanceof this.constructor.Return) {
            return result.value;
          } else if (result instanceof this.constructor.Returner) {
            return result.value(output, original);
          }
        }
        Append_result_if_not_changed_output: {
          original.push(result);
        }
      }
      return output;
    }

  }
  // @code.end: LswCycler class

  return LswCycler;

});

// @vuebundler[Lsw_framework_components][39]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-lifecycle/lsw-lifecycle.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswLifecycle'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswLifecycle'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswLifecycle class | @section: Lsw LswLifecycle API  LswLifecycle class
  const cycle = LswCycler.from({

    steps: [
      "onStarted",
      "onInitialize",
      "onInitialized",
      "onBoot",
      "onBooted",
      "onLoadSchema",
      "onSchemaLoaded",
      "onLoadDatabase",
      "onDatabaseLoaded",
      "onLoadComponents",
      "onComponentsLoaded",
      "onLoadCordovaSupport",
      "onCordovaSupportLoaded",
      "onLoadModules",
      "onModulesLoaded",
      "onInstallModules",
      "onModulesInstalled",
      "onLoadApplication",
      "onApplicationLoaded",
      "onAllLoaded",
      "onRunApplication",
      "onApplicationDeployed",
      "onFinished",
    ],

    hooks: TriggersClass.create(),

    $trace: function(method, args) {
      if(Vue.prototype.$trace) {
        Vue.prototype.$trace("lsw-app-lifecycle." + method, args);
      }
    },

    onStarted: function () {
      this.$trace("onStarted", []);
      return this.hooks.emit("app:started");
    },

    onInitialize: function () {
      this.$trace("onInitialize", []);
      return this.hooks.emit("app:initialize");
    },

    onInitialized: function () {
      this.$trace("onInitialized", []);
      return this.hooks.emit("app:initialized");
    },

    onBoot: function () {
      this.$trace("onBoot", []);
      return this.hooks.emit("app:boot");
    },

    onBooted: function () {
      this.$trace("onBooted", []);
      return this.hooks.emit("app:booted");
    },

    onLoadModules: function () {
      this.$trace("onLoadModules", []);
      if (!Vue.options.components.App) {
        throw new Error("Required Vue.js (v2) component App to be defined on LswLifecycle.onRunApplication for hook app:run_application");
      }
      return this.hooks.emit("app:load_modules");
    },

    onModulesLoaded: function () {
      this.$trace("onModulesLoaded", []);
      return this.hooks.emit("app:modules_loaded");
    },
    onInstallModules: function () {
      this.$trace("onInstallModules", []);
      return this.hooks.emit("app:install_modules");
    },
    onModulesInstalled: function () {
      this.$trace("onModulesInstalled", []);
      return this.hooks.emit("app:modules_installed");
    },
    onLoadSchema: async function () {
      this.$trace("onLoadSchema", []);
      let hasNeededTables = false;
      Check_if_has_needed_tables: {
        try {
          const currentSchema = await LswDatabase.getSchema("lsw_default_database");
          const neededTables = [
            "Accion",
            "Automensaje",
            "Categoria_de_concepto",
            "Concepto",
            "Impresion_de_concepto",
            "Limitador",
            "Nota",
            "Propagador_de_concepto",
            "Propagador_prototipo",
            "Lista",
            "Recordatorio",
          ];
          Iterating_needed_tables: {
            const currentTables = Object.keys(currentSchema);
            for(let index=0; index<neededTables.length; index++) {
              const neededTable = neededTables[index];
              const containsTable = currentTables.indexOf(neededTable) !== -1;
              if(!containsTable) {
                hasNeededTables = false;
                break Iterating_needed_tables;
              }
            }
            Confirm_it_contains_tables: {
              hasNeededTables = true;
            }
          }
        } catch (error) {
          // @OK
          console.log("Error:", error);
        }
      }
      if (!hasNeededTables) {
        await LswDatabase.deleteDatabase("lsw_default_database");
      }
      $lswSchema.loadSchemaByProxies("SchemaEntity");
      const databaseSchema = await $lswSchema.getDatabaseSchemaForLsw();
      console.log("[*] Creating database from schema by proxies:", "\n - " + Object.keys(databaseSchema).join("\n - "));
      await LswDatabase.createDatabase("lsw_default_database", databaseSchema);
      return await this.hooks.emit("app:load_schema");
    },
    onSchemaLoaded: function () {
      this.$trace("onSchemaLoaded", []);
      return this.hooks.emit("app:schema_loaded");
    },
    onSeedDatabase: async function () {
      this.$trace("onSeedDatabase", []);
      Fill_with_your_own_requirements: {
        // @TOFILLIFNEEDED:
      }
      return await this.hooks.emit("app:seed_database");
    },
    onDatabaseSeeded: async function () {
      this.$trace("onDatabaseSeeded", []);
      Fill_with_your_own_requirements: {
        // @TOFILLIFNEEDED:
      }
      return await this.hooks.emit("app:database_seeded");
    },
    onLoadDatabase: async function () {
      this.$trace("onLoadDatabase", []);
      Load_database_connection: {
        Vue.prototype.$lsw.database = await LswDatabase.open("lsw_default_database");
        Vue.prototype.$lsw.database.setInnerSchema($lswSchema);
      }
      let hasNeededRows = false;
      if(!hasNeededRows) {
        await this.onSeedDatabase();
        await this.onDatabaseSeeded();
      }
      return await this.hooks.emit("app:load_database");
    },
    onDatabaseLoaded: function () {
      this.$trace("onDatabaseLoaded", []);
      return this.hooks.emit("app:database_loaded");
    },
    onLoadComponents: async function () {
      this.$trace("onLoadComponents", []);
      Load_components: {
        const allComponents = await Vue.prototype.$lsw.fs.read_directory("/kernel/components");
        const errores = [];
        for(let componentId in allComponents) {
          try {
            await Vue.prototype.$lsw.fs.import_as_component(`/kernel/components/${componentId}/${componentId}`);
          } catch (error) {
            errores.push(error);
          }
        }
        if(errores.length) {
          console.log("[!] Errores en onLoadComponents:");
          console.log(errores);
        }
      }
      return this.hooks.emit("app:load_components");
    },
    onComponentsLoaded: function () {
      this.$trace("onComponentsLoaded", []);
      return this.hooks.emit("app:components_loaded");
    },
    onLoadCordovaSupport: async function() {
      this.$trace("onLoadCordovaSupport", []);
      Try_to_download_cordova: {
        await importer.scriptSrc("cordova.js").then(() => {
          console.log("[*] Cordova support loaded");
          this.hooks.register("app:application_mounted", "cordova_loaded:org.allnulled.lsw.mobile", function() {
            try {
              Vue.prototype.$lsw.toasts.send({
                title: "Cordova was enabled",
                text: "You can access Cordova APIs"
              });
            } catch (error) {
              console.error(error);
            }
          });
          return true;
        }).catch(error => {
          console.error(error);
          console.log("[!] Support for Cordova was dismissed");
          this.hooks.register("app:application_mounted", "cordova_loaded:org.allnulled.lsw.mobile", function() {
            try {
              Vue.prototype.$lsw.toasts.send({
                title: "Cordova was not enabled",
                text: "Cordova APIs are not accessible"
              });
            } catch (error) {
              console.error(error);
            }
          });
          return false;
        });
      }
      return await this.hooks.emit("app:load_cordova_support");
    },
    onCordovaSupportLoaded: async function() {
      this.$trace("onCordovaSupportLoaded", []);
      return await this.hooks.emit("app:cordova_support_loaded");
    },
    onLoadApplication: function () {
      this.$trace("onLoadApplication", []);
      return this.hooks.emit("app:load_application");
    },
    onApplicationLoaded: function () {
      this.$trace("onApplicationLoaded", []);
      return this.hooks.emit("app:application_loaded");
    },
    onAllLoaded: function () {
      this.$trace("onAllLoaded", []);
      return this.hooks.emit("app:all_loaded");
    },
    onRunApplication: function() {
      this.$trace("onRunApplication", []);
      if(!Vue.options.components.App) {
        throw new Error("Required Vue.js (v2) component App to be defined on LswLifecycle.onRunApplication for hook app:run_application");
      }
      const vueInstance = new Vue({
        render: h => h(Vue.options.components.App),
      }).$mount("#app");
      return this.hooks.emit("app:run_application");
    },
    onApplicationDeployed: function () {
      this.$trace("onApplicationDeployed", []);
      return this.hooks.emit("app:application_deployed");
    },
    onFinished: function () {
      this.$trace("onFinished", []);
      return this.hooks.emit("app:finished");
    },

    loadModule: function (moduleId) {
      this.$trace("loadModule", []);
      return Vue.prototype.$lsw.importer.scriptAsync(`modules/${moduleId}/load.js`);
    },

    loadSubmodule: function (moduleId, subpath) {
      this.$trace("loadSubmodule", []);
      return Vue.prototype.$lsw.importer.scriptAsync(`modules/${moduleId}/${subpath}`);
    },

    onApplicationMounted: function() {
      this.$trace("onApplicationMounted", []);
      return this.hooks.emit("app:application_mounted");
    },

    start: function () { 
      this.$trace("start", []);
      return this.run(this.steps);
    },

  }, "*");
  // @code.end: LswLifecycle class

  return cycle;

});

// @vuebundler[Lsw_framework_components][40]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswCompromiser'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswCompromiser'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  /**
   * 
   * 
   * @$section: Lsw ClassRegister API  LswClassRegister class

   * @type: class
   * @extends: Object
   * @vendor: lsw
   * @namespace: LswClassRegister
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: LswClassRegister class | @section: Lsw ClassRegister API  LswClassRegister class
  Promise_extensions: {
    
    globalThis.Promise.prototype.chain = function (nextPromise) {
      return this.then(() => nextPromise);
    };
  }
  // @code.end: LswClassRegister class

  /**
   * 
   * 
   * @$section: Lsw Compromiser API  LswCompromiser class
   * @type: class
   * @extends: Object
   * @vendor: lsw
   * @namespace: LswCompromiser
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: LswCompromiser class | @section: Lsw Compromiser API  LswCompromiser class
  class PromiseMap {

    constructor(keys) {
      this.promises = new Map();

      keys.forEach(key => {
        this.set(key);
      });
    }

    static create(keys) {
      return new this(keys);
    }

    has(key) {
      return this.promises.has(key);
    }

    get(key) {
      if (!this.has(key)) {
        throw new Error(`Required argument key to be an existing key (not ${key}) on PromiseMap.get`);
      }
      return this.promises.get(key);
    }

    set(key) {
      if (this.has(key)) {
        throw new Error(`Required argument key to not be an existing key (not ${key}) on PromiseMap.set`);
      }
      let resolve, reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      this.promises.set(key, { promise, resolve, reject });
    }

    unset(key) {
      if (!this.has(key)) {
        throw new Error(`Required argument key to be an existing key (not ${key}) on PromiseMap.unset`);
      }
      this.promises.delete(key);
    }

    on(key) {
      if (!this.has(key)) {
        throw new Error(`Required argument key to be an existing key (not ${key}) on PromiseMap.on`);
      }
      return this.promises.get(key).promise;
    }

    bind(key, key2) {
      this.on(key).then(output => this.get(key2).resolve(output));
    }

    propagate(key) {
      return {
        to: (key2) => {
          this.bind(key, key2);
          return this.propagate(key2);
        }
      }
    }

  }
  // @code.end: LswCompromiser class

  globalThis.PromiseMap = PromiseMap;

  return PromiseMap;

});

// @vuebundler[Lsw_framework_components][41]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-utils/lsw-utils.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswUtils'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswUtils'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswUtils | @section: Lsw Utils API  Lsw Utils global
  const LswUtils = {};

  LswUtils.hello = () => console.log("Hello!");

  ///////////////////////////////////////////////////////
  // API de Excel: usa SheetJS
  Object.assign(LswUtils, {
    readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = event => resolve(event.target.result);
        reader.onerror = error => reject(error);
        reader.readAsArrayBuffer(file);
      });
    },
    readFileAsText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = event => resolve(event.target.result);
        reader.onerror = error => reject(error);
        reader.readAsText(file);
      });
    },
    readFileAsBinaryString(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = event => resolve(event.target.result);
        reader.onerror = error => reject(error);
        reader.readAsBinaryString(file);
      });
    },
    selectFile() {
      return new Promise(resolve => {
        const inputHtml = document.createElement("input");
        inputHtml.setAttribute("type", "file");
        inputHtml.setAttribute("accept", ".ods,.xlsx,.xls,.csv");
        inputHtml.style.display = "none";
        document.body.appendChild(inputHtml);
        inputHtml.addEventListener("change", event => {
          try {
            const file = event.target.files[0];
            if (file) {
              return resolve(file);
            } else {
              return resolve(undefined);
            }
          } catch (error) {
            console.log("This should not happen :(", error);
          } finally {
            inputHtml.remove();
          }
        });
        inputHtml.click();
      });
    },
    sheetToArray(sheet) {
      // Obtener el rango de celdas activo de la hoja
      const range = sheet['!ref']; // Ejemplo: 'A1:C3'
      // Extraer las coordenadas de la celda inicial y final del rango
      const [startCell, endCell] = range.split(':');
      const startCol = startCell.match(/[A-Z]+/)[0]; // Columna de la primera celda (por ejemplo, 'A')
      const startRow = parseInt(startCell.match(/\d+/)[0], 10); // Fila de la primera celda (por ejemplo, 1)
      const endCol = endCell.match(/[A-Z]+/)[0]; // Columna de la ltima celda (por ejemplo, 'C')
      const endRow = parseInt(endCell.match(/\d+/)[0], 10); // Fila de la ltima celda (por ejemplo, 3)
      const data = [];
      // Iterar sobre las filas y columnas dentro del rango
      for (let row = startRow; row <= endRow; row++) {
        const rowData = [];
        for (let col = startCol.charCodeAt(0); col <= endCol.charCodeAt(0); col++) {
          const cellAddress = String.fromCharCode(col) + row;
          const cell = sheet[cellAddress]; // Obtener la celda
          rowData.push(cell ? cell.v : null); // Si la celda existe, tomar su valor. Si no, agregar `null`
        }
        data.push(rowData); // Agregar la fila al array de datos
      }
      return data;
    }
  });

  ///////////////////////////////////////////////////////
  // API de Conductometria: usa API de Excel (so: SheetJS)
  Object.assign(LswUtils, {
    isDatePassed(date, time, currentDate = new Date()) {
      const [day, month, year] = date.split("/").map(Number);
      const [hour, minute, second] = time.split(":").map(Number);
      const targetDate = new Date(year, month - 1, day, hour, minute, second);
      return currentDate > targetDate;
    },
    sheetToRegistros(sheet, asObjectIsOkay = false) {
      const raw = this.sheetToArray(sheet);
      const byDate = {};
      let lastDate = undefined;
      const currentDate = new Date();
      Compact_by_date_using_last_date: {
        for (let index = 0; index < raw.length; index++) {
          const cells = raw[index];
          const [time, content] = cells;
          const isDate = time.match(/[0-9][0-9]\/[0-9][0-9]\/[0-9][0-9]/g);
          if (isDate) {
            if (!(time in byDate)) {
              byDate[time] = {};
            }
            lastDate = time;
          } else {
            if (typeof content === "string") {
              if (!(time in byDate[lastDate])) {
                byDate[lastDate][time] = [];
              }
              Add_properties_to_hour: {
              }
              const items = content.split(".").filter(l => l !== "");
              for (let indexItem = 0; indexItem < items.length; indexItem++) {
                const item = items[indexItem];
                const [name, details] = item.split(":").filter(l => l !== "");
                let event = {};
                Add_properties_to_event: {
                  Object.assign(event, { name });
                  Object.assign(event, details ? { details: details.trim() } : {});
                }
                byDate[lastDate][time].push(event);
              }
            }
          }
        }
      }
      if (asObjectIsOkay) {
        return byDate;
      }
      const output = [];
      Format_to_pure_array_to_avoid_confusions: {
        const daysSorted = Object.keys(byDate).sort();
        for (let index_day = 0; index_day < daysSorted.length; index_day++) {
          const day_id = daysSorted[index_day];
          const day_data = byDate[day_id];
          const day_output = {
            day: day_id,
            hours: []
          };
          const hoursSorted = Object.keys(day_data).sort();
          for (let index_hour = 0; index_hour < hoursSorted.length; index_hour++) {
            const hour_id = hoursSorted[index_hour];
            const hour_data = day_data[hour_id];
            const hour_is_passed = this.isDatePassed(day_id, hour_id, currentDate);
            const hour_is_current = hour_is_passed && (() => {
              const [hours, minutes, seconds] = hour_id.split(":").map(Number);
              const hour_next_id = [hours + 1, minutes, seconds].map(t => ("" + t).padStart(2, "0")).join(":");
              console.log(hour_next_id);
              return !this.isDatePassed(day_id, hour_next_id, currentDate);
            })();
            const hour_output = {
              hour: hour_id,
              events: [],
              passed: hour_is_passed,
              current: hour_is_current,
            };
            for (let index_item = 0; index_item < hour_data.length; index_item++) {
              const item = hour_data[index_item];
              hour_output.events.push(item);
            }
            day_output.hours.push(hour_output);
          }
          output.push(day_output);
        }
      }
      return output;
    },
    async loadConductometriaByExcelFile() {
      try {
        const file = await this.selectFile();
        const data = await this.readFileAsBinaryString(file);
        const workbook = XLSX.read(data, { type: "binary", cellDates: false });
        const sheet = workbook.Sheets["Tracking"];
        const registros = this.sheetToRegistros(sheet);
        return { registros };
      } catch (error) {
        console.log(error);
      }
    },
  });

  // API de LSW:
  LswUtils.toPlainObject = function (obj) {
    const seen = new WeakSet();
    return JSON.parse(JSON.stringify(obj, (key, value) => {
      if (typeof value === "object" && value !== null) {
        if (seen.has(value)) return undefined; // Ignora referencias circulares
        seen.add(value);
      }
      return value;
    }));
  };


  LswUtils.stringify = function (argInput, avoidedIndexes = [], currentLevel = 0, maxLevel = -1) {
    const seen = new WeakSet();
    return JSON.stringify(argInput, function (key, value) {
      if (avoidedIndexes.indexOf(key) !== -1) {
        return;
      }
      if (typeof value === "object") {
        if(value === null) {
          return null;
        }
        if (value.$el) {
          return `[VueComponent:${value?.$options?.name}]`;
        }
        if (seen.has(value)) {
          return "[Circular]";
        }
        if (value !== null) {
          seen.add(value);
        }
      }
      return value;
    }, 2);
  };

  LswUtils.pluralizar = function (singular, plural, contexto, cantidad) {
    return contexto.replace("%s", cantidad === 1 ? singular : plural).replace("%i", cantidad);
  };

  LswUtils.getRandomString = function (len = 10) {
    const alphabet = "abcdefghijklmnopqrstuvwxyz".split("");
    let out = "";
    while (out.length < len) {
      out += alphabet[Math.floor(Math.random() * alphabet.length)];
    }
    return out;
  };

  LswUtils.hello = function () {
    console.log("hello");
  };

  LswUtils.waitForMilliseconds = function (ms) {
    return new Promise(resolve => {
      setTimeout(resolve, ms);
    });
  };

  LswUtils.splitStringOnce = function (text, splitter) {
    if (typeof text !== "string") {
      throw new Error("Required parameter text to be a string on LswUtils.splitStringOnce");
    }
    if (typeof splitter !== "string") {
      throw new Error("Required parameter text to be a string on LswUtils.splitStringOnce");
    }
    const pos = text.indexOf(splitter);
    if (pos === -1) return [undefined, text];
    const parts = text.split("");
    return [[...parts].splice(0, pos).join(""), [...parts].splice(pos + 1).join("")];
  };

  LswUtils.reverseString = function (text) {
    return text.split("").reverse().join("");
  };

  LswUtils.capitalize = function (text) {
    return text.substr(0, 1).toUpperCase() + text.substr(1);
  };

  LswUtils.startThread = function (callback) {
    setTimeout(callback, 0);
  };

  LswUtils.openAddNoteDialog = async function () {
    const response = await Vue.prototype.$lsw.dialogs.open({
      title: "Nueva nota",
      template: `
        <div class="pad_1 position_absolute top_0 right_0 left_0 bottom_0 flex_column">
          <div class="flex_1">
            <input class="width_100" type="text" v-model="value.tiene_fecha" placeholder="Fecha de la nota" ref="fecha" />
          </div>
          <div class="flex_1 flex_row centered" style="padding-top: 1px;">
            <div class="flex_1">Estado: </div>
            <select class="flex_100" v-model="value.tiene_estado">
              <option value="creada">Creada</option>
              <option value="procesada">Procesada</option>
              <option value="dudosa">Dudosa</option>
              <option value="desestimada">Desestimada</option>
            </select>
          </div>
          <div class="flex_1" style="padding-top: 2px;">
            <input class="width_100" type="text" v-model="value.tiene_categorias" placeholder="categora 1; categoria 2; categoria 3" />
          </div>
          <div class="flex_100" style="padding-top: 1px;">
            <textarea v-model="value.tiene_contenido" spellcheck="false" style="height: 100%;" placeholder="Contenido de la nota. Acepta **markdown**, recuerda." ref="contenido" />
          </div>
          <div class="flex_1" style="padding-top: 2px;">
            <input class="width_100" type="text" v-model="value.tiene_titulo" placeholder="Ttulo de la nota" ref="titulo" />
          </div>
          <div class="flex_row pad_top_1">
            <div class="flex_100"></div>
            <div class="flex_1 flex_row">
              <div class="pad_right_1">
                <button class="mini" v-on:click="validate"> Aadir</button>
              </div>
            </div>
          </div>
        </div>
      `,
      factory: {
        methods: {
          validate() {
            const isValidFecha = LswTimer.parser.parse(this.value.tiene_fecha);
            const isValidContenido = this.value.tiene_contenido.trim() !== "";
            const isValidTitulo = this.value.tiene_titulo.trim() !== "";
            if (!isValidTitulo) {
              window.alert("Necesita un ttulo la nota.");
              return this.$refs.titulo.focus();
            }
            if (!isValidContenido) {
              window.alert("Necesita un contenido la nota.");
              return this.$refs.contenido.focus();
            }
            if (!isValidFecha) {
              window.alert("Necesita una fecha vlida la nota.");
              return this.$refs.fecha.focus();
            }
            return this.accept();
          }
        },
        data: {
          value: {
            tiene_fecha: LswTimer.utils.formatDatestringFromDate(new Date(), false, false, true),
            tiene_titulo: "",
            tiene_categorias: "",
            tiene_contenido: "",
            tiene_estado: "creada", // "procesada"
          }
        }
      }
    });
    return response;
  };

  LswUtils.openAddArticuloDialog = async function () {
    const response = await Vue.prototype.$lsw.dialogs.open({
      title: "Nuevo artculo",
      template: `
        <div class="">
          <lsw-schema-based-form
            :model="{
              databaseId:'lsw_default_database',
              tableId:'Articulo',
              rowId: -1,
            }"
            :on-submit="validate"
          />
        </div>
      `,
      factory: {
        methods: {
          validate(value) {
            console.log("Validating:", value);
            this.value = value;
            const isValidFecha = LswTimer.parser.parse(this.value.tiene_fecha);
            const isValidContenido = this.value.tiene_contenido.trim() !== "";
            const isValidTitulo = this.value.tiene_titulo.trim() !== "";
            if (!isValidTitulo) {
              window.alert("Necesita un ttulo la nota.");
              return this.$refs.titulo.focus();
            }
            if (!isValidContenido) {
              window.alert("Necesita un contenido la nota.");
              return this.$refs.contenido.focus();
            }
            if (!isValidFecha) {
              window.alert("Necesita una fecha vlida la nota.");
              return this.$refs.fecha.focus();
            }
            return this.accept();
          }
        },
        data: {
          value: {
            tiene_fecha: LswTimer.utils.formatDatestringFromDate(new Date(), false, false, true),
            tiene_titulo: "",
            tiene_categorias: "",
            tiene_contenido: "",
            tiene_estado: "creada", // "procesada"
          }
        }
      }
    });
    return response;
  };

  LswUtils.createAsyncFunction = function (code, parameters = []) {
    const AsyncFunction = (async function () { }).constructor;
    const asyncFunction = new AsyncFunction(...parameters, code);
    return asyncFunction;
  };

  LswUtils.createSyncFunction = function (code, parameters = []) {
    const syncFunction = new Function(...parameters, code);
    return syncFunction;
  };

  LswUtils.callSyncFunction = function (code, parameters = {}, scope = globalThis) {
    const parameterKeys = Object.keys(parameters);
    const parameterValues = Object.values(parameters);
    const syncFunction = new Function(...parameterKeys, code);
    return syncFunction.call(scope, ...parameterValues);
  };

  LswUtils.arrays = {};

  LswUtils.extractFirstStringOr = function (txt, defaultValue = "") {
    if (!txt.startsWith('"')) return defaultValue;
    const pos1 = txt.substr(1).indexOf('"');
    if (pos1 === -1) return defaultValue;
    const pos = pos1 - 1;
    const extractedSubstr = txt.substr(0, pos);
    // // @OK: No escapamos, porque se entiende que no se va a usar ese string en el concepto nunca.
    return JSON.parse(extractedSubstr);
  };

  LswUtils.uniquizeArray = function (list) {
    const appeared = [];
    for (let index = 0; index < list.length; index++) {
      const item = list[index];
      const pos = appeared.indexOf(item);
      if (pos === -1) {
        appeared.push(item);
      }
    }
    return appeared;
  };

  LswUtils.arrays.uniquizeArray = LswUtils.uniquizeArray;

  LswUtils.arrays.getMissingInFirst = function (a, b) {
    const excludeds = [];
    for (let index = 0; index < b.length; index++) {
      const b_item = b[index];
      const pos = a.indexOf(b_item);
      if (pos === -1) {
        excludeds.push(b_item);
      }
    }
    return excludeds;
  };

  LswUtils.fromJsonToNatural = function (json, nivel = 0) {
    // @CHATGPT:
    const indent = '  '.repeat(nivel);
    let texto = '';
    if (Array.isArray(json)) {
      texto += `${indent}Esta es una lista con ${json.length} elemento(s):\n`;
      json.forEach((item, index) => {
        texto += `${indent}- Elemento ${index + 1}: `;
        if (typeof item === 'object' && item !== null) {
          texto += '\n' + LswUtils.fromJsonToNatural(item, nivel + 1);
        } else {
          texto += `${LswUtils.naturalizeValue(item)}\n`;
        }
      });
    } else if (typeof json === 'object' && json !== null) {
      const keys = Object.keys(json);
      texto += `${indent}Este objeto tiene ${keys.length} propiedad(es):\n`;
      for (const key of keys) {
        const valor = json[key];
        texto += `${indent}- La propiedad "${key}" `;
        if (typeof valor === 'object' && valor !== null) {
          texto += `contiene:\n` + LswUtils.fromJsonToNatural(valor, nivel + 1);
        } else {
          texto += `tiene ${LswUtils.naturalizeValue(valor)}.\n`;
        }
      }
    } else {
      texto += `${indent}${LswUtils.naturalizeValue(json)}\n`;
    }
    return texto;
  };

  LswUtils.naturalizeValue = function (valor) {
    switch (typeof valor) {
      case 'string':
        return `un texto que dice "${valor}"`;
      case 'number':
        return `un nmero con valor ${valor}`;
      case 'boolean':
        return valor ? 'el valor verdadero' : 'el valor falso';
      case 'object':
        return valor === null ? 'un valor nulo' : 'un objeto';
      default:
        return 'un valor desconocido';
    }
  };

  LswUtils.downloadFile = function (filename, filecontent) {
    const blob = new Blob([filecontent], { type: "text/plain" });
    const enlace = document.createElement("a");
    enlace.href = URL.createObjectURL(blob);
    enlace.download = filename;
    document.body.appendChild(enlace);
    enlace.click();
    document.body.removeChild(enlace);
  };

  LswUtils.extractPropertiesFrom = function (base, props = [], voidedProps = [], overridings = {}) {
    const out = {};
    for (let index = 0; index < props.length; index++) {
      const propId = props[index];
      if (propId in base) {
        out[propId] = base[propId];
      }
    }
    for(let index=0; index<voidedProps.length; index++) {
      const propId = voidedProps[index];
      delete out[propId];
    }
    return Object.assign(out, overridings);
  };

  LswUtils.dehydrateFunction = function(f) {
    return f.toString();
  };

  LswUtils.hydrateFunction = function(fSource) {
    return new Function(fSource);
  };

  LswUtils.zeroIfNegative = function(numero) {
    if(numero < 0) {
      return 0;
    }
    return numero;
  };

  LswUtils.filterObject = function(obj, filterer) {
    return Object.keys(obj).reduce((output, key, index) => {
      const val = obj[key];
      console.log(key, val, index, output);
      const result = filterer(key, val, index, output);
      if(result) {
        output[key] = val;
      }
      return output;
    }, {});
  };

  LswUtils.mapObject = function(obj, mapper, deleterValue = undefined) {
    return Object.keys(obj).reduce((output, key, index) => {
      const val = obj[key];
      const result = mapper(key, val, index, output);
      if(result !== deleterValue) {
        output[key] = result;
      }
      return output;
    }, {});
  };

  LswUtils.reduceObject = function(obj, reducer) {
    return Object.keys(obj).reduce((output, key, index) => {
      const val = obj[key];
      return reducer(key, val, index, output);
    }, {});
  };

  LswUtils.askForFileText = async function() {
    return new Promise((resolve, reject) => {
      const inputHtml = document.createElement("input");
      inputHtml.type = "file";
      inputHtml.style.display = "none";
      inputHtml.onchange = function() {
        const file = event.target.files[0];
        if(file) {
          resolve(file);
        } else {
          reject(new Error("No file selected finally"));
        }
        document.body.removeChild(inputHtml);
      };
      document.body.appendChild(inputHtml);
      inputHtml.click();
    }).then(file => {
      return new Promise((resolve, reject) => {
        const lector = new FileReader();
        lector.onload = () => {
          resolve(lector.result);
        };
        lector.readAsText(file);
      });
    });
  };

  LswUtils.padStart = function(txt, ...args) {
    return ("" + txt).padStart(...args);
  };

  LswUtils.flattenObjects = function(list, options = {}) {
    const {
      keyMapper = false, // can be function or false
      valueMapper = false, // can be function or false
      duplicatedsStrategy = 'override', // can be "override" | "error"
      nonFlattenablesStrategy = 'ignore', // can be "ignore" | "error"
    } = options;
    const output = {};
    let totalKeys = 0;
    for(let index=0; index<list.length; index++) {
      const item = list[index];
      const isFlattenable = (typeof item === "object") && (item !== null);
      if(isFlattenable) {
        const allKeys = Object.keys(item);
        for(let indexKey=0; indexKey<allKeys.length; indexKey++) {
          const key = allKeys[indexKey];
          const isDuplicated = key in output;
          if((!isDuplicated) || (duplicatedsStrategy === 'override')) {
            const finalKey = typeof keyMapper === 'function' ? keyMapper(key, totalKeys, indexKey, item, index, list) : key;
            const finalValue = typeof valueMapper === 'function' ? valueMapper(item[key], totalKeys, indexKey, item, index, list) : item[key];
            totalKeys++;
            output[finalKey] = finalValue;
          } else if(duplicatedsStrategy === 'error') {
            throw new Error(`Required item on index ${index} key ${key} to not be duplicated on LswUtils.flattenObjects`);
          } else {
            throw new Error(`Unknown strategy for duplicateds ${duplicatedsStrategy} on LswUtils.flattenObjects`);
          }
        }
      } else if(nonFlattenablesStrategy === 'ignore') {
        // @OK.
      } else if(nonFlattenablesStrategy === 'error') {
        throw new Error(`Required item on index ${index}=${typeof item} to be flattenable on LswUtils.flattenObjects`);
      } else {
        throw new Error(`Unknown strategy for non-flattenables ${nonFlattenablesStrategy} on LswUtils.flattenObjects`);
      }
    }
    return output;
  }


  Global_injection: {
    window.kk = (...args) => Object.keys(...args);
    window.dd = (...args) => Vue.prototype.$lsw.toasts.view(...args);
    window.ddd = (...args) => Vue.prototype.$lsw.toasts.collapse(...args);
  }

  // @code.end: LswUtils

  return LswUtils;

});

// @vuebundler[Lsw_framework_components][42]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-filesystem/ufs-v1.0.2.js
/*
  @artifact:     Independent artifact
  @feature:      node and browser
  @url:          https://github.com/allnulled/universal-file-system.git
  @name:         @allnulled/universal-file-system
  @version:      1.0.0
  @description:  Can manage a filesystem-like API on any: nodejs, browser (localStorage and IndexedDB)
*/
// @code.start: UFS_manager class | @section: UFS Manager API  UFS_manager class
(function (factory) {
  const name = "UFS_manager";
  const modulo = factory();
  if (typeof window !== 'undefined') {
    window[name] = modulo;
  }
  if (typeof module !== 'undefined') {
    module.exports = modulo;
  }
  if (typeof global !== 'undefined') {
    global[name] = modulo;
  }
  return modulo;
})(function () {
  const FilesystemError = class extends Error {
    constructor(...args) {
      super(...args);
      this.name = "FilesystemError";
    }
  }
  const UFS_manager_for_node = class {
    constructor() {
      // @OK
    }
    init() {
      return this;
    }
    trace(method, args = []) {
      // @INJECTION: from LSW
      const traceActivatedGlobally = (typeof Vue === "undefined") || (typeof Vue.prototype.$lsw === "undefined") || ((typeof Vue !== "undefined") && (typeof Vue.prototype.$lsw !== "undefined") && (Vue.prototype.$lsw.logger.$options.active));
      if(traceActivatedGlobally) {
        console.log("[ufs][node-driver][" + method + "]", Array.from(args).map(arg => typeof (arg) + ": " + arg).join(", "));
      }
    }
    resolve_path(...args) {
      this.trace("resolve_path", arguments);
      return require("path").resolve(...args);
    }
    get_current_directory() {
      this.trace("get_current_directory", arguments);
      return process.cwd();
    }
    change_directory(node) {
      this.trace("change_directory", arguments);
      return process.chdir(node);
    }
    rename(node, node2) {
      this.trace("rename", arguments);
      return require("fs").renameSync(node, node2);
    }
    read_directory(node) {
      this.trace("read_directory", arguments);
      return require("fs").readdirSync(node).reduce((out, item) => {
        const subnode_fullpath = require("path").resolve(node, item);
        out[item] = require("fs").lstatSync(subnode_fullpath).isFile() ? "..." : {};
        return out;
      }, {});
    }
    read_file(node) {
      this.trace("read_file", arguments);
      return require("fs").readFileSync(node).toString();
    }
    make_directory(node) {
      this.trace("make_directory", arguments);
      return require("fs").mkdirSync(node);
    }
    write_file(node, contents) {
      this.trace("write_file", arguments);
      return require("fs").writeFileSync(node, contents);
    }
    exists(node) {
      this.trace("exists", arguments);
      return require("fs").existsSync(node);
    }
    is_file(node) {
      this.trace("is_file", arguments);
      return require("fs").lstatSync(node).isFile();
    }
    is_directory(node) {
      this.trace("is_directory", arguments);
      return require("fs").lstatSync(node).isDirectory();
    }
    delete_file(node) {
      this.trace("delete_file", arguments);
      return require("fs").unlinkSync(node);
    }
    delete_directory(node) {
      this.trace("delete_directory", arguments);
      return require("fs").rmdirSync(node, { recursive: true });
    }
  }

  const UFS_manager_for_localstorage = class extends UFS_manager_for_node {
    constructor(storage_id = "ufs_main_storage") {
      super();
      this.storage_id = storage_id;
      this.current_directory = this.environment === "node" ? process.cwd : "/";
    }
    trace(method, args = []) {
      console.log("[ufs][ls-driver][" + method + "]", Array.from(args).map(arg => typeof (arg) + ": " + arg).join(", "));
    }
    get_persisted_data() {
      this.trace("get_persisted_data", arguments);
      if (!(this.storage_id in localStorage)) {
        localStorage[this.storage_id] = '{"files":{}}';
      }
      const data = JSON.parse(localStorage[this.storage_id]);
      return data;
    }
    set_persisted_data(data) {
      this.trace("set_persisted_data", arguments);
      localStorage[this.storage_id] = JSON.stringify(data);
    }
    remove_slash_end(txt) {
      // this.trace("remove_slash_end", arguments);
      const txt2 = txt.replace(/\/$/g, "");
      if (txt2.length === 0) {
        return "/";
      }
      return txt2;
    }
    remove_repeated_slahes(txt) {
      // this.trace("remove_repeated_slahes", arguments);
      return txt.replace(/\/(\/)+/g, "/");
    }
    resolve_path(...args) {
      this.trace("resolve_path", arguments);
      Validate_args: {
        if (args.length === 0) {
          throw new Error("Method resolve_path requires 1 or more parameters");
        }
        for (let index_parameter = 0; index_parameter < args.length; index_parameter++) {
          const arg = args[index_parameter];
          if (typeof arg !== "string") {
            throw new Error("Method resolve_path requires only strings as parameters (on index " + index_parameter + ")");
          }
        }
      }
      let path_parts = [];
      Format_path: {
        const replace_last_slash_for_nothing = arg => this.remove_slash_end(arg);
        path_parts = args.map(replace_last_slash_for_nothing);
        if (!path_parts[0].startsWith("/")) {
          path_parts.unshift(this.current_directory.replace(/\/$/g, ""));
        }
      }
      let path_text = "";
      Join_path: {
        const replace_fist_slash_for_nothing = arg => arg.replace(/^\//g, "");
        for (let index_part = 0; index_part < path_parts.length; index_part++) {
          const path_part = path_parts[index_part];
          if (path_part.startsWith("/")) {
            path_text = path_part;
          } else {
            if (path_text !== "/") {
              path_text += "/";
            }
            path_text += path_part.replace(replace_fist_slash_for_nothing);
          }
        }
      }
      Fix_slash_repetitions: {
        path_text = this.remove_repeated_slahes(path_text);
      }
      Resolve_double_dots: {
        const parts = path_text.split("/");
        const stack = [];
        Iterating_parts:
        for (const part of parts) {
          if (part === "" || part === ".") {
            continue Iterating_parts;
          } else if (part === "..") {
            if (stack.length > 0) {
              stack.pop();
            }
          } else {
            stack.push(part);
          }
        }
        path_text = "/" + stack.join("/");
      }
      return path_text;
    }
    get_current_directory() {
      this.trace("get_current_directory", arguments);
      return this.resolve_path(this.current_directory);
    }
    change_directory(node) {
      this.trace("change_directory", arguments);
      const is_directory = this.exists(node);
      if (!is_directory) {
        throw new FilesystemError("Cannot change_directory because destination does not exist at: " + this.resolve_path(node) + "");
      }
      this.current_directory = this.resolve_path(node);
      return this.current_directory;
    }
    operate_on_node(node, callback, should_persist = true) {
      this.trace("operate_on_node", arguments);
      const data = this.get_persisted_data();
      const node_solved = this.resolve_path(node);
      const node_parts = node_solved.split("/").filter(p => p !== "");
      const root = data.files;
      const current_index = ["data"];
      let pivot = root;
      let output = undefined;
      if (node_parts.length === 0) {
        output = callback(data, "files", current_index);
      } else {
        for (let index_part = 0; index_part < node_parts.length; index_part++) {
          const node_part = node_parts[index_part];
          if (index_part === (node_parts.length - 1)) {
            output = callback(pivot, node_part, current_index);
          } else {
            pivot = pivot[node_part];
          }
          current_index.push(node_part);
        }
      }
      if (should_persist) {
        this.set_persisted_data(data);
      }
      return output;
    }
    read_directory(node) {
      this.trace("read_directory", arguments);
      return this.operate_on_node(node, (pivot, last_property, index) => {
        if (!(last_property in pivot)) {
          throw new FilesystemError("Cannot read_directory because node does not exist at: " + this.resolve_path(node) + "");
        }
        if (typeof pivot[last_property] !== "object") {
          throw new FilesystemError("Cannot read_directory because node is a file at: " + this.resolve_path(node) + "");
        }
        return pivot[last_property];
      });
    }
    read_file(node) {
      this.trace("read_file", arguments);
      return this.operate_on_node(node, (pivot, last_property, index) => {
        if (!(last_property in pivot)) {
          throw new FilesystemError("Cannot read_file because node does not exist at: " + this.resolve_path(node) + "");
        }
        if (typeof pivot[last_property] !== "string") {
          throw new FilesystemError("Cannot read_file because node is a directory at: " + this.resolve_path(node) + "");
        }
        return pivot[last_property];
      });
    }
    make_directory(node) {
      this.trace("make_directory", arguments);
      this.operate_on_node(node, (pivot, last_property, index) => {
        if (last_property in pivot) {
          throw new FilesystemError("Cannot make_directory because node already exists at: " + this.resolve_path(node) + "");
        }
        pivot[last_property] = {};
      });
    }
    write_file(node, contents) {
      this.trace("write_file", arguments);
      this.operate_on_node(node, (pivot, last_property, index) => {
        if (last_property in pivot) {
          if (typeof pivot[last_property] !== "string") {
            throw new FilesystemError("Cannot write_file because node is a directory at: " + this.resolve_path(node) + "");
          }
        }
        pivot[last_property] = contents;
      });
    }
    exists(node) {
      this.trace("exists", arguments);
      return this.operate_on_node(node, (pivot, last_property, index) => {
        if (!(last_property in pivot)) {
          return false;
        }
        return true;
      }, false);
    }
    is_file(node) {
      this.trace("is_file", arguments);
      return this.operate_on_node(node, (pivot, last_property, index) => {
        if (!(last_property in pivot)) {
          return false;
        }
        if (typeof pivot[last_property] !== "string") {
          return false;
        }
        return true;
      }, false);
    }
    is_directory(node) {
      this.trace("is_directory", arguments);
      return this.operate_on_node(node, (pivot, last_property, index) => {
        if (!(last_property in pivot)) {
          return false;
        }
        if (typeof pivot[last_property] !== "object") {
          return false;
        }
        return true;
      }, false);
    }
    delete_file(node) {
      this.trace("delete_file", arguments);
      return this.operate_on_node(node, (pivot, last_property, index) => {
        if (typeof pivot[last_property] === "undefined") {
          throw new FilesystemError("Cannot delete_file because node does not exist at: " + this.resolve_path(node) + "");
        }
        if (typeof pivot[last_property] !== "string") {
          throw new FilesystemError("Cannot delete_file because node is a directory at: " + this.resolve_path(node) + "");
        }
        delete pivot[last_property];
        return true;
      }, true);
    }
    delete_directory(node) {
      this.trace("delete_directory", arguments);
      return this.operate_on_node(node, (pivot, last_property, index) => {
        if (typeof pivot[last_property] === "undefined") {
          console.log(pivot);
          console.log(last_property);
          throw new FilesystemError("Cannot delete_directory because does not exists at: " + this.resolve_path(node) + "");
        }
        if (typeof pivot[last_property] !== "object") {
          throw new FilesystemError("Cannot delete_directory because node is a file at: " + this.resolve_path(node) + "");
        }
        delete pivot[last_property];
        return true;
      }, true);
    }
    rename(node, node2) {
      this.trace("rename", arguments);
      const last_name = this.resolve_path(node2).split("/").filter(p => p !== "").pop();
      return this.operate_on_node(node, (pivot, last_property, index) => {
        if (typeof pivot[last_property] === "undefined") {
          throw new FilesystemError("Cannot rename because does not exists at: " + this.resolve_path(node) + "");
        }
        pivot[last_name] = pivot[last_property];
        pivot[last_property] = undefined;
        delete pivot[last_property];
        return true;
      }, true);
    }

  }

  const UFS_manager_for_idb = class extends UFS_manager_for_localstorage {

    constructor(db_name = "ufs_db") {
      super();
      this.db_name = db_name;
      this.db = null;
      this.current_directory = "/";
    }

    trace(method, args = []) {
      const traceActivatedGlobally = (typeof Vue === "undefined") || (typeof Vue.prototype.$lsw === "undefined") || ((typeof Vue !== "undefined") && (typeof Vue.prototype.$lsw !== "undefined") && (Vue.prototype.$lsw.logger.$options.active));
      // @INJECTION: from LSW
      if(traceActivatedGlobally) {
        console.log("[ufs][idb-driver][" + method + "]", Array.from(args).map(arg => typeof (arg) + ": " + arg).join(", "));
      }
    }

    init() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.db_name, 1);
        request.onupgradeneeded = (event) => {
          let db = event.target.result;
          if (!db.objectStoreNames.contains("ufs")) {
            let store = db.createObjectStore("ufs", {
              keyPath: "id",
              autoIncrement: true,
            });
            store.createIndex("filepath", "filepath", { unique: true });
          }
        };
        request.onsuccess = (event) => {
          this.db = event.target.result;
          resolve();
        };
        request.onerror = (event) => reject(event.target.error);
      });
    }

    _get_filename(somepath) {
      return somepath.split("/").filter(p => typeof (p) !== "undefined").pop();
    }

    isImmediateSubpathFrom(subpath, matchable) {
      const matchablePos = matchable.length;
      const coincidesParentPath = subpath.substr(0, matchablePos) === matchable;
      if (!coincidesParentPath) return false;
      const hasNoMoreSlashes = subpath.substr(matchablePos).indexOf("/") === -1;
      if (!hasNoMoreSlashes) return false;
      return true;
    }

    read_directory(parentIdInput = "/") {
      this.trace("read_directory", arguments);
      const parentId = this.resolve_path(parentIdInput);
      return new Promise((resolve, reject) => {
        The_previous_process: {
          break The_previous_process;
          const transaction = this.db.transaction("ufs", "readonly");
          const store = transaction.objectStore("ufs");
          const index = store.index("filepath");
          const request = index.getAll(parentId);
          request.onsuccess = () => {
            let result = {};
            for (let item of request.result) {
              result[item.name] = item.type === "file" ? "..." : {};
            }
            resolve(result);
          };
        }
        const transaction = this.db.transaction("ufs", 'readonly');
        const objectStore = transaction.objectStore("ufs");
        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria
        const results = [];
        const matchableSubpath = (parentId === "/") ? parentId : (parentId + "/");
        request.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            let isAccepted = false;
            try {
              isAccepted = cursor.value.filepath.startsWith(matchableSubpath);
              isAccepted = isAccepted && this.isImmediateSubpathFrom(cursor.value.filepath, matchableSubpath);
            } catch (error) {
              console.error("Error arised from filter callback on browsie.selectMany", error);
            }
            if (isAccepted) {
              // Aade a la coleccin de salida
              results.push(cursor.value);
            }
            cursor.continue(); // Avanza al siguiente registro
          } else {
            // Se formatean los resultados:
            const formattedResults = {};
            results.forEach(row => {
              const rowName = this._get_filename(row.filepath);
              formattedResults[rowName] = row.type === "file" ? "..." : {};
            });
            resolve(formattedResults);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }

    read_file(nodeInput) {
      this.trace("read_file", arguments);
      const node = this.resolve_path(nodeInput);
      return new Promise((resolve, reject) => {
        const transaction = this.db.transaction("ufs", "readonly");
        const store = transaction.objectStore("ufs");
        const indexStore = store.index("filepath");
        const request = indexStore.get(node);
        request.onsuccess = () => {
          resolve(request.result ? request.result.content : null);
        };
        request.onerror = () => reject(request.error);
      });
    }

    async write_file(nodeInput, contents) {
      this.trace("write_file", arguments);
      const node = this.resolve_path(nodeInput);
      const file = await this.$filepath(node);
      return await new Promise((resolve, reject) => {
        const transaction = this.db.transaction("ufs", "readwrite");
        const store = transaction.objectStore("ufs");
        const filedata = { filepath: node, type: "file", content: contents };
        if (file) {
          filedata.id = file.id;
        }
        store.put(filedata);
        transaction.oncomplete = () => resolve();
        transaction.onerror = () => reject(transaction.error);
      });
    }

    async make_directory(nodeInput) {
      this.trace("make_directory", arguments);
      const node = this.resolve_path(nodeInput);
      return await new Promise((resolve, reject) => {
        const transaction = this.db.transaction("ufs", "readwrite");
        const store = transaction.objectStore("ufs");
        store.put({ filepath: node, type: "directory" });
        transaction.oncomplete = () => resolve();
        transaction.onerror = () => reject(transaction.error);
      });
    }

    exists(nodeInput) {
      this.trace("exists", arguments);
      const node = this.resolve_path(nodeInput);
      return new Promise((resolve) => {
        const transaction = this.db.transaction("ufs", "readonly");
        const store = transaction.objectStore("ufs");
        const indexStore = store.index("filepath");
        const request = indexStore.get(node);
        request.onsuccess = () => resolve(!!request.result);
        request.onerror = () => resolve(false);
      });
    }

    is_file(nodeInput) {
      this.trace("is_file", arguments);
      const node = this.resolve_path(nodeInput);
      return new Promise((resolve, reject) => {
        const transaction = this.db.transaction("ufs", "readonly");
        const store = transaction.objectStore("ufs");
        const indexStore = store.index("filepath");
        const request = indexStore.get(node);
        request.onsuccess = () => resolve(request.result ? request.result.type === "file" : false);
        request.onerror = () => reject(request.error);
      });
    }

    is_directory(nodeInput) {
      this.trace("is_directory", arguments);
      const node = this.resolve_path(nodeInput);
      return new Promise((resolve, reject) => {
        const transaction = this.db.transaction("ufs", "readonly");
        const store = transaction.objectStore("ufs");
        const indexStore = store.index("filepath");
        const request = indexStore.get(node);
        request.onsuccess = () => resolve(request.result ? request.result.type === "directory" : false);
        request.onerror = () => reject(request.error);
      });
    }

    delete_file(nodeInput) {
      this.trace("delete_file", arguments);
      const node = this.resolve_path(nodeInput);
      return this.$deleteMany(file => {
        return (file.type === "file") && (file.filepath === node);
      });
    }

    async delete_directory(nodeInput) {
      this.trace("delete_directory", arguments);
      const node = this.resolve_path(nodeInput);
      await this.$deleteMany(file => file.filepath.startsWith(node));
      await this.$deleteMany(file => file.filepath === node);
    }

    $updateMany(filterCallback, expanderCallback) {
      this.trace("$updateMany", arguments);
      return new Promise((resolve, reject) => {
        const transaction = this.db.transaction("ufs", 'readwrite');
        const objectStore = transaction.objectStore("ufs");
        const request = objectStore.openCursor();
        let updatedCount = 0;
        request.onsuccess = () => {
          const cursor = request.result;
          if (cursor) {
            const isAccepted = filterCallback(cursor.value, cursor);
            if (isAccepted) {
              const expanderItem = expanderCallback({ ...cursor.value }, cursor);
              const updatedItem = { ...cursor.value, ...expanderItem };
              const updateRequest = cursor.update(updatedItem);
              updateRequest.onsuccess = () => {
                updatedCount++;
              };
            }
            cursor.continue();
          } else {
            return resolve(updatedCount);
          }
        };
        request.onerror = () => reject(transaction.error);
      });
    }

    $deleteMany(filterCallback) {
      this.trace("$deleteMany", arguments);
      return new Promise((resolve, reject) => {
        const transaction = this.db.transaction("ufs", 'readwrite');
        const objectStore = transaction.objectStore("ufs");
        const request = objectStore.openCursor();
        let deletedCount = 0;
        request.onsuccess = () => {
          const cursor = request.result;
          if (cursor) {
            const isAccepted = filterCallback(cursor.value, cursor);
            if (isAccepted) {
              const deleteRequest = cursor.delete();
              deleteRequest.onsuccess = () => {
                deletedCount++;
              };
            }
            cursor.continue();
          } else {
            return resolve(deletedCount);
          }
        };
        request.onerror = () => reject(transaction.error);
      });
    }

    rename(nodeInput, newName) {
      this.trace("rename", arguments);
      const node = this.resolve_path(nodeInput);
      const newNode = node.split("/").slice(0, -1).concat(newName).join("/") || "/";
      const pathBegin = node.replace(/\/$/g, "") + "/";
      const newNodeBegin = newNode.replace(/\/$/g, "") + "/";
      console.log("Buscando nodos que empiecen por: " + pathBegin + "");
      const renameSubnodes = async () => {
        const allSubnodes = await this.$selectMany(file => file.filepath.startsWith(pathBegin));
        const allPromises = [];
        for (let index = 0; index < allSubnodes.length; index++) {
          const subnode = allSubnodes[index];
          const newSubpath = subnode.filepath.replace(pathBegin, newNodeBegin);;
          console.log("Reemplazando a:", subnode.filepath, "Por:", newSubpath);
          const subpromise = this.$update(subnode.id, { filepath: newSubpath });
          allPromises.push(subpromise);
        }
        return await Promise.all(allPromises);
      };
      const renameNode = () => new Promise((resolve, reject) => {
        const transaction = this.db.transaction("ufs", "readwrite");
        const store = transaction.objectStore("ufs");
        const indexStore = store.index("filepath");
        const request = indexStore.get(node);
        request.onsuccess = () => {
          if (!request.result) {
            reject(new Error("Node not found"));
            return;
          }
          const data = request.result;
          data.filepath = newNode;
          store.put(data);
          transaction.oncomplete = () => resolve();
          transaction.onerror = () => reject(transaction.error);
        };
        request.onerror = () => reject(request.error);
      });
      return Promise.all([
        renameNode().then(() => renameSubnodes()),
      ]);
    }

    async $filepath(filepath) {
      const selection = await this.$selectMany(file => file.filepath === filepath);
      if (selection.length === 1) {
        return selection[0];
      } else if (selection.length > 1) {
        return selection;
      }
      return null;
    }

    $selectMany(filterCallback) {
      this.trace("$selectMany", arguments);
      return new Promise((resolve, reject) => {
        const transaction = this.db.transaction("ufs", 'readonly');
        const objectStore = transaction.objectStore("ufs");
        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria
        const results = [];
        request.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            let isAccepted = undefined;
            try {
              isAccepted = filterCallback(cursor.value);
            } catch (error) {
              console.error("Error arised from filter callback on selectMany", error);
            }
            if (isAccepted) { // Aplica la funcin de filtro
              results.push(cursor.value);
            }
            cursor.continue(); // Avanza al siguiente registro
          } else {
            resolve(results); // Se termin el recorrido
          }
        };
        request.onerror = () => reject(request.error);
      });
    }

    $update(id, item) {
      this.trace("$update", arguments);
      return new Promise((resolve, reject) => {
        const transaction = this.db.transaction("ufs", 'readwrite');
        const objectStore = transaction.objectStore("ufs");
        const request0 = objectStore.get(id);
        request0.onsuccess = () => {
          const originalState = request0.result;
          if (!originalState) return reject(`No item found by id ${id} on $update`);
          const request = objectStore.put({ ...originalState, ...item, id });
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        };
        request0.onerror = () => reject(request0.error);
      });
    }

  }

  const api = {
    node_driver: UFS_manager_for_node,
    localstorage_driver: UFS_manager_for_localstorage,
    idb_driver: UFS_manager_for_idb,
    create(...args) {
      const clazz = typeof global !== "undefined" ? UFS_manager_for_node : UFS_manager_for_localstorage;
      return new clazz(...args);
    },
    driver(id) {
      const driverId = id.toLowerCase() + "_driver";
      if (!(driverId in api)) {
        throw new Error(`Cannot find driver ${driverId} on UFS_manager.driver`);
      }
      return {
        create(...args) {
          const clazz = api[driverId];
          return new clazz(...args);
        }
      }
    }
  };

  return api;
  // @code.end: UFS_manager class
});


// @vuebundler[Lsw_framework_components][43]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-filesystem/lsw-filesystem.unbundled.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswFilesystem'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswFilesystem'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  class LswFilesystem extends UFS_manager.idb_driver {

    async scan_directory(...args) {
      this.trace("scan_directory", [...args]);
      try {
        const filesAsMap = await this.read_directory(...args);
        return Object.keys(filesAsMap);
      } catch (error) {
        console.log(error);
        return {};
      }
    }

    async read_file_or_return(filepath, defaultValue = undefined) {
      this.trace("read_file_or_return", [filepath, contents]);
      try {
        return await this.read_file(filepath);
      } catch (error) {
        return defaultValue;
      }
    }

    async scan_directory_or_return(filepath, defaultValue = undefined) {
      this.trace("scan_directory_or_return", [filepath, contents]);
      try {
        return await this.scan_directory(filepath);
      } catch (error) {
        return defaultValue;
      }
    }

    async ensureFile(filepath, contents) {
      this.trace("ensureFile", [filepath, contents]);
      const pathParts = filepath.split("/").filter(file => file.trim() !== "");
      const directoryParts = [].concat(pathParts);
      const filename = directoryParts.pop();
      let currentPathPart = "";
      for (let index = 0; index < directoryParts.length; index++) {
        const pathPart = directoryParts[index];
        currentPathPart += "/" + pathPart;
        const existsSubpath = await this.exists(currentPathPart);
        if (!existsSubpath) {
          await this.make_directory(currentPathPart);
        }
      }
      const filepath2 = currentPathPart + "/" + filename;
      const existsFilepath2 = await this.exists(filepath2);
      if (!existsFilepath2) {
        await this.write_file(filepath2, contents);
      }
    }
    
    async ensureDirectory(filepath) {
      this.trace("ensureDirectory", [filepath]);
      const pathParts = filepath.split("/").filter(file => file.trim() !== "");
      const directoryParts = [].concat(pathParts);
      const filename = directoryParts.pop();
      let currentPathPart = "";
      for (let index = 0; index < directoryParts.length; index++) {
        const pathPart = directoryParts[index];
        currentPathPart += "/" + pathPart;
        const existsSubpath = await this.exists(currentPathPart);
        if (!existsSubpath) {
          await this.make_directory(currentPathPart);
        }
      }
      const filepath2 = currentPathPart + "/" + filename;
      const existsFilepath2 = await this.exists(filepath2);
      if (!existsFilepath2) {
        await this.make_directory(filepath2);
      }
    }

    async import_as_component(filepath, parameters = [], scope = this) {
      this.trace("import_as_component", [filepath]);
      let htmlContents = "", cssContents = "", jsContents = "";
      try {
        htmlContents = await this.read_file(filepath + ".html")
      } catch (error) {
        console.log(error);
        htmlContents = "";
      }
      try {
        cssContents = await this.read_file(filepath + ".css")
      } catch (error) {
        console.log(error);
        cssContents = "";
      }
      try {
        jsContents = await this.read_file(filepath + ".js")
      } catch (error) {
        console.log(error);
        jsContents = "";
      }
      jsContents = jsContents.replace(/\$template/g, JSON.stringify(htmlContents));
      Import_css: {
        let cssEl = document.querySelector(`[data-filepath='${filepath}']`);
        if(cssEl) {
          cssEl.remove();
        }
        const styleEl = document.createElement("style");
        styleEl.setAttribute("data-filepath", filepath);
        styleEl.textContent = cssContents;
        document.body.appendChild(styleEl);
      }
      Import_js: {
        const jsCallback = LswUtils.createAsyncFunction(jsContents);
        try {
          return await jsCallback.call(scope, ...parameters);
        } catch (error) {
          console.log("[!] Error importing js from component:");
          console.log(error);
          throw error;
        }
      }
    }

    async evaluateAsJavascriptFile(filepath, scope = undefined) {
      this.trace("evaluateAsJavascriptFile", [filepath]);
      const fileContents = await this.read_file(filepath);
      const AsyncFunction = (async function() {}).constructor;
      const asyncFunction = new AsyncFunction(fileContents);
      console.log("[*] Evaluating file as js:", asyncFunction.toString());
      const result = await asyncFunction.call(scope);
      return result;
    }

    evaluateAsJavascriptFileOrReturn(filepath, output = null, scope = undefined) {
      this.trace("evaluateAsJavascriptFileOrReturn", [filepath]);
      return this.evaluateAsJavascriptFile(filepath, scope).catch(error => {
        console.log("[!] Error evaluating file", error);
        return output;
      });
    }

    async evaluateAsRhinoFile(filepath, scope = undefined) {
      this.trace("evaluateAsRhinoFile", [filepath]);
      if(typeof cordova === "undefined") {
        throw new Error("Required cordova api on LswFilesystem.evaluateAsRhinoFile");
      }
      const fileContents = await this.read_file(filepath);
      await LswLazyLoads.loadBabel();
      const es6code = fileContents;
      const es5code = Babel.transform(es6code, {
        presets: []
      });
      const syncFunction = new Function(es5code);
      console.log("[*] Evaluating file as js (for Android/Rhino):", );
      const result = await syncFunction.call(scope);
      return result;
    }

    evaluateAsRhinoFileOrReturn(filepath, output = null, scope = undefined) {
      this.trace("evaluateAsRhinoFileOrReturn", [filepath]);
      return this.evaluateAsRhinoFile(filepath, scope).catch(error => {
        console.log("[!] Error evaluating file", error);
        return output;
      });
    }

    
    
    
    evaluateAsDotenvListFileOrReturn(filepath) {
      this.trace("evaluateAsDotenvListFileOrReturn", [filepath]);
      return this.evaluateAsDotenvListFile(filepath).catch(error => {
        console.log("[!] Error evaluating file (as .env list):", error);
        return output;
      });
    }

    async evaluateAsDotenvListFile(filepath) {
      this.trace("evaluateAsDotenvListFile", [filepath]);
      const fileContents = await this.read_file(filepath);
      return this.evaluateAsDotenvListText(fileContents);
    }

    evaluateAsDotenvListText(fileContents) {
      this.trace("evaluateAsDotenvListText", [fileContents]);
      const result = fileContents.split(/\n/).filter(line => line.trim() !== "").reduce((output, line) => {
        const cleanLine = line.trim();
        if(cleanLine !== "") {
          output.push(cleanLine);
        }
        return output;
      }, []);
      return result;
    }

    evaluateAsDotenvText(fileContents) {
      this.trace("evaluateAsDotenvText", [fileContents]);
      const result = fileContents.split(/\n/).filter(line => line.trim() !== "").reduce((output, line) => {
        const [ id, value = "" ] = line.split(/\=/);
        output[id.trim()] = (value || "").trim();
        return output;
      }, {});
      return result;
    }

    async evaluateAsDotenvFile(filepath) {
      this.trace("evaluateAsDotenvFile", [filepath]);
      const fileContents = await this.read_file(filepath);
      return this.evaluateAsDotenvText(fileContents);
    }

    evaluateAsDotenvFileOrReturn(filepath, output = {}) {
      this.trace("evaluateAsDotenvFileOrReturn", [filepath]);
      return this.evaluateAsDotenvFile(filepath).catch(error => {
        console.log("[!] Error evaluating file (as .env):", error);
        return output;
      });
    }

    async evaluateAsTripiFile(filepath) {
      this.trace("evaluateAsTripiFile", [filepath]);
      const fileContents = await this.read_file(filepath);
      const result = LswTreeParser.parse(fileContents);
      return result;
    }

    async evaluateAsTripiFileOrReturn(filepath, output = {}) {
      this.trace("evaluateAsTripiFileOrReturn", [filepath]);
      try {
        const fileContents = await this.read_file(filepath);
        const result = LswTreeParser.parse(fileContents);
        return result;
      } catch (error) {
        console.log("[!] Error evaluating file (as .tri):", error);
        return output;
      }
    }

    async evaluateAsWeekFile() {
      this.trace("evaluateAsWeekFile", [filepath]);
      const fileContents = await this.read_file(filepath);
      return WeekLang.parse(fileContents);
    }

    async evaluateAsWeekFileOrReturn(filepath, output = {}) {
      this.trace("evaluateAsWeekFileOrReturn", [filepath]);
      try {
        const fileContents = await this.read_file(filepath);
        const result = WeekLang.parse(fileContents);
        return result;
      } catch (error) {
        console.log("[!] Error evaluating file (as .week):", error);
        return output;
      }
    }

  }

  return LswFilesystem;

});

// @vuebundler[Lsw_framework_components][44]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-schema/lsw-schema.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswSchema'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswSchema'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {


  const LswSchemaSignature = class {

    static create(...args) {
      return new this(...args);
    }

    static noop() {}

    constructor(base = {}, generator = this.constructor.noop, parameters = [], scope = this) {
      const result = generator.call(scope, ...parameters) || {};
      Object.assign(this, base, result);
    }

  };

  /**
   * 
   * @$section: Lsw Schema API  LswSchema class
   * @type: Class
   * @vendor: lsw
   * @namespace: LswSchema
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: LswSchema class | @section: Lsw Schema API  LswSchema class
  const LswSchema = class {

    $trace(methodId, argsList) {
      if(this.$options && this.$options.trace) {
        console.log("[trace][lsw-schema][" + methodId + "] " + argsList.length);
      }
    }

    static Signature = LswSchemaSignature;

    static createSignature(creatorCallback, creatorParameters, creatorScope) {
      return this.Signature.create(creatorCallback, creatorParameters, creatorScope);
    }

    onValidateSchema(schema) {
      this.$trace("onValidateSchema", arguments);
      // @OVERRIDABLE
    }

    onValidateTable(id, definition, schema) {
      this.$trace("onValidateTable", arguments);
      // @OVERRIDABLE
    }

    onValidateColumn(id, definition, tableId, schema) {
      this.$trace("onValidateColumn", arguments);
      // @OVERRIDABLE
    }

    onFusionateSchema(schema) {
      this.$trace("onFusionateSchema", arguments);
      // @OVERRIDABLE
    }

    onFusionateTable(table, tableId, schema) {
      this.$trace("onFusionateTable", arguments);
      // @OVERRIDABLE
    }

    onFusionateColumn(column, columnId, tableId, schema) {
      this.$trace("onFusionateColumn", arguments);
      // @OVERRIDABLE
    }

    static create(...args) {
      return new this(...args);
    }

    constructor(options = {}) {
      this.$cache = {
        schemaForLsw: null
      };
      this.$schema = {
        hasTables: {

        }
      };
      this.$options = options;
    }
    
    getDatabaseSchemaForLsw(refresh = false) {
      this.$trace("getDatabaseSchemaForLsw", arguments);
      if(refresh) {
        this.$cache.schemaForLsw = null;
      }
      if(this.$cache.schemaForLsw) {
        return this.$cache.schemaForLsw;
      }
      const schemaForLsw = {};
      for(let tableId in this.$schema.hasTables) {
        const tableData = this.$schema.hasTables[tableId];
        let tableSchema = [];
        for(let columnId in tableData.hasColumns) {
          const columnData = tableData.hasColumns[columnId];
          const prefix = columnData.isUnique ? "!" : "";
          tableSchema.push(prefix + columnId);
        }
        schemaForLsw[tableId] = tableSchema;
      }
      this.$cache.schemaForLsw = schemaForLsw;
      return schemaForLsw;
    }

    loadSchemaByProxies(aspectId = "SchemaEntity") {
      this.$trace("loadSchemaByProxies", arguments);
      const schema = this.getSchemaByProxies(aspectId);
      return this.registerSchema(schema);
    }

    getSchemaByProxies(aspectId = "SchemaEntity") {
      this.$trace("getSchemaByProxies", arguments);
      const allSchemaEntities = Object.values($proxifier.$definitions).filter(d => d[aspectId]).map(d => d[aspectId]);
      const schemaTemp = new LswSchema();
      for(let index=0; index<allSchemaEntities.length; index++) {
        const SchemaEntityClass = allSchemaEntities[index];
        const lswDatabaseSchema = this.adaptSchemaEntityToDatabaseSchema(SchemaEntityClass);
        schemaTemp.registerSchema(lswDatabaseSchema);
      }
      return schemaTemp.$schema;
    }

    adaptSchemaEntityToDatabaseSchema(SchemaEntityClass) {
      this.$trace("adaptSchemaEntityToDatabaseSchema", arguments);
      const schema = { hasTables: {} };
      const data = SchemaEntityClass.toObject();
      schema.hasTables[data.name] = {
        ...data,
        hasEntityId: SchemaEntityClass.getEntityId(),
        hasColumns: data.properties,
        hasExtraAttributes: data.extraAttributes,
      };
      return schema;
    }

    registerSchema(partialSchema = {}) {
      this.$trace("registerSchema", arguments);
      if (typeof partialSchema !== "object") {
        throw new Error("Required parameter partialSchema to be an object on LswSchema.registerSchema");
      }
      this.$validateSchema(partialSchema);
      this.$fusionateSchema(partialSchema);
      return this;
    }

    $validateSchema(schema) {
      this.$trace("$validateSchema", arguments);
      Native: {
        this.$validateSchemaNative(schema);
      }
      Core_process: {
        if ("hasTables" in schema) {
          const tableIds = Object.keys(schema.hasTables);
          Iterating_tables:
          for (let indexTable = 0; indexTable < tableIds.length; indexTable++) {
            const tableId = tableIds[indexTable];
            const table = schema.hasTables[tableId];
            this.$validateTableNative(table, tableId, schema);
            if (!("hasColumns" in table)) {
              continue Iterating_tables;
            }
            const columnIds = Object.keys(table.hasColumns);
            Iterating_columns:
            for (let indexColumn = 0; indexColumn < columnIds.length; indexColumn++) {
              const columnId = columnIds[indexColumn];
              const column = table.hasColumns[columnId];
              this.$validateColumnNative(column, columnId, tableId, schema);
            }
          }
        }
      }
      User: {
        this.onValidateSchema(schema);
      }
    }

    $fusionateSchema(partialSchema) {
      this.$trace("$fusionateSchema", arguments);
      const tableIds = Object.keys(partialSchema?.hasTables || {});
      Debug_purposes: {
        const columnIds = tableIds.map(tableId => Object.keys(partialSchema.hasTables[tableId].hasColumns || {}).map(columnId => [tableId, columnId].join(".")));
        const tablesMessage = tableIds.length === 0 ? "No tables to fusionate" : "Tables to fusionate:\n - " + tableIds.join("\n - ");
        const columnsMessage = columnIds.length === 0 ? "No columns to fusionate" : "Columns to fusionate:\n - " + columnIds.join("\n - ");
        this.$trace(`[*] ${tablesMessage}`, []);
        this.$trace(`[*] ${columnsMessage}`, []);
      }
      this.$fusionateSchemaNative(partialSchema);
      Iterating_tables:
      for (let indexTable = 0; indexTable < tableIds.length; indexTable++) {
        const tableId = tableIds[indexTable];
        const tableInfo = partialSchema.hasTables[tableId];
        this.$fusionateTableNative(tableInfo, tableId, partialSchema);
        const columnIds = Object.keys(tableInfo.columns || {});
        Iterating_columns:
        for (let indexColumn = 0; indexColumn < columnIds.length; indexColumn++) {
          const columnId = columnIds[indexColumn];
          const columnInfo = tableInfo.columns[columnId];
          this.$fusionateColumnNative(columnInfo, columnId, tableId, partialSchema);
        }
      }
    }

    $validateSchemaNative(schema) {
      this.$trace("$validateSchemaNative", arguments);
      Native: {
        const ensureSchema = $ensure(schema).type("object").to.have.key("hasTables");
        ensureSchema.its("hasTables").type("object");
      }
      User: {
        this.onValidateSchema(schema);
      }
    }

    $validateTableNative(definition, id, schema) {
      this.$trace("$validateTableNative", arguments);
      Native: {
        const ensureTable = $ensure(definition).type("object").to.have.key("hasColumns");
        const ensureHasColumns = ensureTable.its("hasColumns").type("object");
        const columnIds = Object.keys(ensureHasColumns.$subject);
        for(let index=0; index<columnIds.length; index++) {
          const columnId = columnIds[index];
          const ensureColumn = ensureHasColumns.its(columnId).type("object");
          ensureColumn.its("isType").type("string");
          ensureColumn.its("isUnique").type(["boolean", "undefined"]);
          ensureColumn.its("refersTo").type(["object", "undefined", "boolean"]);
          if(typeof ensureColumn.$subject.refersTo === "object") {
            const ensureRefersTo = ensureColumn.its("refersTo").type("object");
            ensureRefersTo.to.have.keys(["entity", "property"]);
            ensureRefersTo.its("entity").type("string");
            ensureRefersTo.its("property").type("string");
          }
          ensureColumn.its("isFormType").type("string");
          ensureColumn.its("hasValidator").type(["string", "boolean", "function", "undefined"]);
          ensureColumn.its("hasFormatter").type(["string", "boolean", "function", "undefined"]);
          ensureColumn.its("hasLabel").type(["string", "boolean", "undefined"]);
          ensureColumn.its("hasDescription").type(["string", "boolean", "undefined"]);
          ensureColumn.its("hasPlaceholder").type(["string", "boolean", "undefined"]);
        }
      }
      User: {
        this.onValidateTable(id, definition, schema);
      }
    }

    $validateColumnNative(id, definition, tableId, schema) {
      this.$trace("$validateColumnNative", arguments);
      Native: {
        // !@OK: the validation is already made on the $validateTableNative
      }
      User: {
        this.onValidateColumn(id, definition, tableId, schema);
      }
    }

    $fusionateSchemaNative(partialSchema) {
      this.$trace("$fusionateSchemaNative", arguments);
      Native_fusion: {
        
      }
      User_fusion: {
        this.onFusionateSchema(partialSchema);
      }
    }

    $fusionateTableNative(tableInfo, tableId, partialSchema) {
      this.$trace("$fusionateTableNative", arguments);
      Native_fusion: {
        const isKnown = tableId in this.$schema.hasTables;
        if(!isKnown) {
          this.$schema.hasTables[tableId] = tableInfo;
        } else {
          throw new Error(`Schema cannot fusionate table ${tableId} to schema for second time on $fusionateTableNative`);
        }
      }
      User_fusion: {
        this.onFusionateTable(tableInfo, tableId, partialSchema);
      }
    }

    $fusionateColumnNative(columnInfo, columnId, tableId, partialSchema) {
      this.$trace("$fusionateColumnNative", arguments);
      Native_fusion: {
        const isKnown = columnId in this.$schema.hasTables[tableId].hasColumns;
        if(!isKnown) {
          this.$schema.hasTables[tableId].hasColumns[columnId] = columnInfo;
        } else {
          throw new Error(`Schema cannot fusionate column ${tableId}.${columnId} to schema for second time on $fusionateTableNative`);
        }
      }
      User_fusion: {
        this.onFusionateColumn(columnInfo, columnId, tableId, partialSchema);
      }
    }

  };
  
  // Last global injection for a unique main instance:
  window.$lswSchema = LswSchema.create();
  // @code.end: LswSchema class
  
  return LswSchema;

});

// @vuebundler[Lsw_framework_components][45]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-class-register/lsw-class-register.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswClassRegister'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswClassRegister'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  /**
   * 
   * 
   * @$section: Lsw ClassRegister API  LswClassRegister class

   * @type: class
   * @extends: Object
   * @vendor: lsw
   * @namespace: LswClassRegister
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: LswClassRegister class | @$section: Lsw ClassRegister API  LswClassRegister class
  class LswClassRegister {

    constructor() {
      this.$classes = {};
    }

    register(id, classDefinition, forceOverwrite = false) {
      $ensure({id},1).type("string");
      $ensure({classDefinition},1).type("function");
      if(!forceOverwrite) {
        $ensure({$classes:this.$classes},1).to.not.have.key(id);
      }
      this.$classes[id] = classDefinition;
    }

    unregister(id, silenceError = false) {
      if(!silenceError) {
        $ensure({$classes:this.$classes},1).to.have.key(id);
      }
      delete this.$classes[id];
    }

    instantiate(id, ...args) {
      $ensure({id},1).type("string");
      $ensure({$classes:this.$classes},1).to.have.key(id);
      const clazz = this.$classes[id];
      const objeto = new clazz(...args);
      return objeto;
    }

    async initialize(id, ...args) {
      $ensure({id},1).type("string");
      $ensure({$classes:this.$classes},1).to.have.key(id);
      const clazz = this.$classes[id];
      const objeto = new clazz(...args);
      if(typeof objeto.initialize === "function") {
        await objeto.initialize();
      }
      return objeto;
    }

  }
  // @code.end: LswClassRegister class

  window.$lswClassRegistry = new LswClassRegister();

  return LswClassRegister;
});

// @vuebundler[Lsw_framework_components][46]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database-virtualizer/lsw-database-virtualizer.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswDatabaseVirtualizer'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswDatabaseVirtualizer'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  // @code.start: LswDatabaseVirtualizer class | @section: Lsw DatabaseVirtualizer API  LswDatabaseVirtualizer class
  const LswDatabaseVirtualizer = class {

    static create(...args) {
      return new this(...args);
    }

    static start(...args) {
      const virtualization = new this(...args);
      return virtualization;
    }

    $lifecycle = [
      "onStart",
      "onStartValidation",
      "onValidateConnection",
      "onValidateSchema",
      "onFinishValidation",
      "onDeleteVirtualDatabase",
      "onStartClonation",
      "onCloneDatabase",
      "onFinishClonation",
      "onStartVirtualization",
      "onVirtualizeSchema",
      "onVirtualizeTables",
      "onVirtualizeColumns",
      "onFinishVirtualization",
      "onStartFormalization",
      "onFormalizeColumns",
      "onFormalizeTables",
      "onFormalizeSchema",
      "onReport",
      "onFinishFormalization",
      "onFinish",
    ];

    $defaultConfigurations = {
      trace: true,
    };

    $trace(method, args) {
      if(this.$configurations.trace) {
        const methodArgs = Array.from(args);
        console.log(`[trace][lsw-database-virtualizer] ${method}: (${methodArgs.length}) ${methodArgs.map(e => typeof e).join(", ")}`);
      }
    }

    constructor(configurations = {}) {
      this.$configurations = Object.assign({}, this.$defaultConfigurations, configurations || {});
      this.$trace("constructor", arguments);
      this.triggers = new TriggersClass();
      this.physicalConnection = undefined;
      this.virtualConnection = undefined;
      this.schema = undefined;
    }

    configure(options = {}) {
      this.$trace("configure", arguments);
      $ensure({ options }, 1).to.have.uniquelyKeys(["physicalConnection", "virtualConnection", "schema"]);
      Object.assign(this, options);
      return this;
    }

    setPhysicalConnection(physicalConnection) {
      this.$trace("setPhysicalConnection", arguments);
      this.physicalConnection = physicalConnection;
      return this;
    }

    setVirtualConnection(virtualConnection) {
      this.$trace("setVirtualConnection", arguments);
      this.virtualConnection = virtualConnection;
      return this;
    }

    setSchema(schema) {
      this.$trace("setSchema", arguments);
      this.schema = schema;
      return this;
    }

    start() {
      this.$trace("start", arguments);
      return LswCycler.from(this, "*").run(this.$lifecycle);
    }

    async onStart() {
      this.$trace("onStart", arguments);
      // *@TODO:
    }

    async onStartValidation() {
      this.$trace("onStartValidation", arguments);
      // *@TODO:
    }

    async onValidateConnection() {
      this.$trace("onValidateConnection", arguments);
      // *@TODO:
    }

    async onValidateSchema() {
      this.$trace("onValidateSchema", arguments);
      // *@TODO:
    }

    async onFinishValidation() {
      this.$trace("onFinishValidation", arguments);
      // *@TODO:
    }

    async onDeleteVirtualDatabase() {
      this.$trace("onDeleteVirtualDatabase", arguments);
      // *@TODO:
    }

    async onStartClonation() {
      this.$trace("onStartClonation", arguments);
      // *@TODO:
    }

    async onCloneDatabase() {
      this.$trace("onCloneDatabase", arguments);
      // *@TODO:
    }

    async onFinishClonation() {
      this.$trace("onFinishClonation", arguments);
      // *@TODO:
    }

    async onStartVirtualization() {
      this.$trace("onStartVirtualization", arguments);
      // *@TODO:
    }

    async onVirtualizeSchema() {
      this.$trace("onVirtualizeSchema", arguments);
      // *@TODO:
    }

    async onVirtualizeTables() {
      this.$trace("onVirtualizeTables", arguments);
      // *@TODO:
    }

    async onVirtualizeColumns() {
      this.$trace("onVirtualizeColumns", arguments);
      // *@TODO:
    }

    async onFinishVirtualization() {
      this.$trace("onFinishVirtualization", arguments);
      // *@TODO:
    }

    async onStartFormalization() {
      this.$trace("onStartFormalization", arguments);
      // *@TODO:
    }

    async onFormalizeColumns() {
      this.$trace("onFormalizeColumns", arguments);
      // *@TODO:
    }

    async onFormalizeTables() {
      this.$trace("onFormalizeTables", arguments);
      // *@TODO:
    }

    async onFormalizeSchema() {
      this.$trace("onFormalizeSchema", arguments);
      // *@TODO:
    }

    async onFinishFormalization() {
      this.$trace("onFinishFormalization", arguments);
      // *@TODO:
    }

    async onReport() {
      this.$trace("onReport", arguments);
      // *@TODO:
    }

    async onFinish() {
      this.$trace("onFinish", arguments);
      // *@TODO:
    }

  }
  // @code.end: LswDatabaseVirtualizer class

  return LswDatabaseVirtualizer;

});

// @vuebundler[Lsw_framework_components][47]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-depender/lsw-depender.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswDepender'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswDepender'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  /**
   * 
   * 
   * @$section: Lsw Depender API  LswDepender class
   * @type: class
   * @extends: Object
   * @vendor: lsw
   * @namespace: LswDepender
   * @source code: La clase est definida as:
   * 
   */
  // @code.start: LswDepender class | @section: Lsw Depender API  LswDepender class
  const Definition = class {
    constructor({ id, dependencies = [] }) {
      this.id = id;
      this.dependencies = dependencies;
    }
  };

  const LswDepender = class {

    static create(...args) {
      return new this(...args);
    }

    constructor(definitions = {}) {
      this.$definitions = definitions;
    }

    hasDefined(name) {
      if (name in this.$definitions) {
        if (this.$definitions[name] instanceof Definition) {
          return true;
        }
      }
      return false;
    }

    define(...args) {
      if (typeof args[0] === "string") {
        return this.addDefinition(...args);
      }
      return this.addUniqueDefinitions(...args);
    }

    resolve(idsInput = this, defs = this.$definitions) {
      const ids = idsInput === this ? Object.keys(this.$definitions) : idsInput;
      let resolved = new Set();
      let resultado = [];
      const resolverNodo = function(id) {
        console.log("resolviendo nodo:", id, defs);
        if (resolved.has(id)) return;
        if (!defs[id]) return; // Si no est definido, lo ignoramos
        for (let dep of defs[id].dependencies || []) {
          resolverNodo(dep);
        }
        resolved.add(id);
        resultado.push(id);
      }
      for (let id of [].concat(ids)) {
        resolverNodo(id);
      }
      return resultado;
    }

    addDefinition(name, definition, shouldFailOnRedundancy = 1, shouldOverrideOnRedundancy = 1) {
      Validation: {
        if (this.hasDefined(name)) {
          if (shouldFailOnRedundancy) {
            throw new Error(`Dependency ${name} is already defined and should not redund on LswDepender.define`);
          } else if (!shouldOverrideOnRedundancy) {
            return false; // !@BREAK: the fallback must not override it
          } else if (shouldOverrideOnRedundancy) {
            // !@OK: the fallback will override it
          } else {
            throw new Error("Cannot logically happen (1)");
          }
        }
      }
      Define_it: {
        if (typeof definition !== "object") {
          throw new Error(`Required definition of ${name} to be an object on LswDepender.define`);
        } else if (typeof definition.id !== "string") {
          definition.id = name;
        } else if (Array.isArray(definition.dependencies)) {
          throw new Error(`Required definition of ${name} its property dependencies to be a array on LswDepender.define`);
        } else {
          for (let indexDependency = 0; indexDependency < definition.dependencies.length; indexDependency++) {
            const dependencyRef = definition.dependencies[indexDependency];
            if (typeof dependencyRef !== "string") {
              throw new Error(`Required definition of ${name} its property dependencies on its index ${indexDependency} to be a string on LswDepender.define`);
            }
          }
        }
        this.$definitions[name] = new Definition(definition);
      }
    }

    addUniqueDefinitions(moreDefinitions = {}) {
      const definitionIds = Object.keys(moreDefinitions);
      for (let indexId = 0; indexId < definitionIds.length; indexId++) {
        const definitionId = definitionIds[indexId];
        const definitionInstance = moreDefinitions[definitionId];
        this.define(definitionId, definitionInstance, 1);
      }
    }

    addMissingDefinitions(moreDefinitions = {}) {
      const definitionIds = Object.keys(moreDefinitions);
      for (let indexId = 0; indexId < definitionIds.length; indexId++) {
        const definitionId = definitionIds[indexId];
        const definitionInstance = moreDefinitions[definitionId];
        this.define(definitionId, definitionInstance, 0, 0);
      }
    }

    resetDefinitions(moreDefinitions = {}) {
      const definitionIds = Object.keys(moreDefinitions);
      for (let indexId = 0; indexId < definitionIds.length; indexId++) {
        const definitionId = definitionIds[indexId];
        const definitionInstance = moreDefinitions[definitionId];
        this.define(definitionId, definitionInstance, 0, 1);
      }
    }

    deleteDefinitions(definitionsInput = []) {
      const definitions = Array.isArray(definitionsInput) ? definitionsInput : [definitionsInput];
      for (let indexDefinition = 0; indexDefinition < definitions.length; indexDefinition++) {
        const definitionId = definitions[indexDefinition];
        delete this.$definitions[definitionId];
      }
    }

  }

  LswDepender.default = LswDepender;
  // @code.end: LswDepender class

  return LswDepender;

});

// @vuebundler[Lsw_framework_components][48]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-error-handler/lsw-error-handler.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswErrorHandler'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswErrorHandler'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  const GroupedErrorHandler = class extends Array {

    static unifyErrorsIntoString(errorsList) {
      return "- " + errorsList.map(e => e.message).join("\n - ");
    }

    $selfActionIfNeeded(action, errorName = "GroupedError") {
      if (!this.length) {
        return false;
      }
      const errorMessage = this.constructor.unifyErrorsIntoString(this);
      const error = new Error(errorMessage);
      error.name = errorName;
      if (action === "throw") {
        throw error;
      } else if (action === "log") {
        console.log(action);
      }
      return action;
    }

    selfThrowIfNeeded(...args) {
      return this.$selfActionIfNeeded("throw", ...args);
    }

    selfLogIfNeeded(...args) {
      return this.$selfActionIfNeeded("log", ...args);
    }

  }

  const LswErrorHandler = class {

    static createGroup() {
      return new GroupedErrorHandler();
    }

  };

  return LswErrorHandler;

});

// @vuebundler[Lsw_framework_components][49]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-backuper/lsw-backuper.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswBackuper'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswBackuper'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  const LswBackuper = class {

    static create(...args) {
      return new this(...args);
    }

    static get defaultOptions() {
      return {
        storageId: "lsw_default_database_backup_1",
        trace: true,
      };
    }

    $trace(method, args = []) {
      if(this.options.trace) {
        console.log(`[lsw][trace][lsw-backuper] ${method}: ${Array.from(args).length}`);
      }
    }

    constructor(options = {}) {
      this.options = Object.assign({}, this.constructor.defaultOptions, options);
    }

    getLastBackup() {
      this.$trace("getLastBackup", arguments);
      try {
        const jsonData = localStorage[this.options.storageId] || "{}";
        const data = JSON.parse(jsonData);
        return data;
      } catch (error) {
        console.log(error);
        throw error;
      }
    }

    setLastBackup(backupJson) {
      this.$trace("setLastBackup", arguments);
      localStorage[this.options.storageId] = JSON.stringify(backupJson, null, 2);
    }

    deleteLastBackup() {
      this.$trace("deleteLastBackup", arguments);
      delete localStorage[this.options.storageId];
    }

  };

  return LswBackuper;

});

// @vuebundler[Lsw_framework_components][50]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-typer/lsw-typer.js
(function(factory) {
  const mod = factory();
  if(typeof window !== 'undefined') {
    window["LswTyperParser"] = mod;
  }
  if(typeof global !== 'undefined') {
    global["LswTyperParser"] = mod;
  }
  if(typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function() {
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { Start: peg$parseStart },
      peg$startRuleFunction  = peg$parseStart,

      peg$c0 = function(value) { return value; },
      peg$c1 = function(tp, vl) { return tp ? { ...tp, $value: vl } : vl; },
      peg$c2 = /^[A-Za-z$_]/,
      peg$c3 = peg$classExpectation([["A", "Z"], ["a", "z"], "$", "_"], false, false),
      peg$c4 = /^[A-Za-z0-9$_]/,
      peg$c5 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "$", "_"], false, false),
      peg$c6 = function() { return text() },
      peg$c7 = ".",
      peg$c8 = peg$literalExpectation(".", false),
      peg$c9 = function(noun) { return "." + noun },
      peg$c10 = "/",
      peg$c11 = peg$literalExpectation("/", false),
      peg$c12 = function(noun) { return "/" + noun },
      peg$c13 = function(first, others) { return [first].concat(others || []).join("") },
      peg$c14 = "|",
      peg$c15 = peg$literalExpectation("|", false),
      peg$c16 = function(token1, otherType) { return otherType },
      peg$c17 = "@",
      peg$c18 = peg$literalExpectation("@", false),
      peg$c19 = function(jspath, fallbacks) {
            return {
              $type: [jspath].concat(fallbacks || []),
            };
          },
      peg$c20 = "{",
      peg$c21 = peg$literalExpectation("{", false),
      peg$c22 = "}",
      peg$c23 = peg$literalExpectation("}", false),
      peg$c24 = function(members) {
            return members !== null ? members : {};
          },
      peg$c25 = ",",
      peg$c26 = peg$literalExpectation(",", false),
      peg$c27 = function(head, tail) {
            const result = { [head.key]: head.value };
            tail.forEach((item) => {
              const subitem = item[3];
              const { key, value } = subitem;
              result[key] = value;
            });
            return result;
          },
      peg$c28 = ":",
      peg$c29 = peg$literalExpectation(":", false),
      peg$c30 = function(key, value) {
            return { key, value };
          },
      peg$c31 = "[",
      peg$c32 = peg$literalExpectation("[", false),
      peg$c33 = "]",
      peg$c34 = peg$literalExpectation("]", false),
      peg$c35 = function(elements) {
            return elements !== null ? elements : [];
          },
      peg$c36 = function(head, tail) {
            return [head, ...tail.map(e => e[3])];
          },
      peg$c37 = "\"",
      peg$c38 = peg$literalExpectation("\"", false),
      peg$c39 = function(chars) {
            return chars;
          },
      peg$c40 = "\\\"",
      peg$c41 = peg$literalExpectation("\\\"", false),
      peg$c42 = peg$anyExpectation(),
      peg$c43 = function(chars) { return text(); },
      peg$c44 = "-",
      peg$c45 = peg$literalExpectation("-", false),
      peg$c46 = /^[0-9]/,
      peg$c47 = peg$classExpectation([["0", "9"]], false, false),
      peg$c48 = /^[eE]/,
      peg$c49 = peg$classExpectation(["e", "E"], false, false),
      peg$c50 = /^[\-+]/,
      peg$c51 = peg$classExpectation(["-", "+"], false, false),
      peg$c52 = function(value) {
            return parseFloat(value);
          },
      peg$c53 = "true",
      peg$c54 = peg$literalExpectation("true", false),
      peg$c55 = function() { return true; },
      peg$c56 = "false",
      peg$c57 = peg$literalExpectation("false", false),
      peg$c58 = function() { return false; },
      peg$c59 = "null",
      peg$c60 = peg$literalExpectation("null", false),
      peg$c61 = function() { return null; },
      peg$c62 = peg$otherExpectation("whitespace"),
      peg$c63 = /^[ \t\n\r]/,
      peg$c64 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parseStart() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseValue();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseValue() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseType_def_by_js_property();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseValue_untyped();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseJs_noun() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (peg$c2.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c3); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c4.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (peg$c4.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c5); }
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c6();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseJs_noun_predotted() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 46) {
      s1 = peg$c7;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c8); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseJs_noun();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c9(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseJs_noun_preslashed() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      s1 = peg$c10;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c11); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseJs_noun();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c12(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseJs_path() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseJs_noun();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseJs_noun_predotted();
      if (s3 === peg$FAILED) {
        s3 = peg$parseJs_noun_preslashed();
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseJs_noun_predotted();
        if (s3 === peg$FAILED) {
          s3 = peg$parseJs_noun_preslashed();
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c13(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseJs_path_fallback() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parse_();
    if (s2 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 124) {
        s3 = peg$c14;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c15); }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseJs_path();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c16(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseType_def_by_js_property() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 64) {
      s1 = peg$c17;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c18); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseJs_path();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseJs_path_fallback();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseJs_path_fallback();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c19(s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseValue_untyped() {
    var s0;

    s0 = peg$parseObject();
    if (s0 === peg$FAILED) {
      s0 = peg$parseArray();
      if (s0 === peg$FAILED) {
        s0 = peg$parseString();
        if (s0 === peg$FAILED) {
          s0 = peg$parseNumber();
          if (s0 === peg$FAILED) {
            s0 = peg$parseBoolean();
            if (s0 === peg$FAILED) {
              s0 = peg$parseNull();
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseObject() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c20;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c21); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseMemberList();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c22;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c24(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseMemberList() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseMember();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c25;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseMember();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c25;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c26); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseMember();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c27(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseMember() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseString();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s3 = peg$c28;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c29); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseValue();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c30(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseArray() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      s1 = peg$c31;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c32); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseElementList();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s5 = peg$c33;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c34); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseElementList() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseValue();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c25;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseValue();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c25;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c26); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseValue();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c36(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseString() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c37;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c38); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseDoubleQuotedString();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c37;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c39(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDoubleQuotedString() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    if (input.substr(peg$currPos, 2) === peg$c40) {
      s2 = peg$c40;
      peg$currPos += 2;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c41); }
    }
    if (s2 === peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 34) {
        s4 = peg$c37;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c42); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      if (input.substr(peg$currPos, 2) === peg$c40) {
        s2 = peg$c40;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c41); }
      }
      if (s2 === peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 34) {
          s4 = peg$c37;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c42); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c43(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseNumber() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s3 = peg$c44;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c45); }
    }
    if (s3 === peg$FAILED) {
      s3 = null;
    }
    if (s3 !== peg$FAILED) {
      s4 = [];
      if (peg$c46.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$c46.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c47); }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s6 = peg$c7;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
        if (s6 !== peg$FAILED) {
          s7 = [];
          if (peg$c46.test(input.charAt(peg$currPos))) {
            s8 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c47); }
          }
          if (s8 !== peg$FAILED) {
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              if (peg$c46.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c47); }
              }
            }
          } else {
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 === peg$FAILED) {
          s5 = null;
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$currPos;
          if (peg$c48.test(input.charAt(peg$currPos))) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c49); }
          }
          if (s7 !== peg$FAILED) {
            if (peg$c50.test(input.charAt(peg$currPos))) {
              s8 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c51); }
            }
            if (s8 === peg$FAILED) {
              s8 = null;
            }
            if (s8 !== peg$FAILED) {
              s9 = [];
              if (peg$c46.test(input.charAt(peg$currPos))) {
                s10 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s10 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c47); }
              }
              if (s10 !== peg$FAILED) {
                while (s10 !== peg$FAILED) {
                  s9.push(s10);
                  if (peg$c46.test(input.charAt(peg$currPos))) {
                    s10 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s10 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c47); }
                  }
                }
              } else {
                s9 = peg$FAILED;
              }
              if (s9 !== peg$FAILED) {
                s7 = [s7, s8, s9];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          if (s6 !== peg$FAILED) {
            s3 = [s3, s4, s5, s6];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c52(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseBoolean() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c53) {
      s1 = peg$c53;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c54); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c55();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c56) {
        s1 = peg$c56;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c57); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c58();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseNull() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c59) {
      s1 = peg$c59;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c60); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c61();
    }
    s0 = s1;

    return s0;
  }

  function peg$parse_() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    if (peg$c63.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c64); }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      if (peg$c63.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c64); }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c62); }
    }

    return s0;
  }


    // Funcin auxiliar para convertir cadenas con escapes
    function unescapeString(str) {
      return JSON.parse(str);
    }


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

return {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};

});

(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswTyper'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswTyper'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  class LswTyper {

    static parse(jsontypedText) {
      return LswTyperParser.parse(jsontypedText);
    }

    constructor(types = {}) {
      this.$types = types;
    }

    define(typeId, typeCallback) {
      this.$types[typeId] = typeCallback;
    }

    getTypeCallbackById(typeId) {
      return this.$types[typeId] || null;
    }

    parse(jsontypedText) {
      const ast = this.constructor.parse(jsontypedText);
      const json = this.constructor.resolveTypes(ast, this.$types);
      return JSON.parse(json);
    }

    static resolveTypes(input, reducers) {
      return JSON.stringify(input, (key, value) => {
        const isTyped = value && (typeof value === 'object') && ("$value" in value) && ("$type" in value);
        // Filtramos los que no son type:
        if (!isTyped) {
          return value;
        }
        console.log("is typed:", key, value);
        const $types = Array.isArray(value.$type) ? value.$type : [value.$type];
        Iterating_possible_types:
        for(let index=0; index<$types.length; index++) {
          const reducerId = $types[index];
          // Filtramos los que cuyo $type no se encuentra entre los reducers:
          if(!(reducerId in reducers)) {
            console.log("Id not found:", reducerId);
            continue Iterating_possible_types;
          }
          console.log("Id reduceable:", reducerId);
          // Aplicamos el reducer pertinente...
          const reducer = reducers[reducerId];
          const result = reducer(value);
          // Y si devuelven diferente de undefined...
          console.log("Reduction:", result);
          if (typeof result !== "undefined") {
            // Los retornamos.
            return result;
          }
        }
        // Y si no devolvemos lo normal.
        return value;
      }, 2);
    }

  }

  globalThis.$lswTyper = new LswTyper();

  return LswTyper;

});

$lswTyper.define("day", $lswTyper.$types["org.allnulled.lsw/type/day.js"]);
$lswTyper.define("duration", $lswTyper.$types["org.allnulled.lsw/type/duration.js"]);
$lswTyper.define("moment", $lswTyper.$types["org.allnulled.lsw/type/moment.js"]);
$lswTyper.define("org.allnulled.lsw/type/day.js", function(input) {
  let output = undefined;
  try {
    if(typeof input !== "object") {
      throw new Error("Parsed data must enter as {$type:'org.allnulled.lsw/type/day.js, $value: '0min'}");
    }
    const text = input.$value;
    if(typeof text !== "string") {
      console.log(text);
      throw new Error("Parsed data must enter as string");
    }
    output = LswTimer.parser.parse(text);
    if(!Array.isArray(output)) {
      throw new Error("Parsed data does not return a meaning");
    }
    if(output.length === 0) {
      throw new Error("Parsed data does not return any sentence");
    }
    if(output.length !== 1) {
      throw new Error("Parsed data does not return only one sentence");
    }
    if(output[0].tipo !== "SoloFecha") {
      throw new Error(`Parsed data does not return a day type, but ${output[0].tipo} type`);
    }
    return output[0];
  } catch (error) {
    output = `${error.name}: ${error.message}`;
  }
  return output;
});
$lswTyper.define("org.allnulled.lsw/type/duration.js", function(input) {
  let output = undefined;
  try {
    if(typeof input !== "object") {
      throw new Error("Parsed data must enter as {$type:'org.allnulled.lsw/type/duration.js, $value: '0min'}");
    }
    const text = input.$value;
    if(typeof text !== "string") {
      console.log(text);
      throw new Error("Parsed data must enter as string");
    }
    output = LswTimer.parser.parse(text);
    if(!Array.isArray(output)) {
      throw new Error("Parsed data does not return a meaning");
    }
    if(output.length === 0) {
      throw new Error("Parsed data does not return any sentence");
    }
    if(output.length !== 1) {
      throw new Error("Parsed data does not return only one sentence");
    }
    if(output[0].tipo !== "Duracion") {
      throw new Error(`Parsed data does not return a duration type, but ${output[0].tipo} type`);
    }
    return output[0];
  } catch (error) {
    output = `${error.name}: ${error.message}`;
  }
  return output;
});
$lswTyper.define("org.allnulled.lsw/type/moment.js", function(input) {
  let output = undefined;
  try {
    if(typeof input !== "object") {
      throw new Error("Parsed data must enter as {$type:'org.allnulled.lsw/type/moment.js, $value: '0min'}");
    }
    const text = input.$value;
    if(typeof text !== "string") {
      console.log(text);
      throw new Error("Parsed data must enter as string");
    }
    output = LswTimer.parser.parse(text);
    if(!Array.isArray(output)) {
      throw new Error("Parsed data does not return a meaning");
    }
    if(output.length === 0) {
      throw new Error("Parsed data does not return any sentence");
    }
    if(output.length !== 1) {
      throw new Error("Parsed data does not return only one sentence");
    }
    if(output[0].tipo !== "FechaHora") {
      throw new Error(`Parsed data does not return a moment type, but ${output[0].tipo} type`);
    }
    return output[0];
  } catch (error) {
    output = `${error.name}: ${error.message}`;
  }
  return output;
});


// @vuebundler[Lsw_framework_components][51]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-microdata-bank/lsw-microdata-bank.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswMicrodataBank'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswMicrodataBank'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  const LswMicrodataBank = class {

    static create(...args) {
      return new this(...args);
    }

    static ACCEPT_ALL_FILTER() {
      return true;
    }

    static DEFAULT_OPTIONS() {
      return {
        trace: false,
      };
    }

    constructor(store = "Banco_de_datos_principal") {
      this.$store = store;
      this.$options = Object.assign(this.constructor.DEFAULT_OPTIONS);
    }

    trace(method, part = false) {
      if (!!this.$options.trace) {
        return;
      }
      let message = `[trace][lsw-microdata-bank] ${method}`;
      if (part) {
        message += ` ${part}`;
      }
    }

    async select(subtype, filter = this.constructor.ACCEPT_ALL_FILTER) {
      this.trace("select");
      try {
        if (typeof filter !== "function") {
          throw new Error("Required parameter 2 to be a function on LswMicrodataBank.select");
        }
        const allRows = await Vue.prototype.$lsw.database.select(this.$store, this.constructor.ACCEPT_ALL_FILTER);
        const matchedRows = allRows.filter((it) => {
          try {
            const matchesDatatype = it.datatype === subtype;
            if (!matchesDatatype) {
              return false;
            }
            return filter(it);
          } catch (error) {
            console.log("Error on LswMicrodataBank.select while applying filter:", error);
            return false;
          }
        });
        return matchedRows;
      } catch (error) {
        console.log(error);
        throw error;
      }
    }

    selectMany(subtype, filter) {
      this.trace("selectMany");
      return this.select(subtype, filter);
    }

    async selectFirst(subtype, filter) {
      this.trace("selectFirst");
      const data = await this.select(subtype, filter);
      if (data.length === 0) {
        throw new Error("Required parameter id to exist on LswMicrodataBank.selectFirst");
      }
      return data[0];
    }

    insert(subtype, itemOrList) {
      this.trace("insert");
      if (Array.isArray(itemOrList)) {
        return this.insertMany(subtype, itemOrList);
      } else if (typeof itemOrList === 'object') {
        return this.insertOne(subtype, itemOrList);
      } else {
        throw new Error("Required parameter 2 to be array or object on LswMicrodataBank.insert");
      }
    }

    insertOne(subtype, item) {
      this.trace("insertOne");
      let typedItem = undefined;
      typedItem = Object.assign({}, item, {
        datatype: subtype,
      });
      return Vue.prototype.$lsw.database.insert(this.$store, typedItem);
    }

    insertMany(subtype, list) {
      this.trace("insertMany");
      const insertables = [];
      for (let index = 0; index < list.length; index++) {
        const item = list[index];
        const typedItem = Object.assign({}, item, {
          datatype: subtype,
        });
        insertables.push(typedItem);
      }
      return Vue.prototype.$lsw.database.insertMany(this.$store, insertables);
    }

    update(subtype, idOrFilter, value) {
      this.trace("update");
      if (typeof idOrFilter === 'function') {
        return this.updateMany(subtype, idOrFilter, value);
      } else if (["string", "number"].indexOf(typeof idOrFilter) !== -1) {
        return this.updateOne(subtype, idOrFilter, value);
      } else {
        throw new Error("Required parameter 2 to be function, string or number on LswMicrodataBank.update");
      }
    }

    async updateOne(subtype, id, value) {
      this.trace("updateOne");
      const item = await this.selectFirst(subtype, it => {
        const matchesType = it.datatype === subtype;
        const matchesId = it.id === id;
        return matchesType && matchesId;
      });
      return await Vue.prototype.$lsw.database.update(this.$store, item.id, value);
    }

    updateMany(subtype, filter, value) {
      this.trace("updateMany");
      return Vue.prototype.$lsw.database.updateMany(this.$store, it => {
        try {
          const matchesType = it.datatype === subtype;
          if (!matchesType) return false;
          const matchesFilter = filter(it);
          return matchesFilter;
        } catch (error) {
          // @BADLUCK.
          return false;
        }
      }, value);
    }

    delete(subtype, idOrFilter) {
      this.trace("delete");
      if (typeof idOrFilter === 'function') {
        return this.deleteMany(subtype, idOrFilter);
      } else if (["string", "number"].indexOf(typeof idOrFilter) !== -1) {
        return this.deleteOne(subtype, idOrFilter);
      } else {
        throw new Error("Required parameter 2 to be function, string or number on LswMicrodataBank.delete");
      }
    }

    deleteOne(subtype, id) {
      this.trace("deleteOne");
      return Vue.prototype.$lsw.database.deleteMany(this.$store, it => {
        const matchesType = it.datatype === subtype;
        const matchesId = it.id === id;
        return matchesType && matchesId;
      });
    }

    deleteMany(subtype, filter) {
      this.trace("deleteMany");
      return Vue.prototype.$lsw.database.deleteMany(this.$store, it => {
        const matchesType = it.datatype === subtype;
        const matchesFilter = filter(it);
        return matchesType && matchesFilter;
      });
    }

    upsert(subtype, idOrFilter, value) {
      this.trace("upsert");
      if (typeof idOrFilter === 'function') {
        return this.upsertMany(subtype, idOrFilter, value);
      } else if (["string", "number"].indexOf(typeof idOrFilter) !== -1) {
        return this.upsertOne(subtype, idOrFilter, value);
      } else {
        throw new Error("Required parameter 2 to be function, string or number on LswMicrodataBank.upsert");
      }
    }

    async upsertOne(subtype, id, value) {
      this.trace("upsertOne");
      // @TODO:
      const originalItem = await this.selectFirst(subtype, it => {
        const matchesId = it.id === id;
        return matchesId;
      });
      const newItem = Object.assign({}, originalItem);
      return await Vue.prototype.$lsw.database.update(this.$store, originalItem.id, newItem);
    }

    upsertMany(subtype, filter, value) {
      this.trace("upsertMany");
      // @TODO:
    }

    overwrite(subtype, idOrFilter, value) {
      this.trace("overwrite");
      if (typeof idOrFilter === 'function') {
        return this.overwriteMany(subtype, idOrFilter, value);
      } else if (["string", "number"].indexOf(typeof idOrFilter) !== -1) {
        return this.overwriteOne(subtype, idOrFilter, value);
      } else {
        throw new Error("Required parameter 2 to be function, string or number on LswMicrodataBank.overwrite");
      }
    }

    overwriteOne(subtype, filter, value) {
      this.trace("overwriteOne");
      // @TODO:
    }

    overwriteMany(subtype, filter, value) {
      this.trace("overwriteMany");
      // @TODO:
    }

  };

  return LswMicrodataBank;

});

// @vuebundler[Lsw_framework_components][52]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-books/lsw-books.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswBooks'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswBooks'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  const PickableCommon = class {
    
    static for(...args) {
      return new this(...args);
    }

    constructor(table) {
      this.$table = table;
    }

    static normalizeStrangeSymbols(txt, onlyLowers = true) {
      if(onlyLowers) {
        return txt
          .toLowerCase()
          .trim()
          .replaceAll("", "a")
          .replaceAll("", "e")
          .replaceAll("i", "i")
          .replaceAll("", "o")
          .replaceAll("", "u");
      }
      return txt
        .toLowerCase()
        .trim()
        .replaceAll("", "A")
        .replaceAll("", "E")
        .replaceAll("", "I")
        .replaceAll("", "O")
        .replaceAll("", "U")
        .replaceAll("", "a")
        .replaceAll("", "e")
        .replaceAll("i", "i")
        .replaceAll("", "o")
        .replaceAll("", "u");
    }

  };

  const PickableSingular = class extends PickableCommon {

    byName(name) {
      return Vue.prototype.$lsw.database.selectFirst(this.$table, it => it.tiene_titulo === name);
    }

    byId(id) {
      return Vue.prototype.$lsw.database.selectFirst(this.$table, it => it.id === id);
    }

  };

  const PickablePlural = class extends PickableCommon {

    all() {
      return Vue.prototype.$lsw.database.selectMany(this.$table);
    }

    where(callback) {
      return Vue.prototype.$lsw.database.selectMany(this.$table, callback);
    }

    byCategory(category) {
      const categoryNormalized = this.constructor.normalizeStrangeSymbols(category);
      return Vue.prototype.$lsw.database.selectMany(this.$table, it => it.tiene_categorias.split(";").reduce((out, itsCategory) => {
        const itsCategoryNormalized = this.constructor.normalizeStrangeSymbols(itsCategory);
        return out = out || (itsCategoryNormalized === categoryNormalized);
      }, false));
    }

  };

  const LswBooks = class {

    static pick = {
      note: PickableSingular.for("Nota"),
      notes: PickablePlural.for("Nota"),
      article: PickableSingular.for("Articulo"),
      articles: PickablePlural.for("Articulo"),
    };

    static toMarkdown(listOrItem, prop = "tiene_contenido") {
      if(Array.isArray(listOrItem)) {
        const output = [];
        for(let index=0; index<listOrItem.length; index++) {
          const item = listOrItem[index];
          const markableText = this.toMarkdown(item, prop);
          output.push(markableText);
        }
        return output.join("\n");
      } else if(typeof listOrItem === "object") {
        return marked.parse(listOrItem[prop]);
      }
      throw new Error("Required parameter 1 listOrItem to be an array or an object on LswBooks.toMarkdown");
    }

  };

  return LswBooks;

});

// @vuebundler[Lsw_framework_components][53]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/database-adapter/LswDatabaseAdapter.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswDatabaseAdapter'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswDatabaseAdapter'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  class LswDatabaseAdapter extends Browsie {

  }

  return LswDatabaseAdapter;
});

// @vuebundler[Lsw_framework_components][54]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/directives/v-descriptor/v-descriptor.js
// @code.start: v-descriptor API | @$section: Lsw Directives  v-descriptor directive
(() => {

  const getDescriptorKeys = function (el, binding) {
    if (binding.expression.startsWith("'") || binding.expression.startsWith('"')) {
      return (binding.value || el.getAttribute("descriptor")).split(" ");
    }
    return (binding.expression || el.getAttribute("descriptor")).split(" ");
  };

  Vue.directive("descriptor", {
    bind(el, binding) {
      const resolveClasses = key => {
        let resolved = window.stylingDescriptor[key];
        if (!resolved) return key;
        if (typeof resolved === "string") {
          resolved = resolved.split(" ");
        }
        return resolved.map(subKey => resolveClasses(subKey)).flat();
      };
      const descriptorKeys = getDescriptorKeys(el, binding);
      const descriptorClasses = descriptorKeys.map(key => resolveClasses(key)).flat();
      descriptorClasses.forEach(cls => {
        if (cls.indexOf(".") === -1) {
          el.classList.add(cls);
        }
      });
    }
  });

  const styleTag = document.createElement("style");
  styleTag.textContent = `
  .title_of_form {
    border: 1px solid #113;
    box-shadow: 0 0 4px black;
    border-radius: 0pt;
    color: black;
    width: 100%;
    padding: 8px;
    font-size: 12px;
    background-color: #AAF;
  }
  .block_of_form {
    padding: 4px;
    padding-left: 0px;
    padding-right: 0px;
    padding-bottom: 0px;
    padding-top: 0px;
  }
  .bordered_1 {
    border: 1px solid #999;
    border-radius: 2pt;
  }
  .with_separator_on_bottom_1 {
    border-bottom: 1px solid #999;
  }
  .lateral_button {
    height: 100%;
  }
  .lateral_button_cell {
    padding-top: 4px;
    padding-bottom: 4px;
    padding-right: 4px;
  }
  .padded_1 {
    padding: 4px;
  }
  .vertically_padded_1 {
    padding-top: 4px;
    padding-bottom: 4px;
  }
  .horizontally_padded_1 {
    padding-left: 4px;
    padding-right: 4px;
  }
  .left_padded_1 {
    padding-left: 4px;
  }
  .right_padded_1 {
    padding-right: 4px;
  }
  .top_padded_1 {
    padding-top: 4px;
  }
  .bottom_padded_1 {
    padding-bottom: 4px;
  }
  .calendar_main_panel {
    padding-left: 0px;
    padding-right: 0px;
    padding-top: 0px;
    padding-bottom: 4px;
  }
  .calendar_buttons_panel_1 {
    padding-bottom: 0px;
    padding-top: 0px;
  }
`;

  window.addEventListener("load", function() {
    document.body.appendChild(styleTag);
  });

  window.stylingDescriptor = {
    "agenda.calendar.buttons_panel_1": "calendar_main_panel calendar_buttons_panel_1",
    "agenda.task_form.title": "title_of_form",
    "agenda.task_form.block": "block_of_form",
    "agenda.task_form.block_of_add_button": "block_of_form vertically_padded_1",
    "agenda.task_form.block_of_aggregated_field": "bordered_1",
    "agenda.task_form.section": "with_separator_on_bottom_1",
    "agenda.task_form.aggregations.block": "block_of_form",
    "agenda.task_form.aggregations.lateral_button": "lateral_button",
    "agenda.task_form.aggregations.lateral_button_cell": "lateral_button_cell",
    "lsw_table.no_data_provided_message": "pad_top_2 pad_bottom_2"
  }

})();
// @code.end: v-descriptor API

// @vuebundler[Lsw_framework_components][55]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/directives/v-focus/v-focus.js
// @code.start: v-focus API | @$section: Lsw Directives  v-focus directive
Vue.directive("focus", {
  inserted: function(el) {
    el.focus();
  }
});
// @code.end: v-focus API

// @vuebundler[Lsw_framework_components][56]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/directives/v-xform/v-xform.js
// @code.start: LswXForm API | @$section: Lsw Directives  v-xform directive
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswXForm'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswXForm'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  let isTracing = true;
  let $COUNTADOR1 = 0;

  const trace = function (method, args = []) {
    if (isTracing) {
      console.log("[trace][lsw-xform][" + method + "]", args.length);
    }
  };

  const XformCommonInterface = class {
    formInterface = "Common";
    static create(...args) {
      return new this(...args);
    }
    constructor(inheritedArgument, subtype) {
      const { el, binding, scope } = inheritedArgument;
      trace("XformCommonInterface.constructor:" + this.formInterface);
      this.$el = el;
      this.$binding = binding;
      this.$component = scope;
      this.$type = subtype;
      this.$name = this.$binding.value?.name || false;
      this.$onValidateInterfaceArguments();
      this.$injectAttributesToElement();
    }
    $injectAttributesToElement() {
      trace("XformCommonInterface.$injectAttributesToElement:" + this.formInterface);
      this.$el.setAttribute("data-xform-node", this);
    }
    $onValidateInterfaceArguments() {
      trace("XformCommonInterface.$onValidateInterfaceArguments:" + this.formInterface);
      const ensureEl = $ensure(this.$el).type("object").to.be.instanceOf(HTMLElement);
      const ensureBinding = $ensure(this.$binding).type("object");
      const ensureValue = ensureBinding.its("value").type("object");
      const checkValue = $check(ensureValue.$subject);
      $ensure(this.$type).type("string").to.be.oneOf(["form", "control", "input", "error"]);
      ensureValue.to.have.keys(["name"]).its("name").type("string").back();
      if (checkValue.to.have.key("onSetError")) {
        ensureValue.its("onSetError").type("function");
      }
      if (checkValue.to.have.key("onClearError")) {
        ensureValue.its("onClearError").type("function");
      }
      if (checkValue.to.have.key("onGetValue")) {
        ensureValue.its("onGetValue").type("function");
      }
      if (checkValue.to.have.key("onGetChildren")) {
        ensureValue.its("onGetChildren").type("function");
      }
      if (checkValue.to.have.key("onValidate")) {
        ensureValue.its("onValidate").type("function");
      }
      if (checkValue.to.have.key("onSubmit")) {
        ensureValue.its("onSubmit").type("function");
      }
    }
    validate() {
      trace("XformCommonInterface.validate:" + this.formInterface);
      const value = this.getValue();
      const result = this.$hookWith("onValidate", [value, this]);
      this.$propagateSuccess();
      return true;
    }
    $getParent(onlyTypes = false) {
      trace("XformCommonInterface.$getParent:" + this.formInterface);
      if (typeof onlyTypes === "string") {
        onlyTypes = [onlyTypes];
      }
      const found = LswDom.getClosestParent(this.$el, "[data-xform-node]");
      if (!Array.isArray(onlyTypes)) {
        return found;
      } else if (!found?.length) {
        return found;
      }
      return found.filter(el => onlyTypes.indexOf(el.$xform.$type) !== -1);
    }
    $getChildren(onlyTypesInput = false) {
      trace("XformCommonInterface.$getChildren:" + this.formInterface);
      let onlyTypes = onlyTypesInput;
      if (typeof onlyTypesInput === "string") {
        onlyTypes = [onlyTypesInput];
      }
      const found = LswDom.getClosestChildren(this.$el, "[data-xform-node]");
      if (!Array.isArray(onlyTypes)) {
        return found;
      } else if (!found?.length) {
        return found;
      }
      const foundChildren = found.filter(el => onlyTypes.indexOf(el.$xform.$type) !== -1);
      return foundChildren;
    }
    getValue() {
      trace("XformCommonInterface.getValue:" + this.formInterface);
      const result = this.$hookWith("onGetValue");
      if (typeof result !== "undefined") {
        return result;
      }
      return this.$getChildren(["form", "control", "input"]).reduce((output, el) => {
        const hasName = el.$xform.$binding.value.name;
        if (hasName === "*") {
          output = el.$xform.getValue();
        } else if (!hasName) {
          // @OK...
        } else {
          output[hasName] = el.$xform.getValue();
        }
        return output;
      }, {});
    }
    $hookWith(hookId, parameters = []) {
      trace("XformCommonInterface.$hookWith:" + this.formInterface);
      if (!(hookId in this.$binding.value)) {
        console.log(`[-] No hooks found for ${hookId}`);
        return undefined;
      }
      const hookFunction = this.$binding.value[hookId];
      if (typeof hookFunction === "undefined") {
        console.log(`[-] Hook with bad type found for ${hookId}`);
        return undefined;
      } else if (typeof hookFunction !== "function") {
        throw new Error(`Expected parameter ${hookId} to be a function on $hookWith`);
      }
      console.log(`[*] Executing hook for ${hookId}`);
      console.log(hookFunction.toString(), parameters);
      return hookFunction(...parameters);
    }
    $setError(error) {
      trace("XformCommonInterface.$setError:" + this.formInterface);
      this.$error = error;
      this.$hookWith("onSetError", [error, this]);
      return this;
    }
    $clearError() {
      trace("XformCommonInterface.$clearError:" + this.formInterface);
      this.$error = false;
      this.$hookWith("onClearError", [this]);
      return this;
    }
    $propagateError(error, rethrowIt = 1, propagateDown = 1, propagateUp = 1) {
      trace("XformCommonInterface.$propagateError:" + this.formInterface);
      try {
        if (this.$binding.value.debug) {
          console.error(`[DEBUG] Error propagated to v-form.${this.$type}:`, error);
        }
        const contador = ++$COUNTADOR1;
        Propagate_down: {
          if(!propagateDown) {
            break Propagate_down;
          }
          console.log("propagate down now " + contador + " " + this.formInterface);
          const propagableChildren = this.$getChildren(["error"]);
          console.log(propagableChildren);
          if (propagableChildren && propagableChildren.length) {
            for (let index = 0; index < propagableChildren.length; index++) {
              const child = propagableChildren[index];
              child.$xform.$setError(error);
            }
          }
          console.log("ok down now " + contador + " " + this.formInterface);
        }
        Propagate_up: {
          if(!propagateUp) {
            break Propagate_up;
          }
          console.log("propagate up now " + contador + " " + this.formInterface);
          const propagableParent = this.$getParent(["form", "control"]);
          console.log(propagableParent);
          if (propagableParent) {
            try {
              propagableParent.$xform.$propagateError(error, 1);
            } catch (error) {
              console.log(error);
            }
          }
          console.log("ok up now " + contador + " " + this.formInterface);
        }
      } catch (error) {
        console.log(error);
      } finally {
        this.$setError(error);
        if (rethrowIt === 1) {
          throw error;
        }
      }
    }
    $propagateSuccess() {
      trace("XformCommonInterface.$propagateSuccess:" + this.formInterface);
      // this.$getParent(["form", "control"]).$propagateSuccess(error);
      const contador = ++$COUNTADOR1;
      Propagate_down: {
        console.log("propagate SUCCESS down now (to errors)" + contador + " " + this.formInterface);
        const propagableChildren = this.$getChildren(["error"]);
        console.log(propagableChildren);
        for (let index = 0; index < propagableChildren.length; index++) {
          const child = propagableChildren[index];
          child.$xform.$clearError();
        }
        console.log("ok down now (to errors)" + contador + " " + this.formInterface);
      }
      this.$clearError();
    }
  };

  const XformForm = class extends XformCommonInterface {
    formInterface = "Form";
    $onValidateInterfaceArguments() {
      trace("XformForm.$onValidateInterfaceArguments");
      const ensureEl = $ensure(this.$el);
      const ensureBinding = $ensure(this.$binding);
      const ensureValue = ensureBinding.its("value").type("object");
      const checkValue = $check(ensureValue.$subject);
    }
    submit() {
      trace("XformForm.submit");
      const resultado = this.validate();
      if(resultado !== true) throw new Error("Could not validate form");
      const value = this.getValue();
      const result = this.$hookWith("onSubmit", [value], this);
      if (typeof result !== "undefined") {
        return result;
      }
    }
    validate() {
      trace("XformForm.validate");
      try {
        const allChildren = this.$getChildren(["form", "control"]);
        let allErrors = 0;
        for (let indexChild = 0; indexChild < allChildren.length; indexChild++) {
          const child = allChildren[indexChild];
          console.log("Validating [from form] now child to validate:", child);
          try {
            const result = child.$xform.validate();
            if(!result) {
              allErrors++;
            }
          } catch (error) {
            allErrors++;
          }
        }
        if(allErrors > 0) {
          throw new Error(`Form has ${allErrors} validation errors. Fix them to continue.`);
        }
        const resultado = super.validate();
        if(resultado !== true) {
          throw new Error("Could not validate form natively (calling super.validate) on XformForm.validate");
        }
        this.$propagateSuccess();
        return true;
      } catch (error) {
        this.$propagateError(error, 0, 1, 0);
        throw error;
      }
    }
  };

  const XformControl = class extends XformCommonInterface {
    formInterface = "Control";
    $onValidateInterfaceArguments() {
      trace("XformControl.$onValidateInterfaceArguments");
      const ensureEl = $ensure(this.$el);
      const ensureBinding = $ensure(this.$binding);
      const ensureValue = ensureBinding.its("value").type("object");
      const checkValue = $check(ensureValue.$subject);
      ensureValue.to.have.keys(["name"]).its("name").type("string").back();
      if (checkValue.to.have.key("onSetError")) {
        ensureValue.its("onSetError").type("function");
      }
      if (checkValue.to.have.key("onClearError")) {
        ensureValue.its("onClearError").type("function");
      }
      if (checkValue.to.have.key("onGetValue")) {
        ensureValue.its("onGetValue").type("function");
      }
      if (checkValue.to.have.key("onGetChildren")) {
        ensureValue.its("onGetChildren").type("function");
      }
      if (checkValue.to.have.key("onValidate")) {
        ensureValue.its("onValidate").type("function");
      }
    }
    $validateChildren() {
      trace("XformControl.$validateChildren");
      const allChildren = this.$getChildren(["form", "control", "input"]);
      for (let indexChild = 0; indexChild < allChildren.length; indexChild++) {
        const child = allChildren[indexChild];
        console.log("Validating [from control] now child to validate:", child);
        child.$xform.validate();
      }
      this.$propagateSuccess();
    }
    validate(deeply = false) {
      trace("XformControl.validate");
      try {
        const value = this.getValue();
        this.$hookWith("onValidate", [value, this]);
        this.$propagateSuccess();
        return true;
      } catch (error) {
        this.$propagateError(error, 0, 1, 0);
      }
    }
  };

  const XformInput = class extends XformCommonInterface {
    formInterface = "Input";
    validate() {
      trace("XformInput.validate");
      const value = this.getValue();
      this.$hookWith("onValidate", [value, this]);
      return true;
    }
    $onValidateInterfaceArguments() {
      trace("XformInput.$onValidateInterfaceArguments");
      const ensureEl = $ensure(this.$el);
      const ensureBinding = $ensure(this.$binding);
      const ensureValue = ensureBinding.its("value").type("object");
      const checkValue = $check(ensureValue.$subject);
      ensureValue.to.have.keys(["name"]).its("name").type("string").back();
      if (checkValue.to.have.key("onSetError")) {
        ensureValue.its("onSetError").type("function");
      }
      if (checkValue.to.have.key("onClearError")) {
        ensureValue.its("onClearError").type("function");
      }
      if (checkValue.to.have.key("onGetValue")) {
        ensureValue.its("onGetValue").type("function");
      }
    }
    getValue() {
      trace("XformInput.getValue");
      if (["INPUT", "TEXTAREA", "SELECT"].indexOf(this.$el.tagName) !== -1) {
        const ownValue = this.$el.value;
        return ownValue;
      } else {
        return super.getValue();
      }
    }
    $propagateSuccess() {
      const control = this.$getParent(["control"]);
      control.$xform.$propagateSuccess();
    }
  };

  const XformError = class extends XformCommonInterface {
    formInterface = "Error";
    $onValidateInterfaceArguments() {
      trace("XformError.$onValidateInterfaceArguments");
      const ensureEl = $ensure(this.$el);
      const ensureBinding = $ensure(this.$binding);
      const ensureValue = ensureBinding.its("value").type("object");
      const checkValue = $check(ensureValue.$subject);
      if (checkValue.to.have.key("onSetError")) {
        ensureValue.its("onSetError").type("function");
      }
      if (checkValue.to.have.key("onClearError")) {
        ensureValue.its("onClearError").type("function");
      }
    }
    validate() {
      // @EMPTY.
    }
    $getChildren() {
      trace("XformError.$getChildren");
      throw new Error(`Error can not contain children on XformError.$getChildren`);
    }
    getValue() {
      trace("XformError.getValue");
      throw new Error(`Error can not contain a value on XformError.getValue`);
    }
    $setError(error) {
      trace("XformError.$setError");
      this.$error = error;
      this.$el.classList.add("error_is_affecting_field");
      try {
        const summarizedError = error.summarized();
        summarizedError.stack2 = summarizedError.stack.map(tr => {
          return tr.split("\n").map((msg, errorIndex) => {
            const [callbackName, rest1] = LswUtils.splitStringOnce(msg, "@");
            if (!rest1) {
              return [1, callbackName, rest1];
            }
            const rest2 = LswUtils.reverseString(rest1);
            const [columnReversed, rest3] = LswUtils.splitStringOnce(rest2, ":");
            if (!rest3) {
              return [3, rest3, columnReversed, callbackName];
              return msg;
            }
            const [lineReversed, errorSource] = LswUtils.splitStringOnce(rest3, ":");
            if (!errorSource) {
              return [5, errorSource, lineReversed, rest3, columnReversed, callbackName];
              return msg;
            }
            const line = LswUtils.reverseString(lineReversed);
            const column = LswUtils.reverseString(columnReversed);
            return `${errorIndex + 1}. ${LswUtils.reverseString(errorSource)}:${line}:${column}::${callbackName}`;
          }).join("\n")
        });
        this.$getErrorMessageElement().textContent = `${error.name}: ${error.message}.\n${summarizedError.stack2}`;
      } catch (error2) {
        this.$getErrorMessageElement().textContent = `${error.name}: ${error.message} [${error.stack}]`;
      }
      try {
        this.$hookWith("onSetError", [error, this]);
      } catch (error) {
        console.log(error);
      }
      return this;
    }
    $getErrorMessageElement() {
      return (this.$el.querySelector(".errorMessage") || this.$el);
    }
    $clearError() {
      trace("XformError.$clearError");
      this.$error = undefined;
      this.$el.classList.remove("error_is_affecting_field");
      this.$getErrorMessageElement().textContent = ``;
      this.$hookWith("onClearError", [this]);
      return this;
    }
  };

  const xformClasses = {
    form: XformForm,
    control: XformControl,
    input: XformInput,
    error: XformError,
  };

  Vue.directive("xform", {
    bind(el, binding) {
      trace("xform-directive.bind");
      // console.log(binding);
      const modifierType = Object.keys(binding.modifiers)[0];
      if (!(modifierType in xformClasses)) {
        throw new Error("Required directive v-form to be injected with a known modifier on xform.bind");
      }
      const xformClass = xformClasses[modifierType];
      const xformInstance = xformClass.create({ el, binding, scope: this }, modifierType);
      el.$xform = xformInstance;
    },
    unbind(el) {
      trace("xform-directive.unbind");
      delete el.$xform.$binding;
      delete el.$xform.$el;
      delete el.$xform;
    }
  });

  const XFormPublicAPI = {
    validateSettings(settings) {
      trace("XFormPublicAPI.validateSettings");
      const checkSettings = $check(settings);
      const ensureSettings = $ensure(settings).type("object").to.have.key("name");
      ensureSettings.its("name").type("string").back();
      if (checkSettings.to.have.key("input")) {
        const ensureInput = ensureSettings.its("input").type("object");
        ensureInput.to.have.uniquelyKeys(["props", "events"]);
        if(checkSettings.its("input").to.have.key("props")) {
          ensureInput.its("props").type("object");
        }
        if(checkSettings.its("input").to.have.key("events")) {
          ensureInput.its("events").type("object");
        }
      }
    }
  }

  return XFormPublicAPI;

});
// @code.end: LswXForm API

// @vuebundler[Lsw_framework_components][57]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-homepage/lsw-homepage.html

// @vuebundler[Lsw_framework_components][57]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-homepage/lsw-homepage.js
const homepage_apps_events = {
  "base de datos": function () {

  },
  "calendario": function () {

  },
  "sistema de ficheros": function () {

  },
  "configuraciones": function () {

  },
  "calendario": function () {

  },
  "tareas posteriores": function () {

  },
  "tareas anteriores": function () {

  },
  "conductometria": function () {

  },
  "notas": function () {

  },
  "nueva nota": function () {

  },
  "enciclopedia": function () {

  },
  "nuevo articulo": function () {

  },
};

// @code.start: LswHomepage API | @$section: Vue.js (v2) Components  LswHomepage component
Vue.component("LswHomepage", {
  template: `<div class="lsw_homepage">
    <h4 class="">
        <div class="flex_row centered">
            <div class="flex_100"> Apps instaladas </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini"
                    v-on:click="openAppsDirectory"></button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini"
                    v-on:click="loadOwnApps"></button>
            </div>
        </div>
    </h4>
    <div class="pad_vertical_1 flex_row">
        <div class="flex_100">
            <input class="width_100 supermini"
                type="text"
                placeholder="Busca aqu"
                v-on:keypress.enter="filterApps"
                v-model="filterSearchText" />
        </div>
        <div class="flex_1 pad_left_1">
            <button class="supermini" v-on:click="filterApps"></button>
        </div>
    </div>
    <div class="supermini pad_vertical_1" v-if="lastAppliedFilter">
        Filtrando por {{ lastAppliedFilter }}.
    </div>
    <div class="lista_apps">
        <div class="item_app" v-for="app, appIndex in filteredApps" v-bind:key="'app_' + appIndex">
            <div class="nombre_app flex_row centered" v-on:click="app.event">
                <div class="flex_100">{{ app.label }}</div>
                <div class="flex_1 nowrap"></div>
            </div>
        </div>
    </div>
</div>`,
  props: {
    appsViewer: {
      type: Object,
      required: true,
    }
  },
  data() {
    this.$trace("lsw-homepage.data");
    return {
      isLoaded: false,
      ownApps: {},
      lastAppliedFilter: false,
      filterSearchText: "",
      filteredApps: {},
      systemApps: [{
        label: " Base de datos",
        event: () => this.abrirApp("base de datos"),
      }, {
        label: " Sistema de ficheros",
        event: () => this.abrirApp("sistema de ficheros"),
      }, {
        label: " Binarios",
        event: () => this.abrirApp("binarios"),
      }, {
        label: " Calendario",
        event: () => this.abrirApp("calendario"),
      }, {
        label: " Tareas anteriores",
        event: () => this.abrirApp("antes"),
      }, {
        label: " Tareas posteriores",
        event: () => this.abrirApp("despues"),
      }, {
        label: " Notas",
        event: () => this.abrirApp("notas"),
      }, {
        label: " Nueva nota",
        event: () => this.abrirApp("nueva nota"),
      }, {
        label: " Enciclopedia",
        event: () => this.abrirApp("enciclopedia"),
      }, {
        label: " Nuevo artculo",
        event: () => this.abrirApp("nuevo articulo"),
      }, {
        label: " Inspector de JS",
        event: () => this.abrirApp("js inspector"),
      }, {
        label: " Consola de JS",
        event: () => this.abrirApp("js consola"),
      }, {
        label: " Tests de aplicacin",
        event: () => this.abrirApp("app tests"),
      }, {
        label: " Configuraciones",
        event: () => this.abrirApp("configuraciones"),
      }, {
        label: " Nueva feature",
        event: () => this.abrirApp("nueva feature"),
      }]
    };
  },
  methods: {
    registerApp(appName, appData, force = false, silence = false) {
      this.$trace("lsw-homepage.methods.registerApp");
      try {
        if ((appName in this.ownApps) && !force) {
          throw new Error(`App ${appName} is already registered`);
        }
        Validate_app_data: {
          const $ensureAppData = $ensure({ [appName]: appData }, 1).type("object");
          $ensureAppData.to.have.keys([
            "label", 
            "event",
          ]);
        }
        this.ownApps[appName] = appData;
      } catch (error) {
        if (!silence) {
          this.$lsw.toasts.showError(error);
        }
      }
    },
    filterApps() {
      this.$trace("lsw-homepage.methods.filterApps");
      const s = this.filterSearchText.toLowerCase();
      if (s.trim() === "") {
        this.lastAppliedFilter = false;
        return this.filteredApps = Object.assign({}, this.ownApps);
      }
      this.filteredApps = {};
      for (let appName in this.ownApps) {
        const appData = this.ownApps[appName];
        const pos = JSON.stringify([appName, appData]).toLowerCase().indexOf(s);
        if (pos !== -1) {
          this.filteredApps[appName] = appData;
        }
      }
      this.lastAppliedFilter = s;
      this.isLoaded = true;
    },
    async loadOwnApps() {
      this.$trace("lsw-homepage.methods.loadOwnApps");
      this.ownApps = {};
      System_apps: {
        for (let indexApp = 0; indexApp < this.systemApps.length; indexApp++) {
          const app = this.systemApps[indexApp];
          try {
            this.registerApp(app.label, app);
          } catch (error) {
            console.log(error);
          }
        }
      }
      Custom_apps: {
        const appsFilesMap = await this.$lsw.fs.read_directory("/kernel/apps");
        const appsFiles = Object.keys(appsFilesMap);
        for (let indexApp = 0; indexApp < appsFiles.length; indexApp++) {
          const appName = appsFiles[indexApp];
          try {
            const appData = await lsw.fs.evaluateAsJavascriptFileOrReturn("/kernel/apps/" + appName + "/load.js", false);
            this.registerApp(appName, appData);
          } catch (error) {
            console.log(error);
          }
        }
      }
      this.filterApps();
    },
    openAppsDirectory() {
      this.$trace("lsw-homepage.methods.openAppsDirectory");
      this.$lsw.dialogs.open({
        title: "Directorio de apps",
        template: `<lsw-filesystem-explorer opened-by="/kernel/apps" />`,
      });
    },
    async abrirApp(appId) {
      this.$trace("lsw-homepage.methods.abrirApp");
      this.$lsw.toasts.send({
        title: "Yendo a: " + appId,
      });
      this.appsViewer.selectApplication(appId);
    }
  },
  watch: {},
  mounted() {
    this.$trace("lsw-homepage.mounted");
    this.loadOwnApps();
  },
  unmounted() {
    this.$trace("lsw-homepage.unmounted");

  }
});
// @code.end: LswHomepage API

// @vuebundler[Lsw_framework_components][57]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-homepage/lsw-homepage.css

// @vuebundler[Lsw_framework_components][58]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-sourceable/lsw-sourceable.html

// @vuebundler[Lsw_framework_components][58]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-sourceable/lsw-sourceable.js
// @code.start: LswSourceable API | @$section: Vue.js (v2) Components  LswSourceable component
Vue.component("LswSourceable", {
  template: `<div class="lsw_sourceable">
    <template v-if="!isLoaded">
        Cargando componente. Por favor, aguarde...
    </template>
    <template>
        <component :is="componentId" />
    </template>
</div>`,
  props: {
    fixedId: {
      type: [String, Boolean],
      default: () => false,
    },
    source: {
      type: [String, Boolean],
      default: () => false,
    },
    composition: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    this.$trace("lsw-sourceable.data");
    const reflectedId = this.fixedId || LswRandomizer.getRandomString(10);
    return {
      isLoaded: false,
      componentId: "lsw-sourceable-" + reflectedId,
    };
  },
  methods: {
    loadReflection() {
      this.$trace("lsw-sourceable.methods.loadReflection");
      const that = this;
      const source = this.source || this.$slots.default;
      Vue.component(this.componentId, {
        template: "<div>" + source + "</div>",
        ...this.composition,
      });
      this.isLoaded = true;
    },
    unloadReflection() {
      this.$trace("lsw-sourceable.methods.loadReflection");
      delete Vue.options.components[this.componentId];
    }
  },
  watch: {},
  mounted() {
    this.$trace("lsw-sourceable.mounted");
    this.loadReflection();
  },
  unmounted() {
    this.$trace("lsw-sourceable.unmounted");
    this.unloadReflection();
  }
});
// @code.end: LswSourceable API

// @vuebundler[Lsw_framework_components][58]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-sourceable/lsw-sourceable.css

// @vuebundler[Lsw_framework_components][59]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-debugger/lsw-debugger.api.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswDebugger'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswDebugger'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  const LswDebugger = class {

    static create(...args) {
      return new this(...args);
    }

    constructor(component) {
      this.$component = component;
    }

    debug(...args) {
      return this.$component.debug(...args);
    }

  };

  return LswDebugger;

});

// @vuebundler[Lsw_framework_components][60]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-debugger/lsw-debugger.html

// @vuebundler[Lsw_framework_components][60]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-debugger/lsw-debugger.js
// @code.start: LswDebugger API | @$section: Vue.js (v2) Components  LswDebugger component
Vue.component("LswDebugger", {
  template: `<div class="lsw_debugger">
    <div class="lsw_debugger_container"
        v-if="currentMessages.length">
        <div class="lsw_debugger_content pad_2 position_relative">
            <div class="dialog_window process_manager_window"
                style="z-index: 501;">
                <div class="dialog_topbar">
                    <div class="dialog_title">
                        <div>Live debugger</div>
                    </div>
                    <div class="dialog_topbar_buttons">
                        <button class="mini"
                            v-on:click="clearMessages"></button>
                    </div>
                </div>
                <div class="dialog_body">
                    <div class="lsw_debugger_message"
                        v-for="data, dataIndex in currentMessages"
                        v-bind:key="'debugger_data_' + dataIndex">
                        <div class=""
                            v-if="data.title">{{ data.title }}</div>
                        <div class="pad_bottom_1">
                            <div class="pad_top_1 pad_horizontal_1">
                                <span class="smallest_font"> [{{ data.created_at }}] </span>
                                <span class=""> ({{ typeof data.data }}) </span>
                                <span class="smallest_font"> [for {{ (data.timeout/1000).toFixed(3) }}s]: </span>
                            </div>
                            <div class="pad_top_1 pad_horizontal_1">
                                <span class="font_weight_bold"> {{ data.data }} </span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="dialog_footer">
                    <button class="mini"
                        v-on:click="clearMessages"> Cancelar</button>
                </div>
            </div>
        </div>
    </div>
</div>`,
  props: {
    
  },
  data() {
    this.$trace("lsw-error-box.data");
    return {
      currentMessages: [],
    };
  },
  methods: {
    debug(data, options = {}) {
      this.$trace("lsw-debugger.methods.debug");
      const id = options.id || LswRandomizer.getRandomString(10);
      const timeout = options.timeout || 3000;
      const timeoutId = setTimeout(() => {
        const pos = this.currentMessages.findIndex(it => it.id === id);
        if(pos === -1) return;
        this.currentMessages.splice(pos, 1);
        this.$forceUpdate(true);
      }, timeout);
      this.currentMessages.unshift({
        id,
        data: data,
        options,
        timeout,
        timeoutId,
        created_at: LswTimer.utils.fromDateToDatestring(new Date(), 0, 0, 1, 0, 1),
      });
    },
    clearMessages() {
      this.$trace("lsw-debugger.methods.clearMessages");
      this.currentMessages = [];
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-error-box.mounted");
      LswDebugger.global = LswDebugger.create(this);
      this.$debugger = LswDebugger.global;
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswDebugger API

// @vuebundler[Lsw_framework_components][60]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-debugger/lsw-debugger.css

// @vuebundler[Lsw_framework_components][61]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-coverage-viewer/lsw-coverage-viewer.html

// @vuebundler[Lsw_framework_components][61]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-coverage-viewer/lsw-coverage-viewer.js
Vue.component("LswCoverageViewer", {
  template: `<div class="coverage-report">

    <table class="width_100">
        <tbody>
            <tr class="nowrap">
                <td class="width_100"></td>
                <td>S</td>
                <td>B</td>
                <td>F</td>
                <td>L</td>
            </tr>
        </tbody>
        <tbody>
            <template v-for="(coverageItem, file) in coverageData">
                <tr class=""
                    style="color: black;"
                    v-bind:key="'row_overview_file_' + file">
                    <td class="" style="color: white;">
                         <span class="small_font like_link" v-on:click="() => selectFile(file)">{{ getPathRelativeToProject(file) }}</span>
                    </td>
                    <td class="small_font coverage_report_status_box" :class="coverageClass(calcPercent(coverageItem.s, coverageItem.statementMap))">
                        {{ calcPercent(coverageItem.s, coverageItem.statementMap) }}%
                    </td>
                    <td class="small_font coverage_report_status_box" :class="coverageClass(calcPercent(coverageItem.b, coverageItem.branchMap))">
                        {{ calcPercent(coverageItem.b, coverageItem.branchMap) }}%
                    </td>
                    <td class="small_font coverage_report_status_box" :class="coverageClass(calcPercent(coverageItem.f, coverageItem.fnMap))">
                        {{ calcPercent(coverageItem.f, coverageItem.fnMap) }}%
                    </td>
                    <td class="small_font coverage_report_status_box" :class="coverageClass(calcLineCoverage(coverageItem))">
                        {{ calcLineCoverage(coverageItem) }}%
                    </td>
                </tr>
                <tr class=""
                    style="color: black;"
                    v-bind:key="'row_sourcecode_file_' + file"
                    v-if="selectedFiles.indexOf(file) !== -1">
                    <td colspan="100" v-if="typeof sourceCodeOf[file] === 'string'">
                        <lsw-js-file-coverage-viewer :source="sourceCodeOf[file]" :coverage="coverageItem" />
                    </td>
                </tr>
            </template>
        </tbody>
    </table>

</div>`,
  data() {
    return {
      COVERAGE_TARGET_DIR: "/home/carlos/Escritorio/lsw-one/src/",
      coverageData: null,
      sourceCodeOf: {},
      selectedFiles: [],
    };
  },
  methods: {
    async selectFile(fileBrute) {
      const pos = this.selectedFiles.indexOf(fileBrute);
      const fileRelative = this.getPathRelativeToProject(fileBrute);
      if(pos === -1) {
        const contenido = await importer.text("assets/coverage/" + fileRelative);
        this.selectedFiles.push(fileBrute);
        this.sourceCodeOf[fileBrute] = contenido;
      } else {
        this.selectedFiles.splice(pos, 1);
      }
    },
    calcPercent(counts, map) {
      this.$trace("lsw-coverage-viewer.methods.calcPercent");
      const total = Object.keys(map).length;
      const covered = Object.values(counts).filter(c => {
        if (Array.isArray(c)) return c.every(x => x > 0); // for branches
        return c > 0;
      }).length;
      return this.cleanDecimals(total > 0 ? ((covered / total) * 100).toFixed(1) : '0.0');
    },
    calcLineCoverage(data) {
      this.$trace("lsw-coverage-viewer.methods.calcLineCoverage");
      // basic estimation using statementMap line numbers
      const lines = new Set();
      for (let key in data.statementMap) {
        lines.add(data.statementMap[key].start.line);
      }
      const covered = new Set();
      for (let key in data.s) {
        if (data.s[key] > 0) {
          covered.add(data.statementMap[key].start.line);
        }
      }
      return this.cleanDecimals(lines.size > 0 ? ((covered.size / lines.size) * 100).toFixed(1) : '0.0');
    },
    cleanDecimals(input) {
      this.$trace("lsw-coverage-viewer.methods.cleanDecimals");
      return (input + "").replace(/0+$/g, "").replace(/\.$/g, "");
    },
    coverageClass(percentStr) {
      this.$trace("lsw-coverage-viewer.methods.coverageClass");
      const percent = parseFloat(percentStr);
      if (percent >= 85) return 'high';
      if (percent >= 40) return 'medium';
      return 'low';
    },
    getPathRelativeToProject(file) {
      this.$trace("lsw-coverage-viewer.methods.getPathRelativeToProject");
      return file.replace(this.COVERAGE_TARGET_DIR, "");
    },
    async openFile(file) {
      this.$trace("lsw-coverage-viewer.methods.openFile");
      const relativeFile = this.getPathRelativeToProject(file);
      console.log(relativeFile);
      
    }
  },
  mounted() {
    this.$trace("lsw-coverage-viewer.mounted");
    if (typeof window.__coverage__ !== 'undefined') {
      this.coverageData = window.__coverage__;
    }
    window.$cov = this;
  },
});

// @vuebundler[Lsw_framework_components][61]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-coverage-viewer/lsw-coverage-viewer.css

// @vuebundler[Lsw_framework_components][62]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-js-file-coverage-viewer/lsw-js-file-coverage-viewer.html

// @vuebundler[Lsw_framework_components][62]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-js-file-coverage-viewer/lsw-js-file-coverage-viewer.js
/*
// @code.start: LswJsFileCoverageViewer API | @$section: Vue.js (v2) Components  Lsw SchemaBasedForm API  LswJsFileCoverageViewer component
Vue.component("LswJsFileCoverageViewer", {
  template: $ template,
  props: {
    source: {
      type: String,
      required: true,
    },
    coverage: {
      type: [Object, Boolean],
      default: () => false,
    },
  },
  data() {
    this.$trace("lsw-js-file-coverage-viewer.data");
    return {
      isLoaded: false,
      isExpanded: false,
      beautifiedSource: false,
    };
  },
  methods: {
    toggleExpansion() {
      this.$trace("lsw-js-file-coverage-viewer.methods.toggleExpansion");
      this.isExpanded = !this.isExpanded;
    },
    async load() {
      this.$trace("lsw-js-file-coverage-viewer.methods.load");
      await LswLazyLoads.loadHighlightJs();
      await LswLazyLoads.loadBeautifier();
      try {
        this.beautifiedSource = beautifier.js(this.source);
      } catch (error) {
        // @BADLUCK!
        this.beautifiedSource = this.source;
      } finally {
        this.isLoaded = true;
      }
      this.$nextTick(() => {
        hljs.highlightElement(this.$refs.sourceTag);
      });
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-js-file-coverage-viewer.mounted");
      await this.load();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswJsFileCoverageViewer API
//*/

Vue.component("LswJsFileCoverageViewer", {
  template: `<div class="lsw_js_file_coverage_viewer">
    <!--
    <div class="position_relative">
        <div class="position_absolute_fixed"
            style="left: auto; right: 7px; top: 7px;">
            <button class="supermini"
                :class="{activated:isExpanded}"
                v-on:click="toggleExpansion">
                
            </button>
        </div>
        <div v-if="isLoaded"
            class="js_viewer_tag hljs"
            :class="isExpanded ? 'expanded' : ''"
            ref="sourceTag"
            v-on:dblclick="toggleExpansion">{{ beautifiedSource || source }}</div>
        <div class="pad_1"
            v-else>
            Cargando...
        </div>
    </div>
    <div>{{ coverage }}</div>
-->
    <div class="coverage-table">
        <div class="container_to_view">
            <div class="typical_title_1">{{ ast.path }}</div>
            <table>
                <tbody>
                    <tr v-for="(lineContent, index) in lines"
                        :key="index"
                        class="line-row">
                        <td class="line-number">
                            <span :class="{ hit: isLineHit(index), miss: !isLineHit(index) }">
                                <button class="supermini for_line_coverage"
                                    v-on:click="() => showLineInfo(index)">{{ index }}</button>
                            </span>
                        </td>
                        <td class="line-code">
                            <!-- Aqu se colocaran decoradores por statement, branch o function -->
                            <span v-html="decorateLine(index + 1, lineContent)"></span>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>`,
  props: {
    source: String,
    coverage: Object,
  },
  data() {
    return {
      ast: this.coverage,
      lines: this.source.split("\n"),
    };
  },
  computed: {
    statementHits() {
      const hits = {};
      for (const [id, stmt] of Object.entries(this.ast.statementMap)) {
        const line = stmt.start.line;
        hits[line] = hits[line] || [];
        hits[line].push({
          type: "statement",
          hit: this.ast.s[id] > 0,
          loc: stmt,
          id,
        });
      }
      return hits;
    },
    functionHits() {
      const hits = {};
      for (const [id, fn] of Object.entries(this.ast.fnMap)) {
        const line = fn.decl.start.line;
        hits[line] = hits[line] || [];
        hits[line].push({
          type: "function",
          hit: this.ast.f[id] > 0,
          name: fn.name,
          id,
        });
      }
      return hits;
    },
    branchHits() {
      const hits = {};
      for (const [id, branch] of Object.entries(this.ast.branchMap)) {
        branch.locations.forEach((loc, i) => {
          const line = loc.start.line;
          hits[line] = hits[line] || [];
          hits[line].push({
            type: "branch",
            hit: this.ast.b[id][i] > 0,
            kind: branch.type,
            id,
            index: i,
          });
        });
      }
      return hits;
    },
  },
  methods: {
    isLineHit(line) {
      // Consideramos lnea cubierta si tiene algn statement/function/branch cubierto
      const s = this.statementHits[line] || [];
      const f = this.functionHits[line] || [];
      const b = this.branchHits[line] || [];

      return [...s, ...f, ...b].some(item => item.hit);
    },
    decorateLine(line, content) {
      const hits = [
        ...(this.statementHits[line] || []),
        ...(this.functionHits[line] || []),
        ...(this.branchHits[line] || []),
      ];

      if (hits.length === 0) {
        return this.escapeHtml(content);
      }

      // Para cada tipo, envolvemos el texto con spans con clases especficas y tooltips
      let decorated = this.escapeHtml(content);
      hits.forEach(hit => {
        const className = `${hit.type}-marker ${hit.hit ? 'hit' : 'miss'}`;
        const tooltip = this.getTooltipText(hit);
        // Marcador simple con tooltip - t luego aplicars el estilo
        decorated = `<span class="${className}" title="${tooltip}">${decorated}</span>`;
      });

      return decorated;
    },
    getTooltipText(hit) {
      if (hit.type === 'statement') {
        return `Statement ${hit.id}: ${hit.hit ? 'Ejecutado' : 'No ejecutado'}`;
      } else if (hit.type === 'function') {
        return `Funcin ${hit.name || hit.id}: ${hit.hit ? 'Ejecutada' : 'No ejecutada'}`;
      } else if (hit.type === 'branch') {
        return `Branch ${hit.id}[${hit.index}] (${hit.kind}): ${hit.hit ? 'Tomado' : 'No tomado'}`;
      }
      return '';
    },
    escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    },
    showLineInfo(line) {
      this.$lsw.toasts.send({
        title: `Usos de lnea ${line}`,
        text: this.getCoverageByLine(line, this.ast, true),
      });
      this.$lsw.toasts.collapse(this.getCoverageByLine(line, this.ast, false), 5000);
    },
    getCoverageByLine(line, ast, summarized = false) {
      const statements = [];
      const functions = [];
      const branches = [];
      const statementRows = Object.entries(ast.statementMap);
      for(let statementIndex=0; statementIndex<statementRows.length; statementIndex++) {
        const row = statementRows[statementIndex];
        const [id, loc] = row;
        if(loc.start.line === (line + 1)) {
          statements.push({
            id,
            loc,
            hits: ast.s[id],
          });
        }
      }
      const functionRows = Object.entries(ast.fnMap);
      for(let functionIndex=0; functionIndex<functionRows.length; functionIndex++) {
        const row = functionRows[functionIndex];
        const [id, fn] = row;
        if(fn.decl.start.line === (line + 1)) {
          functions.push({
            id,
            name: fn.name,
            hits: ast.f[id],
          });
        }
      }
      const branchRows = Object.entries(ast.branchMap);
      for(let branchIndex=0; branchIndex<branchRows.length; branchIndex++) {
        const row = branchRows[branchIndex];
        const [id, branch] = row;
        branch.locations.forEach((loc, indexLoc) => {
          if(loc.start.line === (line + 1)) {
            branches.push({
              id,
              loc,
              hits: ast.b[id],
              index: indexLoc,
              kind: branch.type,
              loc,
            });
          }
        })
      }
      const stats = { statements, functions, branches };
      if(!summarized) {
        return stats;
      }
      let S = 0, F = 0, B = 0;
      stats.statements.forEach(st => {
        if(typeof st.hits === "number") {
          S += st.hits;
        } else if(Array.isArray(st.hits)) {
          st.hits.forEach(subst => {
            if(typeof subst === "number") {
              S += subst;
            }
          });
        }
      });
      stats.functions.forEach(st => {
        if(typeof st.hits === "number") {
          F += st.hits;
        } else if(Array.isArray(st.hits)) {
          st.hits.forEach(subst => {
            if(typeof subst === "number") {
              F += subst;
            }
          });
        }
      });
      stats.branches.forEach(st => {
        if(typeof st.hits === "number") {
          B += st.hits;
        } else if(Array.isArray(st.hits)) {
          st.hits.forEach(subst => {
            if(typeof subst === "number") {
              B += subst;
            }
          });
        }
      });
      const summary = {
        Sentencias: S,
        Funciones: F,
        Brancas: B
      };
      return summary;
    }
  },
});

// @vuebundler[Lsw_framework_components][62]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-js-file-coverage-viewer/lsw-js-file-coverage-viewer.css

// @vuebundler[Lsw_framework_components][63]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-calendario/lsw-calendario.html

// @vuebundler[Lsw_framework_components][63]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-calendario/lsw-calendario.js
// @code.start: LswCalendario API | @$section: Vue.js (v2) Components  LswCalendario API  LswCalendario component
Vue.component("LswCalendario", {
  template: `<div class="Component LswCalendario">
  <div class="visor_de_calendario">
    <table class="tabla_de_calendario" v-if="fecha_seleccionada">
      <tbody>
        <tr>
          <td>
            <button class="boton_de_mover_mes"
              v-on:click="ir_a_mes_anterior">  </button>
          </td>
          <td colspan="5"
            style="width:auto; vertical-align: middle;">
            <div class="chivato_de_fecha">{{ obtener_fecha_formateada(fecha_seleccionada) }}</div>
            <div class="chivato_de_fecha"
              v-if="(!es_solo_fecha) && fecha_seleccionada">a las {{ obtener_expresion_de_hora(fecha_seleccionada) }}
            </div>
          </td>
          <td>
            <button class="boton_de_mover_mes"
              v-on:click="ir_a_mes_siguiente">  </button>
          </td>
        </tr>
      </tbody>
      <tbody>
        <tr class="fila_de_dias_de_semana">
          <td><div class="">Lu</div></td>
          <td><div class="">Ma</div></td>
          <td><div class="">Mi</div></td>
          <td><div class="">Ju</div></td>
          <td><div class="">Vi</div></td>
          <td><div class="">S</div></td>
          <td><div class="">Do</div></td>
        </tr>
      </tbody>
      <tbody class="dias_de_calendario">
        <tr v-for="semana, semana_index in celdas_del_mes_actual"
          v-bind:key="'semana-' + semana_index">
          <td v-for="dia, dia_index in semana"
            v-bind:key="'dia-' + dia_index">
            <span v-if="dia && (dia instanceof Date)">
              <button class="boton_de_calendario boton_de_dia_de_calendario position_relative"
                :class="{
                  active: dia.getDate() === fecha_seleccionada.getDate(),
                  current: (dia_actual === dia.getDate())
                    && (mes_actual === dia.getMonth())
                    && (anio_actual === dia.getFullYear())
                }"
                v-on:click="() => seleccionar_dia(dia)">
                <div class="dia_de_calendario_texto">{{ dia.getDate() }}</div>
                <div v-if="dia.getDate() in marcadores_del_mes"
                  class="total_de_tareas_de_dia">
                  <div>
                    {{ marcadores_del_mes[dia.getDate()].length }}
                  </div>
                </div>
              </button>
            </span>
          </td>
        </tr>
      </tbody>
    </table>
    <div class="text_align_center" v-if="modo === 'datetime' || modo === 'time'">

      <!--div class="panel_de_hora_de_calendario">{{ obtener_expresion_de_hora(fecha_seleccionada) }}</div-->

      <hr class="dashed" />

      <div class="pad_bottom_1 text_align_center">
        <div class="flex_row centered">
          <div class="flex_1">Seleccin: </div>
          <div class="flex_100 text_align_right" v-if="fecha_seleccionada">
            {{ LswTimer.utils.fromDateToHour(fecha_seleccionada) }}
          </div>
        </div>
      </div>

      <div class="pad_bottom_1">
        <div class="flex_row centered">
          <div class="flex_1">
            <button class="supermini" v-on:click="() => setHora(0)"></button>
          </div>
          <div class="flex_1 pad_horizontal_1">
            <button class="supermini" v-on:click="() => increaseHora(-1)"></button>
          </div>
          <div class="flex_100">
            {{ LswUtils.padStart(hora_actual, 2, '0') }}
          </div>
          <div class="flex_1">
            <button class="supermini" v-on:click="() => askHora()"></button>
          </div>
          <div class="flex_1 pad_horizontal_1">
            <button class="supermini" v-on:click="() => increaseHora(1)"></button>
          </div>
          <div class="flex_1">
            <button class="supermini" v-on:click="() => setHora(23)"></button>
          </div>
        </div>
      </div>

      <div class="">
        <div class="flex_row centered">
          <div class="flex_1">
            <button class="supermini" v-on:click="() => setMinuto(0)"></button>
          </div>
          <div class="flex_1 pad_horizontal_1">
            <button class="supermini" v-on:click="() => increaseMinuto(-1)"></button>
          </div>
          <div class="flex_100">
            {{ LswUtils.padStart(minuto_actual, 2, '0') }}
          </div>
          <div class="flex_1">
            <button class="supermini" v-on:click="() => askMinuto()"></button>
          </div>
          <div class="flex_1 pad_horizontal_1">
            <button class="supermini" v-on:click="() => increaseMinuto(1)"></button>
          </div>
          <div class="flex_1">
            <button class="supermini" v-on:click="() => setMinuto(59)"></button>
          </div>
        </div>
      </div>

      <!--div class="duration_control_details_panel">
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(0)">00:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(1)">01:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(2)">02:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(3)">03:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(4)">04:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(5)">05:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(6)">06:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(7)">07:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(8)">08:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(9)">09:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(10)">10:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(11)">11:00:00</div>
      </div>
      
      <hr class="dashed" />
      
      <div class="duration_control_details_panel">
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(12)">12:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(13)">13:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(14)">14:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(15)">15:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(16)">16:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(17)">17:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(18)">18:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(19)">19:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(20)">20:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(21)">21:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(22)">22:00:00</div>
        <div class="duration_control_option" v-on:click="() => establecer_hora_directamente(23)">23:00:00</div>
      </div>

      <hr class="dashed" />

      <div class="duration_control_details_panel">
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(0)">00min</div>
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(5)">05min</div>
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(10)">10min</div>
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(15)">15min</div>
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(20)">20min</div>
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(25)">25min</div>
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(30)">30min</div>
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(35)">35min</div>
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(40)">40min</div>
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(45)">45min</div>
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(50)">50min</div>
        <div class="duration_control_option" v-on:click="() => establecer_minutos_directamente(55)">55min</div>
      </div>

      <hr class="dashed" />

      <div class="duration_control_details_panel">
        <div class="duration_control_option" v-on:click="() => aniadir_minutos_directamente(1)">+01min</div>
        <div class="duration_control_option" v-on:click="() => aniadir_minutos_directamente(5)">+05min</div>
        <div class="duration_control_option" v-on:click="() => aniadir_minutos_directamente(10)">+10min</div>
        <div class="duration_control_option" v-on:click="() => aniadir_minutos_directamente(30)">+30min</div>
      </div>

      <hr class="dashed" />

      <div class="duration_control_details_panel">
        <div class="duration_control_option" v-on:click="() => aniadir_minutos_directamente(-1)">-01min</div>
        <div class="duration_control_option" v-on:click="() => aniadir_minutos_directamente(-5)">-05min</div>
        <div class="duration_control_option" v-on:click="() => aniadir_minutos_directamente(-10)">-10min</div>
        <div class="duration_control_option" v-on:click="() => aniadir_minutos_directamente(-30)">-30min</div>
      </div-->

    </div>
    <!--table class="width_100 no_borders_table"
      >
      <tbody>
        <tr class="fila_de_digito">
          <td v-on:click="agregar_digito_de_hora(1)"><button class="boton_de_ajuste_de_hora"></button></td>
          <td v-on:click="agregar_digito_de_hora(2)"><button class="boton_de_ajuste_de_hora"></button></td>
          <td></td>
          <td v-on:click="agregar_digito_de_hora(3)"><button class="boton_de_ajuste_de_hora"></button></td>
          <td v-on:click="agregar_digito_de_hora(4)"><button class="boton_de_ajuste_de_hora"></button></td>
          <td></td>
          <td v-on:click="\$noop"><button class="boton_de_ajuste_de_hora"></button></td>
          <td v-on:click="\$noop"><button class="boton_de_ajuste_de_hora"></button></td>
        </tr>
        <tr class="fila_de_digito"
          v-if="fecha_seleccionada">
          <td>{{ obtener_digito_de_hora(1) }}</td>
          <td>{{ obtener_digito_de_hora(2) }}</td>
          <td>:</td>
          <td>{{ obtener_digito_de_hora(3) }}</td>
          <td>{{ obtener_digito_de_hora(4) }}</td>
          <td>:</td>
          <td>{{ obtener_digito_de_hora(5) }}</td>
          <td>{{ obtener_digito_de_hora(6) }}</td>
        </tr>
        <tr class="fila_de_digito">
          <td v-on:click="quitar_digito_de_hora(1)"><button class="boton_de_ajuste_de_hora"></button></td>
          <td v-on:click="quitar_digito_de_hora(2)"><button class="boton_de_ajuste_de_hora"></button></td>
          <td></td>
          <td v-on:click="quitar_digito_de_hora(3)"><button class="boton_de_ajuste_de_hora"></button></td>
          <td v-on:click="quitar_digito_de_hora(4)"><button class="boton_de_ajuste_de_hora"></button></td>
          <td></td>
          <td v-on:click="\$noop"><button class="boton_de_ajuste_de_hora"></button></td>
          <td v-on:click="\$noop"><button class="boton_de_ajuste_de_hora"></button></td>
        </tr>
      </tbody>
    </table-->
    <!--table class="tabla_para_horas"
      v-if="!es_solo_fecha">
      <tr>
        <td>
          <button style="display: table-cell;"
            class="boton_de_calendario"
            v-on:click="agregar_hora">  </button>
        </td>
        <td>
          <button style="display: table-cell;"
            class="boton_de_calendario"
            v-on:click="agregar_minuto">  </button>
        </td>
        <td>
          <button style="display: table-cell;"
            class="boton_de_calendario"
            v-on:click="agregar_segundo">  </button>
        </td>
      </tr>
      <tr>
        <td>
          <input style="display: table-cell;"
            class="entrada_de_calendario"
            type="text"
            v-model="hora_seleccionada" />
        </td>
        <td>
          <input style="display: table-cell;"
            class="entrada_de_calendario"
            type="text"
            v-model="minuto_seleccionado" />
        </td>
        <td>
          <input style="display: table-cell;"
            class="entrada_de_calendario"
            type="text"
            v-model="segundo_seleccionado" />
        </td>
      </tr>
      <tr>
        <td>
          <button style="display: table-cell;"
            class="boton_de_calendario"
            v-on:click="quitar_hora">  </button>
        </td>
        <td>
          <button style="display: table-cell;"
            class="boton_de_calendario"
            v-on:click="quitar_minuto">  </button>
        </td>
        <td>
          <button style="display: table-cell;"
            class="boton_de_calendario"
            v-on:click="quitar_segundo">  </button>
        </td>
      </tr>
    </table-->
  </div>
</div>`,
  props: {
    modo: {
      type: String,
      default: () => "datetime" // can be: date, time, datetime
    },
    valorInicial: {
      type: [String, Date],
      default: () => new Date()
    },
    alCambiarValor: {
      type: Function,
      default: () => { }
    },
    alIniciar: {
      type: Function,
      default: () => { }
    },
  },
  data() {
    try {
      this.$trace("lsw-calendario.data");
      const hoy = new Date();
      return {
        es_carga_inicial: true,
        valor_inicial_adaptado: this.adaptar_valor_inicial(this.valorInicial),
        es_solo_fecha: this.modo === "date",
        es_solo_hora: this.modo === "time",
        es_fecha_y_hora: this.modo === "datetime",
        fecha_seleccionada: undefined,
        celdas_del_mes_actual: undefined,
        marcadores_del_mes: {},
        hoy: hoy,
        hora_actual: hoy.getHours(),
        minuto_actual: hoy.getMinutes(),
        dia_actual: hoy.getDate(),
        mes_actual: hoy.getMonth(),
        anio_actual: hoy.getFullYear(),
        /*
        hora_seleccionada: "0",
        minuto_seleccionado: "0",
        segundo_seleccionado: "0",
        milisegundo_seleccionado: "0",
        //*/
      };
    } catch (error) {
      console.log(error);
      throw error;
    }
  },
  methods: {
    getValue() {
      this.$trace("lsw-calendario.methods.getValue");
      return this.fecha_seleccionada;
    },
    adaptar_valor_inicial(valor) {
      this.$trace("lsw-calendario.methods.adaptar_valor_inicial");
      if (typeof valor === "string") {
        try {
          const resultado = LswTimer.utils.getDateFromMomentoText(valor);
          console.log("FECHA ENTRADA:", resultado);
          return resultado;
        } catch (error) {
          console.error("Error parseando valor inicial de lsw-calendario:", error);
        }
      }
      return valor || new Date();
    },
    agregar_digito_de_hora(indice) {
      this.$trace("lsw-calendario.methods.agregar_digito_de_hora");
      const value = this.obtener_digito_de_hora(indice);
      const isInMaximum = ([3, 5].indexOf(indice) !== -1) ? value === 5 : ([1].indexOf(indice) !== -1) ? value === 2 : value === 9;
      if (!isInMaximum) {
        this.establecer_digito_de_hora(indice, value + 1);
      }
    },
    quitar_digito_de_hora(indice) {
      this.$trace("lsw-calendario.methods.quitar_digito_de_hora");
      const value = this.obtener_digito_de_hora(indice);
      const isInMinimum = value === 0;
      if (!isInMinimum) {
        this.establecer_digito_de_hora(indice, value - 1);
      }
    },
    obtener_digito_de_hora(indice, fecha = this.fecha_seleccionada) {
      this.$trace("lsw-calendario.methods.obtener_digito_de_hora");
      if (indice === 1) {
        return parseInt(this.espaciar_izquierda(fecha.getHours(), 2)[0]);
      } else if (indice === 2) {
        return parseInt(this.espaciar_izquierda(fecha.getHours(), 2)[1]);
      } else if (indice === 3) {
        return parseInt(this.espaciar_izquierda(fecha.getMinutes(), 2)[0]);
      } else if (indice === 4) {
        return parseInt(this.espaciar_izquierda(fecha.getMinutes(), 2)[1]);
      } else if (indice === 5) {
        return parseInt(this.espaciar_izquierda(fecha.getSeconds(), 2)[0]);
      } else if (indice === 6) {
        return parseInt(this.espaciar_izquierda(fecha.getSeconds(), 2)[1]);
      } else {
        throw new Error("No se reconoci el ndice del dgito: " + indice);
      }
    },
    cambiar_posicion_en_texto(texto, posicion, valor) {
      this.$trace("lsw-calendario.methods.cambiar_posicion_en_texto");
      const arr = ("" + texto).split("");
      arr[posicion] = valor;
      return arr.join("");
    },
    establecer_digito_de_hora(indice, valor) {
      this.$trace("lsw-calendario.methods.establecer_digito_de_hora");
      console.log(indice, valor);
      const fecha_clonada = new Date(this.fecha_seleccionada);
      if (indice === 1) {
        let horas = this.espaciar_izquierda(this.fecha_seleccionada.getHours(), 2);
        horas = this.cambiar_posicion_en_texto(horas, 0, valor);
        const horasInt = parseInt(horas);
        if(horasInt > 23) return;
        fecha_clonada.setHours(horasInt);
      } else if (indice === 2) {
        let horas = this.espaciar_izquierda(this.fecha_seleccionada.getHours(), 2);
        horas = this.cambiar_posicion_en_texto(horas, 1, valor);
        const horasInt = parseInt(horas);
        if(horasInt > 23) return;
        fecha_clonada.setHours(horasInt);
      } else if (indice === 3) {
        let minutos = this.espaciar_izquierda(this.fecha_seleccionada.getMinutes(), 2);
        minutos = this.cambiar_posicion_en_texto(minutos, 0, valor);
        const minutosInt = parseInt(minutos);
        if(minutosInt > 59) return;
        fecha_clonada.setMinutes(minutosInt);
      } else if (indice === 4) {
        let minutos = this.espaciar_izquierda(this.fecha_seleccionada.getMinutes(), 2);
        minutos = this.cambiar_posicion_en_texto(minutos, 1, valor);
        const minutosInt = parseInt(minutos);
        if(minutosInt > 59) return;
        fecha_clonada.setMinutes(minutosInt);
      } else if (indice === 5) {
        // @OK
      } else if (indice === 6) {
        // @OK
      } else {
        throw new Error("No se reconoci el ndice del dgito: " + indice);
      }
      console.log(fecha_clonada);
      this.fecha_seleccionada = fecha_clonada;
      this.actualizar_fecha_seleccionada(true);
    },
    ir_a_mes_anterior() {
      this.$trace("lsw-calendario.methods.ir_a_mes_anterior");
      try {
        const nueva_fecha = new Date(this.fecha_seleccionada);
        this.fecha_seleccionada = new Date(nueva_fecha.getFullYear(), nueva_fecha.getMonth()-1, 1);
      } catch (error) {
        console.log(error);
        throw error;
      }

    },
    ir_a_mes_siguiente() {
      this.$trace("lsw-calendario.methods.ir_a_mes_siguiente");
      try {
        const nueva_fecha = new Date(this.fecha_seleccionada);
        this.fecha_seleccionada = new Date(nueva_fecha.getFullYear(), nueva_fecha.getMonth()+1, 1);
      } catch (error) {
        console.log(error);
        throw error;
      }

    },
    seleccionar_dia(dia) {
      this.$trace("lsw-calendario.methods.seleccionar_dia");
      try {
        this.fecha_seleccionada = dia;
        this.actualizar_fecha_seleccionada(true);
      } catch (error) {
        console.log(error);
        throw error;
      }

    },
    espaciar_izquierda(texto,
      longitud,
      relleno = "0") {
      this.$trace("lsw-calendario.methods.espaciar_izquierda");
      try {
        let salida = "" + texto;
        while (salida.length < longitud) {
          salida = relleno + salida;
        }
        return salida;
      } catch (error) {
        console.log(error);
        throw error;
      }

    },
    obtener_fecha_formateada(fecha) {
      this.$trace("lsw-calendario.methods.obtener_fecha_formateada");
      try {
        if (!(fecha instanceof Date)) {
          console.log(fecha);
          throw new Error("Required parameter fecha to be a Date on LswCalendario.methods.obtener_fecha_formateada");
        }
        let formato = "";
        formato += (() => {
          try {
            if (fecha.getDay() === 0) {
              return "Domingo";
            }
            if (fecha.getDay() === 1) {
              return "Lunes";
            }
            if (fecha.getDay() === 2) {
              return "Martes";
            }
            if (fecha.getDay() === 3) {
              return "Mircoles";
            }
            if (fecha.getDay() === 4) {
              return "Jueves";
            }
            if (fecha.getDay() === 5) {
              return "Viernes";
            }
            if (fecha.getDay() === 6) {
              return "Sbado";
            }
          } catch (error) {
            console.log(error);
            throw error;
          }
        })();
        formato += ", ";
        formato += fecha.getDate();
        formato += " de ";
        formato += (() => {
          try {
            if (fecha.getMonth() === 0) {
              return "Enero";
            }
            if (fecha.getMonth() === 1) {
              return "Febrero";
            }
            if (fecha.getMonth() === 2) {
              return "Marzo";
            }
            if (fecha.getMonth() === 3) {
              return "Abril";
            }
            if (fecha.getMonth() === 4) {
              return "Mayo";
            }
            if (fecha.getMonth() === 5) {
              return "Junio";
            }
            if (fecha.getMonth() === 6) {
              return "Julio";
            }
            if (fecha.getMonth() === 7) {
              return "Agosto";
            }
            if (fecha.getMonth() === 8) {
              return "Septiembre";
            }
            if (fecha.getMonth() === 9) {
              return "Octubre";
            }
            if (fecha.getMonth() === 10) {
              return "Noviembre";
            }
            if (fecha.getMonth() === 11) {
              return "Diciembre";
            }
          } catch (error) {
            console.log(error);
            throw error;
          }
        })();
        formato += " de ";
        formato += fecha.getFullYear();
        return formato;
      } catch (error) {
        console.log(error);
        throw error;
      }

    },
    actualizar_calendario(nuevo_valor = this.fecha_seleccionada) {
      this.$trace("lsw-calendario.methods.actualizar_calendario");
      try {
        const dias = [];
        const dia_1_del_mes = new Date(nuevo_valor);
        dia_1_del_mes.setDate(1);
        dia_1_del_mes.setHours(0);
        dia_1_del_mes.setMinutes(0);
        dia_1_del_mes.setSeconds(0);
        dia_1_del_mes.setMilliseconds(0);
        const dias_antes_de_entrar_en_el_mes = (() => {
          try {
            const dia_de_semana = dia_1_del_mes.getDay();
            if (dia_de_semana === 0) {
              return 6;
            }
            if (dia_de_semana === 1) {
              return 0;
            }
            if (dia_de_semana === 2) {
              return 1;
            }
            if (dia_de_semana === 3) {
              return 2;
            }
            if (dia_de_semana === 4) {
              return 3;
            }
            if (dia_de_semana === 5) {
              return 4;
            }
            if (dia_de_semana === 6) {
              return 5;
            }
          } catch (error) {
            console.log(error);
            throw error;
          }
        })();
        const celdas_vacias_anteriores = new Array(dias_antes_de_entrar_en_el_mes);
        let dia_final_del_mes = undefined;
        Logica_anterior: {
          dia_final_del_mes = new Date(nuevo_valor);
          dia_final_del_mes.setMonth(dia_final_del_mes.getMonth() + 1);
          dia_final_del_mes.setDate(1);
          dia_final_del_mes.setDate(dia_final_del_mes.getDate() - 1);
        }
        Logica_chatgpt: {
          dia_final_del_mes = new Date(nuevo_valor.getFullYear(), nuevo_valor.getMonth() + 1, 0);
        }
        const numero_final_de_mes = dia_final_del_mes.getDate();
        let fila_actual = celdas_vacias_anteriores;
        for (let index = 1; index <= numero_final_de_mes; index++) {
          const nueva_fecha = new Date(dia_1_del_mes);
          nueva_fecha.setDate(index);
          fila_actual.push(nueva_fecha);
          if (nueva_fecha.getDay() === 0) {
            dias.push(fila_actual);
            fila_actual = [];
          }
        }
        if (fila_actual.length) {
          dias.push(fila_actual);
        }
        this.celdas_del_mes_actual = dias;
        this.propagar_cambio();
      } catch (error) {
        console.log(error);
        throw error;
      }
    },
    actualizar_fecha_seleccionada(con_propagacion = true, fecha_seleccionada = this.fecha_seleccionada) {
      this.$trace("lsw-calendario.methods.actualizar_fecha_seleccionada");
      if (con_propagacion) {
        const clon_fecha = new Date(fecha_seleccionada);
        this.fecha_seleccionada = clon_fecha;
      }
    },
    propagar_cambio() {
      this.$trace("lsw-calendario.methods.propagar_cambio");
      if (typeof this.alCambiarValor === "function") {
        // Si es carga inicial, no propagamos el evento:
        if(this.es_carga_inicial) {
          return;
        }
        this.alCambiarValor(this.fecha_seleccionada, this);
      }
    },
    obtener_expresion_de_hora(fecha = this.fecha_seleccionada) {
      this.$trace("lsw-calendario.methods.obtener_expresion_de_hora");
      let hours = fecha.getHours();
      let minutes = fecha.getMinutes();
      let seconds = fecha.getSeconds();
      hours = this.espaciar_izquierda(hours, 2, "0");
      minutes = this.espaciar_izquierda(minutes, 2, "0");
      seconds = this.espaciar_izquierda(seconds, 2, "0");
      return `${hours}:${minutes}:${seconds}`;
    },
    establecer_marcadores_del_mes(marcadores_del_mes) {
      this.$trace("lsw-calendario.methods.establecer_marcadores_del_mes");
      this.marcadores_del_mes = marcadores_del_mes;
    },
    establecer_hora_directamente(hora, minutos = 0) {
      this.$trace("lsw-calendario.methods.establecer_hora_directamente");
      this.fecha_seleccionada.setHours(hora);
      this.fecha_seleccionada.setMinutes(minutos);
      this.fecha_seleccionada.setSeconds(0);
      this.fecha_seleccionada = new Date(this.fecha_seleccionada);
    },
    increaseHora(horas_aniadidos) {
      this.$trace("lsw-calendario.methods.increaseHora");
      const horas_actuales = this.fecha_seleccionada.getHours();
      this.fecha_seleccionada.setHours(horas_actuales + horas_aniadidos);
      this.fecha_seleccionada.setSeconds(0);
      this.fecha_seleccionada = new Date(this.fecha_seleccionada);
    },
    increaseMinuto(minutos_aniadidos) {
      this.$trace("lsw-calendario.methods.increaseMinuto");
      const minutos_actuales = this.fecha_seleccionada.getMinutes();
      this.fecha_seleccionada.setMinutes(minutos_actuales + minutos_aniadidos);
      this.fecha_seleccionada.setSeconds(0);
      this.fecha_seleccionada = new Date(this.fecha_seleccionada);
    },
    setHora(horas) {
      this.$trace("lsw-calendario.methods.setHora");
      this.fecha_seleccionada.setHours(horas);
      this.fecha_seleccionada.setSeconds(0);
      this.fecha_seleccionada = new Date(this.fecha_seleccionada);
    },
    setMinuto(minutos) {
      this.$trace("lsw-calendario.methods.setMinuto");
      this.fecha_seleccionada.setMinutes(minutos);
      this.fecha_seleccionada.setSeconds(0);
      this.fecha_seleccionada = new Date(this.fecha_seleccionada);
    },
    askHora() {
      this.$trace("lsw-calendario.methods.askHora");
      const hora = window.prompt("Qu hora quieres poner?", this.fecha_seleccionada.getHours());
      if(typeof hora !== "string") return;
      this.fecha_seleccionada.setHours(hora);
      this.fecha_seleccionada.setSeconds(0);
      this.fecha_seleccionada = new Date(this.fecha_seleccionada);
    },
    askMinuto() {
      this.$trace("lsw-calendario.methods.askMinuto");
      const minuto = window.prompt("Qu minuto quieres poner?", this.fecha_seleccionada.getMinutes());
      if(typeof minuto !== "string") return;
      this.fecha_seleccionada.setMinutes(minuto);
      this.fecha_seleccionada.setSeconds(0);
      this.fecha_seleccionada = new Date(this.fecha_seleccionada);
    },
  },
  watch: {
    fecha_seleccionada(nuevo_valor) {
      this.$trace("lsw-calendario.watch.fecha_seleccionada");
      this.hora_actual = nuevo_valor.getHours();
      this.minuto_actual = nuevo_valor.getMinutes();
      this.actualizar_calendario(nuevo_valor);
    },
  },
  mounted() {
    this.$trace("lsw-calendario.mounted");
    try {
      this.fecha_seleccionada = this.valor_inicial_adaptado;
      this.$nextTick(() => {
        this.es_carga_inicial = false;
      });
      if(this.alIniciar) {
        this.alIniciar(this.fecha_seleccionada, this);
      }
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
});
// @code.end: LswCalendario API

// @vuebundler[Lsw_framework_components][63]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-calendario/lsw-calendario.css

// @vuebundler[Lsw_framework_components][64]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-table/lsw-table/lsw-table.html

// @vuebundler[Lsw_framework_components][64]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-table/lsw-table/lsw-table.js
// @code.start: LswTable API | @$section: Vue.js (v2) Components  Lsw Table API  LswTable component
Vue.component("LswTable", {
  template: `<div class="lsw_table pad_top_1">
    <div>
        <div class="lsw_table_top_panel pad_horizontal_1">
            <div class="lsw_table_top_panel_1 flex_row centered pad_top_1 pad_bottom_1">
                <div class="flex_1 pad_right_1">
                    *
                </div>
                <div class="flex_100 title_box">{{ title }}</div>
                <div class="flex_1 pad_left_1"
                    v-for="topButton, topButtonIndex in attachedTopButtons"
                    v-bind:key="'table-button-' + topButtonIndex">
                    <button class=""
                        v-on:click="topButton.event">
                        {{ topButton.text }}
                    </button>
                </div>
                <div class="flex_1 pad_left_1">
                    <lsw-data-printer-button class="cursor_pointer"
                        :input="() => output" />
                </div>
                <div class="flex_1 pad_left_1">
                    <button class="cursor_pointer"
                        v-on:click="digestOutput"></button>
                </div>
            </div>
            <div class="lsw_table_top_panel_2 flex_row centered pad_bottom_1">
                <div class="flex_100">
                    <div class="flex_row">
                        <div class="flex_100">
                            <input spellcheck="false"
                                class="width_100"
                                type="text"
                                v-model="searcher"
                                style="min-height: 25px;"
                                v-on:keypress.enter="digestOutput"
                                :placeholder="placeholderForBuscador" />
                        </div>
                        <div class="flex_1 pad_left_1">
                            <button class="width_100"
                                v-on:click="toggleMenu"
                                :class="{activated: isShowingMenu === true}">
                                <span v-if="hasFiltersApplying"></span>
                                <span v-else></span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div v-if="isShowingMenu">
                <div class="">
                    <div class="table_navigation_menu_cell"
                        colspan="1000">
                        <div class="table_navigation_menu">
                            <div class="flex_row centered">
                                <div class="flex_1 nowrap"> Ests en: </div>
                                <div class="flex_100 left_padded_1">
                                    <select class="width_100 text_align_right"
                                        v-model="isShowingSubpanel">
                                        <option value="Buscador">Buscador {{ searcher.length ? \`(con: \${searcher.length}B)\` : '' }}</option>
                                        <option value="Paginador">Paginador (en: {{ itemsPerPage }})</option>
                                        <option value="Columnas">Columnas {{ columnsOrder.length ? \`(con: \${columnsOrder.length}B)\` : '' }}</option>
                                        <option value="Extensor">Extensor {{ extender.length ? \`(con: \${extender.length}B)\` : '' }}</option>
                                        <option value="Filtro">Filtro {{ filter.length ? \`(con: \${filter.length}B)\` : '' }}</option>
                                        <option value="Ordenador">Orden {{ sorter.length ? \`(con: \${sorter.length}B)\` : '' }}</option>
                                        <option value="Todo">Todo a la vez</option>
                                    </select>
                                </div>
                                <div class="flex_1 pad_left_1" v-if="storageId">
                                    <button class="" v-on:click="saveState"></button>
                                </div>
                            </div>
                            <hr />
                            <div class="lsw_table_config_panel">
                                <div class="config_panel" v-if="(isShowingSubpanel === 'Buscador') || (isShowingSubpanel === 'Todo')">
                                    <h5>Buscador por texto</h5>
                                    <input spellcheck="false"
                                        class="width_100"
                                        type="text"
                                        v-model="searcher"
                                        v-on:keypress.enter="digestOutput"
                                        :placeholder="placeholderForBuscador" />
                                </div>
                                <div class="config_panel" v-if="(isShowingSubpanel === 'Filtro') || (isShowingSubpanel === 'Todo')">
                                    <h5>Filtro de filas</h5>
                                    <textarea spellcheck="false"
                                        v-model="filter"
                                        :placeholder="placeholderForFiltro"></textarea>
                                </div>
                                <div class="config_panel" v-if="(isShowingSubpanel === 'Extensor') || (isShowingSubpanel === 'Todo')">
                                    <h5>Extensor de propiedades</h5>
                                    <textarea spellcheck="false"
                                        v-model="extender"
                                        :placeholder="placeholderForExtensor"></textarea>
                                </div>
                                <div class="config_panel" v-if="(isShowingSubpanel === 'Ordenador') || (isShowingSubpanel === 'Todo')">
                                    <h5>Ordenador de filas</h5>
                                    <textarea spellcheck="false"
                                        v-model="sorter"
                                        :placeholder="placeholderForOrdenador"></textarea>
                                </div>
                                <div class="config_panel" v-if="(isShowingSubpanel === 'Columnas') || (isShowingSubpanel === 'Todo')">
                                    <h5>Ordenador de columnas</h5>
                                    <div class="flex_row centered">
                                        <div class="flex_100">
                                            <input type="text"
                                                class="width_100"
                                                v-model="columnsOrderInput"
                                                v-on:keypress.enter="updateColumnsOrderFromInput"
                                                placeholder="Ej: age, name, id" />
                                        </div>
                                        <div class="flex_1 pad_left_1">
                                            <button class=""
                                                v-on:click="updateColumnsOrderFromInput"></button>
                                        </div>
                                    </div>
                                    <ol>
                                        <li v-for="columnRule, columnIndex in columnsOrder"
                                            v-bind:key="'column_order_' + columnIndex">
                                            <b>Columna {{ columnIndex+1 }}.</b> {{ columnRule }}
                                        </li>
                                    </ol>
                                </div>
                                <div class="config_panel" v-if="(isShowingSubpanel === 'Paginador') || (isShowingSubpanel === 'Todo')">
                                    <h5>Pgina de resultados</h5>
                                    <div class="flex_row">
                                        <div class="flex_1 pad_right_1">
                                            <button class="" v-on:click="decreasePage">-</button>
                                        </div>
                                        <div class="flex_100">
                                            <input spellcheck="false"
                                                class="width_100 text_align_center"
                                                type="number"
                                                v-model="currentPageOnForm"
                                                v-on:keypress.enter="digestOutput"
                                                :placeholder="placeholderForPaginador" />
                                        </div>
                                        <div class="flex_1 pad_left_1">
                                            <button class="" v-on:click="increasePage">+</button>
                                        </div>
                                    </div>
                                    <h5 class="margin_top_1">Items por pgina</h5>
                                    <div class="flex_row">
                                        <div class="flex_1 pad_right_1">
                                            <button class="" v-on:click="decreaseItemsPerPage">-</button>
                                        </div>
                                        <div class="flex_100">
                                            <input spellcheck="false"
                                                class="width_100 text_align_center"
                                                type="number"
                                                v-model="itemsPerPageOnForm"
                                                v-on:keypress.enter="digestOutput"
                                                :placeholder="placeholderForPaginador" />
                                        </div>
                                        <div class="flex_1 pad_left_1">
                                            <button class="" v-on:click="increaseItemsPerPage">+</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="pad_bottom_0" v-if="isShowingSubpanel === 'Todo'">
                                    <button class="width_100" v-on:click="digestOutput"></button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="paginator_widget this_code_is_duplicated_always">
        <div>
            <div>
                <div class="flex_row centered">
                    <div class="flex_1 pagination_button_box first_box">
                        <div class="pagination_button first_button"
                            v-on:click="goToFirstPage"
                            v-if="currentPage !== 0"></div>
                        <div class="pagination_button cursor_default"
                            v-else></div>
                    </div>
                    <div class="flex_1 pagination_button_box">
                        <div class="pagination_button"
                            v-on:click="decreasePage"
                            v-if="currentPage !== 0"></div>
                        <div class="pagination_button cursor_default"
                            v-else></div>
                    </div>
                    <div class="flex_100 text_align_center">Pg. {{ currentPage+1 }}/{{ totalOfPages }} - mx: {{ itemsPerPage }}</div>
                    <div class="flex_1 pagination_button_box">
                        <div class="pagination_button"
                            v-on:click="increasePage"
                            v-if="(currentPage+1) !== totalOfPages"></div>
                        <div class="pagination_button cursor_default"
                            v-else></div>
                    </div>
                    <div class="flex_1 pagination_button_box last_box">
                        <div class="pagination_button last_button"
                            v-on:click="goToLastPage"
                            v-if="(currentPage+1) !== totalOfPages"></div>
                        <div class="pagination_button cursor_default"
                            v-else></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="lsw_table_viewer">
        <table class="collapsed_table lsw_table_itself translucid_background">
            <thead v-if="paginatedOutput && headers">
                <tr class="">
                    <!--Id cell:-->
                    <th>n</th>
                    <!--Selectable buttons headers:-->
                    <th v-if="selectable === 'one'"></th>
                    <th v-else-if="selectable === 'many'"></th>
                    <!--Row buttons headers:-->
                    <th class="button_header"
                        v-for="attachedHeader, attachedHeaderIndex in attachedHeaders"
                        v-bind:key="'attached-header-' + attachedHeaderIndex">{{ attachedHeader.text }}</th>
                    <!--Object properties headers:-->
                    <th v-for="header, headerIndex in headers"
                        v-bind:key="'header-' + headerIndex">{{ header }}</th>
                    <th>*size</th>
                </tr>
            </thead>
            <template v-if="paginatedOutput && headers">
                <tbody v-if="!paginatedOutput.length">
                    <tr>
                        <td colspan="1000"
                            v-descriptor="'lsw_table.no_data_provided_message'">
                            No data provided.
                        </td>
                    </tr>
                </tbody>
                <template v-else>
                    <tbody>
                        <template v-for="row, rowIndex in paginatedOutput">
                            <tr class="row_for_table"
                                :class="{ odd: rowIndex === 0 ? true : (rowIndex % 2 === 0) ? true : false }"
                                v-bind:key="'row-for-table-' + rowIndex">
                                <!--Id cell:-->
                                <td class="index_cell">
                                    <button v-on:click="() => toggleRow(row.id)"
                                        class="supermini"
                                        :class="{activated: row.id && selectedRows.indexOf(row.id) !== -1}">
                                        {{ (rowIndex + 1) + (currentPage * itemsPerPage) }}
                                    </button>
                                </td>
                                <!--Selectable cell:-->
                                <td class="index_cell"
                                    v-if="selectable === 'one'">
                                    <span v-on:click="() => toggleChoosenRow(row[choosableId])">
                                        <button class="supermini activated"
                                            v-if="choosenRows === row[choosableId]">
                                            <!--input type="radio" :checked="true" /-->
                                            
                                        </button>
                                        <button class="supermini"
                                            v-else>
                                            
                                            <!--input type="radio" :checked="false" /-->
                                        </button>
                                    </span>
                                </td>
                                <td class="index_cell"
                                    v-else-if="selectable === 'many'">
                                    <label>
                                        <input type="checkbox"
                                            v-model="choosenRows"
                                            :value="row[choosableId]" />
                                    </label>
                                </td>
                                <!--Row buttons cells:-->
                                <td class="button_cell"
                                    v-for="attachedColumn, attachedColumnIndex in attachedColumns"
                                    v-bind:key="'attached-column-' + attachedColumnIndex">
                                    <button class="supermini"
                                        v-on:click="() => rowButtons[attachedColumnIndex].event(row, rowIndex, attachedColumn)">{{
                                        attachedColumn.text }}</button>
                                </td>
                                <!--Object properties cells:-->
                                <td class="data_cell"
                                    v-for="columnKey, columnIndex in headers"
                                    v-bind:key="'column-' + columnIndex"
                                    :title="JSON.stringify(row[columnKey])">
                                    <template v-if="columnsAsList.indexOf(columnKey) !== -1 && Array.isArray(row[columnKey])">
                                        <ul>
                                            <li v-for="item, itemIndex in row[columnKey]"
                                                v-bind:key="'column-' + columnIndex + '-item-' + itemIndex">
                                                {{ itemIndex + 1 }}. {{ item }}
                                            </li>
                                        </ul>
                                    </template>
                                    <template v-else>
                                        {{ row[columnKey] ?? "-" }}
                                    </template>
                                </td>
                                <td class="data_cell metadata_cell">
                                    {{ JSON.stringify(row).length }} bytes
                                </td>
                            </tr>
                            <tr class="row_for_details"
                                v-show="row.id && selectedRows.indexOf(row.id) !== -1"
                                v-bind:key="'row-for-cell-' + rowIndex">
                                <td class="data_cell details_cell"
                                    colspan="1000">
                                    <pre class="">{{ JSON.stringify(row, null, 2) }}</pre>
                                </td>
                            </tr>
                        </template>
                    </tbody>
                </template>
            </template>
            <tbody v-else>
                <tr>
                    <td colspan="1000">
                        Un momento, por favor, la tabla est cargando...
                    </td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="paginator_widget this_code_is_duplicated_always">
        <div>
            <div>
                <div class="flex_row centered">
                    <div class="flex_1 pagination_button_box first_box">
                        <div class="pagination_button first_button"
                            v-on:click="goToFirstPage"
                            v-if="currentPage !== 0"></div>
                        <div class="pagination_button cursor_default"
                            v-else></div>
                    </div>
                    <div class="flex_1 pagination_button_box">
                        <div class="pagination_button"
                            v-on:click="decreasePage"
                            v-if="currentPage !== 0"></div>
                        <div class="pagination_button cursor_default"
                            v-else></div>
                    </div>
                    <div class="flex_100 text_align_center">Pg. {{ currentPage+1 }}/{{ totalOfPages }} - mx: {{ itemsPerPage }}</div>
                    <div class="flex_1 pagination_button_box">
                        <div class="pagination_button"
                            v-on:click="increasePage"
                            v-if="(currentPage+1) !== totalOfPages"></div>
                        <div class="pagination_button cursor_default"
                            v-else></div>
                    </div>
                    <div class="flex_1 pagination_button_box last_box">
                        <div class="pagination_button last_button"
                            v-on:click="goToLastPage"
                            v-if="(currentPage+1) !== totalOfPages"></div>
                        <div class="pagination_button cursor_default"
                            v-else></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>`,
  props: {
    initialInput: {
      type: Array,
      default: () => []
    },
    initialSettings: {
      type: Object,
      default: () => ({})
    },
    rowButtons: {
      type: Array,
      default: () => []
    },
    tableButtons: {
      type: Array,
      default: () => []
    },
    selectable: {
      type: String,
      default: () => "none"
    },
    onChooseRow: {
      type: Function,
      default: () => {}
    },
    choosableId: {
      type: String,
      default: () => "id"
    },
    initialChoosenValue: {
      type: [],
      default: () => []
    },
    storageId: {
      type: [String, Boolean],
      default: () => false
    },
    storageStrategy: {
      type: String,
      default: () => "ufs/lsw", // No otras de momento.
    }
  },
  data() {
    this.$trace("lsw-table.data");
    const input = [].concat(this.initialInput);
    return {
      input,
      title: this.initialSettings?.title || "",
      isShowingMenu: this.initialSettings?.isShowingMenu || false,
      isShowingSubpanel: this.initialSettings?.isShowingSubpanel || "Todo", // "Buscador", ...
      selectedRows: [],
      choosenRows: this.initialChoosenValue || [],
      searcher: this.initialSettings?.searcher || "",
      extender: this.initialSettings?.extender || "",
      filter: this.initialSettings?.filter || "",
      sorter: this.initialSettings?.sorter || "",
      itemsPerPageOnForm: this.initialSettings?.itemsPerPage || 10,
      itemsPerPage: this.initialSettings?.itemsPerPage || 10,
      currentPage: this.initialSettings?.currentPage || 0,
      currentPageOnForm: (this.initialSettings?.currentPage+1) || 1,
      columnsAsList: this.initialSettings?.columnsAsList || [],
      columnsOrder: this.initialSettings?.columnsOrder || [],
      columnsOrderInput: (this.initialSettings?.columnsOrder || []).join(", "),
      output: [],
      paginatedOutput: [],
      headers: [],
      attachedHeaders: this._adaptRowButtonsToHeaders(this.rowButtons),
      attachedColumns: this._adaptRowButtonsToColumns(this.rowButtons),
      attachedTopButtons: this._adaptRowButtonsToColumns(this.tableButtons),
      placeholderForExtensor: "data.map(function(it, i) {\n  return Object.assign({}, it, /* you start here */ || {});\n});",
      placeholderForOrdenador: "data.sort(function(a, b) {\n  return /* you start here */;\n});",
      placeholderForFiltro: "data.filter(function(it, i) {\n  return /* you start here */;\n});",
      placeholderForBuscador: "Bsqueda de texto rpida",
      placeholderForPaginador: "tems por pgina. Por defecto: 10"
    };
  },
  methods: {
    goToFirstPage() {
      this.$trace("lsw-table.methods.goToFirstPage");
      this.currentPage = 0;
    },
    decreasePage() {
      this.$trace("lsw-table.methods.decreasePage");
      if (this.currentPage > 0) {
        this.currentPage--;
      }
    },
    increasePage() {
      this.$trace("lsw-table.methods.increasePage");
      const lastPage = Math.floor(this.output.length / this.itemsPerPage);
      if (this.currentPage < lastPage) {
        this.currentPage++;
      }
    },
    goToLastPage() {
      this.$trace("lsw-table.methods.goToLastPage");
      const lastPage = Math.floor(this.output.length / this.itemsPerPage);
      if (this.currentPage !== lastPage) {
        this.currentPage = lastPage;
      }
    },
    toggleChoosenRow(rowId) {
      this.$trace("lsw-table.methods.toggleChoosenRow");
      if(this.selectable === 'many') {
        const pos = this.choosenRows.indexOf(rowId);
        if (pos === -1) {
          this.choosenRows.push(rowId);
        } else {
          this.choosenRows.splice(pos, 1);
        }
      } else if(this.selectable === 'one') {
        const isSame = this.choosenRows === rowId;
        if(isSame) {
          this.choosenRows = undefined;
        } else {
          this.choosenRows = rowId;
        }
      }
    },
    toggleRow(rowIndex) {
      this.$trace("lsw-table.methods.toggleRow");
      if(typeof rowIndex === "undefined") {
        return this.$lsw.toasts.send({
          title: "La row no se desplegar",
          text: "Aade id para que se puedan seleccionar las rows"
        })
      }
      const pos = this.selectedRows.indexOf(rowIndex);
      if (pos === -1) {
        this.selectedRows.push(rowIndex);
      } else {
        this.selectedRows.splice(pos, 1);
      }
    },
    toggleMenu() {
      this.$trace("lsw-table.methods.toggleMenu");
      this.isShowingMenu = !this.isShowingMenu;
    },
    digestOutput() {
      this.$trace("lsw-table.methods.digestOutput");
      const input = this.input;
      let temp = [];
      const extenderExpression = this.extender.trim() || "{}";
      const extenderFunction = new Function("it", "i", `return ${extenderExpression}`);
      const filterExpression = this.filter.trim() || "true";
      const filterFunction = new Function("it", "i", `return ${filterExpression}`);
      const sorterExpression = this.sorter.trim() || "0";
      const sorterFunction = new Function("a", "b", `return ${sorterExpression}`);
      let tempHeaders = new Set();
      Iterating_rows:
      for (let index = 0; index < input.length; index++) {
        const row = input[index];
        let extendedRow = undefined;
        Apply_extender: {
          try {
            const extenderProduct = extenderFunction(row, index) || {};
            extendedRow = Object.assign({}, row, extenderProduct);
          } catch (error) {
            extendedRow = Object.assign({}, row);
          }
        }
        let isValidFinally = true;
        Apply_searcher: {
          if(this.searcher.trim() !== "") {
            const hasMatch = JSON.stringify(extendedRow).toLowerCase().indexOf(this.searcher.toLowerCase()) !== -1;
            if(!hasMatch) {
              isValidFinally = isValidFinally && false;
            }
          }
        }
        Apply_filter: {
          try {
            const filterProduct = filterFunction(extendedRow, index);
            if (filterProduct !== true) {
              isValidFinally = isValidFinally && false;
            }
          } catch (error) {
            // @OK.
          }
        }
        Extract_row: {
          if(isValidFinally) {
            temp.push(extendedRow);
          }
        }
        Extract_headers: {
          try {
            Object.keys(extendedRow).forEach(key => {
              tempHeaders.add(key);
            });
          } catch (error) {
            // @OK.
          }
        }
      }
      Apply_sorter: {
        try {
          temp = temp.sort(sorterFunction);
        } catch (error) {
          // @OK.
        }
        Also_to_headers: {
          if(Array.isArray(this.columnsOrder) && this.columnsOrder.length) {
            tempHeaders = [...tempHeaders].sort((h1, h2) => {
              const pos1 = this.columnsOrder.indexOf(h1);
              const pos2 = this.columnsOrder.indexOf(h2);
              if(pos1 === -1 && pos2 === -1) {
                return -1;
              } else if(pos1 === -1) {
                return 1;
              } else if(pos2 === -1) {
                return -1;
              } else if(pos1 > pos2) {
                return 1;
              }
              return -1;
            });
          }
        }
      }
      this.headers = tempHeaders;
      this.output = temp;
      this.digestPagination();
    },
    digestPagination() {
      this.$trace("lsw-table.methods.digestPagination");
      const page = this.currentPageOnForm - 1;
      Inject_form_state_of_items_per_page_here: {
        this.itemsPerPage = this.itemsPerPageOnForm;
      }
      const items = this.itemsPerPage;
      const firstPosition = items * (page);
      this.selectedRows = [];
      this.paginatedOutput = [].concat(this.output).splice(firstPosition, items);
    },
    saveCurrentTransformer() {
      this.$trace("lsw-table.methods.saveCurrentTransformer");
    },
    _adaptRowButtonsToHeaders(rowButtons) {
      const attachedHeaders = [];
      for(let index=0; index<rowButtons.length; index++) {
        const attachedButton = rowButtons[index];
        attachedHeaders.push({
          text: attachedButton.header || ""
        });
      }
      return attachedHeaders;
    },
    _adaptRowButtonsToColumns(rowButtons) {
      const attachedColumns = [];
      for(let index=0; index<rowButtons.length; index++) {
        const attachedButton = rowButtons[index];
        attachedColumns.push({
          text: attachedButton.text || "",
          event: attachedButton.event || this.$noop,
        });
      }
      return attachedColumns;
    },
    updateColumnsOrderFromInput() {
      this.$trace("lsw-table.methods.updateColumnsOrderFromInput");
      this.columnsOrder = this.columnsOrderInput.split(",").map(it => it.trim());
      this.digestOutput();
    },
    increaseItemsPerPage() {
      this.$trace("lsw-table.methods.increaseItemsPerPage");
      this.itemsPerPageOnForm++;
    },
    decreaseItemsPerPage() {
      this.$trace("lsw-table.methods.decreaseItemsPerPage");
      this.itemsPerPageOnForm--;
    },
    getStoragePathFor(id) {
      this.$trace("lsw-table.methods.getStoragePathFor");
      return this.$lsw.fs.resolve_path("/kernel/settings/table/storage/", id);
    },
    async loadState() {
      this.$trace("lsw-table.methods.loadState");
      Check_strategy_and_validation: {
        if(this.storageStrategy !== "ufs/lsw") {
          console.log(`[*] Could not load state on lsw-table because of: UnknownStorageStrategy (=${this.storageStrategy})`);
          return -1;
        }
        if(!this.storageId) {
          // console.log(`[*] Could not load state on lsw-table because of: NoStorageId (=${this.storageId})`);
          return -2;
        }
      }
      const storagePath = this.getStoragePathFor(this.storageId);
      const storageJson = await (() => {
        try {
          return this.$lsw.fs.read_file(storagePath);
        } catch (error) {
          console.log(`[*] Could not load state on lsw-table because of: BadStoragePath (=${this.storagePath})`);
          return undefined;
        }
      })();
      if(typeof storageJson !== "string") {
        console.log(`[*] Could not load state on lsw-table because of: JsonStorageNotString (=${typeof storageJson})`);
        return -3;
      }
      let storageData = undefined;
      try {
        storageData = JSON.parse(storageJson);
      } catch (error) {
        console.log(`[*] Could not load state on lsw-table because of: JsonStorageNotParseable (${error.name}=${error.message})`);
        return -4;
      }
      Cargar_estado: {
        if(typeof storageData !== "object") {
          console.log(`[*] Could not load state on lsw-table because of: StorageDataNotObject (${typeof storageData})`);
          return -5;
        }
        console.log("[*] Loading lsw-table state from: ", storageData);
        Object.assign(this, storageData);
      }
    },
    saveState() {
      this.$trace("lsw-table.methods.saveState");
      Check_strategy_and_validation: {
        if(this.storageStrategy !== "ufs/lsw") {
          console.log(`[*] Could not save state on lsw-table because of: UnknownStorageStrategy (=${this.storageStrategy})`);
          return -1;
        }
        if(!this.storageId) {
          // console.log(`[*] Could not save state on lsw-table because of: NoStorageId (=${this.storageId})`);
          return -2;
        }
      }
      const storagePath = this.getStoragePathFor(this.storageId);
      const storageState = this.extractState();
      const storageJson = JSON.stringify(storageState, null, 2);
      Guardar_estado: {
        console.log("[*] Saving lsw-table state as: ", storageState);
        this.$lsw.fs.write_file(storagePath, storageJson);
        this.$lsw.toasts.send({
          title: "Estado de tabla guardado",
          text: "Con identificador: " + this.storageId,
        });
      }
      return true;
    },
    extractState() {
      this.$trace("lsw-table.methods.extractState");
      return LswUtils.extractPropertiesFrom(this, [
        // "input",
        "title",
        "isShowingMenu",
        "isShowingSubpanel",
        "selectedRows",
        "choosenRows",
        "searcher",
        "extender",
        "filter",
        "sorter",
        "itemsPerPageOnForm",
        "itemsPerPage",
        "currentPage",
        "currentPageOnForm",
        "columnsAsList",
        "columnsOrder",
        "columnsOrderInput",
        // "output",
        // "paginatedOutput",
        "headers",
        // "attachedHeaders",
        // "attachedColumns",
        // "attachedTopButtons",
        // "placeholderForExtensor",
        // "placeholderForOrdenador",
        // "placeholderForFiltro",
        // "placeholderForBuscador",
        // "placeholderForPaginador",
      ], [
        "input",
        "output",
        "paginatedOutput",
        "attachedHeaders",
        "attachedColumns",
        "attachedTopButtons",
        "placeholderForExtensor",
        "placeholderForOrdenador",
        "placeholderForFiltro",
        "placeholderForBuscador",
        "placeholderForPaginador",
      ], {
        isShowingMenu: false,
        isShowingSubpanel: "Todo",
      });
    },
  },
  watch: {
    itemsPerPage(value) {
      this.$trace("lsw-table.watch.itemsPerPage");
      /// this.digestPagination();
    },
    currentPage(value) {
      this.$trace("lsw-table.watch.currentPage");
      this.currentPageOnForm = value + 1;
      this.digestPagination();
    },
    choosenRows(v) {
      this.$trace("lsw-table.watch.value");
      this.onChooseRow(v, this);
    }
  },
  computed: {
    hasFiltersApplying() {
      // @BUGGY: estos logs causan recursividad en el console-hooker
      // this.$trace("lsw-table.computed.hasFiltersApplying");
      if (this.extender.length) {
        return true;
      }
      if (this.filter.length) {
        return true;
      }
      if (this.sorter.length) {
        return true;
      };
      if (this.searcher.length) {
        return true;
      }
      if (this.currentPage !== 0) {
        return true;
      }
      if ((this.currentPage+1) !== this.currentPageOnForm) {
        return true;
      }
      if (this.itemsPerPage < 10) {
        return true;
      }
      if (this.itemsPerPageOnForm !== this.itemsPerPage) {
        return true;
      }
      if(this.columnsOrderInput !== "id") {
        return true;
      }
      if(this.columnsOrder.length !== 1) {
        return true;
      }
      return false;
    },
    totalOfPages() {
      // @BUGGY: estos logs causan recursividad en el console-hooker
      // this.$trace("lsw-table.computed.totalOfPages");
      return Math.ceil(this.output.length / this.itemsPerPage) || 1;
    },
    currentLastPage() {
      this.$trace("lsw-table.computed.currentLastPage");
      return Math.floor(this.output.length / this.itemsPerPage) || 1;
    }
  },
  mounted() {
    this.$trace("lsw-table.mounted");
    this.loadState();
    this.digestOutput();
  }
});
// @code.end: LswTable API

// @vuebundler[Lsw_framework_components][64]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-table/lsw-table/lsw-table.css

// @vuebundler[Lsw_framework_components][65]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-table/lsw-table-transformers/lsw-table-transformers.html

// @vuebundler[Lsw_framework_components][65]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-table/lsw-table-transformers/lsw-table-transformers.js
Vue.component("LswTableTransformers", {
  template: `<div class="lsw_table_transformers">
    Transformers here.
    {{ table.transformers }}
    <div class="flex_row">
        <button class="button_separation" v-on:click="table.showTransformers">All: {{ table.transformers.length }}</button>
        <button class="button_separation" v-on:click="table.askForFilter">+Filter</button>
        <button class="button_separation" v-on:click="table.askForMapper">+Mapper</button>
        <button class="button_separation" v-on:click="table.askForReducer">+Reducer</button>
        <button class="button_separation" v-on:click="table.askForSorter">+Sorter</button>
        <button class="button_separation" v-on:click="table.askForGrouper">+Grouper</button>
        <div style="flex: 100;"></div>
    </div>
</div>`,
  props: {
    table: {
      type: Object,
      required: true
    }
  },
  data() {
    return {

    };
  },
  methods: {

  },
  watch: {

  },
  mounted() {

  }
});

// @vuebundler[Lsw_framework_components][65]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-table/lsw-table-transformers/lsw-table-transformers.css

// @vuebundler[Lsw_framework_components][66]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-code-viewer/lsw-code-viewer.html

// @vuebundler[Lsw_framework_components][66]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-code-viewer/lsw-code-viewer.js
// @code.start: LswCodeViewer API | @$section: Vue.js (v2) Components  Lsw Windows API  LswCodeViewer component
Vue.component("LswCodeViewer", {
  template: `<div class="lsw_code_viewer">
    <div class="flex_row">
        <div class="flex_100"></div>
        <div class="flex_1">
            <button class="supermini" v-on:click="() => increaseFontsize(-1)"></button>
        </div>
        <div class="flex_1 pad_left_1">
            <button class="supermini" v-on:click="() => increaseFontsize(1)"></button>
        </div>
    </div>
    <pre class="lsw_code_viewer_area"><code :style="'font-size: ' + fontsize + 'px;'" :class="'language-' + language">{{ code }}</code></pre>
</div>`,
  props: {
    code: {
      type: String,
      required: () => true,
    },
    language: {
      type: String,
      required: () => true,
    },
  },
  data() {
    this.$trace("lsw-code-viewer.data");
    return {
      isLoaded: false,
      fontsize: 10,
    };
  },
  methods: {
    increaseFontsize(q = 1) {
      this.$trace("lsw-code-viewer.methods.increaseFontsize");
      this.fontsize += q;
    },
    async loadHighlightJs(event) {
      this.$trace("lsw-code-viewer.methods.loadHighlightJs");
      await LswLazyLoads.loadHighlightJs();
      this.isLoaded = true;
    },
  },
  mounted() {
    this.$trace("lsw-code-viewer.mounter");
    this.loadHighlightJs();
  },
  unmount() {
    this.$trace("lsw-code-viewer.mounter");
  }
});
// @code.end: LswCodeViewer API

// @vuebundler[Lsw_framework_components][66]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-code-viewer/lsw-code-viewer.css

// @vuebundler[Lsw_framework_components][67]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-explorer/lsw-data-explorer/lsw-data-explorer.html

// @vuebundler[Lsw_framework_components][67]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-explorer/lsw-data-explorer/lsw-data-explorer.js
// @code.start: LswDataExplorer API | @$section: Vue.js (v2) Components  LswDataExplorer API  LswDataExplorer API
Vue.component('LswDataExplorer', {
  template: `<div class="data-explorer">
    <div class="top_panel flex_row centered" style="padding: 1px;">
        <div class="top_button_cell" v-on:click="toggleTopPanel">
            <button v-if="!isShowingTopPanel"></button>
            <button v-else></button>
        </div>
        <div class="top_button_cell" style="padding-left: 1px;">
            <button v-on:click="applyFastFilter">
                <span v-if="isLoadingInnerValue"></span>
                <span v-else></span>
            </button>
        </div>
        <div class="top_search_bar_cell flex_cell expanded" style="padding-left: 1px; padding-right: 1px;">
            <input type="text" class="width_100" v-model="textFilter" v-keydown.enter="applyFastFilter" />
        </div>
    </div>
    <div class="top_panel_showable" v-if="isShowingTopPanel">
        <div class="content">
            <div class="flex_row centered">
                <div style="padding-right: 1px;">
                    <button v-on:click="saveRelatedDocument"></button>
                </div>
                <div style="padding-right: 1px;">
                    <button v-on:click="toggleRelatedDocuments">
                        <span v-if="isShowingRelatedDocuments"></span>
                        <span v-else></span>
                    </button>
                </div>
                <input v-if="!isShowingRelatedDocuments" class="width_100" type="text" placeholder="Document title here" v-model="documentTitle" />
                <div v-else class="width_100">Related documents: </div>
                <div style="padding-left: 1px;">
                    <button v-on:click="toggleTopPanel"></button>
                </div>
            </div>
            <div v-if="isShowingRelatedDocuments" style="padding-top: 1px;">
                <div v-for="doc, docIndex in relatedDocuments">
                    <button v-on:click="() => openDocument(docIndex)">{{ doc.title }}</button>
                </div>
            </div>
            <div class="width_100" v-show="!isShowingRelatedDocuments">
                <textarea v-model="documentContent" placeholder="// Document content here" />
            </div>
        </div>
    </div>
    <template v-if="hasLoadedInnerValue">
        <LswDataImplorer :value="innerValue" v-bind:key="'data-implorer-' + getRandomId()" />
    </template>
</div>`,
  props: {
    value: {
      required: true
    },
    pageSize: {
      type: Number,
      default: 10
    },
    level: {
      type: Number,
      default: 0
    },
    pointer: {
      type: Array,
      default: () => []
    }
  },
  data() {
    return {
      hasLoadedInnerValue: true,
      isLoadingInnerValue: false,
      originalValue: this.value,
      innerValue: this.value,
      textFilter: "",
      isShowingTopPanel: false,
      isShowingRelatedDocuments: false,
      documentTitle: "",
      documentContent: "",
      expanded: {},
      relatedDocuments: [{
        title: "Document 1",
        text: "console.log('hi!');",
      }],
      propagateFastFilterTimeoutId: undefined,
      propagateFastFilterTimeoutMs: 1500
    };
  },
  methods: {
    getRandomId() {
      return this.$lsw.toasts.getRandomString();
    },
    toggleTopPanel() {
      this.isShowingTopPanel = !this.isShowingTopPanel;
    },
    toggleExpand(key) {
      this.$set(this.expanded, key, !this.expanded[key]);
    },
    toggleRelatedDocuments() {
      this.isShowingRelatedDocuments = !this.isShowingRelatedDocuments;
    },
    openDocument(docIndex) {
      // *@TODO:
      const doc = this.relatedDocuments[docIndex];
      this.documentTitle = doc.title;
      this.documentContent = doc.text;
      this.isShowingRelatedDocuments = false;
    },
    saveRelatedDocument() {

    },
    async applyFastFilter(textFilter = this.textFilter) {
      // *@TODO:
      try {
        this.hasLoadedInnerValue = false;
        this.$forceUpdate(true);
        if(textFilter.trim() === "") {
          this.innerValue = this.originalValue;
          return;
        }
        const textFilterFunction = new Function("it,key,i", "try {\n  return " + textFilter + ";\n} catch(e) {\n  return false;\n}");
        console.log("User-built filter function:");
        console.log(textFilterFunction.toString());
        if(typeof this.originalValue !== "object") {
          this.innerValue = this.originalValue;
          return;
        } else if(Array.isArray(this.originalValue)) {
          this.innerValue = [].concat(this.originalValue).filter(textFilterFunction);
        } else {
          Object.keys(this.originalValue).reduce((out, key, i) => {
            const value = this.originalValue[key];
            const passesFilter = textFilterFunction(value, key, i);
            if(passesFilter) {
              out[key] = value;
            }
            return out;
          }, {});
          this.innerValue = out;
        }
      } catch (error) {
        console.log(error);
      } finally {
        this.isLoadingInnerValue = false;
        this.hasLoadedInnerValue = true;
        this.$forceUpdate(true);
      }
    },
    propagateFastFilter(textFilter = this.textFilter) {
      this.isLoadingInnerValue = true;
      clearTimeout(this.propagateFastFilterTimeoutId);
      this.propagateFastFilterTimeoutId = setTimeout(() => {
        this.applyFastFilter(textFilter);
      }, this.propagateFastFilterTimeoutMs);
    }
  },
  watch: {
    textFilter(newValue) {
      this.propagateFastFilter(newValue);
    }
  }
});
// @code.end: LswDataExplorer API

// @vuebundler[Lsw_framework_components][67]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-explorer/lsw-data-explorer/lsw-data-explorer.css

// @vuebundler[Lsw_framework_components][68]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-explorer/lsw-data-implorer/lsw-data-implorer.html

// @vuebundler[Lsw_framework_components][68]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-explorer/lsw-data-implorer/lsw-data-implorer.js
// @code.start: LswDataImplorer API | @$section: Vue.js (v2) Components  LswDataImplorer API  LswDataImplorer API
Vue.component('LswDataImplorer', {
  template: `<div class="lsw_data_implorer" :class="{ paginated: isPaginated || isRoot }">
    <div class="paginator flex_row centered" v-if="isPaginated" style="padding-left: 1px; padding-top: 1px;">
        <div>
            <button v-on:click="goToPage(1)"></button>
        </div>
        <div>
            <button v-on:click="goToPreviousPage()"></button>
        </div>
        <div>
            <button v-on:click="goToNextPage()"></button>
        </div>
        <div>
            <button v-on:click="goToLastPage()"></button>
        </div>
        <div style=" font-size: 10px;">
            Page {{ currentPage }} out of {{ Math.ceil(entries.length / pageSize) }} in packs of {{ pageSize }}
        </div>
    </div>
    <div class="paginated_entry"
        v-for="(entry, index) in paginatedEntries"
        :key="index">
        <div class="entry flex_row">
            <button
                v-if="typeof entry.value === 'object' && entry.value !== null"
                style="margin: 1px; min-width: 20px;"
                @click="toggleExpand(entry.key)">
                {{ expanded[entry.key] ? '' : '' }}
            </button>
            <button
                v-else
                style="margin: 1px; min-width: 20px; background-color: transparent; color: black; border: 1px solid transparent; cursor: default;">
                
            </button>
            <div class="prop_row">
                <span class="level_cell"
                    :title="'value[' + pointer.concat([entry.key]).map(v => JSON.stringify(v)).join('][') + ']'">L{{ level + 1 }} 
                </span><span class="prop_cell">
                    <span class="prop_id">{{ entry.key }}</span>
                    <span class="prop_type">[{{ typeof entry.value }}]</span>
                </span>
            </div>
            <div class="val_cell"
                v-if="typeof entry.value !== 'object' || entry.value === null"> = {{ entry.value }}</div>
        </div>
        <div class="inner_sight_row" v-if="expanded[entry.key]">
            <div class="path_row flex_row">
                <span class="type_cell">{{ typeof entry.value }}  </span>
                <span class="path_cell_container">
                    <span class="path_cell">{{
                        ["#"].concat(pointer).concat([entry.key]).reverse().join('  ') }}
                    </span>
                </span>
            </div>
            <LswDataImplorer :value="entry.value"
                :pageSize="pageSize"
                :level="level + 1"
                :pointer="pointer.concat([entry.key])" />
        </div>
    </div>
</div>`,
  props: {
    value: {
      required: true
    },
    pageSize: {
      type: Number,
      default: () => 10
    },
    level: {
      type: Number,
      default: () => 0
    },
    pointer: {
      type: Array,
      default: () => []
    }
  },
  data() {
    return {
      expanded: {},
      isRoot: this.pointer.length === 0,
      currentPageSize: this.pageSize,
      currentPage: 1,
      page: {},
      entries: [],
      paginatedEntries: [],
      isPaginated: false,
    };
  },
  methods: {
    loadEntries() {
      if (typeof this.value !== 'object' || this.value === null) {
        return [{ key: 'value', value: this.value }];
      }
      this.entries = Object.entries(this.value).map(([key, value]) => ({ key, value }));
    },
    toggleExpand(key) {
      this.$set(this.expanded, key, !this.expanded[key]);
    },
    goToPage(page) {
      this.currentPage = page;
      this.loadPaginatedEntries();
    },
    goToPreviousPage() {
      if(this.currentPage <= 1) {
        return;
      }
      this.currentPage--;
      this.loadPaginatedEntries();
    },
    goToNextPage() {
      if(this.currentPage >= Math.ceil(this.entries.length / this.pageSize)) {
        return;
      }
      this.currentPage++;
      this.loadPaginatedEntries();
    },
    goToLastPage() {
      this.currentPage = Math.ceil(this.entries.length / this.pageSize);
      this.loadPaginatedEntries();
    },
    paginateArray(array, pageSize = this.currentPageSize, currentPage = this.currentPage) {
      const start = (currentPage - 1) * pageSize;
      const end = start + pageSize;
      return array.slice(start, end);
    },
    loadPaginatedEntries(entries = this.entries) {
      this.paginatedEntries = this.paginateArray(entries);
      this.isPaginated = this.paginatedEntries.length !== this.entries.length;
    },
  },
  watch: {
    entries(newValue) {
      if(this.pageSize <= 0) {
        return newValue;
      }
      this.loadPaginatedEntries(newValue);
    }
  },
  mounted() {
    this.loadEntries();
  }
});
// @code.end: LswDataImplorer API

// @vuebundler[Lsw_framework_components][68]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-explorer/lsw-data-implorer/lsw-data-implorer.css

// @vuebundler[Lsw_framework_components][69]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-printer-button/lsw-data-printer-button.html

// @vuebundler[Lsw_framework_components][69]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-printer-button/lsw-data-printer-button.js
// @code.start: LswDataPrinterButton API | @$section: Vue.js (v2) Components  LswDataPrinterButton component
Vue.component("LswDataPrinterButton", {
  template: `<button class="lsw_data_printer_button" v-on:click="openViewer">
    
</button>`,
  props: {
    input: {
      type: [Object, String, Boolean, Number, Function],
      default: () => false,
    },
  },
  data() {
    this.$trace("lsw-data-printer-button.data");
    return {
      inputType: typeof(this.input),
      formatType: undefined,
    };
  },
  methods: {
    async openViewer() {
      this.$trace("lsw-data-printer-button.methods.openViewer");
      let input = this.input;
      if(this.inputType === "function") {
        input = await this.input();
      }
      this.formatType = typeof input;
      this.$lsw.dialogs.open({
        title: "Impresin de " + this.formatType + "",
        template: `
          <lsw-data-printer-report :input="input" />
        `,
        factory: { data: { input } },
      });
    }
  },
  watch: {},
  mounted() {
    this.$trace("lsw-data-printer-button.mounted");
    
  },
  unmounted() {
    this.$trace("lsw-data-printer-button.unmounted");
    
  }
});
// @code.end: LswDataPrinterButton API

// @vuebundler[Lsw_framework_components][69]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-printer-button/lsw-data-printer-button.css

// @vuebundler[Lsw_framework_components][70]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-printer-report/lsw-data-printer-report.html

// @vuebundler[Lsw_framework_components][70]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-printer-report/lsw-data-printer-report.js
// @code.start: LswDataPrinterReport API | @$section: Vue.js (v2) Components  LswDataPrinterReport component
Vue.component("LswDataPrinterReport", {
  template: `<div class="lsw_data_printer_report">
    <div class="pad_2">
        <h4>Reporte de impresin</h4>
    </div>
    <div class="flex_row centered  pad_1 pad_top_0">
        <div class="flex_1">Versin: </div>
        <select class="flex_100 width_100" v-model="selectedSection">
            <option v-for="val, valIndex in availableOptions" :value="val">{{ val }}</option>
        </select>
    </div>
    <div class="seccion pad_1 pad_top_0" v-if="selectedSection === 'Crudo'" v-bind:key="'section_Crudo'">
        <div class="pad_1 flex_row centered">
            <div class="flex_100">
                <h5>Versin cruda</h5>
            </div>
            <div class="flex_1">
                <button class="supermini" v-on:click="copyCrude">Copiar</button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="downloadCrude">Descargar</button>
            </div>
        </div>
        <div class="pad_1">
            <pre class="texto_markdown light_bg small_font">{{ input }}</pre>
        </div>
    </div>
    <div class="seccion pad_1 pad_top_0" v-else-if="selectedSection === 'Natural'" v-bind:key="'section_Natural'">
        <div class="pad_1 flex_row centered">
            <div class="flex_100">
                <h5>Versin natural</h5>
            </div>
            <div class="flex_1">
                <button class="supermini" v-on:click="copyNatural">Copiar</button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="downloadNatural">Descargar</button>
            </div>
        </div>
        <div class="pad_1">
            <pre class="texto_markdown light_bg small_font">{{ inputNatural }}</pre>
        </div>
    </div>
    <div class="seccion pad_1 pad_top_0" v-else-if="selectedSection === 'Markdown'" v-bind:key="'section_Markdown'">
        <div class="pad_1 flex_row centered">
            <div class="flex_100">
                <h5>Versin markdown (interpretado como)</h5>
            </div>
            <div class="flex_1">
                <button class="supermini" v-on:click="copyMarkdown">Copiar</button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="downloadMarkdown">Descargar</button>
            </div>
        </div>
        <div class="pad_1">
            <div class="texto_markdown light_bg small_font" v-html="inputMarkdown"></div>
        </div>
    </div>
    <div class="seccion pad_1 pad_top_0" v-else-if="selectedSection === 'Solo texto plano'" v-bind:key="'section_Solo_texto_plano'">
        <div class="pad_1 flex_row centered">
            <div class="flex_100">
                <h5>Versin texto plano (solo texto)</h5>
            </div>
            <div class="flex_1">
                <button class="supermini" v-on:click="copyPlain">Copiar</button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="downloadPlain">Descargar</button>
            </div>
        </div>
        <div class="pad_1">
            <pre class="texto_markdown light_bg small_font">{{ inputPlain }}</pre>
        </div>
    </div>
</div>`,
  props: {
    input: {
      type: [Object, String, Boolean, Number],
      default: () => false,
    },
  },
  data() {
    this.$trace("lsw-data-printer-report.data");
    const inputType = typeof(this.input);
    const availableOptions = (() => {
      switch(inputType) {
        case "string":
          return ["Crudo", "Markdown", "Solo texto plano"];
        default:
          return ["Crudo", "Natural"];
      }
    })();
    return {
      availableOptions,
      selectedSection: "Crudo",
      inputType,
    };
  },
  methods: {
    copyCrude() {
      this.$trace("lsw-data-printer-report.methods.copyCrude");
      const json = JSON.stringify(this.input, null, 2);
      this.$window.navigator.clipboard.writeText(json);
      this.$lsw.toasts.send({
        title: "Texto copiado correctamente!"
      });
    },
    askForFilename() {
      return this.$lsw.dialogs.open({
        title: "Descargar en fichero",
        template: `
          <div class="pad_1">
            <div>Qu nombre de fichero quieres para la descarga?</div>
            <input class="width_100 margin_top_1" type="text" v-model="value" />
            <hr />
            <div class="flex_row centered pad_1">
              <div class="flex_100"></div>
              <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="accept">Descargar</button>
              </div>
              <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: { data: { value: "" } },
      });
    },
    async downloadCrude() {
      this.$trace("lsw-data-printer-report.methods.downloadCrude");
      const filename = await this.askForFilename();
      if(filename === -1) return;
      LswUtils.downloadFile(filename, JSON.stringify(this.input, null, 2));
    },
    copyNatural() {
      this.$trace("lsw-data-printer-report.methods.copyNatural");
      const text = this.inputNatural;
      this.$window.navigator.clipboard.writeText(text);
      this.$lsw.toasts.send({
        title: "Texto copiado correctamente!"
      });
    },
    async downloadNatural() {
      this.$trace("lsw-data-printer-report.methods.downloadNatural");
      const filename = await this.askForFilename();
      if(filename === -1) return;
      LswUtils.downloadFile(filename, this.inputNatural);
    },
    copyMarkdown() {
      this.$trace("lsw-data-printer-report.methods.copyMarkdown");
      const text = this.inputMarkdown;
      this.$window.navigator.clipboard.writeText(text);
      this.$lsw.toasts.send({
        title: "Texto copiado correctamente!"
      });
    },
    async downloadMarkdown() {
      this.$trace("lsw-data-printer-report.methods.downloadMarkdown");
      const filename = await this.askForFilename();
      if(filename === -1) return;
      LswUtils.downloadFile(filename, this.inputMarkdown);
    },
    copyHtml() {
      this.$trace("lsw-data-printer-report.methods.copyHtml");
      const text = this.inputHtml;
      this.$window.navigator.clipboard.writeText(text);
      this.$lsw.toasts.send({
        title: "Texto copiado correctamente!"
      });
    },
    async downloadHtml() {
      this.$trace("lsw-data-printer-report.methods.downloadHtml");
      return this.$window.alert("Exportacin a HTML no disponible. xD");
      const filename = await this.askForFilename();
    },
    copyPlain() {
      this.$trace("lsw-data-printer-report.methods.copyPlain");
      const text = this.inputPlain;
      this.$window.navigator.clipboard.writeText(text);
      this.$lsw.toasts.send({
        title: "Texto copiado correctamente!"
      });
    },
    async downloadPlain() {
      this.$trace("lsw-data-printer-report.methods.downloadPlain");
      const filename = await this.askForFilename();
      if(filename === -1) return;
      LswUtils.downloadFile(filename, this.inputPlain);
    }
  },
  computed: {
    inputNatural() {
      this.$trace("lsw-data-printer-report.computed.inputNatural");
      return LswUtils.fromJsonToNatural(this.input);
    },
    inputMarkdown() {
      this.$trace("lsw-data-printer-report.computed.inputMarkdown");
      return marked.parse(this.input);
    },
    inputPlain() {
      this.$trace("lsw-data-printer-report.computed.inputPlain");
      return LswDom.extractPlaintextFromHtmltext(this.inputMarkdown);
    }
  },
  watch: {},
  mounted() {
    this.$trace("lsw-data-printer-report.mounted");
    
  },
  unmounted() {
    this.$trace("lsw-data-printer-report.unmounted");
    
  }
});
// @code.end: LswDataPrinterReport API

// @vuebundler[Lsw_framework_components][70]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-printer-report/lsw-data-printer-report.css

// @vuebundler[Lsw_framework_components][71]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-dialogs/lsw-dialogs.html

// @vuebundler[Lsw_framework_components][71]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-dialogs/lsw-dialogs.js
(function () {

  // @code.start: LswDialogs API | @$section: Vue.js (v2) Components  LswDialogs API  LswDialogs classes and functions
  const defaultDialogFactory = () => {
    return {
      props: {},
      data() {
        return {};
      },
      methods: {},
      mounted() { },
    };
  };

  class Dialog {
    static fromIdToComponentName(id) {
      return "lsw-dialog-" + id;
    }
    constructor(info = {}) {
      Object.assign(this, info);
      Validations: {
        if (typeof this.id !== "string") {
          throw new Error(`Required parameter dialog.id to be a string on Dialog.constructor`);
        }
        if (typeof this.name !== "string") {
          throw new Error(`Required parameter dialog.name to be a string on Dialog.constructor`);
        }
        if (typeof this.priority !== "number") {
          throw new Error(`Required parameter dialog.priority to be a number on Dialog.constructor`);
        }
        if (typeof this.component !== "object") {
          throw new Error(`Required parameter dialog.component to be an object on Dialog.constructor`);
        }
        if (typeof this.promiser !== "object") {
          throw new Error(`Required parameter dialog.promiser to be an object on Dialog.constructor`);
        }
        if (!(this.promiser.promise instanceof Promise)) {
          throw new Error(`Required parameter dialog.promiser.promise to be an instance of Promise on Dialog.constructor`);
        }
        if (typeof this.promiser.resolve !== "function") {
          throw new Error(`Required parameter dialog.promiser.resolve to be an function on Dialog.constructor`);
        }
        if (typeof this.promiser.reject !== "function") {
          throw new Error(`Required parameter dialog.promiser.reject to be an function on Dialog.constructor`);
        }
        if (typeof this.acceptButton !== "object") {
          this.acceptButton = false;
        }
        if (typeof this.cancelButton !== "object") {
          this.cancelButton = false;
        }
      }
    }
  }

  const closeSubdialogsHook = function (id, lswDialogs) {
    const ids = Object.keys(lswDialogs.opened);
    for (let index_dialog = 0; index_dialog < ids.length; index_dialog++) {
      const idOpened = ids[index_dialog];
      const idParent = lswDialogs.opened[idOpened].parentId;
      if (idParent === id) {
        lswDialogs.close(idOpened);
      }
    }
  };

  Vue.component("LswDialogs", {
    name: "LswDialogs",
    template: `<div class="lws_dialogs_root">
    <div class="lsw_dialogs"
        v-if="openedLength && notMinimizedLength">
        <div class="lsw_dialogs_box">
            <template v-for="dialog, dialog_index in opened">
                <template v-if="!dialog.minimized">
                    <div class="dialog_window"
                        v-bind:key="'dialog_' + dialog_index"
                        :style="{ zIndex: dialog.priority }">
                        <div class="dialog_topbar">
                            <div class="dialog_title">
                                {{ dialog.title }}
                            </div>
                            <div class="dialog_topbar_buttons">
                                <button
                                    class="mini"
                                    v-if="enabledWindowsSystem"
                                    v-on:click="goHome"></button>
                                <button
                                    class="mini"
                                    v-on:click="minimize(dialog.id)"></button>
                                <button
                                    class="mini"
                                    v-on:click="close(dialog.id)"></button>
                            </div>
                        </div>
                        <div class="dialog_body">
                            <component :is="dialog.name" :ref="'currentDialogComponent_' + dialog_index" />
                        </div>
                        <div class="dialog_footer">
                            <button v-if="dialog && dialog.acceptButton"
                                class="mini"
                                v-on:click="() => dialog.acceptButton.callback ? dialog.acceptButton.callback(\$refs['currentDialogComponent_' + dialog_index][0], dialog, dialog.id, this) : resolve(dialog.id).close()">{{
                                dialog.acceptButton.text || " Aceptar" }}</button>
                            <button v-if="dialog && dialog.cancelButton"
                                class="mini"
                                v-on:click="() => dialog.cancelButton.callback ? dialog.cancelButton.callback(\$refs['currentDialogComponent_' + dialog_index][0], dialog, dialog.id, this) : close(dialog.id)">{{
                                dialog.cancelButton.text || " Cancelar" }}</button>
                            <button v-else
                                class="mini"
                                v-on:click="() => close(dialog.id)">{{ dialog?.cancelButton?.text || " Cancelar" }}</button>
                        </div>
                    </div>
                </template>
            </template>
        </div>
    </div>
</div>`,
    props: {
      asWindows: {
        type: Boolean,
        default: () => false
      }
    },
    data() {
      this.$trace("lsw-dialogs.data", []);
      return {
        enabledWindowsSystem: this.asWindows,
        opened: {},
        openedLength: 0,
        notMinimizedLength: 0,
        hookOnOpen: undefined,
        hookOnClose: closeSubdialogsHook,
      };
    },
    watch: {
      opened(newValue) {
        this.$trace("lsw-dialogs.watch.opened", []);
        this.openedLength = (typeof newValue !== "object") ? 0 : Object.keys(newValue).length;
        this._refreshMinimizedLength(newValue);
      }
    },
    methods: {
      open(parametricObject = {}) {
        this.$trace("lsw-dialogs.methods.open", []);
        if (typeof parametricObject !== "object") {
          throw new Error(`Required argument parametricObject to be an object on LswDialogs.methods.open`);
        }
        const {
          template,
          title = "",
          // @OK: El ID debera ser nico o no se abrirn las duplicadas.
          // @PERO: Pero por algo lo tena as tambin y no recuerdo.
          id = LswRandomizer.getRandomString(10),
          priority = 500,
          factory = defaultDialogFactory,
          parentId = undefined,
          created_at = new Date()
        } = parametricObject;
        const componentInfo = {};
        if (typeof id !== "string") {
          throw new Error(`Required parameter id to be a string on LswDialogs.methods.open`);
        }
        if (id in this.opened) {
          return this.maximize(id);
          // throw new Error(`Cannot open dialog ${id} because it is already opened on LswDialogs.methods.open`);
        }
        if (typeof template !== "string") {
          throw new Error(`Required parameter template to be a string on LswDialogs.methods.open`);
        }
        if (typeof factory === "object") {
          // @OK
        } else if (typeof factory !== "function") {
          throw new Error(`Required parameter factory to be an object or a function on LswDialogs.methods.open`);
        }
        if (typeof priority !== "number") {
          throw new Error(`Required parameter priority to be a number on LswDialogs.methods.open`);
        }
        const dialogComponentInput = typeof factory === "function" ? factory() : factory;
        const dialogComponentData = (() => {
          if (typeof dialogComponentInput.data === "undefined") {
            return function () { return {}; };
          } else if (typeof dialogComponentInput.data === "object") {
            return function () { return dialogComponentInput.data };
          } else if (typeof dialogComponentInput.data === "function") {
            return dialogComponentInput.data;
          } else {
            console.log(dialogComponentInput.data);
            throw new Error("Required parameter data returned by factory to be an object, a function or empty on LswDialogs.methods.open");
          }
        })();
        const scopifyMethods = function (obj, scope) {
          return Object.keys(obj).reduce((out, k) => {
            const v = obj[k];
            if (typeof v !== "function") {
              out[k] = v;
            } else {
              out[k] = v.bind(scope);
            }
            return out;
          }, {});
        };
        // 1) Este es para el Vue.component:
        const componentId = Dialog.fromIdToComponentName(id);
        const dialogComponent = Object.assign({}, dialogComponentInput, {
          name: componentId,
          template,
          data(component, ...args) {
            this.$trace(`lsw-dialogs.[${componentId}].data`, []);
            const preData = dialogComponentData.call(this);
            if (typeof preData.value === "undefined") {
              preData.value = "";
            };
            // console.log("El data del nuevo componente dialog:", preData);
            dialogComponentInput.watch = scopifyMethods(dialogComponentInput.watch || {}, component);
            dialogComponentInput.computed = scopifyMethods(dialogComponentInput.computed || {}, component);
            dialogComponentInput.methods = scopifyMethods(dialogComponentInput.methods || {}, component);
            return preData;
          },
          watch: (dialogComponentInput.watch || {}),
          computed: (dialogComponentInput.computed || {}),
          methods: {
            getValue() {
              this.$trace(`lsw-dialogs.[${componentId}].methods.getValue`, []);
              return JSON.parse(JSON.stringify(this.value));
            },
            accept(solution = undefined, ...args) {
              this.$trace(`lsw-dialogs.[${componentId}].methods.accept`, [solution, ...args]);
              if (solution instanceof Event) {
                return this.$dialogs.resolve(id, this.getValue()).close(id);
              }
              return this.$dialogs.resolve(id, typeof solution !== "undefined" ? solution : this.getValue()).close(id);
            },
            cancel(...args) {
              this.$trace("lsw-dialogs.[${componentId}].methods.cancel", args);
              return this.$dialogs.resolve(id, -1).close(id);
            },
            abort(error = undefined, ...args) {
              this.$trace(`lsw-dialogs.[${componentId}].methods.abort`, [error, ...args]);
              if (solution instanceof Event) {
                return this.$dialogs.reject(id, new Error("Aborted dialog error")).close(id);
              }
              return this.$dialogs.reject(id, error).close(id);
            },
            close(...args) {
              this.$trace(`lsw-dialogs.[${componentId}].methods.close`, args);
              return this.$dialogs.resolve(id, -2).close(id);
            },
            ...(dialogComponentInput.methods || {})
          }
        });
        Define_component: {
          Vue.component(dialogComponent.name, dialogComponent);
        }
        // 1) Este es para el this.$dialogs:
        const dialogDefinition = Object.assign({}, {
          ...parametricObject,
          id,
          title,
          name: dialogComponent.name,
          component: dialogComponent,
          priority,
          minimized: false,
          parentId,
          created_at,
          promiser: Promise.withResolvers(),
        });
        const dialogInstance = new Dialog(dialogDefinition);
        // console.log("Definicin final del dialogo", dialogInstance);
        Define_dialog: {
          this.opened = Object.assign({}, this.opened, {
            [id]: dialogInstance
          });
        }
        if (typeof this.hookOnOpen === "function") {
          this.hookOnOpen(this.opened[id], id, this);
        }
        return this.opened[id].promiser.promise;
      },
      resolve(id, solution, ...args) {
        this.$trace("lsw-dialogs.methods.resolve", [id, solution, ...args]);
        if (typeof id !== "string") {
          throw new Error("Required parameter id (argument:1) to be a string on LswDialogs.resolve");
        }
        if (!(id in this.opened)) {
          throw new Error(`Cannot resolve dialog ${id} because it is not opened on LswDialogs.resolve`);
        }
        this.opened[id].promiser.resolve(solution);
        return {
          close: () => this.close(id)
        };
      },
      reject(id, error, ...args) {
        this.$trace("lsw-dialogs.methods.reject", [id, error, ...args]);
        if (typeof id !== "string") {
          throw new Error("Required parameter id (argument:1) to be a string on LswDialogs.reject");
        }
        if (!(id in this.opened)) {
          throw new Error(`Cannot reject dialog ${id} because it is not opened on LswDialogs.reject`);
        }
        this.opened[id].promiser.reject(error);
        return {
          close: () => this.close(id)
        };
      },
      close(id, ...args) {
        this.$trace("lsw-dialogs.methods.close", [id, ...args]);
        if (typeof id !== "string") {
          throw new Error("Required parameter id (argument:1) to be a string on LswDialogs.close");
        }
        if (!(id in this.opened)) {
          throw new Error(`Cannot close dialog ${id} because it is not opened on LswDialogs.close`);
        }
        let promiseOfDialog = undefined;
        Undefine_component: {
          const dialogName = Dialog.fromIdToComponentName(id);
          delete Vue.options.components[dialogName];
        }
        Undefine_dialog: {
          Solve_promise_if_not_already: {
            if (this.opened[id].promiser.promise.state === "pending") {
              this.opened[id].promiser.resolve(-3);
            }
          }
          promiseOfDialog = this.opened[id].promiser.promise;
          delete this.opened[id];
          this.opened = Object.assign({}, this.opened);
        }
        if (typeof this.hookOnClose === "function") {
          this.hookOnClose(id, this);
        }
        return promiseOfDialog;
        // this.$forceUpdate(true);
      },
      minimize(id, ...args) {
        this.$trace("lsw-dialogs.methods.minimize", [id, ...args]);
        if (typeof id !== "string") {
          throw new Error("Required parameter id (argument:1) to be a string on LswDialogs.minimize");
        }
        if (!(id in this.opened)) {
          throw new Error(`Cannot minimize dialog ${id} because it is not opened on LswDialogs.minimize`);
        }
        this.opened[id].minimized = true;
        this._refreshMinimizedLength(this.opened);
      },
      minimizeAll() {
        this.$trace("lsw-dialogs.methods.minimizeAll");
        for(let id in this.opened) {
          this.opened[id].minimized = true;
        }
        Also_main_tab_if_exists: {
          const windowsViewer = this?.$lsw?.windowsViewer;
          if(windowsViewer) {
            windowsViewer.hide();
          }
        }
        this._refreshMinimizedLength(this.opened);
      },
      maximize(id, ...args) {
        this.$trace("lsw-dialogs.methods.maximize", [id, ...args]);
        if (typeof id !== "string") {
          throw new Error("Required parameter id (argument:1) to be a string on LswDialogs.maximize");
        }
        if (!(id in this.opened)) {
          console.log(this.opened);
          console.log(id);
          console.log(Object.keys(this.opened)[0] === id);
          throw new Error(`Cannot maximize dialog ${id} because it is not opened on LswDialogs.maximize`);
        }
        Iterating_dialogs:
        for (let dialogId in this.opened) {
          if (id === dialogId) {
            continue Iterating_dialogs;
          }
          const dialogData = this.opened[dialogId];
          const currentPriority = parseInt(dialogData.priority);
          this.opened[dialogId].priority = currentPriority - 1;
        }
        this.opened[id].priority = 500;
        this.opened[id].minimized = false;
        this._refreshMinimizedLength();
      },
      _refreshMinimizedLength(newValue = this.opened, ...args) {
        this.$trace("lsw-dialogs.methods._refreshMinimizedLength", []);
        this.notMinimizedLength = Object.keys(newValue).reduce((out, k) => {
          const v = newValue[k];
          if (v.minimized === false) {
            out++;
          }
          return out;
        }, 0);
        this.$forceUpdate(true);
      },
      goHome(...args) {
        this.$trace("lsw-dialogs.methods.goHome", []);
        this.$window.LswWindows.show();
      },
      onOpen(callback, ...args) {
        this.$trace("lsw-dialogs.methods.onOpen", []);
        this.hookOnOpen = callback;
      },
      onClose(callback, ...args) {
        this.$trace("lsw-dialogs.methods.onClose", []);
        this.hookOnClose = callback;
      }
    },
    mounted(...args) {
      this.$trace("lsw-dialogs.mounted", []);
      if(Vue.prototype.$dialogs) {
        throw new Error("Cannot install lsw-dialogs as global on Vue.prototype.$dialogs because it is another instance mounted on LswDialogs.mounted");
      }
      Vue.prototype.$dialogs = this;
      Vue.prototype.$lsw.dialogs = this;
      window.LswDialogs = this;
      console.log("[*] LswDialogs mounted.");
    }
  });
  // @code.end: LswDialogs API

})();

// @vuebundler[Lsw_framework_components][71]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-dialogs/lsw-dialogs.css

// @vuebundler[Lsw_framework_components][72]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-main-tab/lsw-windows-main-tab.html

// @vuebundler[Lsw_framework_components][72]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-main-tab/lsw-windows-main-tab.js
// @code.start: LswWindowsMainTab API | @$section: Vue.js (v2) Components  Lsw Windows API  LswWindowsMainTab component
// Change this component at your convenience:
Vue.component("LswWindowsMainTab", {
  template: `<div class="lsw_windows_main_tab">
        <div class="dialog_window process_manager_window" v-bind:key="'main_dialog'" :style="{ zIndex: 501 }">
            <div class="dialog_topbar">
                <div class="dialog_title">
                    <div>Procesos</div>
                </div>
                <div class="dialog_topbar_buttons">
                    <button class="mini" style="white-space: nowrap;flex: 1;" v-on:click="showConsole"></button>
                    <button class="mini" v-on:click="viewer.toggleState"></button>
                </div>
            </div>
            <div class="dialog_body">
                <div class="main_tab_topbar">
                    <button class="mini main_tab_topbar_button" v-on:click="openAgenda"></button>
                    <button class="mini main_tab_topbar_button" v-on:click="openWiki"></button>
                    <button class="mini main_tab_topbar_button" v-on:click="openRest"></button>
                    <button class="mini main_tab_topbar_button" v-on:click="openFilesystem"></button>
                    <!--button class="mini main_tab_topbar_button" v-on:click="openAutomessages"></button-->
                    <button class="mini main_tab_topbar_button" v-on:click="openNoteUploader"></button>
                    <button class="mini main_tab_topbar_button" v-on:click="openConfigurationsPage"></button>
                </div>
                <div class="pad_normal" v-if="!Object.keys(\$lsw.dialogs.opened).length">
                    <span>Sin procesos actualmente.</span>
                </div>
                <div class="pad_normal" v-else>
                    <div v-for="dialog, dialogIndex, dialogCounter in \$lsw.dialogs.opened" v-bind:key="'dialog-' + dialogIndex">
                        <div class="flex_row centered pad_bottom_1">
                            <div class="flex_100">
                                <button class="supermini width_100 text_align_left" v-on:click="() => viewer.selectDialog(dialogIndex)">
                                    <a href="javascript:void(0)">{{ dialogCounter + 1 }}. {{ dialog.title }} [{{ dialog.id }}]</a>
                                </button>
                            </div>
                            <div class="flex_1 pad_left_1">
                                <button class="supermini danger_button" v-on:click="() => closeProcess(dialog)"></button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dialog_footer">
                <button class="mini" v-on:click="viewer.toggleState"> Cancelar</button>
            </div>
        </div>
</div>`,
  props: {
    viewer: {
      type: Object,
      required: true
    }
  },
  data() {
    this.$trace("lsw-windows-main-tab.data", arguments);
    return {
      
    };
  },
  methods: {
    async showConsole() {
      this.$trace("lsw-windows-main-tab.methods.showConsole", arguments);
      this.$consoleHooker.toggleConsole();
    },
    getRandomString(len = 10) {
      this.$trace("lsw-windows-main-tab.methods.getRandomString", arguments);
      const alphabet = "abcdefghijklmnopqrstuvwxyz".split("");
      let out = "";
      while(out.length < len) {
        out += alphabet[Math.floor(Math.random() * alphabet.length)];
      }
      return out;
    },
    openRest() {
      this.$trace("lsw-windows-main-tab.methods.openRest", arguments);
      this.viewer.hide();
      this.$dialogs.open({
        id: "database-explorer-" + this.getRandomString(5),
        title: "Database explorer",
        template: `<div class="pad_1"><lsw-database-explorer /></div>`,
      });
    },
    openFilesystem() {
      this.$trace("lsw-windows-main-tab.methods.openFilesystem", arguments);
      this.viewer.hide();
      this.$dialogs.open({
        id: "filesystem-explorer-" + this.getRandomString(5),
        title: "Filesystem explorer",
        template: `<lsw-filesystem-explorer  :absolute-layout="true" />`,
      });
    },
    openWiki() {
      this.$trace("lsw-windows-main-tab.methods.openWiki", arguments);
      this.viewer.hide();
      this.$dialogs.open({
        id: "wiki-explorer-" + this.getRandomString(5),
        title: "Wiki explorer",
        template: `<div class="pad_1"><lsw-wiki /></div>`,
      });
    },
    openAgenda() {
      this.$trace("lsw-windows-main-tab.methods.openAgenda", arguments);
      this.viewer.hide();
      this.$dialogs.open({
        id: "agenda-viewer-" + this.getRandomString(5),
        title: "Agenda viewer",
        template: `<div class="pad_1"><lsw-agenda /></div>`,
      });
    },
    openAutomessages() {
      this.$trace("lsw-windows-main-tab.methods.openAutomessages", arguments);
      this.viewer.hide();
    },
    openNoteUploader() {
      this.$trace("lsw-windows-main-tab.methods.openNoteUploader", arguments);
      this.viewer.hide();
      this.$dialogs.open({
        id: "notas-" + this.getRandomString(5),
        title: "Notas",
        template: `<div class="pad_1"><lsw-spontaneous-table-nota /></div>`,
      });
    },
    openConfigurationsPage() {
      this.$trace("lsw-windows-main-tab.methods.openConfigurationsPage", arguments);
      this.viewer.hide();
      this.$dialogs.open({
        id: "configurations-page-" + this.getRandomString(5),
        title: "Configuraciones",
        template: `<div class="pad_1"><lsw-configurations-page /></div>`,
      });
    },
    closeProcess(dialog) {
      this.$trace("lsw-windows-main-tab.methods.closeProcess", arguments);
      this.$lsw.dialogs.close(dialog.id);
    },
  },
  mounted() {
    this.$lsw.windowsMainTab = this;
  }
});
// @code.end: LswWindowsMainTab API

// @vuebundler[Lsw_framework_components][72]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-main-tab/lsw-windows-main-tab.css

// @vuebundler[Lsw_framework_components][73]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-viewer/lsw-windows-viewer.html

// @vuebundler[Lsw_framework_components][73]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-viewer/lsw-windows-viewer.js
// @code.start: LswWindowsViewer API | @$section: Vue.js (v2) Components  Lsw Windows API  LswWindowsViewer classes and functions
// Change this component at your convenience:
Vue.component("LswWindowsViewer", {
  template: `<div class="lsw-windows-viewer">
    <lsw-dialogs ref="dialogs" :as-windows="true" />
    <lsw-windows-pivot-button :viewer="this" />
    <template v-if="isShowing">
        <lsw-windows-main-tab :viewer="this" />
    </template>
</div>`,
  props: {},
  data() {
    return {
      isShowing: false
    };
  },
  methods: {
    hide() {
      this.isShowing = false;
    },
    show() {
      this.isShowing = true;
    },
    toggleState() {
      this.isShowing = !this.isShowing;
      this.$forceUpdate(true);
    },
    selectDialog(id) {
      this.hide();
      this.$refs.dialogs.maximize(id);
    }
  },
  mounted() {
    this.$window.LswWindows = this;
    this.$lsw.windows = this;
    this.$lsw.windowsViewer = this;
  }
});
// @code.end: LswWindowsViewer API


// @vuebundler[Lsw_framework_components][73]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-viewer/lsw-windows-viewer.css

// @vuebundler[Lsw_framework_components][74]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-pivot-button/lsw-windows-pivot-button.html

// @vuebundler[Lsw_framework_components][74]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-pivot-button/lsw-windows-pivot-button.js
// @code.start: LswWindowsPivotButton API | @$section: Vue.js (v2) Components  Lsw Windows API  LswWindowsPivotButton component
// Change this component at your convenience:
Vue.component("LswWindowsPivotButton", {
  template: `<div class="lsw_windows_pivot_button">
    <div class="flex_row centered">
        <div class="">
            <button id="windows_pivot_button" v-on:click="onClick" class=""></button>
        </div>
        <!--div class="lsw_time_box">
            {{ LswTimer.utils.formatDatestringFromDate(currentDate, false, true, true).replace(/ /g, "~") }}
        </div-->
    </div>
</div>`,
  props: {
    viewer: {
      type: Object,
      required: true
    }
  },
  data() {
    this.$trace("lsw-windows-pivot-button.data");
    return {
      
    };
  },
  methods: {
    onClick(event) {
      this.$trace("lsw-windows-pivot-button.methods.onClick");
      this.viewer.toggleState();
    },
  },
});
// @code.end: LswWindowsPivotButton API

// @vuebundler[Lsw_framework_components][74]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-pivot-button/lsw-windows-pivot-button.css

// @vuebundler[Lsw_framework_components][75]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-toasts/lsw-toasts.html

// @vuebundler[Lsw_framework_components][75]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-toasts/lsw-toasts.js
// @code.start: LswToasts API | @$section: Vue.js (v2) Components  Lsw Toasts API  LswToasts component
Vue.component("LswToasts", {
  template: `<div class="lsw_toasts">
    <div class="toasts_box">
        <div class="toast_list">
            <template v-for="toast, toastIndex in sent">
                <div class="toast_box">
                    <div class="toast_item">
                        <div class="toast"
                            v-bind:key="'toast-number-' + toast.id"
                            :style="{ color: toast.foreground, backgroundColor: toast.background }"
                            v-on:click="() => close(toast.id)">
                            <div class="toast_title"
                                style="font-size: 13px;" v-if="toast.title">
                                {{ toast.title }}
                            </div>
                            <div class="toast_text"
                                style="font-size: 10px;">
                                {{ toast.text }}
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>
</div>`,
  props: {},
  data() {
    return {
      sent: {}
    };
  },
  methods: {
    getRandomString(len = 10) {
      const alphabet = "abcdefghijklmnopqrstuvwxyz".split("");
      let out = "";
      while (out.length < len) {
        out += alphabet[Math.floor(Math.random() * alphabet.length)];
      }
      return out;
    },
    showError(error, args = {}, propagate = false, log = true) {
      this.$trace("lsw-toasts.methods.showError");
      let parameters = {};
      const isSyntaxError = typeof error.location === "object";
      if (isSyntaxError) {
        parameters = {
          title: `Error sintctico en ${error.location.start.line}:${error.location.start.column} (${error.found})`,
          text: error.expected,
        }
      } else {
        parameters = {
          title: "Un error ocurri",
          text: error.name + ": " + error.message,
          ...args,
        }
      }
      const output = this.send(parameters);
      if (log) {
        console.log(error);
      }
      if (propagate) {
        throw error;
      }
      return output;
    },
    send(toastsInput = {}) {
      const toastData = Object.assign({
        id: this.getRandomString(),
        title: "",
        text: "",
        timeout: 3000,
        orientation: "bottom",
        background: "rgba(255,255,255,0.5)",
        foreground: "#000",
        started_at: new Date()
      }, toastsInput);
      if (typeof toastData.timeout !== "number") {
        throw new Error("Required parameter timeout to be a number or empty on LswToasts.methods.send");
      }
      if (isNaN(toastData.timeout)) {
        throw new Error("Required parameter timeout to be a (non-NaN) number or empty on LswToasts.methods.send");
      }
      if (["top", "bottom", "center"].indexOf(toastData.orientation) === -1) {
        throw new Error("Required parameter orientation to be a string (top, center, bottom) or empty on LswToasts.methods.send");
      }
      if (toastData.id in this.sent) {
        throw new Error("Required parameter id to not be repeated on LswToasts.methods.send");
      }
      this.sent = Object.assign({}, this.sent, {
        [toastData.id]: toastData
      });
      setTimeout(() => {
        this.close(toastData.id);
      }, toastData.timeout);
    },
    close(id) {
      delete this.sent[id];
      this.$forceUpdate(true);
    },
    debug(anyzing) {
      this.send({
        title: typeof anyzing,
        text: LswUtils.stringify(anyzing),
      });
    },
    collapse(anyzing, timeout = 3000) {
      this.$lsw.dialogs.open({
        title: "Debugging: type " + typeof anyzing,
        template: `
          <div class="pad_1">
            <div>Moment: {{ moment }}</div>
            <pre class="codeblock" style="font-size: 10px;">{{ code }}</pre>
          </div>
        `,
        factory: function() {
          return {
            data() {
              return {
                moment: LswTimer.utils.fromDateToDatestring(new Date(), true),
                code: typeof anyzing === "string" ? anyzing : JSON.stringify(anyzing, null, 2),
              };
            },
            mounted() {
              setTimeout(() => this.cancel(), timeout);
            },
          };
        }
      });
    }
  },
  watch: {},
  mounted() {
    this.$toasts = this;
    this.$window.LswToasts = this;
    if (this.$lsw) {
      this.$lsw.toasts = this;
    }
    this.$window.dd = (...args) => {
      return this.debug(...args);
    };
  }
});
// @code.end: LswToasts API

// @vuebundler[Lsw_framework_components][75]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-toasts/lsw-toasts.css

// @vuebundler[Lsw_framework_components][76]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-console-hooker/console-hooker-api.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['ConsoleHooker'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['ConsoleHooker'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswConsoleHooker API | @$section: Vue.js (v2) Components  LswConsoleHooker API  LswConsoleHooker API
  class ConsoleHooker {

    static extractProps(obj, props = []) {
      const out = {};
      for(let index=0; index<props.length; index++) {
        const prop = props[index];
        out[prop] = obj[prop].bind(obj);
      }
      return out;
    }

    constructor(outputElementId) {
      this.originalConsole = { ...console }; // Guardar los mtodos originales
      this.outputElementId = outputElementId;
      this.isHooked = false;
      this.hookConsole();
      this.messageCounter = 0;
    }

    HOOKED_METHODS = [
      "log",
      "info",
      "warn",
      "error",
      "debug",
    ];

    hookConsole() {
      if(this.isHooked) {
        return;
      }
      this.HOOKED_METHODS.forEach(method => {
        if (typeof console[method] === 'function') {
          console[method] = (...args) => {
            this.writeToHtml(method, args);
            this.originalConsole[method](...args); // Llamar al mtodo original
          };
        }
      });
      this.isHooked = true;
    }

    formatError(error) {
      let errorMessage = "";
      errorMessage += "Error: " + error.name + ": " + error.message;
      if (error.location) {
        errorMessage += JSON.stringify({
          found: error.found,
          expected: error.expected,
          location: error.location
        }, null, 2);
      }
      return errorMessage;
    }

    consoleReducer() {
      return (arg) => {
        if (typeof arg === 'object') {
          if (arg instanceof Error) {
            return this.formatError(arg);
          } else {
            const seen = new WeakSet();
            return JSON.stringify(arg, function (key, value) {
              if (typeof value === "object") {
                if (seen.has(value)) {
                  return "[Circular]";
                }
                if (value !== null) {
                  seen.add(value);
                }
              }
              return value;
            }, 2);
          }
        } else {
          return arg;
        }
      };
    }

    writeToHtml(method, args) {
      // Do not log from this method or it becomes recursive:
      const message = document.createElement('div');
      message.className = `console-${method}`;
      message.textContent = `[${this.messageCounter++}] ${args.map(this.consoleReducer()).join(' ')}`;
      const outputElement = document.getElementById(this.outputElementId);
      if (!outputElement) {
        // console.log("no console hooker output element found");
        return;
      }
      const subnodes = outputElement.children;
      const subnodesLength = outputElement.children.length;
      const hasMoreThan100 = outputElement.children.length > 100;
      if (hasMoreThan100) {
        for (let index = subnodes.length - 1; index > 50; index--) {
          const subnode = subnodes[index];
          subnode.remove();
        }
      }
      const parent = outputElement;
      parent.insertBefore(message, parent.firstChild);
    }

    restoreConsole() {
      if(!this.isHooked) {
        return;
      }
      this.HOOKED_METHODS.forEach(method => {
        console[method] = this.originalConsole[method];
      });
      this.isHooked = false;
    }
  }

  ConsoleHooker.default = ConsoleHooker;

  return ConsoleHooker;
  // @code.end: LswConsoleHooker API

});

// @vuebundler[Lsw_framework_components][77]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-console-hooker/console-hooker.html

// @vuebundler[Lsw_framework_components][77]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-console-hooker/console-hooker.js
// @code.start: LswConsoleHooker API | @$section: Vue.js (v2) Components  LswConsoleHooker API  LswConsoleHooker component
Vue.component("LswConsoleHooker", {
  template: `<div class="console-hooker">
    <div class="" ref="console_hooker_box"></div>
</div>`,
  props: {},
  data() {
    return {

    }
  },
  methods: {

    async loadEruda() {
      this.$trace("console-hooker.methods.loadEruda");
      await LswLazyLoads.loadEruda();
    },

    async toggleConsole() {
      this.$trace("console-hooker.methods.toggleConsole");
      if (typeof eruda === "undefined") {
        await this.loadEruda();
        eruda.init({
          container: this.$refs.console_hooker_box,
        });
        eruda.show();
      } else {
        const isShowing = eruda._$el.find(".eruda-dev-tools").css("display") === "block";
        if (isShowing) {
          eruda.hide();
        } else {
          eruda.show();
        }
      }
    },

  },
  mounted() {
    this.$trace("console-hooker.mounted");
    Exportar_consola: {
      Vue.prototype.$consoleHooker = this;
      this.$window.LswConsoleHooker = this;
    }
  },
  unmounted() {

  }
});
// @code.end: LswConsoleHooker API

// @vuebundler[Lsw_framework_components][77]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-console-hooker/console-hooker.css

// @vuebundler[Lsw_framework_components][78]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/database-explorer/database-explorer.html

// @vuebundler[Lsw_framework_components][78]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/database-explorer/database-explorer.js
// @code.start: LswDatabaseExplorer API | @$section: Vue.js (v2) Components  LswDatabaseExplorer API  LswDatabaseExplorer API
Vue.component("LswDatabaseExplorer", {
  template: `<div class="lsw_database_ui database_explorer" :class="{hideBreadcrumb: !showBreadcrumb}">
    <template v-if="!isLoading">
        <component :is="selectedPage" :args="selectedArgs" :database-explorer="this" />
    </template>
</div>`,
  props: {
    showBreadcrumb: {
      type: Boolean,
      default: () => true
    },
    initialPage: {
      type: String,
      default: () => "lsw-page-tables"
    },
    initialArgs: {
      type: Object,
      default: () => ({ database: "lsw_default_database" })
    },
  },
  data() {
    this.$trace("lsw-database-explorer.data", []);
    return {
      isLoading: false,
      selectedPage: this.initialPage,
      selectedArgs: this.initialArgs,
    }
  },
  methods: {
    selectPage(page, args = {}) {
      try {
        this.$trace("lsw-database-explorer.methods.selectPage", arguments);
        $ensure({page}, 1).type("string");
        $ensure({args}, 1).type("object");
        this.isLoading = true;
        this.$nextTick(() => {
          this.selectedArgs = args;
          this.selectedPage = page;
          this.isLoading = false;
        });
      } catch (error) {
        console.log(error);
        throw error;
      }
    }
  },
  async mounted() {
    this.$trace("lsw-database-explorer.methods.mounted", arguments);
  },
  unmounted() {
    this.$trace("lsw-database-explorer.methods.unmounted", arguments);
  }
});
// @code.end: LswDatabaseExplorer API

// @vuebundler[Lsw_framework_components][78]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/database-explorer/database-explorer.css

// @vuebundler[Lsw_framework_components][79]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/database-breadcrumb/database-breadcrumb.html

// @vuebundler[Lsw_framework_components][79]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/database-breadcrumb/database-breadcrumb.js
// @code.start: LswDatabaseBreadcrumb API | @$section: Vue.js (v2) Components  LswDatabaseBreadcrumb API  LswDatabaseBreadcrumb API
Vue.component("LswDatabaseBreadcrumb", {
  template: `<div class="database_breadcrumb">
    <span> Ests en: </span>
    <template v-for="item, itemIndex in breadcrumb">
        <span v-bind:key="'breadcrumb_item_' + itemIndex">
            <span v-if="itemIndex !== 0">  </span>
            <a v-if="!item.current" href="javascript:void(0)" v-on:click="() => selectPage(item.page, item.args)">
                {{ item.name }}
            </a>
            <span v-else>{{ item.name }}</span>
        </span>
    </template>
</div>`,
  props: {
    databaseExplorer: {
      type: Object,
      required: true
    },
    breadcrumb: {
      type: Array,
      required: true
    }
  },
  data() {
    return {
      
    }
  },
  methods: {
    selectPage(page, args = {}) {
      return this.databaseExplorer.selectPage(page, args);
    }
  },
  async mounted() {
    
  },
  unmounted() {

  }
});
// @code.end: LswDatabaseBreadcrumb API

// @vuebundler[Lsw_framework_components][79]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/database-breadcrumb/database-breadcrumb.css

// @vuebundler[Lsw_framework_components][80]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-databases/page-databases.html

// @vuebundler[Lsw_framework_components][80]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-databases/page-databases.js
// @code.start: LswPageDatabases API | @$section: Vue.js (v2) Components  LswPageDatabases API  LswPageDatabases API
Vue.component("LswPageDatabases", {
  template: `<div>
    <h3>  Todas las bases de datos</h3>
    <lsw-database-breadcrumb :breadcrumb="breadcrumb"
        :database-explorer="databaseExplorer" />
    <lsw-table v-if="databases && databases.length"
        :initial-input="databases"
        :initial-settings="{title: 'Lista de todas las bases de datos:', itemsPerPage: 50 }"
        :row-buttons="[{ header: '', text: '', event: (row) => openDatabase(row.name) }]"></lsw-table>
</div>`,
  props: {
    databaseExplorer: {
      type: Object,
      required: true
    },
    args: {
      type: Object,
      required: true
    },
  },
  data() {
    return {
      databases: [],
      databasesForTable: false,
      breadcrumb: [{
        page: "LswPageDatabases",
        name: "Databases",
        args: {},
        current: true
      }],
    }
  },
  methods: {
    openDatabase(name) {
      this.databaseExplorer.selectPage("LswPageTables", { database: name });
    }
  },
  watch: {
    databases(value) {
      AdaptingForTable: {
        const databasesForTable = [];
        if (typeof value !== "object") {
          break AdaptingForTable;
        }
        const databaseIds = Object.keys(value);
        for(let indexDatabase=0; indexDatabase<databaseIds.length; indexDatabase++) {
          const databaseId = databaseIds[indexDatabase];
          const databaseObject = value[databaseId];
        }
        this.databasesForTable = databasesForTable;
      }
    }
  },
  async mounted() {
    this.databases = await LswDatabaseAdapter.listDatabases();
    Filter_by_entity_schema_matched_db_names: {
      $lswSchema
    }
  },
  unmounted() {

  }
});
// @code.end: LswPageDatabases API

// @vuebundler[Lsw_framework_components][80]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-databases/page-databases.css

// @vuebundler[Lsw_framework_components][81]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-rows/page-rows.html

// @vuebundler[Lsw_framework_components][81]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-rows/page-rows.js
// @code.start: LswPageRows API | @$section: Vue.js (v2) Components  LswPageRows API  LswPageRows API
Vue.component("LswPageRows", {
  template: `<div>
    <div>
        <div class="flex_row centered">
            <div class="flex_1">
                <button v-on:click="goBack"></button>
            </div>
            <div class="flex_100 pad_left_1">
                <h3 class="display_inline_block nowrap">  {{ args.table }} [*]</h3>
                <div class="display_inline_block">[{{ args.database }}]</div>
            </div>
        </div>
    </div>
    <lsw-database-breadcrumb :breadcrumb="breadcrumb" :database-explorer="databaseExplorer" />
    <lsw-table
        :storage-id="getTableId()"
        :initial-input="rows" v-if="rows"
        :initial-settings="{
            title: 'Registros de ' + args.table,
            columnsOrder: ['id'],
            ...(args.initialSettings || {})
        }"
        :row-buttons="[{ header: '', text: '', event: (row) => openRow(row.id) }]"
        :table-buttons="databaseExplorer.showBreadcrumb ? [{ text: '', event() { openRow(-1) }}] : []"></lsw-table>
</div>`,
  props: {
    databaseExplorer: {
      type: Object,
      required: true
    },
    args: {
      type: Object,
      required: true
    },
  },
  data() {
    this.$trace("lsw-page-rows.data", []);
    $ensure({ "args": this.args }, 1).type("object");
    $ensure({ "args.database": this.args.database }, 1).type("string");
    $ensure({ "args.table": this.args.table }, 1).type("string");
    return {
      breadcrumb: [{
        page: "LswPageTables",
        name: this.args.database,
        args: {
          database: this.args.database
        }
      }, {
        page: "LswPageRows",
        name: this.args.table,
        args: {
          database: this.args.database,
          table: this.args.table
        },
        current: true
      }],
      database: this.args.database,
      table: this.args.table,
      rows: undefined,
      connection: undefined,
    }
  },
  methods: {
    goBack() {
      this.$trace("lsw-page-rows.methods.goBack", arguments);
      return this.databaseExplorer.selectPage("LswPageTables", {
        database: this.database,
      });
    },
    getTableId() {
      if(this.args.tableStorageId) {
        return this.args.tableStorageId + '.json';
      } else {
        return 'lsw-database-ui.page-rows.' + this.args.database + '.' + this.args.table + '.json';
      }
    },
    async loadRows() {
      this.$trace("lsw-page-rows.methods.loadRows", arguments);
      this.connection = this.connection ?? new LswDatabaseAdapter(this.database);
      await this.connection.open();
      const filterCallback = (this.args.filterCallback && typeof(this.args.filterCallback) === "function") ? this.args.filterCallback : () => true;
      const selection = await this.connection.select(this.table, filterCallback);
      this.rows = selection;
      return selection;
    },
    openRow(rowId) {
      this.$trace("lsw-page-rows.methods.openRow", arguments);
      return this.databaseExplorer.selectPage("LswPageRow", {
        database: this.database,
        table: this.table,
        rowId: rowId
      });
    }
  },
  mounted() {
    this.$trace("lsw-page-rows.mounted", arguments);
    this.loadRows();
  },
  unmounted() {
    this.$trace("lsw-page-rows.unmounted", arguments);
    this.connection.close();
  }
});
// @code.end: LswPageRows API

// @vuebundler[Lsw_framework_components][81]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-rows/page-rows.css

// @vuebundler[Lsw_framework_components][82]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-row/page-row.html

// @vuebundler[Lsw_framework_components][82]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-row/page-row.js
// @code.start: LswPageRow API | @$section: Vue.js (v2) Components  LswPageRow API  LswPageRow API
Vue.component("LswPageRow", {
  template: `<div>
    <h3>
        <span>
            <span>
                <button v-on:click="goBack"></button>
            </span>
            <span>  </span>
            <span>{{ args.table }}</span>
        </span>
        <span v-if="(args.rowId && args.rowId !== -1)">
            [#{{ args.rowId }}]
        </span>
        <span v-else-if="args.row && args.row.id">
            [#{{ args.row.id }}]
        </span>
        <span v-else>
            [new]
        </span>
        <span>
            [{{ args.database }}]
        </span>
    </h3>
    <lsw-database-breadcrumb :breadcrumb="breadcrumb"
        :database-explorer="databaseExplorer" />
    <div v-if="!isLoaded">Un momento, por favor, est cargando...</div>
    <lsw-schema-based-form v-else
        :on-submit="upsertRow"
        :model="{
            connection: \$lsw.database,
            databaseId: args.database,
            tableId: args.table,
            rowId: args.rowId || row.id,
            row: row,
            databaseExplorer,
        }"
    />
</div>`,
  props: {
    databaseExplorer: {
      type: Object,
      required: true
    },
    args: {
      type: Object,
      required: true
    },
  },
  data() {
    this.$trace("lsw-page-row.data", arguments);
    $ensure(this.args.database).type("string");
    $ensure(this.args.table).type("string");
    $ensure(this.args.rowId).type("number");
    return {
      isLoaded: false,
      breadcrumb: [{
        page: "LswPageTables",
        name: this.args.database,
        args: {
          database: this.args.database
        }
      }, {
        page: "LswPageRows",
        name: this.args.table,
        args: {
          database: this.args.database,
          table: this.args.table
        },
      }, {
        page: "LswPageRow",
        name: (this.args.rowId === -1) ? '#new' : ("#" + this.args.rowId),
        args: {
          database: this.args.database,
          table: this.args.table,
          rowId: this.args.rowId
        },
        current: true
      }],
      database: this.args.database,
      table: this.args.table,
      rowId: this.args.rowId,
      connection: undefined,
      row: false,
    }
  },
  methods: {
    goBack() {
      this.$trace("lsw-page-row.methods.goBack", arguments);
      return this.databaseExplorer.selectPage("LswPageRows", {
        database: this.database,
        table: this.table
      });
    },
    async loadRow() {
      this.$trace("lsw-page-row.methods.loadRow", arguments);
      try {
        if (this.rowId === -1) {
          return false;
        }
        this.connection = this.connection ?? new LswDatabaseAdapter(this.database);
        await this.connection.open();
        const matches = await this.connection.select(this.table, it => it.id === this.rowId);
        this.row = matches[0];
      } catch (error) {
        console.log("Error loading row:", error);
        this.$lsw.toasts.showError(error);
        throw error;
      } finally {
        this.row = false;
      }
    },
    async upsertRow(value) {
      this.$trace("lsw-page-row.methods.upsertRow", arguments);
      try {
        const existsRow = this.rowId || ((typeof (this.row) === "object") && (typeof (this.row.id) === "number") && (this.row.id !== -1));
        let id = this.rowId || this.row.id;
        const operation = (existsRow && (id !== -1)) ? "update" : "insert";
        if (operation === "insert") {
          id = await this.$lsw.database.insert(this.table, value);
        } else {
          await this.$lsw.database.update(this.table, id, value);
        }
        this.$lsw.toasts.send({
          title: `Nueva ${operation === 'insert' ? 'insercin' : 'actualizacin'}`,
          text: `El registro #${id} de ${this.table} fue ${operation === 'insert' ? 'insertado' : 'actualizado'} correctamente.`
        });
        if (operation === "insert") {
          this.databaseExplorer.selectPage("LswPageRow", {
            database: this.database,
            table: this.table,
            rowId: id
          });
        } else {
          // @OK.
        }
      } catch (error) {
        console.log(error);
        this.$lsw.toasts.showError(error);
      }
    }
  },
  async mounted() {
    this.$trace("lsw-page-row.mounted", arguments);
    try {
      await this.loadRow();
    } catch (error) {
      console.log("Error loading row:", error);
      throw error;
    } finally {
      this.isLoaded = true;
    }
  },
  unmounted() {
    this.$trace("lsw-page-row.unmounted", arguments);
    this.connection.close();
  }
});
// @code.end: LswPageRow API

// @vuebundler[Lsw_framework_components][82]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-row/page-row.css

// @vuebundler[Lsw_framework_components][83]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-schema/page-schema.html

// @vuebundler[Lsw_framework_components][83]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-schema/page-schema.js
// @code.start: LswPageSchema API | @$section: Vue.js (v2) Components  LswPageSchema API  LswPageSchema API
Vue.component("LswPageSchema", {
  template: `<div></div>`,
  props: {},
  data() {
    return {
      
    }
  },
  methods: {
    
  },
  mounted() {
    
  },
  unmounted() {

  }
});
// @code.end: LswPageSchema API

// @vuebundler[Lsw_framework_components][83]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-schema/page-schema.css

// @vuebundler[Lsw_framework_components][84]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-tables/page-tables.html

// @vuebundler[Lsw_framework_components][84]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-tables/page-tables.js
// @code.start: LswPageTables API | @$section: Vue.js (v2) Components  LswPageTables API  LswPageTables API
Vue.component("LswPageTables", {
  template: `<div class="page_tables page">
    <div class="typical_title_1 flex_row centered">
        <div class="flex_100">
            <div class="display_inline_block nowrap"> Tablas de {{ args.database }}</div>
        </div>
        <div class="flex_1 pad_left_1">
            <button class="supermini visibility_hidden">ok</button>
        </div>
    </div>
    <lsw-database-breadcrumb :breadcrumb="breadcrumb"
        :database-explorer="databaseExplorer" />
    <div v-if="tablesAsList">
        <div class="pad_bottom_1">
            <div class="h4">Tablas disponibles:</div>
        </div>
        <div class="lista_de_tablas_disponibles">
            <div class=""
                style="padding-bottom:1px;"
                v-for="tableData, tableIndex, tableCounter in tablesAsList"
                v-bind:key="'table_id_' + tableData.id">
                <button class="supermini width_100 text_align_left"
                    v-on:click="() => openTable(tableData.id)">
                    <span class="table_index">{{ tableIndex + 1 }}. </span>
                    <span class="table_name">{{ tableData.id }}</span>
                </button>
            </div>
        </div>
    </div>
    <div v-if="tablesAsList && tablesAsList.length">
        <div class="pad_top_1 flex_row">
            <div class="h4 flex_100">Esquema de tablas:</div>
            <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="toggleSchema"></button>
            </div>
        </div>
        <div v-if="isShowingSchema">
            <lsw-table :initial-input="tablesAsList"
                :initial-settings="{
                    title: 'Tablas de ' + args.database,
                    itemsPerPage: 50,
                    columnsAsList: ['indexes'],
                    columnsOrder: ['name', 'indexes', 'keyPath']
                }"
                :row-buttons="[{
                header: '',
                text: '',
                event: (row, i) => openTable(row.name)
            }]"></lsw-table>
        </div>
    </div>
</div>`,
  props: {
    databaseExplorer: {
      type: Object,
      required: true
    },
    args: {
      type: Object,
      required: true
    },
  },
  data() {
    const ensureArgs = $ensure(this.args).type("object");
    ensureArgs.to.have.key("database").its("database").type("string");
    return {
      breadcrumb: [{
        page: "LswPageTables",
        name: this.args.database,
        args: {
          database: this.args.database
        },
        current: true
      }],
      database: this.args.database,
      tables: false,
      tablesAsList: false,
      isShowingSchema: false,
    }
  },
  methods: {
    async loadDatabase() {
      const db = await LswDatabaseAdapter.getSchema(this.database);
      this.tables = db;
      console.log(`[*] Tables of database ${this.args.database}:`, db);
    },
    openTable(table) {
      $ensure({ table }, 1).type("string");
      return this.databaseExplorer.selectPage("LswPageRows", {
        database: this.database,
        table: table
      });
    },
    toggleSchema() {
      this.isShowingSchema = !this.isShowingSchema;
    }
  },
  watch: {
    tables(value) {
      const tablesAsList = [];
      const tableIds = Object.keys(value);
      for(let index=0; index<tableIds.length; index++) {
        const tableId = tableIds[index];
        const tableData = value[tableId];
        tablesAsList.push({
          id: tableId,
          name: tableId,
          ...tableData,
          indexes: tableData.indexes ? tableData.indexes.map(ind => ind.name) : []
        });
      }
      this.tablesAsList = tablesAsList;
    },
  },
  computed: {
    tablesAsIdsList() {
      return Object.keys(this.tablesAsList || {});
    }
  },
  mounted() {
    this.loadDatabase();
  },
  unmounted() {

  }
});
// @code.end: LswPageTables API

// @vuebundler[Lsw_framework_components][84]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-tables/page-tables.css

// @vuebundler[Lsw_framework_components][85]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-explorer/lsw-filesystem-explorer.html

// @vuebundler[Lsw_framework_components][85]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-explorer/lsw-filesystem-explorer.js
// @code.start: LswFilesystemExplorer API | @$section: Vue.js (v2) Components  Lsw Filesystem Explorer API  LswFilesystemExplorer component
Vue.component("LswFilesystemExplorer", {
  name: "LswFilesystemExplorer",
  template: `<div class="lsw_filesystem_explorer" :class="{absolute_version: absoluteLayout}">
    <div :class=" absoluteLayout ? 'pad_vertical_1' : 'pad_1'">
        <div class="typical_title_1 flex_row centered">
            <div class="flex_100"> Sistema de ficheros:</div>
            <div class="flex_1 pad_left_1">
                <button class="supermini visibility_hidden">ok</button>
            </div>
        </div>
    </div>
    <div class="current_node_box">
        <span class="previous_node_path" :class="current_node !== '/' ? '' : 'visibility_hidden'">
            <button class="previous_node_button" v-on:click="goUp"
            style="transform: rotate(180deg); margin: 1px;"></button>
        </span>
        <span class="current_node_path">{{ current_node_basedir }}</span>
        <span class="current_node_filename">{{ current_node_basename }}</span>
    </div>
    <div class="filesystem_ui">
        <div class="leftside">
            <lsw-filesystem-buttons-panel :explorer="this" ref="panelLeft" orientation="column" />
        </div>
        <div class="middleside">
            <div class="headerside">
                <lsw-filesystem-buttons-panel :explorer="this" ref="panelTop" />
            </div>
            <div class="bodyside" v-if="is_ready">
                <lsw-filesystem-treeviewer v-if="current_node_is_directory" :explorer="this" ref="treeviewer" />
                <lsw-filesystem-editor v-else-if="current_node_is_file" :explorer="this" ref="editor" :filecontents="current_node_contents" />
            </div>
            <div class="footerside">
                <lsw-filesystem-buttons-panel :explorer="this" ref="panelBottom" />
            </div>
        </div>
        <div class="rightside">
            <lsw-filesystem-buttons-panel :explorer="this" ref="panelRight" orientation="column" />
        </div>
    </div>
</div>`,
  props: {
    absoluteLayout: {
      type: Boolean,
      default: () => false,
    },
    openedBy: {
      type: String,
      default: () => "/",
    }
  },
  data() {
    this.$trace("lsw-filesystem-explorer.data");
    return {
      is_ready: false,
      current_node: "/",
      current_node_parts: undefined,
      current_node_basename: undefined,
      current_node_basedir: undefined,
      current_node_contents: undefined,
      current_node_subnodes: [],
      current_node_is_file: false,
      current_node_is_directory: false,
      syntaxValidators: {},
      STANDARIZED_REFRESH_DELAY: 100
    };
  },
  methods: {
    open(...args) {
      this.$trace("lsw-filesystem-explorer.methods.open");
      return this.open_node(...args);
    },
    goUp() {
      this.$trace("lsw-filesystem-explorer.methods.goUp");
      const parts = this.current_node.split("/");
      parts.pop();
      const dest = this.normalize_path("/" + parts.join("/"));
      return this.open(dest);
    },
    async refresh() {
      this.$trace("lsw-filesystem-explorer.methods.refresh");
      this.is_ready = false;
      try {
        await this.open(this.current_node);
      } catch (error) {
        throw error;
      } finally {
        this.$nextTick(() => {
          this.is_ready = true;
          this.$forceUpdate(true);
        });
      }
    },
    normalize_path(subpath) {
      this.$trace("lsw-filesystem-explorer.methods.normalize_path");
      return this.$lsw.fs.resolve_path(this.current_node, subpath);
    },
    async open_node(subpath = this.current_node) {
      this.$trace("lsw-filesystem-explorer.methods.open_node");
      try {
        if (["", "/"].indexOf(subpath) !== -1) {
          return await this._openDirectory("/");
        }
        const temporaryPath = this.normalize_path(subpath);
        const is_directory = await this.$lsw.fs.is_directory(temporaryPath);
        if (is_directory) {
          return await this._openDirectory(temporaryPath);
        }
        const is_file = await this.$lsw.fs.is_file(temporaryPath);
        if (is_file) {
          return await this._openFile(temporaryPath);
        }
        throw new Error(`Cannot open path because it does not exist: ${temporaryPath} on LswFilesystemExplorer.methods.open_node`);
      } catch (error) {
        console.log(error);
        throw error;
      }
    },
    async processToCreateFile() {
      this.$trace("lsw-filesystem-explorer.methods.processToCreateFile");
      const filename = await this.$lsw.dialogs.open({
        title: "Crear fichero",
        template: `<div>
          <div class="pad_1">
            <div>Ests en la carpeta:</div>
            <div class="pad_2">{{ current_directory }}</div>
            <div>Di el nombre del nuevo fichero:</div>
            <div class="pad_top_1">
              <input class="width_100" type="text" placeholder="myfile.txt" v-model="filename" v-focus v-on:keyup.enter="() => accept(filename)" />
            </div>
          </div>
          <hr />
          <div class="flex_row centered pad_1">
            <div class="flex_100"></div>
            <div class="flex_1 pad_right_1">
              <button class="supermini nowrap danger_button" v-on:click="() => accept(filename)">Crear fichero</button>
            </div>
            <div class="flex_1">
              <button class="supermini nowrap " v-on:click="() => accept(false)">Cancelar</button>
            </div>
          </div>
        </div>`,
        factory: {
          data() {
            return {
              current_directory: this.$lsw.fs.get_current_directory(),
              filename: "",
            };
          },
        },
      });
      if (!filename) return;
      const filepath = this.$lsw.fs.resolve_path(this.$lsw.fs.get_current_directory(), filename);
      await this.$lsw.fs.write_file(filepath, "");
      this.refresh();
    },
    async processToCreateDirectory() {
      this.$trace("lsw-filesystem-explorer.methods.processToCreateDirectory");
      const filename = await this.$lsw.dialogs.open({
        title: "Crear directorio",
        template: `<div>
          <div class="pad_1">
            <div>Ests en la carpeta:</div>
            <div class="pad_2">{{ current_directory }}</div>
            <div>Di el nombre del nuevo directorio:</div>
            <div class="pad_top_1">
              <input class="width_100" type="text" placeholder="myfolder" v-model="filename" v-focus v-on:keyup.enter="() => accept(filename)" />
            </div>
          </div>
          <hr />
          <div class="flex_row centered pad_1">
            <div class="flex_100"></div>
            <div class="flex_1 pad_right_1">
              <button class="supermini nowrap danger_button" v-on:click="() => accept(filename)">S, seguro</button>
            </div>
            <div class="flex_1">
              <button class="supermini nowrap " v-on:click="() => accept(false)">Cancelar</button>
            </div>
          </div>
        </div>`,
        factory: {
          data() {
            return {
              current_directory: this.$lsw.fs.get_current_directory(),
              filename: "",
            };
          },
        },
      });
      if (!filename) return;
      const filepath = this.$lsw.fs.resolve_path(this.$lsw.fs.get_current_directory(), filename);
      await this.$lsw.fs.make_directory(filepath);
      this.refresh();
    },
    async processToDeleteDirectory() {
      this.$trace("lsw-filesystem-explorer.methods.processToDeleteDirectory");
      const confirmation = await this.$lsw.dialogs.open({
        title: "Eliminar directorio",
        template: `<div>
          <div class="pad_1">
            <div>Seguro que quieres eliminar el directorio?</div>
            <div class="pad_2">{{ current_directory }}</div>
          </div>
          <hr />
          <div class="flex_row centered pad_1">
            <div class="flex_100"></div>
            <div class="flex_1 pad_right_1">
              <button class="supermini nowrap danger_button" v-on:click="() => accept(true)">S, seguro</button>
            </div>
            <div class="flex_1">
              <button class="supermini nowrap " v-on:click="() => accept(false)">Cancelar</button>
            </div>
          </div>
        </div>`,
        factory: {
          data: {
            current_directory: this.$lsw.fs.get_current_directory(),
          }
        }
      });
      if (!confirmation) return;
      await this.$lsw.fs.delete_directory(this.$lsw.fs.get_current_directory());
      this.refresh();
    },
    async processToDeleteFile() {
      this.$trace("lsw-filesystem-explorer.methods.processToDeleteFile");
      const confirmation = await this.$lsw.dialogs.open({
        title: "Eliminar fichero",
        template: `<div>
          <div class="pad_1">
            <div>Seguro que quieres eliminar el fichero?</div>
            <div class="pad_2">{{ current_file }}</div>
          </div>
          <hr />
          <div class="flex_row centered pad_1">
            <div class="flex_100"></div>
            <div class="flex_1 pad_right_1">
              <button class="supermini nowrap danger_button" v-on:click="() => accept(true)">S, seguro</button>
            </div>
            <div class="flex_1">
              <button class="supermini nowrap " v-on:click="() => accept(false)">Cancelar</button>
            </div>
          </div>
        </div>`,
        factory: {
          data: {
            current_file: this.current_node,
          }
        }
      });
      if (!confirmation) return;
      await this.$lsw.fs.delete_file(this.current_node);
      const upperDir = (() => {
        const parts = this.current_node.split("/");
        parts.pop();
        return parts.join("/");
      })();
      this.refresh();
    },
    async processToRenameFile() {
      this.$trace("lsw-filesystem-explorer.methods.processToRenameFile");
      const elementType = this.current_node_is_file ? "fichero" : "directorio";
      const newName = await this.$lsw.dialogs.open({
        title: "Renombrar " + elementType,
        template: `<div>
          <div class="pad_1">
            <div>Refirindose al {{ elementType }}:</div>
            <div class="pad_2">{{ filename }}</div>
          </div>
          <div class="pad_1">
            <div>Di el nuevo nombre del {{ elementType }}:</div>
            <div class="pad_top_1">
              <input v-focus class="width_100" type="text" placeholder="Nuevo nombre aqu" v-model="new_filename" v-on:keyup.enter="() => accept(new_filename)" />
            </div>
          </div>
          <hr />
          <div class="flex_row centered">
            <div class="flex_100"></div>
            <div class="flex_1 pad_right_1">
              <button class="supermini nowrap danger_button" v-on:click="() => accept(new_filename)">S, seguro</button>
            </div>
            <div class="flex_1">
              <button class="supermini nowrap " v-on:click="() => accept(false)">Cancelar</button>
            </div>
          </div>
        </div>`,
        factory: {
          data: {
            elementType,
            filename: this.current_node,
            new_filename: this.current_node.split("/").pop(),
          }
        }
      });
      if (newName === false) return;
      if (newName.trim() === "") return;
      const allParts = this.current_node.split("/");
      allParts.pop();
      const dirPath = "/" + allParts.join("/");
      const newFullpath = this.$lsw.fs.resolve_path(dirPath, newName);
      await this.$lsw.fs.rename(this.current_node, newName.replace(/^\/+/g, ""));
      await this.open(newFullpath);
    },
    async processToExecuteFile() {
      this.$trace("lsw-filesystem-explorer.methods.processToExecuteFile");
      const editorContents = this.$refs.editor.getContents();
      const AsyncFunction = (async function () { }).constructor;
      const asyncFunction = new AsyncFunction(editorContents);
      try {
        const result = await asyncFunction.call(this);
        this.$lsw.toasts.debug(result);
      } catch (error) {
        this.$lsw.toasts.showError(error);
      }
    },
    async processToLoadFile() {
      this.$trace("lsw-filesystem-explorer.methods.processToLoadFile");
      this.is_ready = false;
      const contents = await this.$lsw.fs.read_file(this.current_node);
      this.current_node_contents = contents;
      this.$nextTick(() => {
        this.is_ready = true;
      });
    },
    async processToSaveFile() {
      this.$trace("lsw-filesystem-explorer.methods.processToSaveFile");
      try {
        if (!this.$refs.editor) {
          throw new Error("No hay editor ahora mismo");
        }
        const editorContents = this.$refs.editor.getContents();
        await this.$lsw.fs.write_file(this.current_node, editorContents);
        this.$lsw.toasts.send({
          title: "Fichero guardado",
          text: "Hablamos de: " + this.current_node
        });
      } catch (error) {
        this.$lsw.toasts.showError(error);
      }
    },
    _setButtonsForFile() {
      this.$trace("lsw-filesystem-explorer.methods._setButtonsForFile");
      this.is_ready = false;
      this.current_node_is_file = true;
      this.current_node_is_directory = false;
      Setup_panel_top_on_file: {
        this.$refs.panelTop.setButtons({
          text: "",
          classes: "reversed",
          click: () => this.goUp(),
        });
      }
      Setup_panel_right_on_file: {
        const rightButtonsOnFile = [
          {
            text: "",
            click: () => this.processToSaveFile(),
          }, {
            text: "",
            click: () => this.processToRenameFile(),
          }, {
            text: "",
            click: () => this.processToLoadFile(),
          }, {
            text: " ",
            classes: "danger_button",
            click: () => this.processToDeleteFile(),
          }
        ];
        BUTTON_INJECTION_HERE__RIGHT_PANEL: {
          // @INJECTABLE: add custom buttons for extensions:
          Button_to_execute_javascript: {
            if (this.current_node.endsWith(".js")) {
              rightButtonsOnFile.push({
                text: "",
                classes: "danger_button",
                click: () => this.processToExecuteFile(),
              });
            }
          }
          Button_to_compile_markdown_to_html: {
            if (this.current_node.endsWith(".md")) {
              rightButtonsOnFile.push({
                text: "",
                classes: "",
                click: () => this.processToCompileMarkdown(),
              });
            }
          }
          Button_to_compile_pegjs_to_js: {
            if (this.current_node.endsWith(".pegjs")) {
              rightButtonsOnFile.push({
                text: "",
                classes: "",
                click: () => this.processToCompilePegjs(),
              });
            }
          }
          Button_to_format_code: {
            if (this.current_node.endsWith(".html")) {
              rightButtonsOnFile.push({
                text: "{html}",
                classes: "",
                click: () => this.processToFormatHtml(),
              });
            } else if (this.current_node.endsWith(".css")) {
              rightButtonsOnFile.push({
                text: "{css}",
                classes: "",
                click: () => this.processToFormatCss(),
              });
            } else if (this.current_node.endsWith(".js")) {
              rightButtonsOnFile.push({
                text: "{js}",
                classes: "",
                click: () => this.processToFormatJs(),
              });
              if(typeof cordova !== "undefined") {
                rightButtonsOnFile.push({
                  text: "",
                  classes: "",
                  click: () => this.processToExecuteFileOnAndroid(),
                });
              }
            }
          }
          Button_to_download_file: {
            rightButtonsOnFile.push({
              text: "",
              classes: "",
              click: () => this.processToDownloadFile(),
            });
          }
          Button_to_search_replace: {
            rightButtonsOnFile.push({
              text: "",
              classes: "",
              click: () => this.processToSearchReplace(),
            });
          }
          Button_to_validate_code: {
            if(this.hasSyntaxValidator(this.current_node)) {
              rightButtonsOnFile.push({
                text: "",
                classes: "",
                click: () => this.processToValidateCode(),
              });
            }
          }
        }
        this.$refs.panelRight.setButtons(...rightButtonsOnFile);
      }
      Setup_panel_bottom_on_file: {
        const bottomButtonsOnFile = [
          {
            text: "",
            click: () => this.increaseFontsize(),
          }, {
            text: "",
            click: () => this.decreaseFontsize(),
          }, {
            text: "|",
            click: () => this.toggleFontfamily(),
          }
        ];
        BUTTON_INJECTION_HERE__BOTTOM_PANEL: {
          // @INJECTABLE: add custom buttons for extensions:
          Button_to_view_code: {
            if (this.current_node.endsWith(".js")) {
              bottomButtonsOnFile.push({
                text: "",
                click: () => this.openCodeViewerForJs()
              });
            } else if (this.current_node.endsWith(".css")) {
              bottomButtonsOnFile.push({
                text: "",
                click: () => this.openCodeViewerForCss()
              });
            } else if (this.current_node.endsWith(".html")) {
              bottomButtonsOnFile.push({
                text: "",
                click: () => this.openCodeViewerForHtml()
              });
            }
          }
          Button_to_view_html: {
            if (this.current_node.endsWith(".html")) {
              bottomButtonsOnFile.push({
                text: "",
                classes: "",
                click: () => this.processToViewHtml(),
              });
            } else if (this.current_node.endsWith(".md")) {
              bottomButtonsOnFile.push({
                text: "",
                classes: "",
                click: () => this.processToViewMarkdown(),
              });
            }
          }
        }
        this.$refs.panelBottom.setButtons(...bottomButtonsOnFile);
      }
      this.$nextTick(() => {
        this.is_ready = true;
      });
    },
    _setButtonsForDirectory() {
      this.$trace("lsw-filesystem-explorer.methods._setButtonsForDirectory");
      this.is_ready = false;
      this.current_node_is_directory = true;
      this.current_node_is_file = false;
      Setup_panel_top_on_directory: {
        if (this.current_node === "/") {
          this.$refs.panelTop.setButtons();
        } else {
          this.$refs.panelTop.setButtons({
            text: "",
            classes: "reversed",
            click: () => this.goUp(),
          });
        }
      }
      Setup_panel_right_on_directory: {
        this.$refs.panelRight.setButtons({
          text: "+",
          click: () => this.processToCreateFile(),
        }, {
          text: "+",
          click: () => this.processToCreateDirectory(),
        }, {
          text: " ",
          classes: "danger_button",
          click: () => this.processToDeleteDirectory()
        });
      }
      Setup_panel_bottom_on_directory: {
        this.$refs.panelBottom.setButtons();
      }
      this.$nextTick(() => {
        this.is_ready = true;
      });
    },
    increaseFontsize() {
      this.$trace("lsw-filesystem-explorer.methods.increaseFontsize");
      this.$refs.editor.increaseFontsize();
    },
    decreaseFontsize() {
      this.$trace("lsw-filesystem-explorer.methods.decreaseFontsize");
      this.$refs.editor.decreaseFontsize();
    },
    toggleFontfamily() {
      this.$trace("lsw-filesystem-explorer.methods.toggleFontfamily");
      this.$refs.editor.toggleFontfamily();
    },
    async _openFile(subpath) {
      this.$trace("lsw-filesystem-explorer.methods._openFile");
      this.current_node = subpath;
      const contents = await this.$lsw.fs.read_file(this.current_node);
      this.current_node_contents = contents;
      this._setButtonsForFile();
    },
    async _openDirectory(subpath) {
      this.$trace("lsw-filesystem-explorer.methods._openDirectory");
      this.current_node = subpath;
      const subnodes = await this.$lsw.fs.read_directory(this.current_node);
      const sortedSubnodes = {
        files: [],
        folders: []
      };
      Object.keys(subnodes).forEach(id => {
        const subnode = subnodes[id];
        const subnodeType = typeof subnode === "string" ? "files" : "folders";
        sortedSubnodes[subnodeType].push(id);
      });
      const formattedSubnodes = {};
      sortedSubnodes.folders.sort().forEach(folder => {
        formattedSubnodes[folder] = {};
      });
      sortedSubnodes.files.sort().forEach(file => {
        formattedSubnodes[file] = "...";
      });
      console.log(subnodes, formattedSubnodes);
      this.$lsw.fs.change_directory(subpath);
      this.current_node_subnodes = formattedSubnodes;
      this._setButtonsForDirectory();
    },
    __update_node_parts(newValue = this.current_node) {
      this.$trace("lsw-filesystem-explorer.methods.__update_node_parts");
      this.current_node_parts = newValue.split("/").filter(p => p !== "");
    },
    __update_current_node_basename(current_node_parts = this.current_node_parts) {
      this.$trace("lsw-filesystem-explorer.methods.__update_current_node_basename");
      if (current_node_parts.length) {
        this.current_node_basename = current_node_parts[current_node_parts.length - 1];
      } else {
        this.current_node_basename = "/";
      }
    },
    __update_current_node_basedir(current_node_parts = this.current_node_parts) {
      this.$trace("lsw-filesystem-explorer.methods.__update_current_node_basedir");
      if (current_node_parts.length > 1) {
        this.current_node_basedir = "/" + [].concat(current_node_parts).splice(0, current_node_parts.length - 1).join("/") + "/";
      } else {
        this.current_node_basedir = "/";
      }
    },
    _updateNodeSubdata(newValue = this.current_node) {
      this.$trace("lsw-filesystem-explorer.methods._updateNodeSubdata");
      this.__update_node_parts(newValue);
      this.__update_current_node_basename();
      this.__update_current_node_basedir();
    },
    setPanelButtons(panelOptions = {}) {
      this.$trace("lsw-filesystem-explorer.methods.setPanelButtons");
      Validation: {
        if (typeof panelOptions !== "object") {
          throw new Error("Required argument panelOptions to be an object on LswFilesystemExplorer.methods.setPanelButtons");
        }
        const keys = Object.keys(panelOptions);
        if (keys.length === 0) {
          throw new Error("Required argument panelOptions to be have 1 or more keys on LswFilesystemExplorer.methods.setPanelButtons");
        }
        const valid_keys = ["top", "bottom", "left", "right"];
        for (let index = 0; index < keys.length; index++) {
          const key = keys[index];
          if (valid_keys.indexOf(key) === -1) {
            throw new Error(`Required argument panelOptions[${key}] to be a valid key out of ${valid_keys.join(",")}, not ${key} on LswFilesystemExplorer.methods.setPanelButtons`);
          }
          const value = panelOptions[key];
          if (typeof value !== "object") {
            throw new Error(`Required argument panelOptions[${key}] to be an object or array, not ${typeof value} on LswFilesystemExplorer.methods.setPanelButtons`);
          }
        }
      }
    },
    async openCodeViewerForJs() {
      this.$trace("lsw-filesystem-explorer.methods.openCodeViewerForJs");
      console.log(this.current_node_contents);
      this.$lsw.dialogs.open({
        title: "Visualizando cdigo JS",
        template: `
          <div class="pad_1">
            <div class="">{{ file }}:</div>
            <hr />
            <lsw-code-viewer :code="code" language="js" />
          </div>`,
        factory: {
          data: {
            file: this.current_node,
            code: this.$refs.editor.getContents(),
          }
        },
      })
    },
    async openCodeViewerForCss() {
      this.$trace("lsw-filesystem-explorer.methods.openCodeViewerForCss");
      this.$lsw.dialogs.open({
        title: "Visualizando cdigo CSS",
        template: `
          <div class="pad_1">
            <div class="">{{ file }}:</div>
            <hr />
            <lsw-code-viewer :code="code" language="css" />
          </div>`,
        factory: {
          data: {
            file: this.current_node,
            code: this.$refs.editor.getContents(),
          }
        },
      })
    },
    async openCodeViewerForHtml() {
      this.$trace("lsw-filesystem-explorer.methods.openCodeViewerForHtml");
      this.$lsw.dialogs.open({
        title: "Visualizando cdigo HTML",
        template: `
          <div class="pad_1">
            <div class="">{{ file }}:</div>
            <hr />
            <lsw-code-viewer :code="code" language="html" />
          </div>`,
        factory: {
          data: {
            file: this.current_node,
            code: this.$refs.editor.getContents(),
          }
        },
      })
    },
    async processToCompileMarkdown() {
      this.$trace("lsw-filesystem.explorer.methods.processToCompileMarkdown");
      const mdContent = this.$refs.editor.getContents();
      const htmlContent = marked.parse(mdContent);
      const fileoutput = await this.$lsw.dialogs.open({
        title: "Compilar markdown a html",
        template: `
          <div class="pad_1">
            <div>A qu fichero quieres exportar el html? Especifica solo el nombre:</div>
            <!--lsw-sourceable :code="htmlContent"-->
            <input class="width_100" type="text" v-model="value" />
            <hr />
            <div class="flex_row centered">
              <div class="flex_100"></div>
              <div class="flex_1">
                <button class="supermini" v-on:click="accept">Aceptar</button>
              </div>
              <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: {
          data: {
            value: this.current_node.replace(this.current_node_basedir, "").replace(/\.md$/, ".html"),
          }
        }
      });
      if (typeof fileoutput !== "string") {
        return;
      }
      const filepath = this.$lsw.fs.resolve_path(this.current_node_basedir, fileoutput);
      try {
        this.$lsw.fs.write_file(filepath, htmlContent);
        this.$lsw.toasts.send({
          title: "Markdown compilado a HTML",
          text: "La salida est en: " + filepath,
        });
      } catch (error) {
        this.$lsw.toasts.showError(error, false, true);
      }
    },
    async processToCompilePegjs() {
      this.$trace("lsw-filesystem.explorer.methods.processToCompilePegjs");
      const currentFile = this.current_node;
      const pegjsContent = this.$refs.editor.getContents();
      const parserOptions = await this.$lsw.dialogs.open({
        title: "Compilar pegjs a js",
        template: `
          <div class="pad_1">
            <div>Global a la que exportar:</div>
            <input class="width_100" type="text" v-model="value.exportVar" />
            <hr />
            <div>Fichero final:</div>
            <input class="width_100" type="text" v-model="value.output" />
            <hr />
            <div>Formato de exportacin:</div>
            <input class="width_100" type="text" v-model="value.format" />
            <hr />
            <div class="flex_row centered">
              <div class="flex_100"></div>
              <div class="flex_1">
                <button class="supermini" v-on:click="accept">Aceptar</button>
              </div>
              <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: {
          data: {
            value: {
              format: 'globals',
              output: this.current_node.replace(this.current_node_basedir, "").replace(/\.pegjs/g, ".js"),
              exportVar: 'DemoParser',
            }
          }
        }
      });
      if (typeof parserOptions !== "object") return;
      const fileoutput = parserOptions.output;
      const parserFormat = parserOptions.format;
      const parserExporter = parserOptions.exportVar;
      await this.$lsw.lazyLoads.loadPegjs();
      const filepath = this.$lsw.fs.resolve_path(this.current_node_basedir, fileoutput);
      try {
        const jsContent = PEG.buildParser(pegjsContent, {
          output: "source",
          format: parserFormat,
          exportVar: parserExporter,
        });
        this.$lsw.fs.write_file(filepath, jsContent);
        this.$lsw.toasts.send({
          title: "Pegjs compilado a JavaScript",
          text: "La salida est en: " + filepath,
        });
      } catch (error) {
        this.$lsw.toasts.showError(error, false, true);
      }
    },
    async processToFormatHtml() {
      this.$trace("lsw-filesystem.exporer.methods.processToFormatHtml");
      try {
        const input = this.$refs.editor.getContents();
        await this.$lsw.lazyLoads.loadBeautifier();
        const output = beautifier.html(input);
        this.$refs.editor.setContents(output);
      } catch (error) {
        this.$lsw.toasts.showError(error, false, true);
      }
    },
    async processToFormatCss() {
      this.$trace("lsw-filesystem.exporer.methods.processToFormatCss");
      try {
        const input = this.$refs.editor.getContents();
        await this.$lsw.lazyLoads.loadBeautifier();
        const output = beautifier.css(input);
        this.$refs.editor.setContents(output);
      } catch (error) {
        this.$lsw.toasts.showError(error, false, true);
      }
    },
    async processToFormatJs() {
      this.$trace("lsw-filesystem.exporer.methods.processToFormatJs");
      try {
        const input = this.$refs.editor.getContents();
        await this.$lsw.lazyLoads.loadBeautifier();
        const output = beautifier.js(input);
        this.$refs.editor.setContents(output);
        this.$lsw.toasts.send({
          title: "Documento formateado",
          text: "El documento fue formateado en js correctamente"
        });
      } catch (error) {
        this.$lsw.toasts.showError(error, false, true);
      }
    },
    processToExecuteFileOnAndroid() {
      this.$trace("lsw-filesystem.exporer.methods.processToExecuteFileOnAndroid");
      return LswAndroid.evalFile(this.current_node);
    },
    async processToDownloadFile() {
      this.$trace("lsw-filesystem.explorer.methods.processToDownloadFile");
      const filename = this.current_node.replace(this.current_node_basedir, "");
      const confirmation = await this.$lsw.dialogs.open({
        title: "Descargar fichero",
        template: `
          <div class="pad_1">
            <div class="pad_top_1">Qu nombre quieres para el fichero a descargar?</div>
            <input type="text" class="width_100 margin_top_1" v-model="value" /> 
            <hr />
            <div class="flex_row centered pad_top_1">
              <div class="flex_100"></div>
              <div class="flex_1 pad_left_1">
                <button class="supermini danger_button" v-on:click="accept">Aceptar</button>
              </div>
              <div class="flex_1 pad_left_1">
                <button class="supermini " v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>`,
        factory: { data: { value: filename } },
      });
      if (typeof confirmation !== "string") return;
      const filecontents = this.current_node_contents;
      LswUtils.downloadFile(filename, filecontents);
    },
    processToViewHtml() {
      this.$trace("lsw-filesystem.explorer.methods.processToCompilePegjs");
      const htmlContent = this.$refs.editor.getContents();
      return this.$lsw.dialogs.open({
        title: "Ver html en vivo",
        template: `
          <div class="pad_1">
            ${htmlContent}
          </div>
        `,
      });
    },
    processToViewMarkdown() {
      this.$trace("lsw-filesystem.explorer.methods.processToCompilePegjs");
      const mdContent = this.$refs.editor.getContents();
      const htmlContent = marked.parse(mdContent);
      return this.$lsw.dialogs.open({
        title: "Ver markdown en vivo",
        template: `
          <div class="pad_1">
            ${htmlContent}
          </div>
        `,
      });
    },
    async processToSearchReplace() {
      this.$trace("lsw-filesystem.explorer.methods.processToSearchReplace");
      let selectedText = "";
      Extract_selected_text: {
        try {
          const textareaHtml = this.$refs.editor.$refs.editorTextarea;
          selectedText = textareaHtml.value.substring(textareaHtml.selectionStart, textareaHtml.selectionEnd);
        } catch (error) {
          // @BADLUCK
          console.log(error);
        }
      }
      const fse = this;
      const value = await this.$lsw.dialogs.open({
        title: "Buscar y reemplazar",
        template: `
          <lsw-search-replacer
            :input="input"
            :initial-search="search"
            :initial-replace="replace"
            :on-accept="out => accept(out)"
            :on-cancel="comeBack"
          />
        `,
        factory: {
          data: {
            input: this.$refs.editor.getContents(),
            search: selectedText,
            replace: selectedText,
          },
          methods: {
            comeBack() {
              this.cancel();
              fse.$refs.editor.gainFocus();
            }
          }
        }
      });
      if (typeof value !== "string") return;
      this.$refs.editor.setContents(value);
    },
    processToValidateCode() {
      this.$trace("lsw-filesystem.explorer.methods.processToValidateCode");
      const currentContents = this.$refs.editor.getContents();
      const syntaxExtensions = Object.keys(this.syntaxValidators).map(id => "." + id);
      let associatedSyntax = undefined;
      Iterating_syntaxes:
      for (let index = 0; index < syntaxExtensions.length; index++) {
        const syntaxExtension = syntaxExtensions[index];
        const isSyntaxCompliant = this.current_node.endsWith(syntaxExtension);
        if (isSyntaxCompliant) {
          associatedSyntax = syntaxExtension;
          break Iterating_syntaxes;
        }
      }
      if (!associatedSyntax) {
        return -1;
      }
      const associatedValidator = this.syntaxValidators[associatedSyntax];
      if (!associatedValidator) {
        return -2;
      }
      try {
        const isValid = associatedValidator(currentContents);
        this.$lsw.toasts.debug(isValid);
      } catch (error) {
        this.$lsw.toasts.showError(error);
      }
    },
    async loadSyntaxValidators() {
      this.$trace("lsw-filesystem-explorer.methods.loadSyntaxValidators");
      const validatorsAsMap = await this.$lsw.fs.read_directory("/kernel/editor/validators");
      const ids = Object.keys(validatorsAsMap).map(f => f.replace(/\.js/g, ""));
      const allValidators = {};
      for(let index=0; index<ids.length; index++) {
        const id = ids[index];
        const validator = await this.$lsw.fs.evaluateAsJavascriptFileOrReturn(`/kernel/editor/validators/${id}.js`, () => true);
        allValidators[id] = validator;
      }
      this.syntaxValidators = allValidators;
      
    },
    hasSyntaxValidator(file) {
      const currentExtension = file.replace(/^([^.]*\.)+/g, "");
      return Object.keys(this.syntaxValidators || {}).indexOf(currentExtension) !== -1;
    },
  },
  watch: {
    current_node(newValue) {
      this.$trace("lsw-filesystem-explorer.watch.current_node");
      this._updateNodeSubdata(newValue);
    }
  },
  computed: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-filesystem-explorer.mounted");
      await this.loadSyntaxValidators();
      this.$lsw.fsExplorer = this;
      // await this.initializeFilesystemForLsw();
      await this.open(this.openedBy ?? "/");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswFilesystemExplorer API

// @vuebundler[Lsw_framework_components][85]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-explorer/lsw-filesystem-explorer.css

// @vuebundler[Lsw_framework_components][86]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-buttons-panel/lsw-filesystem-buttons-panel.html

// @vuebundler[Lsw_framework_components][86]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-buttons-panel/lsw-filesystem-buttons-panel.js
// @code.start: LswFilesystemButtonsPanel API | @$section: Vue.js (v2) Components  Lsw Filesystem Explorer API  LswFilesystemButtonsPanel component
Vue.component("LswFilesystemButtonsPanel", {
  name: "LswFilesystemButtonsPanel",
  template: `<div class="lsw_filesystem_buttons_panel">
    <div class="buttons_panel centered" :class="'flex_' + orientation + ' orientation_' + orientation">
        <div class="button_cell flex_1" v-for="button, buttonIndex in buttons" v-bind:key="'button_index_' + buttonIndex">
            <button class="mini nowrap" :class="button.classes || ''" v-on:click="button.click">{{ button.text }}</button>
        </div>
        <div class="flex_100"></div>
    </div>
</div>`,
  props: {
    explorer: {
      type: Object,
      required: true
    },
    orientation: {
      type: String,
      default: () => "row" // could be "column" too
    }
  },
  data() {
    return {
      buttons: []
    };
  },
  watch: {

  },
  methods: {
    setButtons(...buttons) {
      this.$trace("lsw-filesystem-buttons-panel.methods.prependButtons");
      this.buttons = buttons;
    },
    prependButtons(...buttons) {
      this.$trace("lsw-filesystem-buttons-panel.methods.prependButtons");
      this.buttons = buttons.concat(this.buttons);
    },
    appendButtons(...buttons) {
      this.$trace("lsw-filesystem-buttons-panel.methods.appendButtons");
      this.buttons = this.buttons.concat(buttons);
    },
  },
  mounted() {

  }
});
// @code.end: LswFilesystemButtonsPanel API

// @vuebundler[Lsw_framework_components][86]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-buttons-panel/lsw-filesystem-buttons-panel.css

// @vuebundler[Lsw_framework_components][87]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-editor/lsw-filesystem-editor.html

// @vuebundler[Lsw_framework_components][87]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-editor/lsw-filesystem-editor.js
// @code.start: LswFilesystemEditor API | @$section: Vue.js (v2) Components  Lsw Filesystem Explorer API  LswFilesystemEditor component
Vue.component("LswFilesystemEditor", {
  name: "LswFilesystemEditor",
  template: `<div class="lsw_filesystem_editor">
    <textarea class="editor"
        :style="{
            fontSize: currentFontsize + 'px',
            fontFamily: currentFontfamily
        }"
        v-model="contents"
        spellcheck="false"
        ref="editorTextarea"
        v-on:keydown.ctrl.enter.prevent="executeDocument"
        v-on:keydown.ctrl.m.prevent="executeMobileDocument"
        v-on:keydown.ctrl.s.prevent="saveDocument"
        v-on:keydown.ctrl.b.prevent="beautifyDocument"
        v-on:keydown.ctrl.f.prevent="searchReplace"
        v-on:input="synchronizeCursor"
        v-on:keyup="synchronizeCursor"
        v-on:click="synchronizeCursor"
        v-on:select="synchronizeCursor"
        v-on:focus="synchronizeCursor" />
    <div class="position_absolute editor_position_box"
        style="top:auto; left:auto; right: 10px; bottom: 10px;"
        v-if="cursorPosition">
        {{ cursorPosition.start.line }}:{{ cursorPosition.start.column }}-{{ cursorPosition.end.line }}:{{ cursorPosition.end.column }}|{{ cursorPosition.start.offset }}-{{ cursorPosition.end.offset }}
    </div>
</div>`,
  props: {
    explorer: {
      type: Object,
      required: true
    },
    filecontents: {
      type: String,
      required: true
    },
  },
  data() {
    return {
      contents: this.filecontents,
      cursorPosition: false,
      currentFontsize: 12,
      currentFontfamily: "Arial"
    };
  },
  watch: {

  },
  methods: {
    getContents() {
      return this.contents;
    },
    setContents(contents) {
      this.contents = contents;
    },
    gainFocus() {
      this.$refs.editorTextarea.focus();
    },
    increaseFontsize() {
      this.$trace("lsw-filesystem-editor.methods.increaseFontsize");
      this.currentFontsize++;
    },
    decreaseFontsize() {
      this.$trace("lsw-filesystem-editor.methods.decreaseFontsize");
      this.currentFontsize--;
    },
    toggleFontfamily() {
      this.$trace("lsw-filesystem-editor.methods.toggleFontfamily");
      if(this.currentFontfamily === "monospace") {
        this.currentFontfamily = "Arial";
      } else {
        this.currentFontfamily = "monospace";
      }
    },
    async saveDocument() {
      this.$trace("lsw-filesystem-editor.methods.saveDocument");
      await this.$lsw.fs.write_file(this.explorer.current_node, this.contents);
      this.$lsw.toasts.send({
        title: "Documento guardado",
        text: "El documento se guard correctamente"
      });
    },
    async executeDocument() {
      this.$trace("lsw-filesystem-editor.methods.executeDocument");
      if(this.explorer.current_node.endsWith(".js")) {
        Ejecutar_javascript_asincronamente: {
          this.explorer.processToExecuteFile();
        }
      }
    },
    async executeMobileDocument() {
      this.$trace("lsw-filesystem-editor.methods.executeMobileDocument");
      if(this.explorer.current_node.endsWith(".js")) {
        Ejecutar_javascript_asincronamente: {
          this.explorer.processToExecuteFileOnAndroid();
        }
      }
    },
    beautifyDocument() {
      this.$trace("lsw-filesystem-editor.methods.beautifyDocument");
      const fsExplorer = LswDom.getClosestParent(this.$el, ".lsw_filesystem_explorer");
      if(!fsExplorer) return;
      LswDom.querySelectorFirst("button", "{js}", fsExplorer).click();
    },
    searchReplace() {
      this.$trace("lsw-filesystem-editor.methods.searchReplace");
      const fsExplorer = LswDom.getClosestParent(this.$el, ".lsw_filesystem_explorer");
      if(!fsExplorer) return;
      LswDom.querySelectorFirst("button", "", fsExplorer).click();
    },
    synchronizeCursor() {
      this.$trace("lsw-filesystem-editor.methods.synchronizeCursor");
      const editorHtml = this.$refs.editorTextarea;
      const offsetStart = editorHtml.selectionStart
      const offsetEnd = editorHtml.selectionEnd;
      let lineStart = undefined;
      let lineEnd = undefined;
      let columnStart = undefined;
      let columnEnd = undefined;
      Col_start: {
        const beforeCursor = editorHtml.value.slice(0, offsetStart);
        const lines = beforeCursor.split("\n");
        lineStart = lines.length - 1;
        columnStart = lines[lines.length - 1].length;
      }
      Col_end: {
        const beforeCursor = editorHtml.value.slice(0, offsetEnd);
        const lines = beforeCursor.split("\n");
        lineEnd = lines.length - 1;
        columnEnd = lines[lines.length - 1].length;
      }
      const cursor = {
        start: {
          offset: offsetStart,
          line: lineStart,
          column: columnStart,
        },
        end: {
          offset: offsetEnd,
          line: lineEnd,
          column: columnEnd,
        }
      };
      this.cursorPosition = cursor;
      return cursor;
    }
  },
  mounted() {

  }
});
// @code.end: LswFilesystemEditor API

// @vuebundler[Lsw_framework_components][87]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-editor/lsw-filesystem-editor.css

// @vuebundler[Lsw_framework_components][88]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-treeviewer/lsw-filesystem-treeviewer.html

// @vuebundler[Lsw_framework_components][88]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-treeviewer/lsw-filesystem-treeviewer.js
// @code.start: LswFilesystemTreeviewer API | @$section: Vue.js (v2) Components  Lsw Filesystem Explorer API  LswFilesystemTreeviewer component
Vue.component("LswFilesystemTreeviewer", {
  name: "LswFilesystemTreeviewer",
  template: `<div class="lsw_filesystem_treeviewer">
    <table class="filesystem_treeviewer_table width_100">
        <thead style="display: none;"></thead>
        <tbody>
            <tr v-if="explorer.current_node !== '/'"
                class="treeviewer_row"
                v-on:click="() => goUp()">
                <td class="icon_cell"></td>
                <td>
                    <a class="filename_link" href="javascript:void(0)">..</a>
                </td>
                <td></td>
                <td>
                    <button class="supermini" style="visibility: hidden;" v-on:click="() => deleteNode(subnodeIndex)"></button>
                </td>
            </tr>
            <template v-for="subnode, subnodeIndex, subnodeCounter in explorer.current_node_subnodes">
                <tr class="treeviewer_row"
                    v-bind:key="'subnode_obj_' + subnodeIndex">
                    <template v-if="typeof subnode === 'object'">
                        <td v-on:click="() => openSubnode(subnodeIndex)" class="icon_cell"></td>
                        <td v-on:click="() => openSubnode(subnodeIndex)">
                            <a class="filename_link" href="javascript:void(0)"><b>{{ subnodeIndex }}</b></a>
                        </td>
                        <td style="padding: 2px;">
                            <button class="supermini nowrap" v-on:click="() => renameNode(subnodeIndex)"></button>
                        </td>
                        <td style="padding: 2px;">
                            <button class="supermini danger_button nowrap" v-on:click="() => deleteNode(subnodeIndex)"> </button>
                        </td>
                    </template>
                    <template v-else-if="typeof subnode === 'string'">
                        <td v-on:click="() => openSubnode(subnodeIndex)" class="icon_cell"></td>
                        <td v-on:click="() => openSubnode(subnodeIndex)">
                            <a class="filename_link" href="javascript:void(0)">{{ subnodeIndex }}</a>
                        </td>
                        <td style="padding: 2px;">
                            <button class="supermini nowrap" v-on:click="() => renameNode(subnodeIndex)"></button>
                        </td>
                        <td style="padding: 2px;">
                            <button class="supermini danger_button nowrap" v-on:click="() => deleteNode(subnodeIndex)"> </button>
                        </td>
                    </template>
                </tr>
            </template>
        </tbody>
    </table>

</div>`,
  props: {
    explorer: {
      type: Object,
      required: true
    }
  },
  data() {
    this.$trace("lsw-filesystem-treeviewer.data");
    return {};
  },
  watch: {},
  methods: {
    goUp() {
      this.$trace("lsw-filesystem-treeviewer.methods.goUp");
      return this.explorer.goUp();
    },
    openSubnode(subnodeIndex) {
      this.$trace("lsw-filesystem-treeviewer.methods.openSubnode");
      return this.explorer.open(subnodeIndex);
    },
    async deleteNode(subnodeIndex) {
      this.$trace("lsw-filesystem-treeviewer.methods.deleteNode");
      const fullpath = this.$lsw.fs.resolve_path(subnodeIndex);
      const isDirectory = await this.$lsw.fs.is_directory(fullpath);
      const elementType = isDirectory ? 'directorio' : 'fichero';
      const confirmation = await this.$lsw.dialogs.open({
        title: `Proceder a eliminar ${elementType}`,
        template: `
          <div class="pad_1">
            <div>Seguro que quieres eliminar el {{ elementType }} {{ fullpath }}?</div>
            <hr />
            <div class="flex_row centered">
              <div class="flex_100"></div>
              <div class="flex_1 pad_right_1">
                <button class="supermini danger_button nowrap" v-on:click="() => accept(true)">S, eliminar</button>
              </div>
              <div class="flex_1">
                <button class="supermini" v-on:click="() => accept(false)">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: {
          data: {
            elementType,
            fullpath,
          }
        }
      });
      if (!confirmation) return;
      try {
        if (isDirectory) {
          await this.$lsw.fs.delete_directory(fullpath);
        } else {
          await this.$lsw.fs.delete_file(fullpath);
        }
        await this.explorer.refresh();
      } catch (error) {
        await this.$lsw.dialogs.open({
          title: `El fichero no se pudo eliminar`,
          template: `
            <div class="pad_1">
              <div>El fichero {{ fullpath }} no se pudo eliminar debido al siguiente error:</div>
              <hr />
              <div v-if="error">{{ error.name }}: {{ error.message }}</div>
            </div>
          `,
          factory: {
            data: {
              error,
              fullpath,
            }
          }
        });
      }
    },
    async renameNode(subnodeIndex) {
      this.$trace("lsw-filesystem-treeviewer.methods.renameNode");
      const fullpath = this.$lsw.fs.resolve_path(subnodeIndex);
      const isDirectory = await this.$lsw.fs.is_directory(fullpath);
      const elementType = isDirectory ? 'directorio' : 'fichero';
      const newName = await this.$lsw.dialogs.open({
        title: "Renombrar " + elementType,
        template: `<div>
          <div class="pad_1">
            <div>Refirindose al {{ elementType }}:</div>
            <div class="pad_2">{{ filename }}</div>
            <div>Di el nuevo nombre del {{ elementType }}:</div>
            <input v-focus class="width_100" type="text" v-model="newFilename" v-on:keyup.enter="() => accept(newFilename)" />
          </div>
          <hr />
          <div class="flex_row centered pad_1">
            <div class="flex_100"></div>
            <div class="flex_1 pad_right_1">
              <button class="supermini" v-on:click="() => accept(newFilename)">Renombrar</button>
            </div>
            <div class="flex_1">
              <button class="supermini" v-on:click="() => accept(false)">Cancelar</button>
            </div>
          </div>
        </div>`,
        factory: {
          data: {
            elementType,
            fullpath,
            filename: subnodeIndex,
            newFilename: subnodeIndex,
          }
        }
      });
      if (typeof newName !== "string") return;
      if (newName.trim() === "") return;
      await this.$lsw.fs.rename(subnodeIndex, newName.replace(/^\/+/g, ""));
      this.explorer.refresh();
    }
  },
  mounted() {
    this.$trace("lsw-filesystem-treeviewer.mounted");
    this.explorer.setPanelButtons({
      top: [],
      left: [],
      right: [],
      bottom: [],
    })
  },
  unmounted() {
    this.$trace("lsw-filesystem-treeviewer.unmounted");
  }
});
// @code.end: LswFilesystemTreeviewer API

// @vuebundler[Lsw_framework_components][88]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-treeviewer/lsw-filesystem-treeviewer.css

// @vuebundler[Lsw_framework_components][89]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-libros/lsw-wiki-libros.html

// @vuebundler[Lsw_framework_components][89]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-libros/lsw-wiki-libros.js
// @code.start: LswWikiLibros API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswWikiLibros component
Vue.component("LswWikiLibros", {
  name: "LswWikiLibros",
  template: `<div class="lsw_wiki_libros">
    <div class="">
        <template v-for="libro, libroIndex in libros">
            <div class=""
                v-bind:key="'libro_boton_' + libroIndex">
                <div class="flex_row" :class="libroIndex === 0 ? '' : ''">
                    <div class="flex_100 list_buttons">
                        <button class="supermini list_button width_100 text_align_left"
                            v-on:click="() => toggleLibro(libro)"
                            :class="{activated: selectedLibros.indexOf(libro) !== -1}">
                            <div class="flex_row">
                                <div class="flex_100">{{ getLibroName(libro) }}</div>
                            </div>
                        </button>
                    </div>
                    <div class="flex_1 pad_left_1">
                        <button class="supermini list_button width_100 text_align_left"
                            v-on:click="() => printLibro(libro)">
                            <div class="flex_row">
                                <div class="flex_100 small_font"></div>
                            </div>
                        </button>
                    </div>
                    <div class="flex_1 pad_left_1">
                        <button class="supermini list_button width_100 text_align_left"
                            v-on:click="() => editLibro(libro)">
                            <div class="flex_row">
                                <div class="flex_100 small_font"></div>
                            </div>
                        </button>
                    </div>
                </div>
                <div class="pad_vertical_1" v-if="selectedLibros.indexOf(libro) !== -1">
                    <div class="" v-if="libro in loadedLibros">
                        <lsw-wiki-libro-viewer :arbol="loadedLibros[libro]" :indice-de-arbol="0" :on-click-link="abrirArticulo">
                            <template v-slot:default="{ arbol }">
                                <lsw-wiki-articulo-viewer :articulo-id="arbol.link || arbol.id" />
                            </template>
                        </lsw-wiki-libro-viewer>
                    </div>
                </div>
            </div>
        </template>
    </div>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-wiki-libros.data");
    return {
      selectedLibros: [],
      selectedLibroInfos: [],
      loadedLibros: {},
      libros: false,
    };
  },
  methods: {
    async toggleLibro(libroId) {
      this.$trace("LswWikiLibros.methods.loadLibros");
      const pos = this.selectedLibros.indexOf(libroId);
      if(pos === -1) {
        await this.loadLibro(libroId);
        this.selectedLibros.push(libroId);
      } else {
        this.selectedLibros.splice(pos, 1);
      }
      this.$forceUpdate(true);
    },
    async toggleLibroInfo(libroId) {
      this.$trace("LswWikiLibros.methods.toggleLibroInfo");
      const pos = this.selectedLibroInfos.indexOf(libroId);
      if(pos === -1) {
        this.selectedLibroInfos.push(libroId);
      } else {
        this.selectedLibroInfos.splice(pos, 1);
      }
      this.$forceUpdate(true);
    },
    async loadLibro(libroId) {
      this.$trace("LswWikiLibros.methods.loadLibro");
      const libroData = await this.$lsw.fs.evaluateAsTripiFileOrReturn(`/kernel/wiki/libros/${libroId}`, false);
      if(!libroData) return;
      this.loadedLibros[libroId] = libroData;
      return libroData;
    },
    async loadLibros() {
      this.$trace("LswWikiLibros.methods.loadLibros");
      const librosBrute = await LswWikiUtils.getLibros();
      this.libros = librosBrute;
    },
    getLibroName(file) {
      this.$trace("LswWikiLibros.methods.getLibroName");
      return file.replace(/\.tri(pi)?/g, "")
    },
    async abrirArticulo(articulo, componenteDeArticulo) {
      this.$trace("LswWikiLibros.methods.abrirLibro");
      console.log("Abriendo artculo:", articulo.link);
      componenteDeArticulo.toggleState();
    },
    async editLibro(libro) {
      this.$trace("LswWikiLibros.methods.editLibro");
      await this.$lsw.dialogs.open({
        id: LswRandomizer.getRandomString(10),
        title: "Editar libro",
        template: `
          <lsw-filesystem-explorer
            :absolute-layout="true"
            :opened-by="'/kernel/wiki/libros/' + libro"
          />
        `,
        factory: {
          data: { libro }
        }
      });
    },
    async printLibro(libroId) {
      this.$trace("LswWikiLibros.methods.printLibro");
      const libroTree = await this.loadLibro(libroId);
      const libroTexted = await this.resolveLibroTree(libroTree)
      await this.$lsw.dialogs.open({
        id: LswRandomizer.getRandomString(10),
        title: "Imprimir libro",
        template: `
          <lsw-data-printer-report :input="libro" />
        `,
        factory: {
          data: { libro: libroTexted }
        }
      });
    },
    async resolveLibroTree(treeNode) {
      this.$trace("LswWikiLibros.methods.resolveLibroTree");
      if(typeof treeNode === "undefined") {
        return "";
      }
      let out = "";
      const { id, link, subtree } = treeNode;
      const reference = id || link;
      const articulosCoincidentes = await this.$lsw.database.selectMany("Articulo", articulo => {
        return articulo.tiene_titulo === reference;
      });
      out += `### ${id}\n\n`;
      if(articulosCoincidentes && articulosCoincidentes.length) {
        const articuloTextualizado = articulosCoincidentes.map(articulo => articulo.tiene_contenido).join("\n\n");
        out += `${articuloTextualizado || ""}\n\n`;
      }
      if(typeof subtree === "object") {
        for(let prop in subtree) {
          out += await this.resolveLibroTree(subtree[prop]);
        }
      }
      return out;
    },
  },
  watch: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-wiki-libros.mounted");
      await this.loadLibros();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswWikiLibros API

// @vuebundler[Lsw_framework_components][89]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-libros/lsw-wiki-libros.css

// @vuebundler[Lsw_framework_components][90]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-libro-viewer/lsw-wiki-libro-viewer.html

// @vuebundler[Lsw_framework_components][90]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-libro-viewer/lsw-wiki-libro-viewer.js
// @code.start: LswWikiLibroViewer API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswWikiLibroViewer component
Vue.component("LswWikiLibroViewer", {
  name: "LswWikiLibroViewer",
  template: `<div class="lsw_wiki_libro_viewer" :class="{}">
    <div class="flex_row centered list_buttons" v-if="indiceDeArbol !== 0" :style="'padding-left: ' + ((idHeredado.length-1)*8) + 'px;'">
        <div class="flex_100 list_button"
            :class="{activated: isSelected}"
            v-on:click="() => abrirLink(arbol)">
            {{ indiceDeArbol }}. {{arbol.id}}
        </div>
        <div class="flex_1 list_button cursor_pointer linkable_button margin_left_1"
            style="min-width: 25px; min-height: 20px; padding-top: 4px; padding-left: 7px; display: none;"
            v-on:click="() => abrirClip(arbol)">
            
        </div>
    </div>
    <div class="flex_row" v-if="isShowingTree">
        <pre class="codeblock">{{ arbol }}</pre>
    </div>
    <div class="flex_row" v-if="isShowingDefinition">
        <pre class="codeblock">{{ arbol.definition }}</pre>
    </div>
    <div v-if="isSelected">
        <slot :arbol="arbol" />
    </div>
    <template v-if="arbol.subtree">
        <div class=""
            v-for="subnode, subnodeIndex in arbol.subtree"
            v-bind:key="'subnode_' + subnodeIndex">
            <lsw-wiki-libro-viewer
                :arbol="subnode"
                :indice-de-arbol="subnodeIndex+1"
                :on-click-clip="onClickClip"
                :on-click-link="onClickLink"
                :id-heredado="getIdFor(subnode)">
                <slot :arbol="subnode" />
            </lsw-wiki-libro-viewer>
        </div>
    </template>
</div>`,
  props: {
    idHeredado: {
      type: Array,
      default: () => [],
    },
    indiceDeArbol: {
      type: Number,
      default: () => 0,
    },
    arbol: {
      type: Object,
      required: true,
    },
    onClickLink: {
      type: [Boolean, Function],
      default: () => false,
    },
    onClickClip: {
      type: Function,
      default: () => {},
    }
  },
  data() {
    this.$trace("lsw-wiki-libro-viewer.data");
    return {
      isSelected: false,
      isShowingTree: false,
      isShowingDefinition: false,
    };
  },
  methods: {
    getIdFor(node) {
      this.$trace("lsw-wiki-libro-viewer.methods.getIdFor");
      const lastPartId = node.id || node.link;
      return [].concat(this.idHeredado).concat([lastPartId]);
    },
    toggleState() {
      this.$trace("lsw-wiki-libro-viewer.methods.toggleState");
      this.isSelected = !this.isSelected;
    },
    toggleTree() {
      this.$trace("lsw-wiki-libro-viewer.methods.toggleTree");
      this.isShowingTree = !this.isShowingTree;
    },
    toggleDefinition() {
      this.$trace("lsw-wiki-libro-viewer.methods.toggleDefinition");
      this.isShowingDefinition = !this.isShowingDefinition;
    },
    abrirLink(nodo) {
      this.$trace("lsw-wiki-libro-viewer.methods.abrirLink");
      if(this.onClickLink) {
        this.onClickLink(nodo, this);
      } else {
        this.toggleState();
      }
    },
    abrirClip(nodo) {
      this.$trace("lsw-wiki-libro-viewer.methods.abrirClip");
      this.onClickClip(nodo, this);
    }
  },
  watch: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-wiki-libro-viewer.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswWikiLibroViewer API

// @vuebundler[Lsw_framework_components][90]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-libro-viewer/lsw-wiki-libro-viewer.css

// @vuebundler[Lsw_framework_components][91]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-articulos/lsw-wiki-articulos.html

// @vuebundler[Lsw_framework_components][91]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-articulos/lsw-wiki-articulos.js
// @code.start: LswWikiArticulos API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswWikiArticulos component
Vue.component("LswWikiArticulos", {
  name: "LswWikiArticulos",
  template: `<div class="lsw_wiki_articulos">
    <div class="flex_row centered">
        <div class="flex_100">
            <input class="width_100 wiki_buscador_texto"
                style="min-height: 42px;"
                v-model="searchText"
                type="text"
                placeholder="Buscar en artculos"
                v-on:keyup="loadArticulosDelayed"
                v-on:keyup.enter="loadArticulos" />
        </div>
        <div class="flex_1 pad_left_1">
            <button v-on:click="loadArticulos"></button>
        </div>
        <div class="flex_1 pad_left_1">
            <button v-on:click="createArticulo"></button>
        </div>
    </div>
    <div class="pad_top_1">
        <div class="caja_de_mensaje_sobre_articulos">
            <div class=""
                v-if="isSearching">
                Buscando artculos...
            </div>
            <div class=""
                v-else-if="!articulos">
                No se alcanzaron a encontrar los artculos.
            </div>
            <div class=""
                v-else-if="!articulos.length">
                No se encontraron artculos segn la bsqueda.
            </div>
            <div class=""
                v-else-if="articulos.length !== 1">
                Se encontraron {{ articulos.length }} artculos coincidentes.
            </div>
            <div class=""
                v-else-if="articulos.length === 1">
                Se encontr {{ articulos.length }} artculo coincidente.
            </div>
        </div>
    </div>
    <div class="list_buttons articulos_box"
        v-if="articulos && articulos.length">
        <template v-for="articulo, articuloIndex in articulos">
            <div class="articulo_box"
                v-bind:key="'articulo_de_wiki_' + articulo.id">
                <div class="flex_row centered pad_top_min">
                    <button class="supermini list_button width_100"
                        :class="{activated: openedArticulos.indexOf(articulo.id) !== -1}"
                        v-on:click="() => toggleArticulo(articulo.id)">
                        <div class="flex_column">
                            <div class="flex_1 flex_row centered min_height_14px">
                                <div class="flex_100 shortable_text text_align_left">
                                    {{ articulo.tiene_titulo }}
                                </div>
                                <div class="flex_1 smallest_font nowrap secondary_text_color pad_left_1 pad_right_1 text_align_right"
                                    style="border-left: 1px solid white; max-width: 90px;">
                                    {{ articulo.tiene_fecha }}
                                </div>
                                <div class="flex_1 smallest_font nowrap secondary_text_color pad_left_1"
                                    style="border-left: 1px solid white; min-width: 25px;">
                                    {{ articulo.tiene_contenido?.length }}B
                                </div>
                            </div>
                        </div>
                    </button>
                    <button class="supermini margin_left_1"
                        v-on:click="() => editArticulo(articulo)"></button>
                </div>
                <div class="pad_top_1"
                    v-if="openedArticulos.indexOf(articulo.id) !== -1">
                    <div class="position_relative">
                        <div class="position_absolute top_0 right_0 flex_row centered pad_top_1 pad_right_1">
                            <div class="flex_100"></div>
                            <div class="flex_1">
                                <button class="supermini" v-on:click="() => sendArticuloToNotas(articulo)"></button>
                            </div>
                            <div class="flex_1 pad_left_1">
                                <button class="supermini" v-on:click="() => deleteArticulo(articulo)"></button>
                            </div>
                            <div class="flex_1 pad_left_1">
                                <button class="supermini" v-on:click="() => editArticulo(articulo)"></button>
                            </div>
                        </div>
                        <div class="articulo_detalles texto_markdown rutiner_box pad_1 min_height_33px">
                            <div v-html="marked.parse(articulo.tiene_contenido)"></div>
                        </div>
                    </div>
                </div>
                <div class="articulo_categorias_box" v-if="articulo.tiene_categorias">
                    <div> {{ articulo.tiene_categorias }}</div>
                </div>
            </div>
        </template>
    </div>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-wiki-articulos.data");
    return {
      articulos: false,
      isSearching: false,
      searchText: "",
      timeoutId: undefined,
      timeoutSeconds: 0.4,
      openedArticulos: [],
    };
  },
  methods: {
    async loadArticulos() {
      this.$trace("lsw-wiki-articulos.methods.loadArticulos");
      clearTimeout(this.searchTimeoutId);
      this.isSearching = true;
      const articulos = await (() => {
        if(this.searchText) {
          return this.$lsw.database.selectMany("Articulo", articulo => {
            return JSON.stringify(articulo).indexOf(this.searchText) !== -1;
          });
        } else {
          return this.$lsw.database.selectMany("Articulo");
        }
      })();
      const articulosOrdenados = articulos.sort((a1, a2) => {
        const f1 = a1.tiene_fecha || 0;
        const f2 = a2.tiene_fecha || 0;
        if(f1 < f2) return 1;
        if(f1 > f2) return -1;
        return -1;
      });
      this.openedArticulos = [];
      this.articulos = articulosOrdenados;
      this.isSearching = false;
    },
    loadArticulosDelayed() {
      this.$trace("lsw-wiki-articulos.methods.loadArticulosDelayed");
      clearTimeout(this.searchTimeoutId);
      this.isSearching = true;
      this.searchTimeoutId = setTimeout(() => {
        this.loadArticulos();
      }, 1000 * this.timeoutSeconds);
    },
    toggleArticulo(articuloId) {
      this.$trace("lsw-wiki-articulos.methods.toggleArticulo");
      const pos = this.openedArticulos.indexOf(articuloId);
      if(pos === -1) {
        this.openedArticulos.push(articuloId);
      } else {
        this.openedArticulos.splice(pos, 1);
      }
    },
    async createArticulo() {
      this.$trace("lsw-wiki-articulos.methods.createArticulo");
      const articulosComponent = this;
      await this.$dialogs.open({
        id: LswRandomizer.getRandomString(10),
        title: "Crear nuevo artculo",
        template: `
          <div>
            <lsw-schema-based-form
              :on-submit="submitCallback"
              :model="{
                  connection: $lsw.database,
                  databaseId: 'lsw_default_database',
                  tableId: 'Articulo',
                  rowId: -1,
              }"
            />
          </div>
        `,
        factory: {
          methods: {
            async submitCallback(value) {
              try {
                this.$trace("Dialogs.CrearNuevoArticulo.methods.submitCallback");
                await this.$lsw.database.insert("Articulo", value);
                await this.$lsw.toasts.send({
                  title: "Artculo aadido correctamente",
                  text: "El artculo ha sido aadido con xito."
                });
                this.close();
                articulosComponent.loadArticulos();
              } catch (error) {
                console.log(error);
                await this.$lsw.toasts.send({
                  title: "Error al aadir artculo",
                  text: "No se pudo aadir el artculo por un error: " + error.message,
                  background: "red",
                });
              }

            }
          }
        }
      })
    },
    async editArticulo(articulo) {
      this.$trace("lsw-wiki-articulos.methods.editArticulo");
      const articulosComponent = this;
      await this.$lsw.dialogs.open({
        title: "Editar artculo",
        template: `
          <div>
            <lsw-schema-based-form
              :show-breadcrumb="false"
              :on-submit="(value) => submitCallback(value)"
              :on-delete-row="deleteCallback"
              :model="{
                  connection: $lsw.database,
                  databaseId: 'lsw_default_database',
                  tableId: 'Articulo',
                  rowId: articuloId,
              }"
            />
          </div>
        `,
        factory: {
          data: { articuloId: articulo.id },
          methods: {
            async submitCallback(value) {
              this.$trace("Dialogs.EditarArticulo.methods.submitCallback");
              try {
                await this.$lsw.database.update("Articulo", this.articuloId, value);
                await this.$lsw.toasts.send({
                  title: "Artculo actualizado correctamente",
                  text: "El artculo ha sido actualizado con xito."
                });
                this.close();
                articulosComponent.loadArticulos();
              } catch (error) {
                console.log(error);
                await this.$lsw.toasts.send({
                  title: "Error al actualizar artculo",
                  text: "No se pudo actualizar el artculo por un error: " + error.message,
                  background: "red",
                });
              }
            },
            async deleteCallback() {
              this.$trace("Dialogs.EditarArticulo.methods.deleteCallback");
              this.close();
              articulosComponent.loadArticulos();
              await this.$lsw.toasts.send({
                title: "Artculo eliminado correctamente",
                text: "El artculo se elimin con xito.",
              });
            }
          }
        }
      });
      this.loadArticulos();
    }, 
    async deleteArticulo(articulo) {
      this.$trace("lsw-wiki-articulos.methods.deleteArticulo");
      const articulosComponent = this;
      const respuesta = await this.$lsw.dialogs.open({
        title: "Eliminar artculo",
        template: `
          <div class="pad_2">
            <div class="">Ests seguro que quieres eliminar el artculo?</div>
            <pre class="codeblock margin_top_2 margin_bottom_2">{{ articulo }}</pre>
            <hr />
            <div class="flex_row centered">
              <div class="flex_100"></div>
              <div class="flex_1 pad_right_1">
                <button class="flex_1" v-on:click="() => accept(true)">Aceptar</button>
              </div>
              <div class="flex_1">
                <button class="flex_1 " v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: {
          data: { articulo },
          methods: {}
        }
      });
      if(respuesta !== true) return;
      await this.$lsw.database.delete("Articulo", articulo.id);
      this.$lsw.toasts.send({
        title: "Artculo eliminado correctamente",
        text: "El artculo fue eliminado correctamente"
      });
      this.loadArticulos();
    },
    async sendArticuloToNotas(articulo) {
      this.$trace("lsw-spontaneous-table-nota.methods.sendArticuloToNotas");
      const respuesta = await this.$lsw.dialogs.open({
        title: "Pasar artculo a notas",
        template: `
          <div class="pad_1">
            <div>Vas a pasar el siguiente artculo a nota: </div>
            <div class="pad_2">
              <pre class="codeblock">{{ articulo }}</pre>
            </div>
            <div>Ests seguro?</div>
            <hr/>
            <div class="flex_row centered text_align_right">
              <div class="flex_100"></div>
              <div class="flex_1 pad_right_1">
                <button class="supermini danger_button" v-on:click="accept">Aceptar</button>
              </div>
              <div class="flex_1">
                <button class="supermini" v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: { data: { articulo } },
      });
      if(respuesta === -1) return;
      const notaNew = Object.assign({
        tiene_titulo: '',
        tiene_fecha: '',
        tiene_estado: "creada",
        tiene_categorias: '',
        tiene_contenido: '',
        tiene_garantia: '',
        tiene_tags: '',
      }, articulo);
      delete notaNew.id;
      await this.$lsw.database.insert("Nota", notaNew);
      await this.$lsw.database.delete("Articulo", articulo.id);
      this.$lsw.toasts.send({
        title: "Artculo a nota bien",
        text: "El artculo ha sido pasado a nota correctamente",
      });
      this.loadArticulos();
    }
  },
  watch: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-wiki-articulos.mounted");
      await this.loadArticulos();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswWikiArticulos API

// @vuebundler[Lsw_framework_components][91]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-articulos/lsw-wiki-articulos.css

// @vuebundler[Lsw_framework_components][92]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-categorias/lsw-wiki-categorias.html

// @vuebundler[Lsw_framework_components][92]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-categorias/lsw-wiki-categorias.js
// @code.start: LswWikiCategorias API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswWikiCategorias component
Vue.component("LswWikiCategorias", {
  name: "LswWikiCategorias",
  template: `<div class="lsw_wiki_categorias">
    <div class="">
        <lsw-wiki-libro-viewer :arbol="categorias" :indice-de-arbol="0" :on-click-link="abrirCategoria">
            <template v-slot:default="{ arbol }">
                {{ arbol }}
                <!--lsw-wiki-articulo-viewer :articulo-id="arbol.link" /-->
            </template>
        </lsw-wiki-libro-viewer>
    </div>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-wiki-categorias.data");
    return {
      categorias: false,
    };
  },
  methods: {
    async loadCategorias() {
      this.$trace("LswWikiCategorias.methods.loadCategorias");
      this.categorias = await LswWikiUtils.getCategorias();
    },
    async abrirCategoria(categoria) {
      this.$trace("LswWikiCategorias.methods.abrirCategoria");
      const articulosCategorizados = await this.$lsw.database.selectMany("Articulo", articulo => {
        return articulo.tiene_categorias.indexOf(categoria.id) !== -1;
      })
      console.log(categoria);
      this.$lsw.dialogs.open({
        id: LswRandomizer.getRandomString(10),
        title: "Ver categora: " + categoria.id,
        template: `
          <div>
            <lsw-database-explorer
              :show-breadcrumb="false"
              initial-page="lsw-page-rows"
              :initial-args="{
                database: 'lsw_default_database',
                table: 'Articulo',
                tableStorageId: 'categoria-' + categoriaId,
                filterCallback: it => it.tiene_categorias && (it.tiene_categorias.toLowerCase().indexOf(categoriaId.toLowerCase()) !== -1),
              }"
            />
          </div>
        `,
        factory: {
          data: { categoriaId: categoria.id, articulosCategorizados }
        }
      });
    }
  },
  watch: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-wiki-categorias.mounted");
      await this.loadCategorias();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswWikiCategorias API

// @vuebundler[Lsw_framework_components][92]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-categorias/lsw-wiki-categorias.css

// @vuebundler[Lsw_framework_components][93]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-articulo-viewer/lsw-wiki-articulo-viewer.html

// @vuebundler[Lsw_framework_components][93]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-articulo-viewer/lsw-wiki-articulo-viewer.js
// @code.start: LswWikiArticuloViewer API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswWikiArticuloViewer component
Vue.component("LswWikiArticuloViewer", {
  name: "LswWikiArticuloViewer",
  template: `<div class="lsw_wiki_articulo_viewer">
    <div class="pad_2" v-if="error">
        {{ error.name }}: {{ error.message }}
    </div>
    <template v-if="isLoaded">
        <template v-if="selectedArticulos && selectedArticulos.length">
            <div class="pad_2">
                <div v-for="articulo, articuloIndex in selectedArticulos" v-bind:key="'articulo_' + articuloIndex">
                    - Mostrando artculo {{ articuloIndex + 1 }}. {{ articulo.tiene_titulo }}
                </div>
            </div>
            <div class="pad_2 pad_top_0" v-if="markdownContent">
                <div class="texto_markdown rutiner_box pad_1" v-html="markdownContent"></div>
            </div>
        </template>
    </template>
</div>`,
  props: {
    articuloId: {
      type: [Number, String],
      required: true,
    }
  },
  data() {
    this.$trace("lsw-wiki-articulo-viewer.data");
    return {
      isLoaded: false,
      selectedArticulos: false,
      markdownContent: false,
      error: false,
    };
  },
  methods: {
    setError(error) {
      this.$trace("lsw-wiki-articulo-viewer.methods.setError");
      this.error = error;
    },
    async loadContent() {
      this.$trace("lsw-wiki-articulo-viewer.methods.loadContent");
      const matchedRows = await this.$lsw.database.selectMany("Articulo", articulo => {
        return articulo.tiene_titulo === this.articuloId;
      });
      console.log("[*] Artculos coincidentes:", matchedRows);
      try {
        if(matchedRows.length === 0) {
          throw new Error(`Articulo no encontrado por ${this.articuloId}`);
        } else if(matchedRows.length === 1) {
          this.markdownContent = marked.parse(matchedRows[0].tiene_contenido);
        } else {
          this.markdownContent = matchedRows.map(row => marked.parse(row.tiene_contenido)).join("\n\n----\n\n");
        }
        this.selectedArticulos = matchedRows;
      } catch (error) {
        console.log("[*] Error loading articulo:", error);
        this.setError(error);
      } finally {
        this.isLoaded = true;
      }
    }
  },
  watch: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-wiki-articulo-viewer.mounted");
      await this.loadContent();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswWikiArticuloViewer API

// @vuebundler[Lsw_framework_components][93]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-articulo-viewer/lsw-wiki-articulo-viewer.css

// @vuebundler[Lsw_framework_components][94]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-revistas/lsw-wiki-revistas.html

// @vuebundler[Lsw_framework_components][94]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-revistas/lsw-wiki-revistas.js
// @code.start: LswWikiRevistas API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswWikiRevistas component
Vue.component("LswWikiRevistas", {
  name: "LswWikiRevistas",
  template: `<div class="lsw_wiki_revistas">
    <pre class="codeblock">{{ revistas }}</pre>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-wiki-revistas.data");
    return {
      revistas: false,
    };
  },
  methods: {
    async loadRevistas() {
      this.$trace("lsw-wiki.methods.loadRevistas");
      this.revistas = await LswWikiUtils.getRevistas();
    },
  },
  watch: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-wiki-revistas.mounted");
      await this.loadRevistas();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswWikiRevistas API

// @vuebundler[Lsw_framework_components][94]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-revistas/lsw-wiki-revistas.css

// @vuebundler[Lsw_framework_components][95]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-tree/lsw-wiki-tree.html

// @vuebundler[Lsw_framework_components][95]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-tree/lsw-wiki-tree.js
// @code.start: LswWikiTree API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswWikiTree component
Vue.component("LswWikiTree", {
  name: "LswWikiTree",
  template: `<div class="lsw_wiki_tree">
    <div v-for="node, nodeIndex in treeData"
        v-bind:key="'tree_node_' + nodeIndex">
        
        <button v-on:click="() => toggleNode(nodeIndex)">{{ nodeIndex }}</button>
        <div class="subtree" v-if="selectedNodes.indexOf(nodeIndex) !== -1">
            <lsw-wiki-treenode initial-input="node" />
        </div>
    </div>
</div>`,
  props: {
    initialInput: {
      type: Array,
      default: () => [],
    },
    initialSettings: {
      type: Object,
      default: () => {},
    }
  },
  data() {
    this.$trace("lsw-wiki-tree.data");
    const initialData = this.validateInput(this.initialInput || {});
    return {
      selectedNodes: [],
      treeData: initialData,
    };
  },
  methods: {
    validateInput(jsonTree) {
      this.$trace("LswWikiTree.methods.validateInput");
      $ensure({ jsonTree }, 1).to.be.array().its("length").type("number");
      return jsonTree;
    },
    toggleNode(nodeId) {
      this.$trace("LswWikiTree.methods.toggleNode");
      const pos = this.selectedNodes.indexOf(nodeId);
      if(pos === -1) {
        this.selectedNodes.push(nodeId);
      } else {
        this.selectedNodes.splice(nodeId, 1);
      }
    }
  },
  watch: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-wiki-tree.mounted");
      
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswWikiTree API

// @vuebundler[Lsw_framework_components][95]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-tree/lsw-wiki-tree.css

// @vuebundler[Lsw_framework_components][96]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-treenode/lsw-wiki-treenode.html

// @vuebundler[Lsw_framework_components][96]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-treenode/lsw-wiki-treenode.js
// @code.start: LswWikiTreenode API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswWikiTreenode component
Vue.component("LswWikiTreenode", {
  name: "LswWikiTreenode",
  template: `<div class="lsw_wiki_treenode">
    <div class=""
        v-for="node, nodeIndex in treeNode"
        v-bind:key="'treenode_' + nodeIndex">
        <div>{{ nodeIndex }}</div>
        <div>{{ node }}</div>
    </div>
</div>`,
  props: {
    initialInput: {
      type: Array,
      default: () => [],
    },
    initialSettings: {
      type: Object,
      default: () => {},
    }
  },
  data() {
    this.$trace("lsw-wiki-treenode.data");
    return {
      treeNode: this.initialInput || [],
    };
  },
  methods: {
    
  },
  watch: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-wiki-treenode.mounted");
      
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswWikiTreenode API

// @vuebundler[Lsw_framework_components][96]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-treenode/lsw-wiki-treenode.css

// @vuebundler[Lsw_framework_components][97]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki/lsw-wiki.html

// @vuebundler[Lsw_framework_components][97]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki/lsw-wiki.js
// @code.start: LswWiki API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswWiki component
Vue.component("LswWiki", {
  name: "LswWiki",
  template: `<div class="lsw_wiki">
    <div class="typical_title_1">
        <div class="flex_row centered">
            <div class="flex_100"> Enciclopedia:</div>
            <div class="flex_1">
                <div class="pad_left_1">
                    <button :class="{activated: selectedSection === 'libros'}"
                        class="supermini"
                        v-on:click="() => selectSection('libros')"> </button>
                </div>
            </div>
            <div class="flex_1">
                <div class="pad_left_1">
                    <button :class="{activated: selectedSection === 'categorias'}"
                        class="supermini"
                        v-on:click="() => selectSection('categorias')"></button>
                </div>
            </div>
            <div class="flex_1">
                <div class="pad_left_1">
                    <button :class="{activated: selectedSection === 'articulos'}"
                        class="supermini"
                        v-on:click="() => selectSection('articulos')"></button>
                </div>
            </div>
            <div class="flex_1">
                <div class="pad_left_1">
                    <button class="supermini"
                        v-on:click="() => goToAddArticulo()"></button>
                </div>
            </div>
        </div>
    </div>
    <hr />
    <div class="wiki_libros"
        v-if="selectedSection === 'libros'">
        <lsw-book-factory />
    </div>
    <div class="wiki_categorias"
        v-else-if="selectedSection === 'categorias'">
        <div class="typical_title_1">
            <div class="flex_row centered">
                <div class="flex_100"> Categoras</div>
                <div class="flex_1 pad_left_1">
                    <button class="supermini"
                        v-on:click="refreshCategorias"></button>
                </div>
                <div class="flex_1 pad_left_1">
                    <button class="supermini"
                        v-on:click="openCategoriasFile"></button>
                </div>
            </div>
        </div>
        <div class="pad_top_1">
            <lsw-wiki-categorias v-if="isLoadedCategorias" />
        </div>
    </div>
    <div class="wiki_articulos"
        :class="{esta_buscando:isSearching}"
        v-else-if="selectedSection === 'articulos'">
        <div class="typical_title_1">
            <div class="flex_row centered">
                <div class="flex_100"> Artculos</div>
                <div class="flex_1">
                    <button class="supermini visibility_hidden"
                        v-on:click="refreshArticulos"></button>
                </div>
            </div>
        </div>
        <div class="pad_top_1">
            <lsw-wiki-articulos />
        </div>
    </div>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-wiki.data");
    return {
      isSearching: true,
      isShowingNavigation: false,
      isLoadedLibros: true,
      isLoadedCategorias: true,
      selectedSection: 'articulos',
    };
  },
  methods: {
    selectSection(section) {
      this.$trace("lsw-wiki.methods.selectSection");
      this.selectedSection = section;
      this.isShowingNavigation = false;
    },
    toggleNavigation() {
      this.$trace("lsw-wiki.methods.toggleNavigation");
      this.isShowingNavigation = !this.isShowingNavigation;
    },
    hideNavigation() {
      this.$trace("lsw-wiki.methods.hideNavigation");
      this.isShowingNavigation = false;
    },
    openLibrosFolder() {
      this.$trace("lsw-wiki.methods.openLibrosFolder");
      this.$lsw.dialogs.open({
        id: LswRandomizer.getRandomString(10),
        title: "Todos los libros",
        template: `
          <lsw-filesystem-explorer
            :absolute-layout="true"
            opened-by="/kernel/wiki/libros"
          />
        `
      });
    },
    openCategoriasFile() {
      this.$trace("lsw-wiki.methods.openCategoriasFile");
      this.$lsw.dialogs.open({
        id: LswRandomizer.getRandomString(10),
        title: "Todas las categoras",
        template: `
          <lsw-filesystem-explorer
            :absolute-layout="true"
            opened-by="/kernel/wiki/categorias.tri"
          />
        `
      });
    },
    refreshLibros() {
      this.$trace("lsw-wiki.methods.refreshLibros");
      this.isLoadedLibros = false;
      setTimeout(() => {
        this.isLoadedLibros = true;
      }, 100);
    },
    refreshCategorias() {
      this.$trace("lsw-wiki.methods.refreshCategorias");
      this.isLoadedCategorias = false;
      setTimeout(() => {
        this.isLoadedCategorias = true;
      }, 100);
    },
    refreshRevistas() {
      this.$trace("lsw-wiki.methods.refreshRevistas");
    },
    refreshBuscador() {
      this.$trace("lsw-wiki.methods.refreshBuscador");
    },
    refreshArticulos() {
      this.$trace("lsw-wiki.methods.refreshArticulos");
    },
    goToAddArticulo() {
      this.$trace("lsw-wiki.methods.goToAddArticulo");
      this.$lsw.dialogs.open({
        title: "Aadir nuevo artculo",
        template: `<lsw-spontaneous-form-articulo :on-submitted="closeAndRefresh" />`,
        factory: {
          methods: {
            closeAndRefresh() {
              this.close();
              // @DONT because maybe you have something in hands.
            }
          }
        },
      });
    }
  },
  watch: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-wiki.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswWiki API

// @vuebundler[Lsw_framework_components][97]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki/lsw-wiki.css

// @vuebundler[Lsw_framework_components][98]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki-utils/lsw-wiki-utils.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswWikiUtils'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswWikiUtils'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  class LswWikiUtils {
    
    static async getCategorias() {
      Vue.prototype.$trace("LswWikiUtils.getCategorias");
      const categoriasTree = await Vue.prototype.$lsw.fs.evaluateAsTripiFileOrReturn("/kernel/wiki/categorias.tri", {});
      return categoriasTree;
    }

    static async getLibros() {
      Vue.prototype.$trace("LswWikiUtils.getLibros");
      const libros = await Vue.prototype.$lsw.fs.read_directory("/kernel/wiki/libros");
      return Object.keys(libros);
    }

    static async getLibro(libroId) {
      Vue.prototype.$trace("LswWikiUtils.getLibro");
      const libroAst = await Vue.prototype.$lsw.fs.evaluateAsTripiFileOrReturn(`/kernel/wiki/libros/${libroId}`, false);
      return libroAst;
    }

    static async getRevistas() {
      Vue.prototype.$trace("LswWikiUtils.getRevistas");
      const allCategorias = await this.getCategorias();
      const allArticulos = await Vue.prototype.$lsw.database.selectMany("Articulo");
      // @TODO:
      // ...
      // agrupar por semanas los articulos
      // segn categoras principales
      // ...
      return [];
    }

  }

  return LswWikiUtils;

});

// @vuebundler[Lsw_framework_components][99]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-book-factory/lsw-book-factory.html

// @vuebundler[Lsw_framework_components][99]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-book-factory/lsw-book-factory.js
// @code.start: LswBookFactory API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswBookFactory component
Vue.component("LswBookFactory", {
  template: `<div class="lsw_book_factory">
    <div class="typical_title_1">
        <div class="flex_row centered">
            <div class="flex_100">
                 Libros disponibles:
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini"
                    v-on:click="loadTitles">
                    
                </button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini"
                    v-on:click="openLibrosDirectory">
                    
                </button>
            </div>
        </div>
    </div>
    <table class="width_100"
        v-if="titles && titles.length">
        <tbody>
            <tr class=""
                v-for="title, titleIndex in titles"
                v-bind:key="'title_' + titleIndex">
                <td>
                    <button class="supermini"
                        v-on:click="() => openLibro(title)">
                        
                    </button>
                </td>
                <td>
                    <button class="supermini"
                        v-on:click="() => editLibro(title)">
                        
                    </button>
                </td>
                <td>{{ titleIndex + 1 }}.</td>
                <td class="width_100">{{ title }}</td>
            </tr>
        </tbody>
    </table>
    <div class="" v-else>
        No hay libros disponibles actualmente.
    </div>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-book-factory.data");
    return {
      titles: [],
    };
  },
  methods: {
    async loadTitles() {
      this.$trace("lsw-book-factory.methods.loadTitles");
      const librosMap = await this.$lsw.fs.read_directory("/kernel/wiki/libros");
      this.titles = Object.keys(librosMap);
      // await LswLazyLoads.loadEjs();
    },
    openLibrosDirectory() {
      this.$trace("lsw-book-factory.methods.openLibrosDirectory");
      this.$lsw.dialogs.open({
        title: "Directorio de libros",
        template: `<lsw-filesystem-explorer opened-by="/kernel/wiki/libros" />`,
      });
    },
    editLibro(title) {
      this.$trace("lsw-book-factory.methods.editLibro");
      this.$lsw.dialogs.open({
        title: "Editar libro",
        template: `<lsw-filesystem-explorer :opened-by="'/kernel/wiki/libros/' + title" />`,
        factory: {
          data: {
            title,
          }
        }
      });
    },
    async openLibro(title) {
      this.$trace("lsw-book-factory.methods.openLibro");
      const originalSource = await this.$lsw.fs.read_file(`/kernel/wiki/libros/${title}`);
      const source = originalSource;
      this.$lsw.dialogs.open({
        title: "Leer libro",
        template: `
          <div class="pad_1">
            <lsw-markdown-viewer :source="source" :activate-ejs="true" />
          </div>
        `,
        factory: {
          data: {
            source,
          }
        }
      });
    },
  },
  async mounted() {
    this.$trace("lsw-book-factory.mounted");
    await this.loadTitles();
  },
  unmount() {
    this.$trace("lsw-book-factory.unmount");
  }
});
// @code.end: LswBookFactory API

// @vuebundler[Lsw_framework_components][99]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-book-factory/lsw-book-factory.css

// @vuebundler[Lsw_framework_components][100]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-book-library/lsw-book-library.html

// @vuebundler[Lsw_framework_components][100]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-book-library/lsw-book-library.js
// @code.start: LswBookLibrary API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswBookLibrary component
Vue.component("LswBookLibrary", {
  template: `<div class="lsw_book_library">
    lsw-book-library
</div>`,
  props: {},
  data() {
    this.$trace("lsw-book-library.data");
    return {};
  },
  methods: {},
  mounted() {
    this.$trace("lsw-book-library.mounted");
  },
  unmount() {
    this.$trace("lsw-book-library.unmount");
  }
});
// @code.end: LswBookLibrary API

// @vuebundler[Lsw_framework_components][100]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-book-library/lsw-book-library.css

// @vuebundler[Lsw_framework_components][101]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-markdown-viewer/lsw-markdown-viewer.html

// @vuebundler[Lsw_framework_components][101]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-markdown-viewer/lsw-markdown-viewer.js
// @code.start: LswMarkdownViewer API | @$section: Vue.js (v2) Components  LswMarkdownViewer component
Vue.component("LswMarkdownViewer", {
  template: `<div class="lsw_markdown_viewer">
    <div class="">
        <lsw-error-box v-if="parsingEjsError" :error="parsingEjsError" context="Error parseando EJS" />
        <lsw-error-box v-if="parsingMarkdownError" :error="parsingMarkdownError" context="Error parseando Markdown" />
        <div v-if="output">
            <lsw-sourceable :source="'<div>' + output + '</div>'" />
        </div>
    </div>
</div>`,
  props: {
    source: {
      type: String,
      required: true,
    },
    activateEjs: {
      type: Boolean,
      default: () => false,
    },
  },
  data() {
    this.$trace("lsw-markdown-viewer.data");
    return {
      parsingEjsError: false,
      parsingMarkdownError: false,
      output: false,
    };
  },
  methods: {
    async buildSource() {
      this.$trace("lsw-markdown-viewer.methods.buildSource");
      await LswLazyLoads.loadEjs();
      let sourceTransformed = this.source;
      Render_ejs: {
        if (this.activateEjs) {
          try {
            sourceTransformed = await ejs.render(sourceTransformed, {
              component: this
            }, {
              async: true,
            });
          } catch (error) {
            console.log(error);
            this.parsingEjsError = error;
            throw error;
          }
        }
      }
      Render_markdown: {
          try {
            sourceTransformed = await marked.parse(sourceTransformed);
          } catch (error) {
            console.log(error);
            this.parsingMarkdownError = error;
            throw error;
          }
      }
      this.output = sourceTransformed;
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-markdown-viewer.mounted");
      await this.buildSource();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswMarkdownViewer API

// @vuebundler[Lsw_framework_components][101]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-markdown-viewer/lsw-markdown-viewer.css

// @vuebundler[Lsw_framework_components][102]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-microdata-explorer/lsw-microdata-explorer.html

// @vuebundler[Lsw_framework_components][102]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-microdata-explorer/lsw-microdata-explorer.js
// @code.start: LswMicrodataExplorer API | @$section: Vue.js (v2) Components  Lsw Wiki API  LswMicrodataExplorer component
Vue.component("LswMicrodataExplorer", {
  template: `<div class="lsw_microdata_explorer">
    lsw-microdata-explorer
</div>`,
  props: {},
  data() {
    this.$trace("lsw-microdata-explorer.data");
    return {};
  },
  methods: {},
  mounted() {
    this.$trace("lsw-microdata-explorer.mounted");
  },
  unmount() {
    this.$trace("lsw-microdata-explorer.unmount");
  }
});
// @code.end: LswMicrodataExplorer API

// @vuebundler[Lsw_framework_components][102]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-microdata-explorer/lsw-microdata-explorer.css

// @vuebundler[Lsw_framework_components][103]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-clockwatcher/lsw-clockwatcher.html

// @vuebundler[Lsw_framework_components][103]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-clockwatcher/lsw-clockwatcher.js
// @code.start: LswClockwatcher API | @$section: Vue.js (v2) Components  Lsw Windows API  LswClockwatcher component
// Change this component at your convenience:
Vue.component("LswClockwatcher", {
  template: `<div class="clockwatcher_component">
    <div class="clockwatcher_layer_1">
        <div class="clockwatcher_layer_2">
            <div>{{ LswTimer.utils.formatDatestringFromDate(currentDate, false, true, false || false, true) }}</div>
            <div class="clock_message" v-if="currentMessage">{{ currentMessage }}</div>
        </div>
    </div>
</div>`,
  props: {
    viewer: {
      type: Object,
      required: true
    }
  },
  data() {
    this.$trace("lsw-clockwatcher.data");
    return {
      currentDate: new Date(),
      currentMessage: false,
    };
  },
  methods: {
    onClick(event) {
      this.$trace("lsw-clockwatcher.methods.onClick");
      this.viewer.toggleState();
    },
    startTimer() {
      this.$trace("lsw-clockwatcher.methods.startTimer");
      this.timerId = setTimeout(() => {
        this.currentDate = new Date();
        this.startTimer();
      }, 1000 * 60);
    },
    stopTimer() {
      this.$trace("lsw-clockwatcher.methods.stopTimer");
      clearTimeout(this.timerId);
    },
    async loadMessage() {
      this.$trace("lsw-clockwatcher.methods.loadMessage");
      try {
        const userPreferences = await this.$lsw.fs.evaluateAsDotenvFileOrReturn('/kernel/settings/user.env', {});
        const clockMessage = userPreferences["app.clock_message"] || false;
        this.currentMessage = clockMessage;
      } catch (error) {
        // @OK.
        console.error("[!] Could not load preference app.clock_message from clockwatcher:", error);
      }
    }
  },
  mounted() {
    this.$trace("lsw-clockwatcher.mounted");
    this.startTimer();
    this.loadMessage();
  },
  unmount() {
    this.$trace("lsw-clockwatcher.unmounted");
    this.stopTimer();
  }
});
// @code.end: LswClockwatcher API

// @vuebundler[Lsw_framework_components][103]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-clockwatcher/lsw-clockwatcher.css

// @vuebundler[Lsw_framework_components][104]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-goals-viewer/lsw-goals-api.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswGoals'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswGoals'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswGoals class | @section: Lsw Goals API  LswGoals class

  const LocalUtilities = class {

  };

  const LswGoals = class {

    static async getGoalsReport(someDate = new Date()) {
      Vue.prototype.$trace("lsw-goals-viewer.methods.getGoalsReport");
      let originalGoals = undefined;
      // @HISTORICAL:
      Previous_goals_setter: {
        break Previous_goals_setter;
        const parsedLinesPromise = Vue.prototype.$lsw.fs.evaluateAsDotenvListFileOrReturn("/kernel/settings/goals.env", []);
        const parsedLines = await parsedLinesPromise;
        // 1. Get original goals:
        const previousOriginalGoals = parsedLines.map(line => {
          const [concept, condition = "> 0", urgency = "0"] = line.split(/\|/g).map(item => {
            return item.trim();
          });
          return { line, concept, condition, urgency };
        });
        originalGoals = previousOriginalGoals;
      }
      // @CURRENT:
      Current_goals_setter: {
        originalGoals = await Vue.prototype.$lsw.fs.evaluateAsWeekFileOrReturn("/kernel/goals/goals.week", []);
      }
      // 2. Get today's completed actions:
      const todayCompletedActions = await this.getSomeDayActions(someDate, false, "completada");
      const formattedGoals = [];
      const insertedGoals = [];
      // 3. Expand goals:
      Iterating_goals:
      for (let indexGoal = 0; indexGoal < originalGoals.length; indexGoal++) {
        try {
          const originalGoal = originalGoals[indexGoal];
          const {
            type: goalType,
            concept,
            condition,
            urgency,
            from: goalBegin,
            to: goalEnd
          } = originalGoal;
          const isRequire = goalType === "REQ";
          const isSet = goalType === "SET";
          const datestring = LswTimer.utils.fromDateToDatestring(someDate);
          // Filtros de fecha:
          if (goalBegin !== "*") {
            if (datestring < goalBegin) {
              continue Iterating_goals;
            }
          }
          if (goalEnd !== "*") {
            if (datestring > goalEnd) {
              continue Iterating_goals;
            }
          }
          // Aplica cambios en cada caso:
          if (isSet) {
            // Solo si es en un rango de 20 das antes o despus:
            const today = new Date();
            const maxBefore = new Date(today);
            maxBefore.setDate(maxBefore.getDate() - 1);
            const maxLater = new Date(today);
            maxLater.setDate(maxLater.getDate() + 1);
            const isInRange = (someDate > maxBefore) && (someDate < maxLater);
            if(!isInRange) {
              continue Iterating_goals;
            }
            console.log(originalGoal);
            const duration = originalGoal.duration || "1h";
            const hour = originalGoal.hour || "00";
            const minute = originalGoal.minute || "00";
            const weekday = originalGoal.weekday;
            const isAnyWeekday = weekday === "*";
            const currentWeekday = this.fromDateToWeekday(someDate);
            if(!isAnyWeekday && (currentWeekday !== weekday)) {
              continue Iterating_goals;
            }
            const currDatestring = LswTimer.utils.fromDateToDatestring(someDate, true);
            const fullDatestring = `${currDatestring} ${hour}:${minute}`;
            const matchedAcciones = await Vue.prototype.$lsw.database.select("Accion", acc => {
              const sameConcept = acc.en_concepto === concept;
              const sameMinute = acc.tiene_inicio.startsWith(fullDatestring);
              return sameConcept && sameMinute;
            });
            if(matchedAcciones.length === 1) {
              continue Iterating_goals;
            }
            No_haremos_el_insert_aqui: {
              const isToday = LswTimer.utils.areSameDayDates(today, someDate);
              if(!isToday) {
                break No_haremos_el_insert_aqui;
              }
              await Vue.prototype.$lsw.database.insert("Accion", {
                en_concepto: concept,
                tiene_estado: "pendiente",
                tiene_inicio: fullDatestring,
                tiene_duracion: duration,
                tiene_parametros: "[*goal]",
                tiene_resultados: "",
                tiene_comentarios: "",
              });
              insertedGoals.push(`${concept}@${fullDatestring}`);
            }
            continue Iterating_goals;
          } else if (isRequire) {
            const formattedGoal = {};
            const formattedConcept = this.formatConcept(concept);
            const formattedCondition = this.formatCondition(condition, formattedConcept);
            const formattedUrgency = this.formatUrgency(urgency);
            formattedGoal.concept = formattedConcept;
            Object.assign(formattedGoal, formattedCondition(todayCompletedActions));
            formattedGoal.urgency = formattedUrgency;
            formattedGoals.push(formattedGoal);
          }
        } catch (error) {
          console.log(error);
        }
      }
      const sortedGoals = [].concat(formattedGoals).sort((g1, g2) => {
        try {
          const u1 = g1.urgency || 0;
          const u2 = g2.urgency || 0;
          const c1 = g1.filledAsint || 0;
          const c2 = g2.filledAsint || 0;
          const g1over = c1 > 100;
          const g2over = c2 > 100;
          if (g2over) return -1;
          if (g1over) return 1;
          if (u1 > u2) return -1;
          if (u1 < u2) return 1;
          if (c1 < c2) return -1;
          if (c1 > c2) return 1;
          return 0;
        } catch (error) {
          console.log(error);
        }
      });
      if(insertedGoals.length) {
        Vue.prototype.$lsw.toasts.debug(insertedGoals);
      }
      return {
        goals: sortedGoals,
        actions: todayCompletedActions
      };
    }

    static fromDateToWeekday(date) {
      const weekdayNum = date.getDay();
      if(weekdayNum === 0) {
        return "dom";
      } else if(weekdayNum === 1) {
        return "lun";
      } else if(weekdayNum === 2) {
        return "mar";
      } else if(weekdayNum === 3) {
        return "mie";
      } else if(weekdayNum === 4) {
        return "jue";
      } else if(weekdayNum === 5) {
        return "vie";
      } else if(weekdayNum === 6) {
        return "sab";
      }
    }

    static $appliesRange(rangeStart, rangeEnd, date) {
      Vue.prototype.$trace("lsw-goals-viewer.methods.$appliesRange");
      if (rangeStart === "*") {
        if (rangeEnd === "*") {
          return true;
        } else {
          return rangeEnd >= date;
        }
      } else if (rangeStart <= date) {
        if (rangeEnd === "*") {
          return true;
        } else {
          return rangeEnd >= date;
        }
      }
      return true;
    }

    static formatConcept(txt) {
      return txt;
    }

    static formatCondition(originalTxt, concept) {
      const isMin = originalTxt.startsWith(">");
      const op = originalTxt.trim().match(/(\<|\>)(=)?/g);
      const opCorrected = op.length === 1 ? op + "=" : op;
      const txt = originalTxt.replace(/(\<|\>)(=)?/g, "")
      const isTimes = this.isConditionByTimes(txt);
      const isDuration = this.isConditionByDuration(txt);
      if ((!isTimes) && (!isDuration)) {
        throw new Error(`Condition ${txt} must be a number or a durationstring on LswGoals.formatCondition`);
      }
      const referenceValue = isTimes ? parseInt(txt) : LswTimer.utils.fromDurationstringToMilliseconds(txt);
      return completedActions => {
        const conclusion = {};
        conclusion.type = isTimes ? "by times" : isDuration ? "by duration" : undefined;
        conclusion.expectedAs = isMin ? "minimum" : "maximum";
        conclusion.expectedAsAbbr = isMin ? "min" : "max";
        const matchedActions = [];
        Collect_matched_actions:
        for (let index = 0; index < completedActions.length; index++) {
          const acc = completedActions[index];
          const sameConcept = acc.en_concepto === concept;
          const isCompleted = acc.tiene_estado === "completada"; // Redundante, pero bueno.
          if (sameConcept && isCompleted) {
            matchedActions.push(acc);
          }
        }
        Expand_data: {
          conclusion.currentTimes = matchedActions.length;
          conclusion.currentDurationInms = matchedActions.reduce((total, acc) => {
            try {
              total += LswTimer.utils.fromDurationstringToMilliseconds(acc.tiene_duracion || "0min");
            } catch (error) {
              console.log(error);
            }
            return total;
          }, 0);
          conclusion.currentDuration = LswTimer.utils.fromMillisecondsToDurationstring(conclusion.currentDurationInms) || "0min";
        }
        Apply_proper_filters: {
          if (isTimes) {
            const expectedTimes = referenceValue;
            conclusion.expectedTimes = expectedTimes;
            const evaluableSource = `${conclusion.currentTimes} ${opCorrected} ${expectedTimes}`;
            console.log("[*] Evaluating JavaScript for condition: ", evaluableSource);
            conclusion.filledAsint = Math.round(100 * (conclusion.currentTimes / conclusion.expectedTimes));
            conclusion.filled = conclusion.filledAsint + "%";
            Specific_for_time_cases: {
              conclusion.missingTimes = conclusion.expectedTimes - conclusion.currentTimes;
            }
            conclusion.missingAsint = 100 - conclusion.filledAsint;
            conclusion.missing = conclusion.missingAsint + "%";
            conclusion.solved = window.eval(evaluableSource);
            conclusion.solvable = evaluableSource;
          } else if (isDuration) {
            const expectedDuration = referenceValue;
            conclusion.expectedDurationInms = expectedDuration;
            conclusion.expectedDuration = LswTimer.utils.fromMillisecondsToDurationstring(expectedDuration);
            const evaluableSource = `${conclusion.currentDurationInms} ${opCorrected} ${expectedDuration}`;
            console.log("[*] Evaluating JavaScript for condition: ", evaluableSource);
            conclusion.filledAsint = Math.round(100 * (conclusion.currentDurationInms / conclusion.expectedDurationInms));
            conclusion.filled = conclusion.filledAsint + "%";
            const missingDurationInms = LswUtils.zeroIfNegative(conclusion.expectedDurationInms - conclusion.currentDurationInms);
            Specific_for_duration_cases: {
              conclusion.missingDuration = LswTimer.utils.fromMillisecondsToDurationstring(missingDurationInms);
              conclusion.missingDurationInms = missingDurationInms;
            }
            conclusion.missingAsint = 100 - conclusion.filledAsint;
            conclusion.missing = conclusion.missingAsint + "%";
            conclusion.solved = window.eval(evaluableSource);
            conclusion.solvable = evaluableSource;
          }
        }
        this.expandColor(conclusion);
        return conclusion;
      };
    }

    static COLOR_GAMA_1 = {
      SUSPENSO: "red",
      INSUFICIENTE: "#e87489",
      SUFICIENTE: "#5353bf",
      NOTABLE: "orange",
      EXCELENTE: "yellow",
      SOBRESALIENTE: "lime",
    };

    static COLOR_GAMA_2 = {
      SUSPENSO: "#D32F2F",
      INSUFICIENTE: "#F57C00",
      SUFICIENTE: "#FBC02D",
      NOTABLE: "#C0CA33",
      EXCELENTE: "#7CB342",
      SOBRESALIENTE: "#388E3C",
    };

    static COLOR_GAMA_3 = {
      SUSPENSO: "#c62828",
      INSUFICIENTE: "#ef6c00",
      SUFICIENTE: "#ffe300",
      NOTABLE: "#29b6f6",
      EXCELENTE: "#00897b",
      SOBRESALIENTE: "#66bb6a",
    };

    static COLOR = this.COLOR_GAMA_3;

    static COLOR_MEANING = {
      [this.COLOR.SUSPENSO]: "SUSPENSO",
      [this.COLOR.INSUFICIENTE]: "INSUFICIENTE",
      [this.COLOR.SUFICIENTE]: "SUFICIENTE",
      [this.COLOR.NOTABLE]: "NOTABLE",
      [this.COLOR.EXCELENTE]: "EXCELENTE",
      [this.COLOR.SOBRESALIENTE]: "SOBRESALIENTE",
    };

    /*
    static COLOR_MEANING = {
      "red": "SUSPENSO",
      "#e87489": "INSUFICIENTE",
      "#5353bf": "SUFICIENTE",
      "orange": "NOTABLE",
      "yellow": "EXCELENTE",
      "lime": "SOBRESALIENTE",
    };
    //*/

    static expandColor(_) {
      const percentage = _.filledAsint;
      const asMin = _.expectedAs === "minimum" ? true : false;
      const assignedColor = (() => {
        if (percentage <= 0) {
          return asMin ? this.COLOR.SUSPENSO : this.COLOR.SOBRESALIENTE;
        } else if (percentage < 20) {
          return asMin ? this.COLOR.INSUFICIENTE : this.COLOR.EXCELENTE;
        } else if (percentage < 40) {
          return asMin ? this.COLOR.SUFICIENTE : this.COLOR.NOTABLE;
        } else if (percentage < 60) {
          return asMin ? this.COLOR.NOTABLE : this.COLOR.SUFICIENTE;
        } else if (percentage < 80) {
          return asMin ? this.COLOR.EXCELENTE : this.COLOR.INSUFICIENTE;
        } else if (percentage > 80) {
          return asMin ? this.COLOR.SOBRESALIENTE : this.COLOR.SUSPENSO;
        } else {
        }
      })();
      Object.assign(_, {
        color: assignedColor,
        colorMeaning: this.COLOR_MEANING[assignedColor],
      });
    }

    static formatUrgency(txt) {
      return parseFloat(txt.replace(/\!/g, "").trim());
    }

    static isConditionByTimes(txtVal) {
      return txtVal.trim().match(/^[0-9]+(\.[0-9]+)?$/g);
    }

    static isConditionByDuration(txtVal) {
      try {
        return LswTimer.utils.fromDurationstringToMilliseconds(txtVal);
        return true;
      } catch (error) {
        return false;
      }
    }

    static getSomeDayActions(dateToday = new Date(), concept = false, state = false) {
      Vue.prototype.$trace("lsw-goals-viewer.methods.getSomeDayActions");
      return Vue.prototype.$lsw.database.selectMany("Accion", acc => {
        const dateInicio = LswTimer.utils.fromDatestringToDate(acc.tiene_inicio);
        const isSameDay = LswTimer.utils.areSameDayDates(dateInicio, dateToday);
        if (!isSameDay) {
          return false;
        }
        if (concept) {
          const isSameConcept = acc.en_concepto === concept;
          if (!isSameConcept) {
            return false;
          }
        }
        if (state) {
          const isSameState = acc.tiene_estado === state;
          if (!isSameState) {
            return false;
          }
        }
        return true;
      });
    }

  };

  return LswGoals;

  // @code.end: LswGoals class

});

// @vuebundler[Lsw_framework_components][105]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-goals-viewer/lsw-goals-viewer.html

// @vuebundler[Lsw_framework_components][105]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-goals-viewer/lsw-goals-viewer.js
// @code.start: LswGoalsViewer API | @$section: Vue.js (v2) Components  LswGoalsViewer component
Vue.component("LswGoalsViewer", {
  template: `<div class="lsw_goals_viewer">
    <div class="flex_row centered pad_bottom_1">
        <div class="flex_100">
            <div class="flex_row centered">
                <template v-if="isLoaded">
                    <div class="nowrap flex_1">
                        <button class=""
                            :class="{activated: isFiltering === 'none'}"
                            v-on:click="() => selectFilter('none')">   {{ summary.total }} </button>
                    </div>
                    <div class="nowrap flex_1 pad_left_1">
                        <button class=""
                            :class="{activated: isFiltering === 'completed'}"
                            v-on:click="() => selectFilter('completed')">   {{ summary.resolved }} </button>
                    </div>
                    <div class="nowrap flex_1 pad_left_1">
                        <button class=""
                            :class="{activated: isFiltering === 'failing'}"
                            v-on:click="() => selectFilter('failing')">   {{ summary.failed }} </button>
                    </div>
                    <div class="nowrap flex_100"></div>
                </template>
            </div>
        </div>
        <div class="flex_1 pad_left_1">
            <button class=""
                v-on:click="loadGoals"></button>
        </div>
        <div class="flex_1 pad_left_1">
            <button class=""
                v-on:click="openGoalsFile"></button>
        </div>
        <div class="flex_1 pad_left_1">
            <button class="unselectable_text"
                :class="{activated: isClicking}"
                v-on:mousedown="() => isClicking = true"
                v-on:mouseup="() => isClicking = false"
                v-on:touchstart="() => isClicking = true"
                v-on:touchend="() => isClicking = false">
                
            </button>
        </div>
        <!--div class="flex_1 pad_left_1">
            <button class="supermini"
                v-on:click="onClose"></button>
        </div-->
    </div>
    <div class="goals_list"
        v-if="isLoaded">
        <template v-for="goal, goalIndex in report.goals">
            <div v-bind:key="'goal-' + goalIndex"
                v-if="passesFilter(goal)"
                class="goal_item">
                <div>
                    <div class="bar_holder"
                        v-on:click="() => selectGoal(goal)">
                        <div class="bar_text">
                            <div class="position_relative"
                                v-if="!isClicking">
                                <div class="position_absolute"
                                    style="top: 0px; bottom: auto; left: 0px; opacity: 1;">
                                    <div class="flex_row centered">
                                        <div class="flex_1 pad_right_1">{{ goal.solved ? symbolForSolved : symbolForPending }}</div>
                                        <div class="flex_1">{{ goal.concept }} {{ getAbbrvWord(goal.expectedAsAbbr) }} {{ goal.expectedDuration || goal.expectedTimes }}  {{ goal.currentDuration || goal.currentTimes }}  {{ goal.filled }}</div>
                                    </div>
                                </div>
                            </div>
                            <div class="flex_row centered"
                                v-else>
                                <div class="flex_1">{{ goal.solved ? symbolForSolved : symbolForPending }}</div>
                                <template v-if="goal.type === 'by duration'">
                                    <div class="flex_auto pad_left_1"
                                        v-if="goal.missingDurationInms"><b> </b>{{ goal.missingDuration }} </div>
                                    <div class="flex_auto pad_left_1"><b> </b>{{ goal.currentDuration }} </div>
                                    <div class="flex_auto pad_left_1"><b>{{ getAbbrvWord(goal.expectedAsAbbr) }}</b> {{
                                        goal.expectedDuration }} </div>
                                </template>
                                <template v-if="goal.type === 'by times'">
                                    <div class="flex_auto pad_left_1"
                                        v-if="goal.missingTimes"><b> </b>{{ goal.missingTimes }}t </div>
                                    <div class="flex_auto pad_left_1"><b> </b>{{ goal.currentTimes }}t </div>
                                    <div class="flex_auto pad_left_1"><b>{{ getAbbrvWord(goal.expectedAsAbbr) }}</b>{{ goal.expectedTimes
                                        }}t </div>
                                </template>
                                <template>
                                    <div class="flex_auto pad_left_1"><b></b> {{ goal.filled }} </div>
                                    <div class="flex_auto pad_left_1"
                                        v-if="goal.missingAsint > 0">  {{ goal.missing }}</div>
                                </template>
                            </div>
                        </div>
                        <div class="bar_filler"
                            :style="{ width: goal.expectedAs === 'maximum' ? goal.missingAsint < 100 ? goal.missing : (100 + '%') : goal.filledAsint < 100 ? goal.filled : (100 + '%'), backgroundColor: goal.color }">
                        </div>
                    </div>
                    <div v-if="selectedGoal === goal">
                        <div class="pad_1">
                            <div class="smallest_font goal_status_card margin_bottom_1" style="color:black; min-height: 25px;">
                                <div class="position_relative">
                                    <div class="position_absolute"
                                        style="top: 0px; right: 0px;">
                                        <button class="supermini"
                                            v-on:click="() => editTodoOfGoal(goal)"></button>
                                    </div>
                                </div>
                                <template v-if="!isLoadingGoals">
                                    <div class="pad_top_1" v-if="goal.concept in specifiedGoals">
                                        <lsw-sourceable :source="specifiedGoals[goal.concept]" />
                                    </div>
                                    <div class="pad_top_1" v-else>
                                         Sin especificaciones 
                                    </div>
                                </template>
                            </div>
                            <div class="smallest_font goal_status_card">
                                <template
                                    v-for="field, fieldIndex in interestingFields">
                                    <div v-if="fieldIndex in goal"
                                        class="goal_line"
                                        v-bind:key="'field_' + fieldIndex"
                                        style="color: black;">
                                        <div class="width_100 flex_row centered pad_vertical_1">
                                            <div class="flex_1 label nowrap font_weight_bold"> {{ field }}:</div>
                                            <div class="flex_100 value text_align_right">{{ goal[fieldIndex] }}</div>
                                        </div>
                                    </div>
                                </template>
                            </div>
                            <!--pre class="codeblock">{{ goal }}</pre-->
                        </div>
                    </div>
                </div>
                <div class="bar_separation"></div>
            </div>
        </template>
    </div>
    <div class="flex_row centered pad_vertical_1">
        <div class="flex_1 pad_right_1">
            <button class="supermini"
                v-on:click="importGoalsToDay"></button>
        </div>
        <div class="flex_100"></div>
        <div class="flex_1 pad_left_1">
            <button class="supermini"
                v-on:click="saveMoment"></button>
        </div>
        <div class="flex_1 pad_left_1">
            <button class="supermini"
                v-on:click="openRecordsDirectory"></button>
        </div>
        <div class="flex_1 pad_left_1">
            <button class="supermini"
                v-on:click="openRecordsViewer"></button>
        </div>
    </div>
</div>`,
  props: {
    onClose: {
      type: [Function, Boolean],
      default: false,
    },
    onRefresh: {
      type: [Function, Boolean],
      default: false,
    },
    dayToAnalize: {
      type: [Boolean, Date],
      default: () => new Date(),
    }
  },
  data() {
    this.$trace("lsw-goals-viewer.data");
    const solverSymbols = ['', '', '']
    const penderSymbols = ['', '', ''];
    const randomIndex = LswRandomizer.getRandomIntegerBetween(0, penderSymbols.length-1);
    return {
      isLoaded: false,
      isLoadingGoals: false,
      isFiltering: "none",
      isClicking: false,
      specifiedGoals: {},
      interestingFields: {
        "colorMeaning": "Estado actual",
        "filled": "Completado",
        "missing": "Faltante",
        "solved": "Resuelto",
        // "originalConcept": "Concepto",
        // "originalCondition": "Condicin",
        // "originalUrgency": "Urgencia",
        "type": "Tipo",
        "expectedAs": "Formato",
        "expectedDuration": "Duracin esperada",
        // "expectedAsAbbr": "Formato abreviado",
        "currentDuration": "Duracin actual",
        "missingDuration": "Duracin faltante",
        "expectedTimes": "Veces esperadas",
        "currentTimes": "Veces actuales",
        "missingTimes": "Veces faltantes",
        // "currentDurationInms": "Duracin en ms actual",
        // "expectedDurationInms": "Duracin esperada en ms",
        // "filledAsint": "Llenado como nmero",
        // "missingDurationInms": "Duracin faltante en ms",
        // "missingAsint": "Faltante como nmero",
        // "solvable": "Resolvible",
        // "color": "color",
        // "urgency": "Urgencia"
        "originalLine": "Origen",
      },
      symbolForSolved: solverSymbols[randomIndex],
      symbolForPending: penderSymbols[randomIndex],
      selectedGoal: false,
      report: [],
      summary: false,
    };
  },
  methods: {
    async selectGoal(goal) {
      this.$trace("lsw-goals-viewer.methods.selectGoal");
      if(this.selectedGoal === goal) {
        this.selectedGoal = undefined;
      } else {
        this.selectedGoal = goal;
      }
      await this.loadGoalSpecification(goal);
    },
    selectFilter(id) {
      this.$trace("lsw-goals-viewer.methods.selectFilter");
      this.isFiltering = id;
    },
    async loadGoalSpecification(goal) {
      this.$trace("lsw-goals-viewer.methods.loadGoalSpecification");
      try {
        this.isLoadingGoals = true;
        const filepath = "/kernel/goals/todos/" + goal.concept + ".md";
        const filecontent = await this.$lsw.fs.read_file(filepath);
        const parsedContent = marked.parse(filecontent);
        this.specifiedGoals[goal.concept] = `<div class="markdown_texto">${parsedContent}</div>`;
        return parsedContent;
      } catch (error) {
        return false;
      } finally {
        this.isLoadingGoals = false;
      }
    },
    passesFilter(goal) {
      this.$trace("lsw-goals-viewer.methods.passesFilter");
      if(this.isFiltering === "none") {
        return true;
      } else if(this.isFiltering === "completed") {
        return goal.solved === true;
      } else {
        return goal.solved === false;
      }
    },
    async loadGoals() {
      this.$trace("lsw-goals-viewer.methods.loadGoals");
      this.isLoaded = false;
      this.report = await LswGoals.getGoalsReport(this.dayToAnalize);
      let resolved = 0;
      let failed = 0;

      for(let index=0; index<this.report.goals.length; index++) {
        const goal = this.report.goals[index];
        if(goal.solved) {
          resolved++;
        } else {
          failed++;
        }
      }
      this.summary = {
        total: this.report.goals.length,
        resolved,
        failed,
      };
      this.isLoaded = true;
    },
    openGoalsFile() {
      this.$trace("lsw-goals-viewer.methods.openGoalsFile");
      this.$dialogs.open({
        title: "Editar objetivos",
        template: `
          <div>
            <lsw-filesystem-explorer opened-by="/kernel/goals/goals.week" :absolute-layout="true" />
          </div>
        `
      });
    },
    openRecordsDirectory() {
      this.$trace("lsw-goals-viewer.methods.saveMoment");
      this.$dialogs.open({
        title: "Ver rcords anteriores",
        template: `
          <div>
            <lsw-filesystem-explorer opened-by="/kernel/goals/records" :absolute-layout="true" />
          </div>
        `
      });
    },
    openRecordsViewer() {
      this.$trace("lsw-goals-viewer.methods.openRecordsViewer");
      this.$dialogs.open({
        title: "Visualizar rcords",
        template: `
          <div class="pad_1">
            <lsw-goals-records-viewer />
          </div>
        `
      });
    },
    openWeekPlanner() {
      this.$trace("lsw-goals-viewer.methods.openWeekPlanner");
      this.$dialogs.open({
        title: "Planificador de semana",
        template: `
          <div class="pad_1">
            <lsw-week-planner />
          </div>
        `
      });
    },
    async saveMoment() {
      this.$trace("lsw-goals-viewer.methods.saveMoment");
      const dayUid = LswTimer.utils.fromDateToDatestring(new Date(), false, false, true).replace(/\/|\:/g, "-").replace(/ .*$/g, "");
      const filepath = "/kernel/goals/records/" + dayUid + ".json";
      const reportSnapshot = Object.assign({
        date: LswTimer.utils.fromDateToDatestring(this.dayToAnalize || new Date()),
      }, this.report, {});
      const filecontents = JSON.stringify(reportSnapshot, null, 2);
      await this.$lsw.fs.write_file(filepath, filecontents);
      this.$lsw.toasts.send({
        title: "Estadsticas del da guardadas",
        text: `En: ${filepath}`
      });
    },
    getAbbrvWord(id) {
      return id === "min" ? "" : "";
      return id === "min" ? "mnimo" : "mximo";
    },
    async editTodoOfGoal(goal) {
      this.$trace("lsw-goals-viewer.methods.editTodoOfGoal");
      const goalFilepath = `/kernel/goals/todos/${goal.concept}.md`;
      const exists = await this.$lsw.fs.exists(goalFilepath);
      if(!exists) {
        await this.$lsw.fs.write_file(goalFilepath, "");
      }
      this.$lsw.dialogs.open({
        title: "Detallando objetivo",
        template: `<lsw-filesystem-explorer :opened-by="goalFilepath" :absolute-layout="true" />`,
        factory: {
          data: { goal, goalFilepath },
          methods: { }
        }
      });
    },
    async importGoalsToDay() {
      this.$trace("lsw-goals-viewer.methods.importGoalsToDay");
      const originalGoals = await Vue.prototype.$lsw.fs.evaluateAsWeekFileOrReturn("/kernel/goals/goals.week", []);
      const dayString = LswTimer.utils.fromDateToDatestring(this.dayToAnalize, true);
      const weekdayString = LswGoals.fromDateToWeekday(this.dayToAnalize);
      const goalsMatched = originalGoals.filter(goal => {
        if(goal.type !== "SET") {
          return false;
        }
        Filtro_de_goal_segun_dia: {
          const {
            from: goalBegin,
            to: goalEnd,
            type: goalType,
            concept: goalConcept,
            duration: goalDuration,
            hour: goalHour,
            minute: goalMinute,
            weekday: goalWeekday,
          } = goal;
          // No excede el desde fecha.
          if(goalBegin !== "*") {
            if(dayString < goalBegin) {
              return false;
            }
          }
          // No excede el hasta fecha
          if(goalEnd !== "*") {
            if(dayString > goalEnd) {
              return false;
            }
          }
          // Coincide con el dia de la semana
          if(goalWeekday !== "*") {
            if(weekdayString !== goalWeekday) {
              return false;
            }
          }
        }
        return true;
      });
      const goalsMissing = [];
      const accionesDia = await this.$lsw.database.select("Accion", acc => acc.tiene_inicio.startsWith(dayString));
      Iterating_objetivos:
      for(let indexGoal=0; indexGoal<goalsMatched.length; indexGoal++) {
        const goalMatched = goalsMatched[indexGoal];
        const {
          from: goalBegin,
          to: goalEnd,
          type: goalType,
          concept: goalConcept,
          duration: goalDuration,
          hour: goalHour,
          minute: goalMinute,
          weekday: goalWeekday,
        } = goalMatched;
        const presuntoInicio = dayString + " " + goalMatched.hour + ":" + goalMatched.minute;
        let missingAccion = {
          ast: goalMatched,
          acc: {
            en_concepto: goalConcept,
            tiene_estado: "pendiente",
            tiene_inicio: presuntoInicio,
            tiene_duracion: goalDuration || "1h",
            tiene_parametros: "[*semanal]",
            tiene_descripcion: "",
            tiene_comentarios: "",
          }
        };
        Iterating_acciones:
        for(let indexAcc=0; indexAcc<accionesDia.length; indexAcc++) {
          const accionDia = accionesDia[indexAcc];
          const matchesParameter = accionDia.tiene_parametros.indexOf("[*semanal]") !== -1;
          const matchesTime = accionDia.tiene_inicio.startsWith(presuntoInicio);
          const matchesConcept = accionDia.tiene_inicio.startsWith(presuntoInicio);
          if(matchesParameter && matchesTime && matchesConcept) {
            missingAccion = false;
            break Iterating_acciones;
          };
        }
        if(missingAccion) {
          goalsMissing.push(missingAccion);
        }
      }
      if(!goalsMissing.length) {
        return this.$lsw.dialogs.open({
          title: "No hay objetivos por importar",
          template: `
            <div class="pad_1">
              <div>No hay objetivos por importar actualmente.</div>
            </div>
          `
        });
      }
      const confirmation = await this.$lsw.dialogs.open({
        title: "Importar objetivos a da",
        template: `
          <div class="pad_1">
            <div>Seguro que quieres importar los objetivos al da seleccionado?</div>
            <div class="pad_vertical_2">Se aadirn las siguientes {{ goalsToImport.length }} acciones:</div>
            <ul class="margin_vertical_0">
              <li v-for="goal, goalIndex in goalsToImport" v-bind:key="'goal_' + goalIndex">
                <div>{{ currentWeekday }}, {{ currentDay }}  {{ goal.ast.hour }}:{{ goal.ast.minute }}@{{ goal.acc.en_concepto }}</div>
              </li>
            </ul>
            <hr />
            <div class="flex_row centered">
              <div class="flex_100"></div>
              <div class="flex_1">
                <button class="supermini" v-on:click="() => accept(true)">Aceptar</button>
              </div>
              <div class="flex_1">
                <button class="supermini" v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: {
          data: {
            currentWeekday: LswGoals.fromDateToWeekday(this.dayToAnalize),
            currentDay: dayString,
            goalsToImport: goalsMissing
          }
        }
      });
      if(confirmation !== true) {
        return;
      }
      await this.$lsw.database.insertMany("Accion", goalsMissing.map(goalMetadata => goalMetadata.acc));
      this.$lsw.toasts.send({
        title: `Se insertaron ${goalsMissing.length} acciones`,
        text: `Los objetivos generaron ${goalsMissing.length} acciones para el da seleccionado`
      });
      this.updateCalendario();
    },
    updateCalendario() {
      this.$trace("lsw-goals-viewer.methods.updateCalendario");
      try {
        LswDom.findVue(".lsw_agenda").reloadDateTasks();
      } catch (error) {
        // @BADLUCK
      }
    }
  },
  watch: {},
  mounted() {
    this.$trace("lsw-goals-viewer.mounted");
    this.loadGoals();
  },
  unmounted() {
    this.$trace("lsw-goals-viewer.unmounted");
  }
});
// @code.end: LswGoalsViewer API

// @vuebundler[Lsw_framework_components][105]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-goals-viewer/lsw-goals-viewer.css

// @vuebundler[Lsw_framework_components][106]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-goals-records-viewer/lsw-goals-records-viewer.html

// @vuebundler[Lsw_framework_components][106]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-goals-records-viewer/lsw-goals-records-viewer.js
// @code.start: LswGoalsRecordsViewer API | @$section: Vue.js (v2) Components  LswGoalsRecordsViewer component
Vue.component("LswGoalsRecordsViewer", {
  template: `<div class="lsw_goals_records_viewer">
    <div class=""
        v-if="isLoaded">
        <div class="titulo_de_record">
            <div class="flex_row centered">
                <div class="flex_100"> Objetivos extrados:</div>
                <div class="flex_1 pad_right_1">
                    <button class="supermini" v-on:click="toggleAllSelectedGoals"></button>
                </div>
                <div class="flex_1" v-on:click="toggleGoals">
                    <button class="supermini" v-if="!isShowingGoals"></button>
                    <button class="supermini" v-else></button>
                </div>
            </div>
        </div>
        <div class="available_goals_list" v-if="isShowingGoals">
            <div class="display_inline_block"
                v-for="goalId, goalIndex in availableGoals"
                v-bind:key="'goal_id_' + goalId">
                <button class="supermini button_checkbox">
                    <label class="">
                        <input class=""
                            type="checkbox"
                            v-model="selectedGoals"
                            :value="goalId" />
                        <span class="pad_1">{{ goalId }}</span>
                    </label>
                </button>
            </div>
        </div>
        <div class=""
            v-for="record, recordIndex in records">
            <div class="titulo_de_record"> Tomada en: {{ record.date }}</div>
            <template v-for="goal, goalIndex in record.goals">
                <div class="display_inline_block pad_bottom_1"
                    v-if="(!selectedGoals) || (selectedGoals.length === 0) || (selectedGoals.indexOf(goal.originalConcept) !== -1)"
                    v-bind:key="'record-' + recordIndex + '-goal-' + goalIndex">
                    <div class="carta_de_record smallest_font">
                        <div class="celda_de_concepto_de_record flex_row"
                            style="justify-content: start;"
                            :style="{backgroundColor: goal.color, color: goal.foregroundColor || 'black'}">
                            <div class="flex_100">
                                <div class="">
                                    {{ goal.originalConcept }}
                                </div>
                            </div>
                        </div>
                        <div class="flex_row"
                            style="justify-content: start; display: none;">
                            <div class="flex_1">
                                <div class=""
                                    >
                                    {{ goal.colorMeaning }}
                                </div>
                            </div>
                        </div>
                        <div class="flex_row text_align_left"
                            style="justify-content: start;">
                            <div class="flex_100">
                                <div class="">
                                    <span v-if="goal.type === 'by duration'">
                                         {{ goal.currentDuration }}
                                    </span>
                                    <span v-else-if="goal.type === 'by times'">
                                         {{ goal.currentTimes }} {{ goal.currentTimes === 1 ? "vez" : "veces" }}
                                    </span>
                                    <span> | {{ goal.filled }}</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex_row text_align_left"
                            style="justify-content: start;">
                            <div class="flex_100">
                                <div class="">
                                    <span v-if="goal.type === 'by duration'">
                                         {{ goal.missingDuration }}
                                    </span>
                                    <span v-else-if="goal.type === 'by times'">
                                         {{ goal.missingTimes }} {{ goal.missingTimes === 1 ? "vez" : "veces" }}
                                    </span>
                                    <span> | {{ goal.missing }}</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex_row celda_de_regla_de_record"
                            style="justify-content: start;">
                            <div class="flex_100">
                                <div class="">
                                    {{ goal.expectedAs }}
                                    <span v-if="goal.type === 'by duration'">
                                        {{ goal.expectedDuration }}
                                    </span>
                                    <span v-else-if="goal.type === 'by times'">
                                        {{ goal.expectedTimes }} {{ goal.expectedTimes === 1 ? "vez" : "veces" }}
                                    </span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!--pre class="codeblock">{{ goal }}</pre-->
                </div>
            </template>
        </div>
    </div>
</div>`,
  props: {

  },
  data() {
    this.$trace("lsw-goals-records-viewer.data");
    return {
      isLoaded: false,
      isShowingGoals: true,
      records: false,
      selectedGoals: [],
      availableGoals: [],
    };
  },
  methods: {
    async loadRecords() {
      this.$trace("lsw-goals-records-viewer.methods.loadRecords");
      this.isLoaded = false;
      try {
        const recordsFiles = await this.$lsw.fs.read_directory("/kernel/goals/records");
        const recordDays = Object.keys(recordsFiles).map(file => file.replace(/\.json$/g, ""));
        const allRecords = [];
        const allGoalConcepts = [];
        const errors = [];
        for (let index = 0; index < recordDays.length; index++) {
          const recordDay = recordDays[index];
          try {
            const recordPath = `/kernel/goals/records/${recordDay}.json`;
            const recordJson = await this.$lsw.fs.read_file(recordPath);
            const recordData = JSON.parse(recordJson);
            allRecords.push(recordData);
            for(let indexGoals=0; indexGoals<recordData.goals.length; indexGoals++) {
              const goal = recordData.goals[indexGoals];
              try {
                const goalId = goal.originalConcept;
                const goalPos = allGoalConcepts.indexOf(goalId);
                if(goalPos === -1) {
                  allGoalConcepts.push(goalId);
                }
              } catch (error) {
                // @BADLUCK
              }
            }
          } catch (error) {
            console.log(error);
            error.message = `(${recordDay}) ` + error.message;
            error.fileOrigin = recordDay;
            errors.push(error);
          }
        }
        if (errors.length) {
          console.log(errors);
          this.$lsw.toasts.send({
            title: `Hubo ${errors.length} errores cargando los records`,
            text: "Errores en: " + errors.map(err => err.fileOrigin).join(", "),
          });
          return;
        }
        this.records = allRecords;
        this.availableGoals = allGoalConcepts;
      } catch (error) {
        console.log(error);
      }
      this.isLoaded = true;
    },
    toggleGoals() {
      this.$trace("lsw-goals-records-viewer.methods.toggleGoals");
      this.isShowingGoals = !this.isShowingGoals;
    },
    toggleAllSelectedGoals() {
      this.$trace("lsw-goals-records-viewer.methods.toggleAllSelectedGoals");
      if(this.selectedGoals.length) {
        this.selectedGoals = [];
      } else {
        this.selectedGoals = [].concat(this.availableGoals);
      }
    }
  },
  watch: {},
  mounted() {
    this.$trace("lsw-goals-records-viewer.mounted");
    this.loadRecords();
  },
  unmounted() {
    this.$trace("lsw-goals-records-viewer.unmounted");
  }
});
// @code.end: LswGoalsRecordsViewer API

// @vuebundler[Lsw_framework_components][106]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-goals-records-viewer/lsw-goals-records-viewer.css

// @vuebundler[Lsw_framework_components][107]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-bin-directory/lsw-bin-directory.html

// @vuebundler[Lsw_framework_components][107]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-bin-directory/lsw-bin-directory.js
// @code.start: LswBinDirectory API | @$section: Vue.js (v2) Components  LswBinDirectory component
Vue.component("LswBinDirectory", {
  template: `<div class="lsw_bin_directory">
    <div class="flex_row centered">
        <div class="flex_100">
            <h4> Binarios rpidos:</h4>
        </div>
        <div class="flex_1 pad_left_1">
            <button class="supermini"
                v-on:click="loadBinaries"></button>
        </div>
        <div class="flex_1 pad_left_1">
            <button class="supermini"
                v-on:click="openBinarios"></button>
        </div>
    </div>
    <template v-if="!isLoaded">
        Un momento, se estn cargando...
    </template>
    <lsw-error-box :error="hasError"
        v-else-if="hasError" />
    <div class="binaries_list"
        :class="{is_searching: isAboutSearching}"
        v-else>
        <div class="flex_row centered pad_top_1">
            <div class="flex_100 pad_right_1">
                <input class="supermini width_100 binaries_searcher_input"
                    type="text"
                    v-model="searchText"
                    v-on:keyup="digestDelayed"
                    v-on:keypress.enter="digestOutput" />
            </div>
            <div class="flex_1">
                <button class="supermini"
                    v-on:click="digestOutput"></button>
            </div>
        </div>
        <template v-if="binariesInSelection && binariesInSelection.length">
            <div class="binarie_item display_inline_block pad_right_1"
                v-for="binarie, binarieIndex in binariesInSelection"
                v-bind:key="'binarie_' + binarieIndex">
                <div class="flex_row centered">
                    <button class="supermini text_align_left pill_start"
                        v-on:click="() => executeBin(binarie)">
                        <div class="flex_row centered">
                            <div class="flex_100 smallest_font">{{ formatFilepathForUser(binarie.filepath) }}</div>
                            <div class="flex_1 pad_left_1 smallest_font">{{ binarie.content.length }}B</div>
                        </div>
                    </button><button class="supermini smallest_font pill_end"
                        style="margin-left: -1px;"
                        v-on:click="() => editBin(binarie)"></button>
                </div>
            </div>
        </template>
        <template v-else>
            <div class="pad_top_2">No se encontraron binarios con el patrn de bsqueda actual.</div>
        </template>
    </div>
</div>`,
  props: {
    directory: {
      type: String,
      required: true,
    },
  },
  data() {
    this.$trace("lsw-bin-directory.data");
    return {
      hasError: false,
      isLoaded: false,
      isAboutSearching: false,
      searchText: "",
      binaries: [],
      binariesInSelection: [],
      delayedTimeout: 0.7 * 1000,
      delayedTimeoutId: undefined,
    };
  },
  methods: {
    async loadBinaries() {
      this.$trace("lsw-bin-directory.methods.loadBinaries");
      try {
        this.isLoaded = false;
        const allBinaries = await this.$lsw.fs.$selectMany(it => {
          return it.type === "file" && it.filepath.startsWith("/kernel/bin") && it.filepath.endsWith(".js");
        });
        this.binaries = allBinaries;
        await this.digestOutput();
      } catch (error) {
        this.$lsw.toasts.send({
          title: "No pudieron cargarse los binarios",
          text: 'Hubo un error al cargar los binarios'
        });
        console.error(`[!] Could not load bin-directory ${this.directory} because:`, error);
        this.hasError = error;
      } finally {
        this.isLoaded = true;
      }
    },
    digestOutput() {
      this.$trace("lsw-bin-directory.methods.digestOutput");
      return new Promise((resolve, reject) => {
        let output = [];
        try {
          this.isAboutSearching = true;
          Apply_search: {
            if (this.searchText.trim() === "") {
              output = this.binaries;
              break Apply_search;
            }
            const loweredSearchText = this.searchText.toLowerCase();
            for (let index = 0; index < this.binaries.length; index++) {
              const binarie = this.binaries[index];
              const hasMatch = binarie.filepath.toLowerCase().indexOf(loweredSearchText) !== -1;
              if (hasMatch) {
                output.push(binarie);
              }
            }
          }
          return resolve(output);
        } catch (error) {
          return reject(error);
        } finally {
          Export_results: {
            this.isAboutSearching = false;
            this.binariesInSelection = output;
          }
        }
      });
    },
    digestDelayed() {
      this.$trace("lsw-bin-directory.methods.digestDelayed");
      clearTimeout(this.delayedTimeoutId);
      this.isAboutSearching = true;
      this.delayedTimeoutId = setTimeout(this.digestOutput, this.delayedTimeout);
    },
    async executeBin(binarie) {
      this.$trace("lsw-bin-directory.methods.executeBin");
      const asyncBin = LswUtils.createAsyncFunction(binarie.content);
      try {
        const output = await asyncBin.call(this);
        Aqui_se_hookearia_pero_creo_que_no: {
          console.log(output);
        }
        return output;
      } catch (error) {
        this.$lsw.toasts.sendError(error);
      }
    },
    editBin(binarie) {
      this.$trace("lsw-bin-directory.methods.editBin");
      this.$lsw.dialogs.open({
        title: "Editando binario",
        template: `<lsw-filesystem-explorer :opened-by="binarie.filepath" :absolute-layout="true" />`,
        factory: { data: { binarie } },
      });
    },
    openBinarios() {
      this.$trace("lsw-bin-directory.methods.openBinarios");
      this.$lsw.dialogs.open({
        title: "Explorando binarios",
        template: `<lsw-filesystem-explorer opened-by="/kernel/bin" :absolute-layout="true" />`
      });
    },
    formatFilepathForUser(txt) {
      return txt.replace(this.directory, "").replace(/^\//g, "").replace(/\.js$/g, "");
    }
  },
  mounted() {
    this.$trace("lsw-bin-directory.mounted");
    this.loadBinaries();
  },
  unmount() {
    this.$trace("lsw-bin-directory.unmounted");
    // @OK
  }
});
// @code.end: LswBinDirectory API

// @vuebundler[Lsw_framework_components][107]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-bin-directory/lsw-bin-directory.css

// @vuebundler[Lsw_framework_components][108]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-event-tracker/lsw-event-tracker.html

// @vuebundler[Lsw_framework_components][108]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-event-tracker/lsw-event-tracker.js
// @code.start: LswEventTracker API | @$section: Vue.js (v2) Components  LswEventTracker component
Vue.component("LswEventTracker", {
  template: `<div class="lsw_event_tracker">
    <div class="typical_title_1">
        <div class="flex_row centered">
            <div class="flex_100"> Trackeables:</div>
            <div class="flex_1 pad_right_1">
                <button class="supermini"
                    v-on:click="loadTrackables"></button>
            </div>
            <div class="flex_1">
                <button class="supermini"
                    v-on:click="editTrackables"></button>
            </div>
        </div>
    </div>
    <template v-if="!isLoaded">
        Cargando componente. Por favor, aguarde...
    </template>
    <template>
        <div class="flex_row centered pad_top_1">
            <div class="flex_100">
                <input type="text"
                    class="supermini width_100"
                    :class="{ is_searching: isSearching }"
                    v-model="searchText"
                    v-on:keypress.enter="digestOutput"
                    placeholder="Bsqueda rpida de trackeable"
                />
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini"
                    v-on:click="insertTrackable"></button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini"
                    v-on:click="digestOutput"></button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini"
                    v-on:click="clearSearchText"></button>
            </div>
        </div>
        <template v-if="Object.keys(trackables).length === 0">
            <div class="pad_top_1">No se encontraron eventos con ese patrn de bsqueda.</div>
        </template>
        <template v-for="trackable, trackableIndex, trackableCounter in trackables">
            <div v-bind:key="'trackable-' + trackableIndex"
                class="pad_top_1">
                <div class="flex_row centered">
                    <div class="flex_100 shortable_text">
                        <div class="">{{ trackableIndex }}</div>
                    </div>
                    <div class="flex_1 pad_left_1">
                        <button class="supermini"
                            v-on:click="() => deleteTrackable(trackableIndex)"></button>
                    </div>
                    <div class="flex_1 pad_left_1 text_align_center"
                        style="min-width:20px;">
                        {{ trackable.length }}
                    </div>
                    <div class="flex_1 pad_left_1">
                        <button class="supermini"
                            v-on:click="() => addTrackableWithComment(trackableIndex)"></button>
                    </div>
                    <div class="flex_1 pad_left_1">
                        <button class="supermini"
                            v-on:click="() => addTrackable(trackableIndex)"></button>
                    </div>
                </div>
            </div>
        </template>
    </template>
</div>`,
  props: {
    
  },
  data() {
    this.$trace("lsw-event-tracker.data");
    return {
      isLoaded: false,
      isSearching: true,
      allTrackables: [],
      trackables: false,
      searchText: "",
      digestTimeout: 1000,
      digestTimeoutId: undefined,
    };
  },
  methods: {
    async loadTrackables() {
      this.$trace("lsw-event-tracker.methods.loadTrackables");
      this.isLoaded = false;
      try {
        let trackableIds = undefined;
        Get_trackables: {
          trackableIds = await this.$lsw.fs.evaluateAsDotenvListFileOrReturn("/kernel/settings/trackables.env", []);
        }
        let trackedData = {};
        Count_trackables: {
          const accionesTrackeadas = await this.$lsw.database.selectMany("Accion", it => {
            return trackableIds.indexOf(it.en_concepto) !== -1;
          });
          for(let indexTrackables=0; indexTrackables<trackableIds.length; indexTrackables++) {
            const trackableId = trackableIds[indexTrackables];
            trackedData[trackableId] = [];
            for(let indexTrackeadas=0; indexTrackeadas<accionesTrackeadas.length; indexTrackeadas++) {
              const accion = accionesTrackeadas[indexTrackeadas];
              if(accion.en_concepto === trackableId) {
                trackedData[trackableId].push(accion);
              }
            }
          }
        }
        this.allTrackables = trackedData;
        this.digestOutput();
      } catch (error) {
        this.$lsw.toasts.sendError(error);
      }
    },
    digestDelayed() {
      this.$trace("lsw-event-tracker.methods.digestDelayed");
      clearTimeout(this.digestTimeoutId);
      setTimeout(() => {
        this.digestOutput();
      }, this.digestTimeout);
    },
    digestOutput() {
      this.$trace("lsw-event-tracker.methods.digestOutput");
      clearTimeout(this.digestTimeoutId);
      this.isSearching = true;
      setTimeout(() => {
        if(this.searchText.trim() === "") {
          this.trackables = this.allTrackables;
        } else {
          this.trackables = LswUtils.filterObject(this.allTrackables, (key, val) => {
            return key.toLowerCase().indexOf(this.searchText.toLowerCase()) !== -1;
          });
        }
        this.isLoaded = true;
        this.isSearching = false;
      }, 0);
    },
    editTrackables() {
      this.$trace("lsw-event-tracker.methods.editTrackables");
      this.$lsw.dialogs.open({
        title: "Editar trackeables",
        template: `
          <lsw-filesystem-explorer
            opened-by="/kernel/settings/trackables.env"
            :absolute-layout="true"
          />
        `,
      });
    },
    async deleteTrackable(trackableId) {
      this.$trace("lsw-event-tracker.methods.deleteTrackable");
      const eventos = await this.$lsw.database.selectMany("Accion", it => {
        return (it.tiene_estado === "trackeada") && (it.en_concepto === trackableId);
      });
      const eventosOrdenados = eventos.sort((e1, e2) => {
        return e1.tiene_inicio > e2.tiene_inicio ? -1 : 1;
      });
      const evento = eventosOrdenados[0] || false;
      if(!evento) {
        return;
      }
      const respuesta = await this.$lsw.dialogs.open({
        title: "Eliminar ltimo evento trackeada",
        template: `
          <div class="pad_1">
            <div>Seguro que quieres eliminar el evento trackeada?</div>
            <pre class="codeblock">{{ evento }}</pre>
            <hr />
            <div class="flex_row centered">
              <div class="flex_100"></div>
              <div class="flex_1 pad_left_1">
                <button class="supermini danger_button"
                  v-on:click="() => accept(true)">Eliminar</button>
              </div>
              <div class="flex_1 pad_left_1">
                <button class="supermini"
                  v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: { data: { evento } }
      });
      if(respuesta !== true) {
        console.log(respuesta);
        return;
      }
      await this.$lsw.database.delete("Accion", evento.id);
      this.$lsw.toasts.send({
        title: "Evento eliminado correctamente",
        text: "El ltimo evento asociado fue eliminado",
      });
      this.loadTrackables();
    },
    async addTrackableWithComment(trackableId) {
      this.$trace("lsw-event-tracker.methods.addTrackableWithComment");
      const comentario = await this.$lsw.dialogs.open({
        title: "Comentario adjunto a evento",
        template: `
          <div class="pad_1">
            <div class="pad_bottom_1">
              Comentario a adjuntar en el evento:
            </div>
            <div class="pad_bottom_1">
              <textarea class="width_100" v-model="value" spellcheck="false" />
            </div>
            <hr />
            <div class="flex_row centered">
              <div class="flex_100"></div>
              <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="accept">Aadir trackeo</button>
              </div>
              <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `
      });
      if(typeof comentario !== "string") return;
      await this.$lsw.database.insert("Accion", {
        en_concepto: trackableId,
        tiene_estado: "trackeada",
        tiene_inicio: LswTimer.utils.fromDateToDatestring(new Date()),
        tiene_duracion: "1min",
        tiene_parametros: "",
        tiene_resultados: "",
        tiene_comentarios: comentario,
      });
      this.$lsw.toasts.send({
        title: "Evento aadido correctamente",
        text: "Con comentario adjunto",
      });
      this.loadTrackables();
    },
    async addTrackable(trackableId) {
      this.$trace("lsw-event-tracker.methods.addTrackable");
      await this.$lsw.database.insert("Accion", {
        en_concepto: trackableId,
        tiene_estado: "trackeada",
        tiene_inicio: LswTimer.utils.fromDateToDatestring(new Date()),
        tiene_duracion: "1min",
        tiene_parametros: "",
        tiene_resultados: "",
        tiene_comentarios: "",
      });
      this.loadTrackables();
      this.$lsw.toasts.send({
        title: "Evento aadido correctamente",
        text: "Sin comentario adjunto",
      });
    },
    async insertTrackable() {
      this.$trace("lsw-event-tracker.methods.insertTrackable");
      const trackableId = this.searchText;
      if(trackableId.trim() === "") {
        return;
      }
      const trackableIds = await this.$lsw.fs.evaluateAsDotenvListFileOrReturn("/kernel/settings/trackables.env", []);
      const pos = trackableIds.indexOf(trackableId);
      if(pos !== -1) {
        this.$lsw.toasts.send({
          title: "Este trackable ya existe",
          text: "No se insert porque ya existe.",
        });
      } else {
        const previousContent = await this.$lsw.fs.read_file("/kernel/settings/trackables.env");
        const lastContent = previousContent.trim() + "\n" + trackableId;
        await this.$lsw.fs.write_file("/kernel/settings/trackables.env", lastContent);
        this.$lsw.toasts.send({
          title: "Trackable insertado correctamente",
          text: "",
        });
        this.loadTrackables();
      }
    },
    clearSearchText() {
      this.$trace("lsw-event-tracker.watch.clearSearchText");
      this.searchText = "";
      this.digestOutput();
    }
  },
  watch: {
    searchText() {
      this.$trace("lsw-event-tracker.watch.searchText");
      this.digestDelayed();
    }
  },
  mounted() {
    this.$trace("lsw-event-tracker.mounted");
    this.loadTrackables();
  },
  unmounted() {
    this.$trace("lsw-event-tracker.unmounted");
    
  }
});
// @code.end: LswEventTracker API

// @vuebundler[Lsw_framework_components][108]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-event-tracker/lsw-event-tracker.css

// @vuebundler[Lsw_framework_components][109]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-search-replacer/lsw-search-replacer.html

// @vuebundler[Lsw_framework_components][109]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-search-replacer/lsw-search-replacer.js
// @code.start: LswSearchReplacer API | @$section: Vue.js (v2) Components  LswSearchReplacer component
Vue.component("LswSearchReplacer", {
  template: `<div class="lsw_search_replacer">
    <div class="pad_1">
        <div class="">
            <div class="flex_row centered">
                <div class="flex_1 nowrap"> Buscar: </div>
                <div class="flex_100 pad_left_1"></div>
                <div class="flex_1 pad_left_1">
                    <button class="supermini activated has_light_bg" v-on:click="toggleRegexpMode">
                        {{ searchAsRegexp ? "as: RegExp" : "as: Text" }}
                    </button>
                </div>
                <div class="flex_1 pad_left_1">
                    <!--button class="supermini" v-on:click="illuminateMatches"></button-->
                </div>
            </div>
            <div class="pad_top_1">
                <textarea class="width_100"
                    v-model="search"
                    v-on:keyup.esc.prevent="cancel"
                    v-focus></textarea>
            </div>
        </div>
        <div class="pad_top_1">
            <div class="flex_row centered">
                <div class="flex_1 nowrap"> Reemplazar: </div>
                <div class="flex_100 pad_left_1"></div>
                <div class="flex_1 pad_left_1">
                    <button class="supermini" v-on:click="replaceAllMatches">Visualizar *</button>
                </div>
            </div>
            <div class="pad_top_1">
                <textarea class="width_100"
                    v-model="replace"
                    v-on:keyup.esc.prevent="cancel"></textarea>
            </div>
        </div>
        <hr />
        <div class="pad_top_1">
            <div class="flex_row centered">
                <div class="flex_1 nowrap"> Salida: </div>
                <div class="flex_100 pad_left_1"></div>
                <div class="flex_1 pad_left_1">
                    <button class="supermini button_danger"
                    v-on:click="accept">Aplicar cambios</button>
                </div>
            </div>
            <div class="pad_top_1">
                <pre class="codeblock pad_1" style="max-height: 600px; overflow: scroll;">{{ currentInput }}</pre>
            </div>
        </div>
        <hr />
        <div class="flex_row centered">
            <div class="flex_100"></div>
            <div class="flex_1 pad_left_1">
                <button class="supermini button_danger"
                    v-on:click="accept">Aplicar cambios</button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini"
                    v-on:click="cancel">Cancelar</button>
            </div>
        </div>
    </div>
</div>`,
  props: {
    input: {
      type: String,
      default: () => false,
    },
    initialSearch: {
      type: String,
      default: () => "",
    },
    initialReplace: {
      type: String,
      default: () => "",
    },
    onAccept: {
      type: Function,
      default: () => {},
    },
    onCancel: {
      type: Function,
      default: () => {},
    },
    onFinally: {
      type: Function,
      default: () => {},
    },
  },
  data() {
    this.$trace("lsw-search-replacer.data");
    return {
      currentInput: this.input,
      currentMatch: false,
      search: this.initialSearch || "",
      searchAsRegexp: false,
      replace: this.initialReplace || "",
    };
  },
  methods: {
    toggleRegexpMode() {
      this.$trace("lsw-search-replacer.methods.toggleRegexpMode");
      this.searchAsRegexp = !this.searchAsRegexp;
    },
    accept() {
      this.$trace("lsw-search-replacer.methods.accept");
      this.onAccept(this.currentInput, this);
      this.onFinally(this.currentInput, this);
    },
    cancel() {
      this.$trace("lsw-search-replacer.methods.cancel");
      this.onCancel(this.currentInput, this);
      this.onFinally(this.currentInput, this);
    },
    illuminateMatches() {
      this.$trace("lsw-search-replacer.methods.illuminateMatches");
      if(!this.searchAsRegexp) {

      }
    },
    replaceAllMatches() {
      this.$trace("lsw-search-replacer.methods.replaceAllMatches");
      if(this.searchAsRegexp) {
        const regexp = new RegExp(this.search, "g");
        this.currentInput = this.currentInput.replaceAll(regexp, this.replace);
      } else {
        this.currentInput = this.currentInput.replaceAll(this.search, this.replace);
      }
    },
  },
  watch: {},
  mounted() {
    this.$trace("lsw-search-replacer.mounted");
    
  },
  unmounted() {
    this.$trace("lsw-search-replacer.unmounted");
    
  }
});
// @code.end: LswSearchReplacer API

// @vuebundler[Lsw_framework_components][109]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-search-replacer/lsw-search-replacer.css

// @vuebundler[Lsw_framework_components][110]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/lsw-agenda/lsw-agenda.html

// @vuebundler[Lsw_framework_components][110]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/lsw-agenda/lsw-agenda.js
// @code.start: LswAgenda API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgenda API  LswAgenda component
Vue.component("LswAgenda", {
  name: "LswAgenda",
  template: `<div class="lsw_agenda">

    <div class="agenda_topbar flex_1 flex_row"
        style="gap: 4px;">
        <div class="flex_100"></div>
        <template v-if="typeof \$window.cordova !== 'undefined'">
            <div class="flex_1">
                <button class="width_100 nowrap supermini"
                    v-on:click="synchronizeAlarms"></button>
            </div>
            <div class="flex_1">
                <button class="width_100 nowrap supermini"
                    v-on:click="unsynchronizeAlarms"></button>
            </div>
        </template>
    </div>

    <div v-if="selectedContext === 'conductometria'" class="pad_top_1">
        <lsw-conductometria />
    </div>
    
    <div class="calendar_viewer pad_top_1"
        v-show="(selectedContext === 'agenda') && (selectedAction === 'calendario')">
        <lsw-calendario ref="calendario"
            modo="date"
            :al-iniciar="(v, cal) => loadDateTasks(v, cal)"
            :al-cambiar-valor="(v, cal) => loadDateTasks(v, cal)" />
        <div class="pad_top_1">
            <lsw-agenda-acciones-viewer :initial-date="selectedDate" ref="agenda_acciones_viewer" />
        </div>
    </div>

</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda.data");
    return {
      counter: 0,
      isLoading: false,
      hasPsicodelia: true,
      selectedHiddenMenu: "none",
      selectedContext: "agenda",
      selectedAction: 'calendario',
      selectedDate: undefined,
      selectedDateTasks: undefined,
      selectedDateTasksSorted: undefined,
      selectedDateTasksFormattedPerHour: undefined,
      selectedForm: undefined,
      hiddenDateHours: [],
      shownAcciones: [],
    };
  },
  methods: {
    toggleShowAccion(accionId) {
      this.$trace("lsw-agenda.methods.toggleShowAccion");
      const pos = this.shownAcciones.indexOf(accionId);
      if (pos === -1) {
        this.shownAcciones.push(accionId);
      } else {
        this.shownAcciones.splice(pos, 1);
      }
    },
    selectHiddenMenu(menuId) {
      this.$trace("lsw-agenda.methods.selectHiddenMenu");
      this.selectedHiddenMenu = menuId;
    },
    selectAction(accionId, contextId = false) {
      this.$trace("lsw-agenda.methods.selectAction");
      if (contextId) {
        this.selectContext(contextId);
      }
      this.selectedAction = accionId;
    },
    selectContext(id, parameters = {}) {
      this.$trace("lsw-agenda.methods.selectContext");
      this.selectedHiddenMenu = "none";
      this.selectedContextParameters = parameters;
      this.selectedContext = id;
    },
    toggleCalendario() {
      this.$trace("lsw-agenda.methods.toggleCalendario");
      const finalState = (this.selectedAction === "calendario") ? "none" : "calendario";
      if (this.selectedContext !== "agenda") {
        this.selectContext("agenda");
        this.selectAction("calendario");
        return;
      }
      this.selectAction(finalState);
    },
    selectCalendario() {
      this.$trace("lsw-agenda.methods.selectCalendario");
      this.selectContext("agenda");
      this.selectAction("calendario");
    },
    selectConductometria() {
      this.$trace("lsw-agenda.methods.selectCondutometria");
      this.selectContext("conductometria");
      // this.selectAction("calendario");
    },
    togglePsicodelia() {
      this.$trace("lsw-agenda.methods.togglePsicodelia");
      this.hasPsicodelia = !this.hasPsicodelia;
    },
    toggleHour(hourInt) {
      this.$trace("lsw-agenda.methods.toggleHour");
      const pos = this.hiddenDateHours.indexOf(hourInt);
      if (pos === -1) {
        this.hiddenDateHours.push(hourInt);
      } else {
        this.hiddenDateHours.splice(pos, 1);
      }
    },
    reloadDateTasks() {
      this.$trace("lsw-agenda.methods.reloadDateTasks");
      return this.loadDateTasks(this.selectedDate);
    },
    async loadDateTasks(dateInput, calendario, isOnMounted = false) {
      this.$trace("lsw-agenda.methods.loadDateTasks");
      // this.isLoading = true;
      const newDate = dateInput || new Date();
      console.log("[*] Loading date tasks of: " + LswTimer.utils.fromDateToDatestring(newDate));
      try {
        this.selectedDate = newDate;
        const selectedDate = this.selectedDate;
        const selectedDateTasks = await this.$lsw.database.selectMany("Accion", valueBrute => {
          try {
            const valueList = LswTimer.parser.parse(valueBrute.tiene_inicio);
            const value = valueList[0];
            const isSameYear = value.anio === selectedDate.getFullYear();
            const isSameMonth = value.mes === (selectedDate.getMonth() + 1);
            const isSameDay = value.dia === selectedDate.getDate();
            const isAccepted = isSameYear && isSameMonth && isSameDay;
            return isAccepted;
          } catch (error) {
            return true;
          }
        });
        this.selectedDateTasks = selectedDateTasks;
        this.selectedDateTasksSorted = selectedDateTasks.sort((accion1, accion2) => {
          let inicio1 = undefined;
          let inicio2 = undefined;
          try {
            inicio1 = LswTimer.utils.fromDatestringToDate(accion1.tiene_inicio);
          } catch (error) {
            return 1;
          }
          try {
            inicio2 = LswTimer.utils.fromDatestringToDate(accion2.tiene_inicio);
          } catch (error) {
            return -1;
          }
          if (inicio1 < inicio2) {
            return -1;
          } else if (inicio1 > inicio2) {
            return 1;
          } else {
            return -1;
          }
        });
        if (isOnMounted) {
          const noTasksFound = (!this.selectedDateTasks) || (!this.selectedDateTasks.length);
          if (noTasksFound) {
            this.isCalendarioSelected = true;
          }
        }
        this.propagateDateTasks();
      } catch (error) {
        console.log("Error loading date taskes:", error);
      } finally {
        setTimeout(() => { this.isLoading = false }, 100);
      }
      await this.reloadCalendarioMarks(calendario);
      this.refreshTasks();
    },
    async reloadCalendarioMarks(calendario) {
      if (calendario) {
        const selectedDate = this.selectedDate;
        const tasksOfMonth = await this.$lsw.database.selectMany("Accion", valueBrute => {
          const valueList = LswTimer.parser.parse(valueBrute.tiene_inicio);
          const value = valueList[0];
          const isSameYear = value.anio === selectedDate.getFullYear();
          const isSameMonth = value.mes === (selectedDate.getMonth() + 1);
          const isAccepted = isSameYear && isSameMonth;
          return isAccepted;
        });
        const tasksOfMonthByDay = tasksOfMonth.reduce((out, item) => {
          const valueList = LswTimer.parser.parse(item.tiene_inicio);
          const value = valueList[0];
          const day = value.dia;
          if (!(day in out)) {
            out[day] = [];
          }
          out[day].push(item);
          return out;
        }, {});
        calendario.establecer_marcadores_del_mes(tasksOfMonthByDay);
      }
    },
    groupTasksByHour(tareas = this.selectedDateTasks) {
      this.$trace("lsw-agenda.methods.groupTasksByHour");
      const mapaHoras = {};
      Agrupacion_inicial:
      for (let i = 0; i < tareas.length; i++) {
        const tarea = tareas[i];
        const { tiene_inicio } = tarea;
        const [inicioObject] = LswTimer.parser.parse(tiene_inicio);
        const { hora, minuto } = inicioObject;
        if (typeof hora !== "number") {
          continue Agrupacion_inicial;
        }
        if (!(hora in mapaHoras)) {
          mapaHoras[hora] = [];
        }
        mapaHoras[hora].push(tarea);
      }
      //return mapaHoras;
      const segunHoras = [];
      Formateo_final:
      for (let hora in mapaHoras) {
        const lista = mapaHoras[hora];
        segunHoras.push({
          hora,
          tareas: lista,
        });
      }
      return segunHoras;
    },
    propagateDateTasks() {
      this.$trace("lsw-agenda.methods.propagateDateTasks");
      this.selectedDateTasksFormattedPerHour = this.groupTasksByHour();
    },
    async openInsertTaskDialog() {
      this.$trace("lsw-agenda.methods.openInsertTaskDialog");
      // *@TODO: 
    },
    async openDeleteTaskDialog(tarea, e) {
      this.$trace("lsw-agenda.methods.openDeleteTaskDialog");
      const confirmed = await Vue.prototype.$dialogs.open({
        title: "Eliminar registro",
        template: `
          <div>
            <div class="pad_2">Seguro que quieres eliminar el registro?</div>
            <hr class="margin_0" />
            <div class="pad_2 text_align_right">
              <button class="supermini danger_button" v-on:click="() => accept(true)">Eliminar</button>
              <button class="supermini " v-on:click="() => accept(false)">Cancelar</button>
            </div>
          </div>
        `,
      });
      if (!confirmed) return false;
      await this.$lsw.database.delete("Accion", tarea.id);
      this.selectedForm = undefined;
      this.refreshTasks();
    },
    selectHour(hora) {
      this.$trace("lsw-agenda.methods.selectHour");
      if (this.selectedForm === hora) {
        this.selectedForm = undefined;
      } else {
        this.selectedForm = hora;
      }
    },
    async refreshTasks() {
      this.$trace("lsw-agenda.methods.refreshTasks");
      if (this.$refs.agenda_acciones_viewer) {
        this.$refs.agenda_acciones_viewer.changeDate(new Date(this.selectedDate));
      }
    },
    async synchronizeAlarms() {
      this.$trace("lsw-agenda.methods.synchronizeAlarms");
      Cordova_injection: {
        if (typeof this.$window.cordova !== "undefined") {
          const dateToday = new Date();
          const allAlarms = await this.$lsw.database.selectMany("Accion", accion => {
            const dateAccion = LswTimer.utils.fromDatestringToDate(accion.tiene_inicio);
            return LswTimer.utils.areSameDayDates(dateToday, dateAccion);
          });
          const soundFile = LswRandomizer.getRandomItem([
            "file://assets/sounds/alarm.busca.wav",
            "file://assets/sounds/alarm.clock-light.wav",
            "file://assets/sounds/alarm.facility-breach.wav",
            "file://assets/sounds/alarm.heavy.wav",
            "file://assets/sounds/alarm.submarine.wav",
          ])
          try {
            for (let index = 0; index < allAlarms.length; index++) {
              const accion = allAlarms[index];
              const id = index + 1;
              this.$window.cordova.plugins.notification.local.cancel(id);
              this.$window.cordova.plugins.notification.local.schedule({
                id,
                title: "Requiresete!",
                text: `Vamos con ${accion.en_concepto}!`,
                trigger: {
                  at: LswTimer.utils.fromDatestringToDate(accion.tiene_inicio)
                },
                vibrate: [1000, 1000, 1000, 1000],
                wakeUp: true,
                lockscreen: true,
                sound: soundFile
              });
            }
            this.$lsw.toasts.send({
              title: "Alarmas sincronizadas",
              text: `Unas ${allAlarms.length} alarmas fueron sincronizadas con el dispositivo`
            });
          } catch (error) {
            this.$lsw.toasts.showError(error);
          }
        }
      }
    },
    unsynchronizeAlarms() {
      this.$trace("lsw-agenda.methods.unsynchronizeAlarms");
      Cordova_injection: {
        if (typeof this.$window.cordova !== "undefined") {
          try {
            this.$window.cordova.plugins.notification.local.cancelAll(() => {
              this.$lsw.toasts.send({
                title: "Alarmas desincronizadas",
                text: "Las alarmas se eliminaron del dispositivo"
              });
            })
          } catch (error) {
            this.$lsw.toasts.showError(error);
          }
        }
      }
    },
  },
  watch: {
  },
  computed: {
    isCalendarioSelected() {
      return this.selectedAction === "calendario";
    }
  },
  async mounted() {
    try {
      this.$trace("lsw-agenda.mounted");
      const selectedDate = this.$refs.calendario.getValue();
      await this.loadDateTasks(selectedDate, undefined, true);
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgenda API


// @vuebundler[Lsw_framework_components][110]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/lsw-agenda/lsw-agenda.css

// @vuebundler[Lsw_framework_components][111]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-accion-add/lsw-agenda-accion-add.html

// @vuebundler[Lsw_framework_components][111]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-accion-add/lsw-agenda-accion-add.js
// @code.start: LswAgendaAccionAdd API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaAccionAdd API  LswAgendaAccionAdd component
Vue.component("LswAgendaAccionAdd", {
  template: `<div class="LswAgendaAccionAdd" style="padding-top: 4px;">
  <template>
    <lsw-schema-based-form
      :on-submit="insertAccion"
      :model="{
        databaseId: 'lsw_default_database',
        tableId: 'Accion',
        rowId: -1,
      }"
    />
  </template>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-accion-add.data");
    return {
      // 
    };
  },
  methods: {
    async insertAccion(v) {
      this.$trace("lsw-agenda-accion-add.methods.insertAccion");
      await this.$lsw.database.insert("Accion", v);
      // *@TODO: should redirect
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-accion-add.mounted");
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaAccionAdd API

// @vuebundler[Lsw_framework_components][111]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-accion-add/lsw-agenda-accion-add.css

// @vuebundler[Lsw_framework_components][112]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-accion-search/lsw-agenda-accion-search.html

// @vuebundler[Lsw_framework_components][112]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-accion-search/lsw-agenda-accion-search.js
// @code.start: LswAgendaAccionSearch API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaAccionSearch API  LswAgendaAccionSearch component
Vue.component("LswAgendaAccionSearch", {
  template: `<div class="LswAgendaAccionSearch pad_top_1">
  <lsw-database-explorer
    :show-breadcrumb="true"
    initial-page="lsw-page-rows"
    :initial-args="{
      database: 'lsw_default_database',
      table: 'Accion',
    }"
  />
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-accion-search.data");
    return {
      isLoaded: false,
    };
  },
  methods: {
    async loadRows() {
      this.$trace("lsw-agenda-accion-search.methods.loadRows");
      this.rows = await this.$lsw.database.selectMany("Accion", it => true);
      this.isLoaded = true;
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-accion-search.mounted");
      this.loadRows();
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaAccionSearch API

// @vuebundler[Lsw_framework_components][112]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-accion-search/lsw-agenda-accion-search.css

// @vuebundler[Lsw_framework_components][113]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-acciones-viewer/lsw-agenda-acciones-viewer.html

// @vuebundler[Lsw_framework_components][113]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-acciones-viewer/lsw-agenda-acciones-viewer.js
// @code.start: LswAgendaAccionesViewer API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaAccionesViewer API  LswAgendaAccionesViewer component
Vue.component("LswAgendaAccionesViewer", {
  name: "LswAgendaAccionesViewer",
  template: `<div class="lsw_agenda_acciones_viewer">

    <template class=""
        v-if="true || (sorterStrategy === 'despues')">
        <template class=""
            v-if="!isLoading">
            <template class=""
                v-if="isShowingGoals">
                <lsw-goals-viewer ref="goalsViewer"
                    :on-close="() => {isShowingGoals = false;}"
                    :day-to-analize="selectedDate" />
            </template>
        </template>
    </template>

    <div class="tasks_viewer">
        <div class="selected_day_title"
            v-if="selectedDate">
            <div class="flex_row centered">
                <div class="flex_1 margin_right_1">
                    <button class="padded_vertically_1"
                        v-on:click="openNewRowDialog"
                        :class="{activated: selectedForm === 'new'}"></button>
                </div>
                <div class="flex_100">{{ \$lsw.timer.utils.formatDateToSpanish(selectedDate, true) }}</div>
                <div class="flex_1 nowrap">
                    <button :class="{activated:isShowingRandomizer}" v-on:click="toggleRandomizer"></button>
                    <div class="hidden_menu"
                        v-if="isShowingRandomizer">
                        <div class="hidden_menu_fixed_layer"
                            v-on:click="toggleRandomizer"></div>
                        <div class="hidden_menu_box"
                            style="min-width: 160px; left: auto; right: 0px; padding: 0px; padding-top:4px;">
                            <div class="hidden_menu_items flex_column">
                                <div class="title">
                                    <div class="flex_100 pad_left_1 pad_right_1">
                                        El randomizador:
                                    </div>
                                    <div class="flex_1">
                                        <button class="supermini"
                                            v-on:click="toggleRandomizer"></button>
                                    </div>
                                </div>
                                <button class="flex_1 pad_bottom_1 text_align_left supermini"
                                    v-on:click="openRandomizerFile">
                                    <div class="flex_row centered">
                                        <div class="flex_1">
                                            
                                        </div>
                                        <div class="flex_100 text_align_right">
                                            Editar randomizables
                                        </div>
                                    </div>
                                </button>
                                <button class="flex_1 pad_bottom_1 text_align_left supermini"
                                    v-on:click="randomizeDay">
                                    <div class="flex_row centered">
                                        <div class="flex_1">
                                            +
                                        </div>
                                        <div class="flex_100 text_align_right">
                                            Inflar da
                                        </div>
                                    </div>
                                </button>
                                <button class="flex_1 pad_bottom_1 text_align_left supermini"
                                    v-on:click="cleanRandomizedDays">
                                    <div class="flex_row centered">
                                        <div class="flex_1">
                                            
                                        </div>
                                        <div class="flex_100 text_align_right">
                                            Limpiar da
                                        </div>
                                    </div>
                                </button>
                                <button class="flex_1 pad_bottom_1 text_align_left supermini"
                                    v-on:click="showAllHours"
                                    style="display: none;">*</button>
                                <button class="flex_1 pad_bottom_1 text_align_left supermini"
                                    v-on:click="hideAllHours"
                                    style="display: none;">*</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="no_tasks_message"
            v-if="isLoading">
            Por favor, aguarde hasta recuperar los datos.
        </div>
        <div v-if="(!isLoading) && selectedDateTasksSorted && selectedDateTasksSorted.length">
            <template v-for="accion, accionIndex in selectedDateTasksSorted">
                <div class="hour_task_block"
                    v-if="accion.tiene_estado === 'trackeada'">
                    <div class="accion_row flex_row centered"
                        style="padding-top: 2px;">
                        <div class="flex_1 celda_de_hora"
                            v-on:click="\$noop">
                            <div class="padded_vertically_1 pad_left_1">
                                {{
                                \$lsw.timer.utils.formatHourFromMomentoCode(accion.tiene_inicio, false) ?? ''
                                }}
                            </div>
                        </div>
                        <div class="">
                            <button class="supermini padded_vertically_1">
                                
                            </button>
                        </div>
                        <div class="flex_1 celda_de_duracion pad_right_1">{{ accion.tiene_duracion || '' }}</div>
                        <button class="supermini flex_100 text_align_left pad_0 margin_right_1 nowrap shortable_text"
                            disabled="true"
                            style="min-width: 80px;">
                            <b>{{ accion.en_concepto }}</b><span v-if="accion.tiene_comentarios">: {{ accion.tiene_comentarios }}</span>
                        </button>
                        <button class="supermini flex_1"
                            v-on:click="() => openEditRowDialog(accion)">
                            
                        </button>
                        <div class="flex_1">
                            <button class="supermini danger_button padded_vertically_1"
                                v-on:click="(e) => openDeleteTaskDialog(accion, e)"></button>
                        </div>
                    </div>
                </div>
                <div class="hour_task_block"
                    v-else
                    :class="{is_completed: accion.tiene_estado === 'completada', is_failed: accion.tiene_estado === 'fallida', is_pending: accion.tiene_estado === 'pendiente'}"
                    v-bind:key="'accion_' + accionIndex">
                    <div class="accion_row flex_row centered"
                        style="padding-top: 2px;">
                        <div class="flex_1 celda_de_hora"
                            v-on:click="() => toggleShowAccion(accion.id)">
                            <div class="padded_vertically_1 pad_left_1">{{
                                \$lsw.timer.utils.formatHourFromMomentoCode(accion.tiene_inicio, false) ?? ''
                                }}
                            </div>
                        </div>
                        <div>
                            <button class="supermini padded_vertically_1"
                                v-on:click="(e) => toggleAutogeneration(accion)">{{ accion.tiene_parametros.startsWith("[*autogenerada]") ?
                                "" : accion.tiene_parametros.startsWith("[*semanal]") ? "" : "" }}</button>
                        </div>
                        <div class="flex_1 celda_de_duracion pad_right_1">{{ accion.tiene_duracion || '' }}</div>
                        <div class="flex_100 celda_de_concepto shortable_text">
                            <div class=" pad_left_1 pad_right_1 padded_vertically_1"
                                :class="{activated: shownAcciones.indexOf(accion.id) !== -1}"
                                v-on:click="() => advanceTaskState(accion)"> {{ accion.en_concepto || '' }}
                            </div>
                        </div>
                        <div class="flex_1">
                            <button class="supermini padded_vertically_1"
                                :class="{activated: selectedForm === accion.id}"
                                v-on:click="() => openEditRowDialog(accion)"></button>
                        </div>
                        <div class="flex_1">
                            <button class="supermini danger_button padded_vertically_1"
                                v-on:click="(e) => openDeleteTaskDialog(accion, e)"></button>
                        </div>
                    </div>
                    <div class="detalles_de_accion"
                        v-if="shownAcciones.indexOf(accion.id) !== -1">
                        <div class="tabla_de_detalles">
                            <div class="campo"
                                v-if="accion.en_concepto">
                                <div class="clave">Concepto: </div>
                                <div class="valor"><u>{{ accion.en_concepto }}</u></div>
                            </div>
                            <div class="campo"
                                v-if="accion.tiene_estado">
                                <div class="clave">Estado: </div>
                                <div class="valor valor_de_estado">{{ accion.tiene_estado }}</div>
                            </div>
                            <div class="campo"
                                v-if="accion.tiene_inicio">
                                <div class="clave">Inicio: </div>
                                <div class="valor">{{ accion.tiene_inicio }}</div>
                            </div>
                            <div class="campo"
                                v-if="accion.tiene_duracion">
                                <div class="clave">Duracin: </div>
                                <div class="valor">{{ accion.tiene_duracion }}</div>
                            </div>
                            <div class="campo"
                                v-if="accion.tiene_parametros">
                                <div class="clave">Parmetros: </div>
                                <div class="valor texto_markdown sin_decorar"
                                    v-html="marked.parse(accion.tiene_parametros)"></div>
                            </div>
                            <div class="campo"
                                v-if="accion.tiene_comentarios">
                                <div class="clave">Comentarios: </div>
                                <div class="valor texto_markdown sin_decorar"
                                    v-html="(accion.tiene_comentarios)"></div>
                            </div>
                            <div class="campo"
                                v-if="accion.tiene_resultados">
                                <div class="clave">Resultados: </div>
                                <div class="valor texto_markdown sin_decorar"
                                    v-html="(accion.tiene_resultados)"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>
        <div class="no_tasks_message"
            v-else>
            No hay tareas asignadas para este da.
        </div>
    </div>
</div>`,
  props: {
    initialDate: {
      type: Date,
      required: true,
    },
    sorterStrategy: {
      type: String,
      default: () => false,
    }
  },
  data() {
    this.$trace("lsw-agenda-acciones-viewer.data");
    return {
      isLoading: true,
      isShowingGoals: true,
      isShowingRandomizer: false,
      selectedDate: this.initialDate,
      selectedAccion: "",
      selectedForm: false,
      selectedDateTasks: undefined,
      selectedDateTasksSorted: undefined,
      hiddenDateHours: [],
      shownAcciones: [],
    };
  },
  methods: {
    hideRandomizer() {
      this.$trace("lsw-agenda-acciones-viewer.methods.hideRandomizer");
      this.isShowingRandomizer = false;
    },
    toggleRandomizer() {
      this.$trace("lsw-agenda-acciones-viewer.methods.toggleRandomizer");
      this.isShowingRandomizer = !this.isShowingRandomizer;
    },
    openRandomizerFile() {
      this.$trace("lsw-agenda-acciones-viewer.methods.openRandomizerFile");
      this.hideRandomizer();
      Load_secretly_random_actions_as_concepts: {
        setTimeout(async () => {
          const randomizables = await this.$lsw.fs.evaluateAsDotenvFileOrReturn("/kernel/settings/randomizables.env", {});
          const names = Object.keys(randomizables);
          const knownNames = await this.$lsw.database.selectMany("Concepto", c => {
            return names.indexOf(c.tiene_nombre) !== -1;
          });
          const missingNames = LswUtils.arrays.getMissingInFirst(knownNames, names);
          const conceptos = missingNames.map(name => {
            return {
              tiene_nombre: name,
              tiene_comentarios: "",
            }
          });
          for(let indexConcepto=0; indexConcepto<conceptos.length; indexConcepto++) {
            const concepto = conceptos[indexConcepto];
            try {
              await this.$lsw.database.insert("Concepto", concepto);
            } catch (error) {
              // @BADLUCK
            }
          }
        }, 0);
      }
      this.$lsw.dialogs.open({
        title: "Editar randomizables.env",
        template: `
          <div>
            <lsw-filesystem-explorer opened-by="/kernel/settings/randomizables.env" :absolute-layout="true" />
          </div>
        `,
      });
    },
    changeDate(selectedDate) {
      this.$trace("lsw-agenda-acciones-viewer.methods.changeDate");
      this.selectedDate = selectedDate;
      this.loadDateTasks();
    },
    selectForm(hora) {
      this.$trace("lsw-agenda-acciones-viewer.methods.selectForm");
      if (this.selectedForm === hora) {
        this.selectedForm = undefined;
      } else {
        this.selectedForm = hora;
      }
    },
    async onInsertTask(v, tarea) {
      this.$trace("lsw-agenda-acciones-viewer.methods.onInsertTask");
      const id = await this.$lsw.database.insert('Accion', v);
      this.selectForm(id);
      this.loadDateTasks();
    },
    async toggleAutogeneration(tarea) {
      this.$trace("lsw-agenda-acciones-viewer.methods.toggleAutogeneration");
      const siguientesParametros = (() => {
        if(tarea.tiene_parametros.startsWith("[*autogenerada]")) {
          return tarea.tiene_parametros.replace(/^\[\*autogenerada\] */g, "");
        }
        return "[*autogenerada] " + tarea.tiene_parametros;
      })();
      await this.$lsw.database.overwrite('Accion', tarea.id, {
        tiene_parametros: siguientesParametros
      });
      await this.loadDateTasks();
    },
    async advanceTaskState(tarea) {
      this.$trace("lsw-agenda-acciones-viewer.methods.advanceTaskState");
      const siguienteEstado = (() => {
        switch (tarea.tiene_estado) {
          case "pendiente": return "completada";
          case "completada": return "fallida";
          case "fallida": return "pendiente";
          default: return "pendiente";
        }
      })();
      await this.$lsw.database.overwrite('Accion', tarea.id, {
        tiene_estado: siguienteEstado
      });
      await this.loadDateTasks();
    },
    toggleShowAccion(accionId) {
      this.$trace("lsw-agenda-acciones-viewer.methods.toggleShowAccion");
      const pos = this.shownAcciones.indexOf(accionId);
      if (pos === -1) {
        this.shownAcciones.push(accionId);
      } else {
        this.shownAcciones.splice(pos, 1);
      }
    },
    async loadDateTasks() {
      this.isLoading = true;
      const selectedDate = this.selectedDate;
      const selectedDateTasks = await this.$lsw.database.selectMany("Accion", valueBrute => {
        try {
          const valueList = LswTimer.parser.parse(valueBrute.tiene_inicio);
          const value = valueList[0];
          const isSameYear = value.anio === selectedDate.getFullYear();
          const isSameMonth = value.mes === (selectedDate.getMonth() + 1);
          const isSameDay = value.dia === selectedDate.getDate();
          const isAccepted = isSameYear && isSameMonth && isSameDay;
          return isAccepted;
        } catch (error) {
          return true;
        }
      });
      Constitute_date_tasks_as_required: {
        if (this.sorterStrategy === false) {
          this.selectedDateTasks = selectedDateTasks;
          this.selectedDateTasksSorted = selectedDateTasks.sort((accion1, accion2) => {
            let inicio1 = undefined;
            let inicio2 = undefined;
            try {
              inicio1 = LswTimer.utils.fromDatestringToDate(accion1.tiene_inicio);
            } catch (error) {
              return 1;
            }
            try {
              inicio2 = LswTimer.utils.fromDatestringToDate(accion2.tiene_inicio);
            } catch (error) {
              return -1;
            }
            if (inicio1 < inicio2) {
              return -1;
            } else if (inicio1 > inicio2) {
              return 1;
            } else {
              return -1;
            }
          });
        } else if (this.sorterStrategy === "despues") {
          this.selectedDateTasks = selectedDateTasks;
          const momentoActual = new Date();
          Mostramos_las_tareas_de_la_hora_actual_en_adelante: {
            momentoActual.setMinutes(0);
          }
          this.selectedDateTasksSorted = selectedDateTasks.filter(accion => {
            const dateInicio = LswTimer.utils.fromDatestringToDate(accion.tiene_inicio);
            try {
              return momentoActual <= dateInicio;
            } catch (error) {
              console.log(error);
              return false;
            }
          }).sort((accion1, accion2) => {
            let inicio1 = undefined;
            let inicio2 = undefined;
            try {
              inicio1 = LswTimer.utils.fromDatestringToDate(accion1.tiene_inicio);
            } catch (error) {
              return 1;
            }
            try {
              inicio2 = LswTimer.utils.fromDatestringToDate(accion2.tiene_inicio);
            } catch (error) {
              return -1;
            }
            if (inicio1 < inicio2) {
              return -1;
            } else if (inicio1 > inicio2) {
              return 1;
            } else {
              return -1;
            }
          });
        } else if (this.sorterStrategy === "antes") {
          this.selectedDateTasks = selectedDateTasks;
          const momentoActual = new Date();
          this.selectedDateTasksSorted = selectedDateTasks.filter(accion => {
            const dateInicio = LswTimer.utils.fromDatestringToDate(accion.tiene_inicio);
            try {
              return momentoActual >= dateInicio;
            } catch (error) {
              console.log(error);
              return false;
            }
          }).sort((accion1, accion2) => {
            let inicio1 = undefined;
            let inicio2 = undefined;
            try {
              inicio1 = LswTimer.utils.fromDatestringToDate(accion1.tiene_inicio);
            } catch (error) {
              return 1;
            }
            try {
              inicio2 = LswTimer.utils.fromDatestringToDate(accion2.tiene_inicio);
            } catch (error) {
              return -1;
            }
            if (inicio1 < inicio2) {
              return 1;
            } else if (inicio1 > inicio2) {
              return -1;
            } else {
              return 1;
            }
          });
        }
      }
      this.isLoading = false;
    },
    showAllHours() {
      this.$trace("lsw-agenda-acciones-viewer.methods.showAllHours");
      this.hiddenDateHours = [];
    },
    hideAllHours() {
      this.$trace("lsw-agenda-acciones-viewer.methods.hideAllHours");
      this.hiddenDateHours = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"];
    },
    sameDayPendingAndAutogeneratedFilter(currentDate) {
      return (accion) => {
        try {
          const accionDate = LswTimer.utils.fromDatestringToDate(accion.tiene_inicio);
          const sameYear = currentDate.getFullYear() === accionDate.getFullYear();
          const sameMonth = currentDate.getMonth() === accionDate.getMonth();
          const sameDay = currentDate.getDate() === accionDate.getDate();
          const isPendiente = accion.tiene_estado === "pendiente";
          const isAutogenerated = accion.tiene_parametros.startsWith("[*autogenerada]");
          const isValid = sameYear && sameMonth && sameDay && isPendiente && isAutogenerated;
          if (isValid) {
            console.log("!!!", accion.en_concepto);
          } else {
            console.log("sameYear, sameMonth, sameDay, isPendiente");
            console.log("Fallo:", sameYear, sameMonth, sameDay, isPendiente, isAutogenerated);
          }
          return isValid;
        } catch (error) {
          console.log(error);
          return false;
        }
      }
    },
    async cleanRandomizedDays() {
      this.$trace("lsw-agenda-acciones-viewer.methods.cleanRandomizedDays");
      this.hideRandomizer();
      const currentDate = this.selectedDate || new Date();
      const filterAutogeneratedPendingOfCurrentDate = this.sameDayPendingAndAutogeneratedFilter(currentDate);
      const matchedAcciones = await this.$lsw.database.selectMany("Accion", filterAutogeneratedPendingOfCurrentDate);
      if (!matchedAcciones.length) {
        return this.$lsw.toasts.send({
          title: "No hay acciones randomizadas",
          text: "Niniguna accin fue eliminada por ello."
        });
      }
      const respuesta = await this.$lsw.dialogs.open({
        title: "Eliminar registros randomizados",
        template: `<div>
                    <div class="pad_1">
                    <div>Ests seguro que quieres eliminar los registros randomizados?</div>
                    <div>Se eliminarn {{ accionesToDelete.length }} registros de acciones randomizados de hoy.</div>
                    <hr />
                    <div class="flex_row pad_1">
                        <div class="flex_100"></div>
                        <div class="flex_1 pad_left_1">
                        <button v-on:click="() => accept(true)" class="supermini danger_button">Eliminar</button>
                        </div>
                        <div class="flex_1 pad_left_1">
                        <button v-on:click="cancel" class="supermini">Cancelar</button>
                        </div>
                    </div>
                    </div>
                </div>`,
        factory: {
          data: {
            accionesToDelete: matchedAcciones
          }
        }
      });
      if (respuesta !== true) return;
      await this.$lsw.database.deleteMany("Accion", filterAutogeneratedPendingOfCurrentDate);
      await this.loadDateTasks(currentDate);
    },
    async randomizeDay() {
      this.$trace("lsw-agenda-acciones-viewer.methods.randomizeDay");
      this.hideRandomizer();
      const respuesta = await this.$dialogs.open({
        title: "Cuestionario de randomizar da",
        template: `<div>
            <div class="pad_1 pad_bottom_0">
                <div class="pad_1 pad_bottom_0">Qu duracin quieres para las acciones de randomizado de da?</div>
                <div class="pad_1 pad_top_2 pad_bottom_0">
                    <lsw-duration-control ref="duracion" :settings="{name:'duracion',initialValue:'20min'}" :skip-label="true" />
                </div>
                <hr />
                <div class="pad_1 pad_bottom_0">Desde qu hora quieres randomizar? Mnimo: 0.</div>
                <div class="pad_1 pad_top_2 pad_bottom_0">
                    <lsw-text-control ref="hora_inicio" :settings="{name:'hora_inicio',initialValue:currentHour}" :skip-label="true" />
                </div>
                <hr />
                <div class="pad_1 pad_bottom_0">Hasta qu hora quieres randomizar? Mximo: 24</div>
                <div class="pad_1 pad_top_2 pad_bottom_0">
                    <lsw-text-control ref="hora_final" :settings="{name:'hora_final',initialValue:'24'}" :skip-label="true" />
                </div>
            </div>
            <div v-if="error">
                <hr/>
                <div class="box_error_container error_is_affecting_field" v-on:click="() => setError(false)">
                    <div class="box_error_content">{{ error.name }}: {{ error.message }}</div>
                </div>
            </div>
            <hr />
            <div class="text_align_right pad_right_1">
                <button class="supermini danger_button" v-on:click="submit">Randomizar da</button>
                <button class="supermini" v-on:click="cancel">Cancelar</button>
            </div>
        </div>`,
        factory: {
          data: {
            error: false,
            currentHour: (new Date()).getHours() + "",
          },
          methods: {
            setError(error) {
              this.error = error;
            },
            submit() {
              this.$trace("Dialogs.randomizar_dia.methos.submit");
              try {
                const valor = this.$refs.duracion.value;
                const ast = LswTimer.parser.parse(valor);
                const esValido = (valor.trim() !== "") && (typeof ast[0] === "object") && (ast[0].tipo === "Duracion");
                if (!esValido) return;
                this.value = {
                  duracion: valor,
                  hora_inicio: parseInt(this.$refs.hora_inicio.value),
                  hora_final: parseInt(this.$refs.hora_final.value),
                };
                if (this.value.hora_inicio < 0) {
                  throw new Error("Hora de inicio debe ser mayor que 0");
                }
                if (this.value.hora_inicio > 24) {
                  throw new Error("Hora de inicio debe ser menor o igual que 24");
                }
                if (this.value.hora_final < 0) {
                  throw new Error("Hora de final debe ser mayor que 0");
                }
                if (this.value.hora_final > 24) {
                  throw new Error("Hora de final debe ser menor o igual que 24");
                }
                return this.accept();
              } catch (error) {
                console.log(error);
                this.setError(error);
              }
            }
          }
        }
      });
      const {
        duracion: duracion_de_bloques,
        hora_inicio,
        hora_final
      } = respuesta;
      if (typeof duracion_de_bloques !== "string") return;
      const currentDate = this.selectedDate;
      const accionesDelDia = await this.$lsw.database.select("Accion", accion => {
        try {
          const accionDate = LswTimer.utils.fromDatestringToDate(accion.tiene_inicio);
          const sameYear = currentDate.getFullYear() === accionDate.getFullYear();
          const sameMonth = currentDate.getMonth() === accionDate.getMonth();
          const sameDay = currentDate.getDate() === accionDate.getDate();
          const isNotPendiente = accion.tiene_estado !== "pendiente";
          const isValid = sameYear && sameMonth && sameDay && isNotPendiente;
          return isValid;
        } catch (error) {
          console.log(error);
          return false;
        }
      });
      const momentoInicio = new Date(this.selectedDate);
      Configurar_hora_de_inicio: {
        momentoInicio.setHours(hora_inicio);
        momentoInicio.setMinutes(0);
        momentoInicio.setSeconds(0);
        momentoInicio.setMilliseconds(0);
      }
      const momentoFinal = new Date(this.selectedDate);
      Configurar_hora_de_final: {
        momentoFinal.setHours(hora_final - 1);
        momentoFinal.setMinutes(0);
        momentoFinal.setSeconds(0);
        momentoFinal.setMilliseconds(0);
      }
      const randomizableRules = await this.$lsw.fs.evaluateAsDotenvFileOrReturn("/kernel/settings/randomizables.env", {});
      const accionesAutogeneradas = LswAgendaRandomizer.generar(
        randomizableRules,
        accionesDelDia,
        momentoInicio,
        duracion_de_bloques,
        momentoFinal,
        0.2
      );
      accionesAutogeneradas.forEach(accion => {
        delete accion.id;
        accion.tiene_estado = "pendiente";
        accion.tiene_parametros = ("[*autogenerada] " + (accion.tiene_parametros.replace(/^\[\*autogenerada\]/g, ""))).trim();
      });
      Insertar_rows: {
        await this.$lsw.database.insertMany("Accion", accionesAutogeneradas);
        await this.loadDateTasks(this.selectedDate);
      }
    },
    async openDeleteTaskDialog(tarea, e) {
      this.$trace("lsw-agenda-acciones-viewer.methods.openDeleteTaskDialog");
      const confirmed = await Vue.prototype.$dialogs.open({
        title: "Eliminar registro",
        template: `
          <div>
            <div class="pad_2">Seguro que quieres eliminar el registro?</div>
            <hr class="margin_0" />
            <div class="pad_2 text_align_right">
              <button class="supermini danger_button" v-on:click="() => accept(true)">Eliminar</button>
              <button class="supermini " v-on:click="() => accept(false)">Cancelar</button>
            </div>
          </div>
        `,
      });
      if (!confirmed) return false;
      await this.$lsw.database.delete("Accion", tarea.id);
      this.selectedForm = undefined;
      this.loadDateTasks();
    },
    async onUpdateTask(v, tarea) {
      this.$trace("lsw-agenda-acciones-viewer.methods.onUpdateTask");
      await this.$lsw.database.update('Accion', tarea.id, v);
      this.selectedForm = tarea.id;
      this.loadDateTasks();
    },
    openNewRowDialog() {
      this.$trace("lsw-agenda-acciones-viewer.methods.openNewRowDialog");
      const that = this;
      this.$lsw.dialogs.open({
        title: "Crear accin",
        template: `
          <lsw-schema-based-form
            :on-submit="v => onInsertTask(v)"
            :on-delete-row="loadDateTasks"
            :overriden-values="{
              tiene_estado: 'pendiente',
              tiene_inicio: $lsw.timer.utils.formatDatestringFromDate(selectedDate, 1)
              + ' '
              + $lsw.timer.utils.fromDateToHour(selectedDate, true)
            }"
            :model="{
              connection: $lsw.database,
              databaseId: 'lsw_default_database',
              rowId: -1,
              tableId: 'Accion',
            }"
          />
        `,
        factory: {
          data: {
            selectedDate: that.selectedDate,
          },
          methods: {
            onInsertTask(v) {
              that.onInsertTask(v)
              this.cancel();
            },
            loadDateTasks() {
              that.loadDateTasks();
              this.cancel();
            },
          }
        }
      });
    },
    openEditRowDialog(accion) {
      this.$trace("lsw-agenda-acciones-viewer.methods.openEditRowDialog");
      const that = this;
      this.$lsw.dialogs.open({
        title: "Editar accin",
        template: `

          <lsw-schema-based-form
            :on-submit="v => onUpdateTask(v, accion)"
            :on-delete-row="loadDateTasks"
            :overriden-values="{
                tiene_inicio: accion.tiene_inicio
            }"
            :model="{
                connection: $lsw.database,
                databaseId: 'lsw_default_database',
                rowId: accion.id,
                tableId: 'Accion',
            }"
          />
        `,
        factory: {
          data: {
            accion,
            selectedDate: that.selectedDate,
          },
          methods: {
            onUpdateTask(v, accion) {
              that.onUpdateTask(v, accion);
              this.cancel();
            },
            loadDateTasks() {
              that.loadDateTasks();
              this.cancel();
            },
          }
        }
      });
    },
  },
  watch: {

  },
  async mounted() {
    try {
      this.$trace("lsw-agenda-acciones-viewer.mounted");
      await this.loadDateTasks();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaAccionesViewer API

// @vuebundler[Lsw_framework_components][113]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-acciones-viewer/lsw-agenda-acciones-viewer.css

// @vuebundler[Lsw_framework_components][114]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-breadcrumb/lsw-agenda-breadcrumb.html

// @vuebundler[Lsw_framework_components][114]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-breadcrumb/lsw-agenda-breadcrumb.js
// @code.start: LswAgendaBreadcrumb API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaBreadcrumb API  LswAgendaBreadcrumb component
Vue.component("LswAgendaBreadcrumb", {
  name: "LswAgendaBreadcrumb",
  template: `<div class="lsw_agenda_breadcrumb">
    <div class="flex_row centered">
        <div class="pad_right_1">
            <button v-on:click="() => goToSection('agenda')"></button>
        </div>
        <h3 class="agenda_breadcrumb flex_100">
            <div class="agenda_breadcrumb_item"
                v-for="pathItem, pathIndex in pathItems"
                v-bind:key="'agenda-breadcrumb-path-item-' + pathIndex">
                <span v-if="pathIndex !== 0">  </span>
                <span class="agenda_breadcrumb_link"
                    v-if="pathItem.link">
                    <a :href="pathItem.link">{{ pathItem.label }}</a>
                </span>
                <span class="agenda_breadcrumb_link"
                    v-else-if="pathItem.section">
                    <span v-on:click="() => goToSection(pathItem.section)">{{ pathItem.label }}</span>
                </span>
                <span class="agenda_breadcrumb_link"
                    v-else-if="pathItem.event">
                    <span v-on:click="pathItem.event">{{ pathItem.label }}</span>
                </span>
                <span class="agenda_breadcrumb_link only_label"
                    v-else-if="pathItem.label">
                    <span>{{ pathItem.label }}</span>
                </span>
            </div>
        </h3>
    </div>
</div>`,
  props: {
    agenda: {
      type: Object,
      default: () => null
    },
    pathItems: {
      type: Array,
      required: true
    }
  },
  data() {
    this.$trace("lsw-agenda-breadcrumb.data");
    return {
      
    };
  },
  methods: {
    goToSection(section) {
      this.$trace("lsw-agenda-breadcrumb.methods.goToSection");
      if(this.agenda) {
        this.agenda.selectContext(section);
      }
    }
  },
  watch: {

  },
  async mounted() {
    try {
      this.$trace("lsw-agenda-breadcrumb.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaBreadcrumb API

// @vuebundler[Lsw_framework_components][114]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-breadcrumb/lsw-agenda-breadcrumb.css

// @vuebundler[Lsw_framework_components][115]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-concepto-add/lsw-agenda-concepto-add.html

// @vuebundler[Lsw_framework_components][115]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-concepto-add/lsw-agenda-concepto-add.js
// @code.start: LswAgendaConceptoAdd API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaConceptoAdd API  LswAgendaConceptoAdd component
Vue.component("LswAgendaConceptoAdd", {
  template: `<div class="LswAgendaConceptoAdd">
  <template>
    <lsw-schema-based-form
      :on-submit="insertConcepto"
      :model="{
        databaseId: 'lsw_default_database',
        tableId: 'Concepto',
        rowId: -1,
      }"
    />
  </template>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-concepto-add.data");
    return {
      // 
    };
  },
  methods: {
    async insertConcepto(v) {
      this.$trace("lsw-agenda-concepto-add.methods.insertConcepto");
      await this.$lsw.database.insert("Concepto", v);
      // *@TODO: should redirect
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-concepto-add.mounted");
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaConceptoAdd API

// @vuebundler[Lsw_framework_components][115]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-concepto-add/lsw-agenda-concepto-add.css

// @vuebundler[Lsw_framework_components][116]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-concepto-search/lsw-agenda-concepto-search.html

// @vuebundler[Lsw_framework_components][116]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-concepto-search/lsw-agenda-concepto-search.js
// @code.start: LswAgendaConceptoSearch API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaConceptoSearch API  LswAgendaConceptoSearch component
Vue.component("LswAgendaConceptoSearch", {
  template: `<div class="LswAgendaConceptoSearch pad_top_1">
  <lsw-database-explorer
    :show-breadcrumb="true"
    initial-page="lsw-page-rows"
    :initial-args="{
      database: 'lsw_default_database',
      table: 'Concepto',
    }"
  />
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-concepto-search.data");
    return {
      isLoaded: false,
    };
  },
  methods: {
    async loadRows() {
      this.$trace("lsw-agenda-concepto-search.methods.loadRows");
      this.rows = await this.$lsw.database.selectMany("Concepto", it => true);
      this.isLoaded = true;
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-concepto-search.mounted");
      this.loadRows();
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaConceptoSearch API

// @vuebundler[Lsw_framework_components][116]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-concepto-search/lsw-agenda-concepto-search.css

// @vuebundler[Lsw_framework_components][117]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-evento-search/lsw-agenda-evento-search.html

// @vuebundler[Lsw_framework_components][117]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-evento-search/lsw-agenda-evento-search.js
// @code.start: LswAgendaEventoSearch API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaEventoSearch API  LswAgendaEventoSearch component
Vue.component("LswAgendaEventoSearch", {
  template: `<div class="LswAgendaEventoSearch">
  LswAgendaEventoSearch
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-evento-search.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-evento-search.mounted");
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaEventoSearch API

// @vuebundler[Lsw_framework_components][117]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-evento-search/lsw-agenda-evento-search.css

// @vuebundler[Lsw_framework_components][118]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-form/lsw-agenda-form.html

// @vuebundler[Lsw_framework_components][118]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-form/lsw-agenda-form.js
// @code.start: LswAgendaForm API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaForm API  LswAgendaForm component
Vue.component("LswAgendaForm", {
  template: `<div>
    
</div>`,
  props: {
    formMetadata: {
      type: Object,
      required: true,
    }
  },
  data() {
    this.$trace("lsw-agenda-form.data");
    this.validateFormMetadata(this.formMetadata);
    return {
      expandedExplanations: [],
      formScope: {},
      formState: {}
    };
  },
  methods: {
    validateFormMetadata(v) {
      const isObject = typeof v === "object";
      const hasFormAsObject = typeof v.form === "object";
      const hasFieldsAsArray = Array.isArray(v.fields);
      if(!isObject) {
        throw new Error("Required parameter formMetadata to be an object on LswAgendaForm.methods.validateFormMetadata");
      }
      if(!hasFormAsObject) {
        throw new Error("Required parameter formMetadata.form to be an object on LswAgendaForm.methods.validateFormMetadata");
      }
      if(!hasFieldsAsArray) {
        throw new Error("Required parameter formMetadata.fields to be an array on LswAgendaForm.methods.validateFormMetadata");
      }
    },
    toggleExplanation(id) {
      const pos = this.expandedExplanations.indexOf(id);
      if(pos === -1) {
        this.expandedExplanations.push(id);
      } else {
        this.expandedExplanations.splice(pos, 1);
      }
    },
    loadFields() {
      this.$window.F = this.$refs.agenda_form;
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-form.mounted");
      this.loadFields();
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaForm API

// @vuebundler[Lsw_framework_components][118]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-form/lsw-agenda-form.css

// @vuebundler[Lsw_framework_components][119]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-impresion-add/lsw-agenda-impresion-add.html

// @vuebundler[Lsw_framework_components][119]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-impresion-add/lsw-agenda-impresion-add.js
// @code.start: LswAgendaImpresionAdd API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaImpresionAdd API  LswAgendaImpresionAdd component
Vue.component("LswAgendaImpresionAdd", {
  template: `<div class="LswAgendaImpresionAdd">
  LswAgendaImpresionAdd
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-impresion-add.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-impresion-add.mounted");
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaImpresionAdd API

// @vuebundler[Lsw_framework_components][119]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-impresion-add/lsw-agenda-impresion-add.css

// @vuebundler[Lsw_framework_components][120]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-impresion-search/lsw-agenda-impresion-search.html

// @vuebundler[Lsw_framework_components][120]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-impresion-search/lsw-agenda-impresion-search.js
// @code.start: LswAgendaImpresionSearch API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaImpresionSearch API  LswAgendaImpresionSearch component
Vue.component("LswAgendaImpresionSearch", {
  template: `<div class="LswAgendaImpresionSearch">
  LswAgendaImpresionSearch
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-impresion-search.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-impresion-search.mounted");
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaImpresionSearch API

// @vuebundler[Lsw_framework_components][120]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-impresion-search/lsw-agenda-impresion-search.css

// @vuebundler[Lsw_framework_components][121]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-infraccion-search/lsw-agenda-infraccion-search.html

// @vuebundler[Lsw_framework_components][121]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-infraccion-search/lsw-agenda-infraccion-search.js
// @code.start: LswAgendaInfraccionSearch API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaInfraccionSearch API  LswAgendaInfraccionSearch component
Vue.component("LswAgendaInfraccionSearch", {
  template: `<div class="LswAgendaInfraccionSearch">
  LswAgendaInfraccionSearch
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-infraccion-search.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-infraccion-search.mounted");
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaInfraccionSearch API

// @vuebundler[Lsw_framework_components][121]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-infraccion-search/lsw-agenda-infraccion-search.css

// @vuebundler[Lsw_framework_components][122]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-add/lsw-agenda-limitador-add.html

// @vuebundler[Lsw_framework_components][122]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-add/lsw-agenda-limitador-add.js
// @code.start: LswAgendaLimitadorAdd API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaLimitadorAdd API  LswAgendaLimitadorAdd component
Vue.component("LswAgendaLimitadorAdd", {
  template: `<div class="LswAgendaLimitadorAdd">
  <template>
    <lsw-schema-based-form
      :on-submit="insertLimitador"
      :model="{
        databaseId: 'lsw_default_database',
        tableId: 'Limitador',
        rowId: -1,
      }"
    />
  </template>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-limitador-add.data");
    return {
      // 
    };
  },
  methods: {
    async insertLimitador(v) {
      this.$trace("lsw-agenda-limitador-add.methods.insertLimitador");
      await this.$lsw.database.insert("Limitador", v);
      // *@TODO: should redirect
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-limitador-add.mounted");
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaLimitadorAdd API

// @vuebundler[Lsw_framework_components][122]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-add/lsw-agenda-limitador-add.css

// @vuebundler[Lsw_framework_components][123]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-search/lsw-agenda-limitador-search.html

// @vuebundler[Lsw_framework_components][123]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-search/lsw-agenda-limitador-search.js
// @code.start: LswAgendaLimitadorSearch API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaLimitadorSearch API  LswAgendaLimitadorSearch component
Vue.component("LswAgendaLimitadorSearch", {
  template: `<div class="LswAgendaLimitadorSearch">
  <lsw-table v-if="isLoaded"
    :initial-input="rows"></lsw-table>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-limitador-search.data");
    return {
      isLoaded: false,
    };
  },
  methods: {
    async loadRows() {
      this.$trace("lsw-agenda-limitador-search.methods.loadRows");
      this.rows = await this.$lsw.database.selectMany("Limitador", it => true);
      this.isLoaded = true;
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-limitador-search.mounted");
      this.loadRows();
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaLimitadorSearch API

// @vuebundler[Lsw_framework_components][123]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-search/lsw-agenda-limitador-search.css

// @vuebundler[Lsw_framework_components][124]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-viewer/lsw-agenda-limitador-viewer.html

// @vuebundler[Lsw_framework_components][124]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-viewer/lsw-agenda-limitador-viewer.js
// @code.start: LswAgendaLimitadorViewer API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaLimitadorViewer API  LswAgendaLimitadorViewer component
Vue.component("LswAgendaLimitadorViewer", {
  template: `<div class="LswAgendaLimitadorViewer">
    <div v-if="isLoaded">
      <div class="infracciones_list" v-if="infracciones.length">
        <template v-for="infraccion, infraccionIndex in infracciones">
          <div class="infraccion_item" v-bind:key="'infraccion_' + infraccionIndex">
            <div class="infraccion_text"> <b style="text-decoration: underline;">Infraccin {{ infraccionIndex + 1 }}.</b> {{ infraccion.message }}</div>
          </div>
        </template>
      </div>
    </div>
  </div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-limitador-viewer.data");
    return {
      isLoaded: false,
      limitadores: undefined,
      infracciones: [],
    };
  },
  methods: {
    fixAsyncCode(asyncCode) {
      if(asyncCode.trim().startsWith("async ")) {
        return `return await (${asyncCode}).call(this)`
      }
      return asyncCode;
    },
    async executeLimitadores() {
      const lims = this.limitadores;
      for(let index=0; index<lims.length; index++) {
        const limitador = lims[index];
        const asyncCode = limitador.tiene_funcion;
        const AsyncFunc = (async function() {}).constructor;
        const fixedAsyncCode = this.fixAsyncCode(asyncCode);
        const asyncFunc = new AsyncFunc(fixedAsyncCode);
        console.log(asyncFunc);
        try {
          await asyncFunc.call(this);
        } catch (error) {
          this.infracciones.push(error);
        }
      }
    },
    async loadLimitadores() {
      this.$trace("lsw-agenda-limitador-viewer.methods.loadLimitadores");
      const limitadores = await this.$lsw.database.selectMany("Limitador");
      this.limitadores = limitadores;
      await this.executeLimitadores();
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-agenda-limitador-viewer.mounted");
      await this.loadLimitadores();
      this.isLoaded = true;
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaLimitadorViewer API

// @vuebundler[Lsw_framework_components][124]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-viewer/lsw-agenda-limitador-viewer.css

// @vuebundler[Lsw_framework_components][125]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-postimpresion-search/lsw-agenda-postimpresion-search.html

// @vuebundler[Lsw_framework_components][125]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-postimpresion-search/lsw-agenda-postimpresion-search.js
// @code.start: LswAgendaPostimpresionSearch API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaPostimpresionSearch API  LswAgendaPostimpresionSearch component
Vue.component("LswAgendaPostimpresionSearch", {
  template: `<div class="LswAgendaPostimpresionSearch">
  LswAgendaPostimpresionSearch
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-postimpresion-search.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-postimpresion-search.mounted");
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaPostimpresionSearch API

// @vuebundler[Lsw_framework_components][125]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-postimpresion-search/lsw-agenda-postimpresion-search.css

// @vuebundler[Lsw_framework_components][126]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-propagacion-search/lsw-agenda-propagacion-search.html

// @vuebundler[Lsw_framework_components][126]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-propagacion-search/lsw-agenda-propagacion-search.js
// @code.start: LswAgendaPropagacionSearch API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaPropagacionSearch API  LswAgendaPropagacionSearch component
Vue.component("LswAgendaPropagacionSearch", {
  template: `<div class="LswAgendaPropagacionSearch">
  LswAgendaPropagacionSearch
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-propagacion-search.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-propagacion-search.mounted");
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaPropagacionSearch API

// @vuebundler[Lsw_framework_components][126]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-propagacion-search/lsw-agenda-propagacion-search.css

// @vuebundler[Lsw_framework_components][127]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-propagador-search/lsw-agenda-propagador-search.html

// @vuebundler[Lsw_framework_components][127]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-propagador-search/lsw-agenda-propagador-search.js
// @code.start: LswAgendaPropagadorSearch API | @$section: Vue.js (v2) Components  LswAgenda API  LswAgendaPropagadorSearch API  LswAgendaPropagadorSearch component
Vue.component("LswAgendaPropagadorSearch", {
  template: `<div class="LswAgendaPropagadorSearch">
  LswAgendaPropagadorSearch
</div>`,
  props: {},
  data() {
    this.$trace("lsw-agenda-propagador-search.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-agenda-propagador-search.mounted");
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswAgendaPropagadorSearch API

// @vuebundler[Lsw_framework_components][127]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-propagador-search/lsw-agenda-propagador-search.css

// @vuebundler[Lsw_framework_components][128]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-conductometria/lsw-conductometria.html

// @vuebundler[Lsw_framework_components][128]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-conductometria/lsw-conductometria.js
// @code.start: LswConductometria API | @$section: Vue.js (v2) Components  LswAgenda API  LswConductometria API  LswConductometria component
Vue.component("LswConductometria", {
  template: `<div class="LswConductometria">
  <template>
    <div class="flex_row centered">
      <div class="flex_100" v-if="isLoaded === false">
        <button class="supermini width_100 text_align_left" v-on:click="reloadEverything"> Iniciar conductometra</button>
      </div>
      <div class="flex_100" v-else>
        <h4> Conductometra</h4>
      </div>
      <div class="flex_1 pad_left_1" v-if="isLoaded === true">
        <button class="supermini" v-on:click="reloadEverything"></button>
      </div>
      <div class="flex_1 pad_left_1">
        <button class="supermini" v-on:click="goToScripts"></button>
      </div>
      <div class="flex_1 pad_left_1">
        <button class="supermini" v-on:click="goToReports"></button>
      </div>
    </div>
  </template>
  <template v-if="isLoaded === null">
    <div class="pad_top_1"> Cargando, un momento, por favor. </div>
  </template>
  <template v-else-if="isLoaded === true">
    <div class="pad_top_1">
      <h4>
        <div class="flex_row centered">
          <div class="flex_100">
             Reportes disponibles:
          </div>
          <div class="flex_1 pad_left_1">
            <button class="supermini" v-on:click="reloadEverything"></button>
          </div>
        </div>
      </h4>
      <div v-for="reporte, reporteIndex in reportes"
        v-bind:key="'reporte_' + reporteIndex">
        <div class="flex_row centered pad_top_1">
          <div class="flex_100">
            <button class="supermini width_100 shortable_text text_align_left nowrap" v-on:click="() => openReport(reporte)">
              <span class="float_left">{{ reporte }}</span><span class="float_right"></span></button>
          </div>
          <div class="flex_1 pad_left_1">
            <button class="supermini" v-on:click="() => editReport(reporte)"> </button>
          </div>
        </div>
      </div>
    </div>
  </template>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-conductometria.data");
    return {
      isLoaded: false,
      reportes: [],
    };
  },
  methods: {
    async reloadEverything() {
      this.$trace("lsw-conductometria.methods.reloadEverything");
      this.isLoaded = null;
      const files = await this.$lsw.fs.read_directory("/kernel/agenda/report");
      this.reportes = Object.keys(files);
      Reload_conductometria_fully: {
        await this.$lsw.conductometria.reload(this);
      }
      this.isLoaded = true;
    },
    goToReports() {
      this.$trace("lsw-conductometria.methods.goToReports");
      this.$lsw.dialogs.open({
        id: 'ver-reportes',
        title: "Reportes de conductometra",
        template: `
          <lsw-filesystem-explorer opened-by="/kernel/agenda/report/" :absolute-layout="true" />
        `
      });
    },
    goToScripts() {
      this.$trace("lsw-conductometria.methods.goToScripts");
      this.$lsw.dialogs.open({
        id: 'ver-script',
        title: "Scripts de conductometra",
        template: `
          <lsw-filesystem-explorer opened-by="/kernel/agenda/proto" :absolute-layout="true" />
        `
      });
    },
    async editReport(reporte) {
      this.$trace("lsw-conductometria.methods.editReport");
      this.$lsw.dialogs.open({
        title: "Editar reporte " + reporte,
        template: `
          <lsw-filesystem-explorer
            :opened-by="'/kernel/agenda/report/' + reporte"
            :absolute-layout="true" />
        `,
        factory: {
          data: { reporte }
        }
      });
    },
    openReport(reporteId) {
      this.$trace("lsw-conductometria.methods.openReport");
      this.$lsw.dialogs.open({
        title: "Reproducir reporte " + reporteId,
        template: `
          <lsw-conductometria-report :report-id="'/kernel/agenda/report/' + reporteId" />
        `,
        factory: {
          data: { reporteId }
        }
      });
    },
    showError(error, ...args) {
      Vue.prototype.$lsw.toasts.showError(error, ...args);
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-conductometria.mounted");
      this.$lsw.conductometria = LswConductometria.create(this);
    } catch(error) {
      this.$lsw.toasts.showError(error);
    }
  }
});
// @code.end: LswConductometria API

// @vuebundler[Lsw_framework_components][128]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-conductometria/lsw-conductometria.css

// @vuebundler[Lsw_framework_components][129]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-conductometria/lsw-conductometria.api.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswConductometria'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswConductometria'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswConductometria API | @$section: Vue.js (v2) Components  LswAgenda API  LswConductometria API  LswConductometria class
  const LswConductometria = class {

    static create(...args) {
      Vue.prototype.$trace("LswConductometria.create");
      return new this(...args);
    }

    constructor(component = false) {
      Vue.prototype.$trace("lswConductometria.constructor");
      this.$component = component;
    }

    async reload() {
      Vue.prototype.$trace("lswConductometria.reload");
      const virtualization = LswConductometriaVirtualization.create(this.$component);
      await virtualization.$resetVirtualTables();
      await virtualization.$reloadProtolangScriptBoot();
      await virtualization.$virtualizePropagations();
    }

  }

  const LswConductometriaVirtualization = class {

    static create(...args) {
      Vue.prototype.$trace("LswConductometriaVirtualization.create");
      return new this(...args);
    }

    constructor(component) {
      this.$component = component;
    }

    reportErrorFromComponent(error) {
      Vue.prototype.$trace("lswConductometriaVirtualization.reportErrorFromComponent");
      this.DEBUG("Lsw-cond-virt.reportErrorFromComponent");
      console.log(error);
      if (this.$component && (typeof this.$component.addError === "function")) {
        this.$component.addError(error);
      }
    }

    async $resetVirtualTables() {
      Vue.prototype.$trace("lswConductometriaVirtualization.$resetVirtualTables");
      this.DEBUG("Lsw-cond-virt.$resetVirtualTables");
      await Vue.prototype.$lsw.database.deleteMany("Accion_virtual", it => true);
      await Vue.prototype.$lsw.database.deleteMany("Propagador_prototipo", it => true);
      await Vue.prototype.$lsw.database.deleteMany("Propagador_de_concepto", it => true);
    }

    async $reloadProtolangScriptBoot() {
      Vue.prototype.$trace("lswConductometriaVirtualization.$reloadProtolangScriptBoot");
      this.DEBUG("Lsw-cond-virt.$reloadProtolangScriptBoot");
      const protoSource = await Vue.prototype.$lsw.fs.read_file("/kernel/agenda/proto/boot.proto");
      return await this.$evaluateProtolangScript(protoSource, {
        sourcePath: "/kernel/agenda/script/boot.proto"
      });
    }

    async $evaluateProtolangScript(source, parameters) {
      Vue.prototype.$trace("lswConductometriaVirtualization.$evaluateProtolangScript");
      this.DEBUG("Lsw-cond-virt.$evaluateProtolangScript");
      const ast = Vue.prototype.$lsw.parsers.proto.parse(source, {
        options: parameters
      });
      for (let index = 0; index < ast.length; index++) {
        const sentence = ast[index];
        if (sentence.type === "inc") {
          await this.$evaluateInclude(sentence);
        } else if (sentence.type === "def") {
          await this.$evaluateDefine(sentence);
        } else if (sentence.type === "fun") {
          await this.$evaluateFunction(sentence);
        } else if (sentence.type === "rel") {
          await this.$evaluateRelation(sentence);
        }
      }
    }

    async $evaluateInclude(sentence) {
      Vue.prototype.$trace("lswConductometriaVirtualization.$evaluateInclude");
      this.DEBUG("Lsw-cond-virt.$evaluateInclude");
      this.DEBUG(sentence);
      let isFile = undefined;
      let isDirectory = undefined;
      const allFiles = [];
      const filepath = sentence.path;
      Read_node: {
        this.DEBUG("read node");
        isFile = await Vue.prototype.$lsw.fs.is_file(filepath);
        isDirectory = await Vue.prototype.$lsw.fs.is_directory(filepath);;
        if (isFile) {
          Vue.prototype.$trace("[*] Reading file: ", filepath);
          this.DEBUG("[*] Reading file: ", filepath);
          const contents = await Vue.prototype.$lsw.fs.read_file(filepath);
          allFiles.push({
            incBy: sentence,
            file: filepath,
            contents: contents
          });
        } else if (isDirectory) {
          Vue.prototype.$trace("[*] Reading directory: ", filepath);
          this.DEBUG("[*] Reading directory: ", filepath);
          const subfilesMap = await Vue.prototype.$lsw.fs.read_directory(filepath);
          const subfiles = Object.keys(subfilesMap);
          Iterating_subfiles:
          for (let indexSubfile = 0; indexSubfile < subfiles.length; indexSubfile++) {
            const subfile = subfiles[indexSubfile];
            this.DEBUG("iterating subfile:", subfile);
            const subfilepath = Vue.prototype.$lsw.fs.resolve_path(filepath, subfile);
            const is_file = await Vue.prototype.$lsw.fs.is_file(subfilepath);
            if (!is_file) {
              continue Iterating_subfiles;
            }
            Vue.prototype.$trace("[*] Reading subfile: ", subfilepath);
            this.DEBUG("[*] Reading subfile: ", subfilepath);
            const filecontents = await Vue.prototype.$lsw.fs.read_file(subfilepath);
            allFiles.push({
              incBy: sentence,
              file: subfilepath,
              contents: filecontents
            });
          }
        } else {
          throw new Error(`File does not exits ${filepath} on lswConductometriaVirtualization.$evaluateInclude`);
        }
      }
      Vue.prototype.$trace("[*] Evaluating all subfiles:", allFiles);
      this.DEBUG("[*] Evaluating all subfiles:", allFiles);
      Evaluate_subnodes: {
        for (let indexFile = 0; indexFile < allFiles.length; indexFile++) {
          const metafile = allFiles[indexFile];
          const file = metafile.file;
          const contents = metafile.contents;
          await this.$evaluateProtolangScript(contents, {
            sourcePath: file
          });
        }
      }
    }

    async $evaluateDefine(sentence) {
      Vue.prototype.$trace("lswConductometriaVirtualization.$evaluateDefine");
      this.DEBUG("Lsw-cond-virt.$evaluateDefine");
      const { names } = sentence;
      // @DONE: insertar names en Concepto
      Iterating_names:
      for (let index = 0; index < names.length; index++) {
        const name = names[index];
        this.DEBUG("in name:", name);
        try {
          await Vue.prototype.$lsw.database.insert("Concepto", {
            tiene_nombre: name,
          });
        } catch (error) {
          if (error.message === "Error on browsie.insert operation over store Concepto: A mutation operation in the transaction failed because a constraint was not satisfied.") {
            continue Iterating_names;
          }
          await this.reportErrorFromComponent(error);
        }
      }
    }

    async $evaluateFunction(sentence) {
      Vue.prototype.$trace("lswConductometriaVirtualization.$evaluateFunction");
      this.DEBUG("Lsw-cond-virt.$evaluateFunction");
      const { name, params, code } = sentence;
      // @DONE: insertar name+params+code en Propagador_prototipo
      try {
        this.DEBUG("inserting prototipo:", name);
        await Vue.prototype.$lsw.database.insert("Propagador_prototipo", {
          tiene_nombre: name,
          tiene_parametros: JSON.stringify(params),
          tiene_funcion: code,
        });
      } catch (error) {
        await this.reportErrorFromComponent(error);
      }
    }

    async $evaluateRelation(sentence) {
      Vue.prototype.$trace("lswConductometriaVirtualization.$evaluateRelation");
      this.DEBUG("Lsw-cond-virt.$evaluateRelation");
      const { name, effects, triggers } = sentence;
      Iterating_effects:
      for (let indexEffect = 0; indexEffect < effects.length; indexEffect++) {
        const effect = effects[indexEffect];
        const { consecuencia, ratio, argumentos } = effect;
        this.DEBUG("inserting propagador:", name);
        await Vue.prototype.$lsw.database.insert("Propagador_de_concepto", {
          tiene_propagador_prototipo: "multiplicador",
          tiene_concepto_disparador: name,
          tiene_concepto_destino: consecuencia,
          tiene_parametros_extra: ratio + (argumentos ? (", " + argumentos) : ''),
          tiene_codigo: null,
        });
      }
      Iterating_triggers:
      for (let indexTrigger = 0; indexTrigger < triggers.length; indexTrigger++) {
        const trigger = triggers[indexTrigger];
        if (trigger.type === "trigger by prototype") {
          const { prototipo, conceptos, argumentos } = trigger;
          if (conceptos) {
            for (let index = 0; index < conceptos.length; index++) {
              const concepto = conceptos[index];
              Insertar_propagador_con_consecuencia: {
                await Vue.prototype.$lsw.database.insert("Propagador_de_concepto", {
                  tiene_propagador_prototipo: prototipo,
                  tiene_concepto_disparador: name,
                  tiene_concepto_destino: concepto,
                  tiene_parametros_extra: argumentos,
                  tiene_codigo: null,
                });
              }
            }
          } else {
            Insertar_propagador_por_llamada: {
              await Vue.prototype.$lsw.database.insert("Propagador_de_concepto", {
                tiene_propagador_prototipo: prototipo,
                tiene_concepto_disparador: name,
                tiene_concepto_destino: null,
                tiene_parametros_extra: argumentos,
                tiene_codigo: null,
              });
            }
          }
        } else if (trigger.type === "trigger by code") {
          Insertar_propagador_por_codigo_directo: {
            await Vue.prototype.$lsw.database.insert("Propagador_de_concepto", {
              tiene_propagador_prototipo: null,
              tiene_concepto_disparador: name,
              tiene_concepto_destino: null,
              tiene_parametros_extra: null,
              tiene_codigo: trigger.code
            });
          }
        }
      }
    }

    $toJsExtension(txt) {
      return txt.replace(/\.js$/g, "") + ".js";
    }

    async $virtualizePropagations() {
      Vue.prototype.$trace("lswConductometriaVirtualization.$virtualizePropagations");
      this.DEBUG("Lsw-cond-virt.$virtualizePropagations");
      const accionesReales = await Vue.prototype.$lsw.database.selectMany("Accion", accion => true);
      // console.log("Acciones reales", accionesReales);
      const errorOptions = {
        timeout: 1000 * 10
      };
      Iterando_acciones_reales:
      for (let indexAccionReal = 0; indexAccionReal < accionesReales.length; indexAccionReal++) {
        const accionReal = accionesReales[indexAccionReal];
        Virtualizar_accion_real: {
          await this.addVirtualAction(accionReal);
        }
      }
    }

    $showError(error, options = {}, propagate = false, log = true) {
      Vue.prototype.$trace("lswConductometriaVirtualization.$showError");
      this.DEBUG("Lsw-cond-virt.$showError");
      try {
        this.$component.showError(error, options, propagate, log);
      } catch (error) {
        console.log("[!] Could not notify to vue component about this previous error");
      }
      if (propagate) {
        throw error;
      }
    }

    async addVirtualAction(accion_inicial) {
      Vue.prototype.$trace("lswConductometriaVirtualization.addVirtualAction");
      this.DEBUG("Lsw-cond-virt.addVirtualAction");
      Validaciones_minimas: {
        break Validaciones_minimas;
        const ensure1 = $ensure({ accion_inicial }, 1).type("object").to.have.keys(["en_concepto", "tiene_inicio", "tiene_duracion"]);
        ensure1.its("en_concepto").type("string");
        ensure1.its("tiene_inicio").type("string").its("length").to.be.greaterThan(0);
        ensure1.its("tiene_duracion").type("string").its("length").to.be.greaterThan(0);
      }
      Filtramos_los_estados_no_completados: {
        if (accion_inicial.tiene_estado === 'pendiente') {
          return "IGNORED BECAUSE OF STATE PENDING";
        }
        if (accion_inicial.tiene_estado === 'fallida') {
          return "IGNORED BECAUSE OF STATE FAILED";
        }
      }
      let conc_inicial = accion_inicial.en_concepto;
      let asoc_propags = false;
      let asoc_proto_ids = false;
      let asoc_protos_found = false;
      let asoc_proto_ids_found = false;
      let asoc_proto_ids_missing = false;
      let asoc_protos_as_map = false;
      Insertar_accion_virtual: {
        await Vue.prototype.$lsw.database.insert("Accion_virtual", accion_inicial);
      }
      Extraer_propags: {
        asoc_propags = await Vue.prototype.$lsw.database.selectMany("Propagador_de_concepto", propag => {
          return propag.tiene_concepto_disparador === conc_inicial;
        });
        if (!asoc_propags) {
          return "NO ASSOCIATED PROPAGATORS FOUND";
        }
      }
      Extraer_protos: {
        asoc_proto_ids = LswUtils.uniquizeArray(asoc_propags.map(propag => {
          return propag.tiene_propagador_prototipo;
        }));
        asoc_protos_found = await Vue.prototype.$lsw.database.selectMany("Propagador_prototipo", proto_it => {
          return asoc_proto_ids.indexOf(proto_it.tiene_nombre) !== -1;
        });
        asoc_proto_ids_found = LswUtils.arrays.uniquizeArray(asoc_protos_found.map(proto_it => proto_it.tiene_nombre));
        asoc_proto_ids_missing = LswUtils.arrays.getMissingInFirst(asoc_proto_ids_found, asoc_proto_ids);
        asoc_protos_as_map = asoc_protos_found.reduce((out, proto_it) => {
          const nombre = proto_it.tiene_nombre;
          out[nombre] = proto_it;
          return out;
        }, {});
        if (asoc_proto_ids_missing.length) {
          this.$showError(new Error("[!] Cuidado: no se encontraron los siguientes Propagador_prototipo: " + asoc_proto_ids_missing.join(", ")));
        }
      }
      let propagation_molecule = {};
      Resolver_propags_con_protos_y_propagar: {
        for (let index_propag = 0; index_propag < asoc_propags.length; index_propag++) {
          const propag = asoc_propags[index_propag];
          const proto_id = propag.tiene_propagador_prototipo;
          const proto_it = asoc_protos_as_map[proto_id];
          try {
            await this.$propagateVirtualAction(accion_inicial, propag, proto_it);
          } catch (error) {
            this.$showError(error);
          }
        }
      }
    }

    async $propagateVirtualAction(accion, propagador_de_concepto, propagador_prototipo = false) {
      Vue.prototype.$trace("lswConductometriaVirtualization.$propagateVirtualAction");
      this.DEBUG("Lsw-cond-virt.$propagateVirtualAction");
      try {
        let concepto_origen = undefined;
        let concepto_destino = undefined;
        let funcion_propagadora = undefined;
        let funcion_propagadora_parametros = [];
        let funcion_propagadora_ambito = this;
        Validaciones_minimas: {
          this.DEBUG("Lsw-cond-virt.$propagateVirtualAction::Validaciones_minimas");
          const ensure1 = $ensure({ accion }, 1).type("object")
          ensure1.its("en_concepto").type("string");
          ensure1.its("tiene_inicio").type("string").its("length").to.be.greaterThan(0);
          ensure1.its("tiene_duracion").type("string").its("length").to.be.greaterThan(0);
          const ensure2 = $ensure({ propagador_de_concepto }, 1).type("object");
          const ensure3 = $ensure({ propagador_prototipo }, 1).type(["object", "boolean"]);
          // console.log("propagador_prototipo", propagador_prototipo);
        }
        const {
          tiene_nombre,     // un texto
          tiene_funcion,    // un JavaScript (cuerpo de funcin)
          tiene_parametros: tiene_parametros_prototipo, // un JSON bi-array
        } = propagador_prototipo;
        const {
          tiene_propagador_prototipo,  // un Propagador_prototipo.tiene_nombre
          tiene_concepto_disparador,       // un Concepto.tiene_nombre
          tiene_concepto_destino,      // un Concepto.tiene_nombre
          tiene_parametros: tiene_parametros_asociado, // un JSON bi-array
          tiene_parametros_extra,      // un JavaScript (solo parmetros)
          tiene_codigo,                // un JavaScript (cuerpo de funcin)
        } = propagador_de_concepto;
        Extraemos_conceptos: {
          this.DEBUG("Lsw-cond-virt.$propagateVirtualAction::Extraemos_conceptos");
          const conceptos_origen_matched = await Vue.prototype.$lsw.database.selectMany("Concepto", conc => conc.tiene_nombre === tiene_concepto_disparador);
          concepto_origen = conceptos_origen_matched[0] || undefined;
          const conceptos_destino_matched = await Vue.prototype.$lsw.database.selectMany("Concepto", conc => conc.tiene_nombre === tiene_concepto_destino);
          concepto_destino = conceptos_destino_matched[0] || undefined;
        }
        Check_point: {
          // console.log("accion", accion);
          // console.log("concepto_origen", concepto_origen);
          // console.log("concepto_destino", concepto_destino);
          // console.log("funcion_propagadora", funcion_propagadora);
          // console.log("funcion_propagadora_parametros", funcion_propagadora_parametros);
          // console.log("funcion_propagadora_ambito", funcion_propagadora_ambito);
          // console.log("CHECKPOINT!");
        }
        let propagacion_resultado = {};
        Fabricamos_la_funcion_propagadora_y_la_llamamos: {
          this.DEBUG("Lsw-cond-virt.$propagateVirtualAction::Fabricamos_la_funcion_propagadora_y_la_llamamos");
          const propagacion_params = (() => {
            try {
              return JSON.parse(tiene_parametros_prototipo);
            } catch (error) {
              return [];
            }
          })();
          const propagacion_source = tiene_funcion;
          if (!propagacion_source) {
            break Fabricamos_la_funcion_propagadora_y_la_llamamos;
          }
          const propagacion_callback = LswUtils.createAsyncFunction(propagacion_source, propagacion_params);
          if (!propagacion_callback) {
            break Fabricamos_la_funcion_propagadora_y_la_llamamos;
          }
          this.$debugEvaluation(propagacion_callback.toString(), "$propagateVirtualAction")
          try {
            const propagacion_context = {
              accion,
              propagador_de_concepto,
              propagador_prototipo
            };
            const propagacion_callback_wrapper = LswUtils.createSyncFunction(`return propagacion_callback(propagacion_context, ${tiene_parametros_asociado || "{}"}, ${tiene_parametros_extra || "undefined"})`, [
              "propagacion_context",
              "propagacion_callback",
            ]);
            this.$debugEvaluation(propagacion_callback_wrapper.toString(), "$propagateVirtualAction")
            propagacion_resultado = await propagacion_callback_wrapper.call(this, propagacion_context, propagacion_callback);
          } catch (error) {
            this.$showError(error);
          }
        }
        let accionVirtual = undefined;
        Fabricamos_nueva_accion: {
          this.DEBUG("Lsw-cond-virt.$propagateVirtualAction::Fabricamos_nueva_accion");
          if (!concepto_destino?.tiene_nombre) {
            return "NO TIENE CONCEPTO DESTINO";
          }
          if (!concepto_origen?.tiene_nombre) {
            return "NO TIENE CONCEPTO ORIGEN";
          }
          accionVirtual = this.createDefaultAction({
            en_concepto: concepto_destino.tiene_nombre,
            desde_concepto: concepto_origen.tiene_nombre,
            tiene_estado: "propagada",
            tiene_inicio: accion.tiene_inicio,
            tiene_duracion: accion.tiene_duracion,
            tiene_accion_anterior: accion.id,
            tiene_accion_origen: undefined,
            viene_de_propagador_de_concepto: propagador_de_concepto.id,
            viene_de_propagador_prototipo: propagador_prototipo.tiene_nombre,
            ...propagacion_resultado
          });
        }
        Insertamos_accion_en_virtuales: {
          this.DEBUG("Lsw-cond-virt.$propagateVirtualAction::Insertamos_accion_en_virtuales");
          this.DEBUG(accionVirtual);
          await this.addVirtualAction(accionVirtual);
        }
        // @TODO: fabricar la funcin propagadora y enchufarla.
        // @TODO: fabricar la funcin propagadora y enchufarla.
        // @TODO: fabricar la funcin propagadora y enchufarla.
        // @TODO: fabricar la funcin propagadora y enchufarla.
        // @TODO: fabricar la funcin propagadora y enchufarla.
      } catch (error) {
        this.$showError(error);
      }
    }

    $debugEvaluation(jsCode, traceId) {
      Vue.prototype.$trace("lswConductometriaVirtualization.$debugEvaluation");
      this.DEBUG("Lsw-cond-virt.$debugEvaluation");
      console.log("[*] Evaluating js from: " + traceId);
      console.log(jsCode);
    }

    createDefaultAction(overwrites = {}) {
      Vue.prototype.$trace("lswConductometriaVirtualization.createDefaultAction");
      this.DEBUG("Lsw-cond-virt.createDefaultAction");
      return Object.assign({
        en_concepto: "?",
        tiene_inicio: LswTimer.utils.fromDateToDatestring(new Date()),
        tiene_duracion: "1min",
      }, overwrites);
    }

    DEBUG(...args) {
      console.log(...args);
    }

  }

  return LswConductometria;
  // @code.end: LswConductometria API

});

// @vuebundler[Lsw_framework_components][130]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-conductometria-report/lsw-conductometria-report.html

// @vuebundler[Lsw_framework_components][130]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-conductometria-report/lsw-conductometria-report.js
// @code.start: LswConductometriaReport API | @$section: Vue.js (v2) Components  LswConductometriaReport API  LswConductometriaReport API  LswConductometriaReport component
Vue.component("LswConductometriaReport", {
  name: "LswConductometriaReport",
  template: `<div class="lsw_conductometria_reports">
    <h4 class="pad_1">Reporte: </h4>
    <h3 class="pad_1">{{ reportId }}</h3>
    <div v-if="!isLoaded">
        <div class="">Reporte cargando. Un momento por favor...</div>
    </div>
    <div class="pad_1" v-else>
        <div class="report_block" v-if="Array.isArray(report)">
            <h4>
                <div class="flex_row centered">
                    <div class="flex_100">
                        Contenido de reporte por dato:
                    </div>
                    <div class="flex_1">
                        <button class="supermini" v-on:click="openReportSource"> </button>
                    </div>
                </div>
            </h4>
            <lsw-table :initial-input="report" :initial-settings="{title: reportId}" />
        </div>
        <div class="report_block" v-else-if="typeof report === 'object'">
            <h4>
                <div class="flex_row centered">
                    <div class="flex_100">
                        ndice de reporte por datos:
                    </div>
                    <div class="flex_1">
                        <button class="supermini" v-on:click="openReportSource"> </button>
                    </div>
                </div>
            </h4>
            <ul>
                <li v-for="reportItem, reportIndex in report"
                    v-bind:key="'report-' + reportIndex">
                    <div class="linkable_text has_light_bg" v-on:click="() => goToReportTitle(reportIndex)">{{ reportIndex }}</div>
                </li>
            </ul>
            <h4>
                <div class="flex_row centered">
                    <div class="flex_100">
                        Secciones de reporte por datos:
                    </div>
                </div>
            </h4>
            <div v-for="reportItem, reportIndex in report"
                v-bind:key="'report-' + reportIndex">
                <lsw-table :initial-input="reportItem" :initial-settings="{title: reportIndex}" :ref="'report_' + reportIndex" />
            </div>
        </div>
        <div class="report_block" v-if="typeof report === 'string'">
            <h4>
                <div class="flex_row centered">
                    <div class="flex_100">
                        Contenido de reporte por plantilla:
                    </div>
                    <div class="flex_1">
                        <button class="supermini" v-on:click="openReportSource"> </button>
                    </div>
                </div>
            </h4>
            <lsw-sourceable :source="report"></lsw-sourceable>
        </div>
    </div>
</div>`,
  props: {
    reportId: {
      type: String,
      required: true,
    }
  },
  data() {
    this.$trace("lsw-conductometria-report.data");
    return {
      isLoaded: false,
      report: false,
    };
  },
  methods: {
    async loadReport() {
      this.$trace("lsw-conductometria-report.methods.loadReport");
      this.isLoaded = false;
      const reportSource = await this.$lsw.fs.read_file(this.reportId);
      const reportInstance = LswConductometriaReport.create(reportSource, this);
      const report = await reportInstance.buildReport();
      this.report = report;
      this.$nextTick(() => {this.isLoaded = true;});
    },
    goToReportTitle(reportIndex) {
      this.$trace("lsw-conductometria-report.methods.loadReport");
      const presuntReportTitle = this.$refs["report_" + reportIndex];
      try {
        presuntReportTitle[0].$el.scrollIntoView();
      } catch (error) {
        console.log(error);
      }
    },
    async openReportSource() {
      this.$trace("lsw-conductometria-report.methods.openReportSource");
      await this.$lsw.dialogs.open({
        title: "Editar reporte",
        template: `
          <lsw-filesystem-explorer :opened-by="reportId" :absolute-layout="true" />
        `,
        factory: {
          data: {
            reportId: this.reportId
          }
        }
      });
    },
  },
  watch: {

  },
  computed: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-conductometria-report.mounted");
      await this.loadReport();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswConductometriaReport API


// @vuebundler[Lsw_framework_components][130]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-conductometria-report/lsw-conductometria-report.css

// @vuebundler[Lsw_framework_components][131]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-conductometria-report/lsw-conductometria-report.api.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswConductometriaReport'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswConductometriaReport'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  const LswConductometriaReport = class {

    static create(...args) {
      return new this(...args);
    }

    constructor(originalInput = false, originalScope = this) {
      Vue.prototype.$trace("LswConductometriaReport.constructor");
      $ensure({ originalInput }, 1).type("string");
      this.$originalInput = originalInput;
      this.$originalScope = originalScope;
      this.$reportBuilder = false;
      this.result = false;
      this.$resetReportState();
    }

    async buildReport() {
      Vue.prototype.$trace("LswConductometriaReport.buildReport");
      await this.$resetReportState();
      await this.$rebuildCallback();
      await this.$rebuildReport();
      return this.result;
    }

    async $resetReportState() {
      Vue.prototype.$trace("LswConductometriaReport.$resetReportState");
      this.result = false;
    }

    async $rebuildCallback() {
      Vue.prototype.$trace("LswConductometriaReport.$rebuildCallback");
      this.$reportBuilder = LswUtils.createAsyncFunction(this.$originalInput);
    }

    async $rebuildReport() {
      Vue.prototype.$trace("LswConductometriaReport.$rebuildReport");
      this.result = await this.$reportBuilder(this.$originalScope);
    }

  };

  return LswConductometriaReport;

});

// @vuebundler[Lsw_framework_components][132]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/api/api.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswFormtypes'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswFormtypes'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  // @code.start: LswFormtypesUtils API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswFormtypesUtils component
  class LswFormtypesUtils {

    static class = this;

    static async submitControl() {
      if (this.settings.parentSchemaForm) {
        await this.validate();
      }

    }

    static validateControl() {
      return this.$refs.controller.$xform.validate();
    }

    static validateSettings() {
      LswXForm.validateSettings(this.settings);
      const ensureSettings = $ensure(this.settings);
      const checkSettings = $check(this.settings);
      ensureSettings.to.have.onlyPotentialKeys([
        "name",
        "input",
        "entity",
        "database",
        "table",
        "column",
        "initialValue",
        "label",
        "parentSchemaForm",
        "extraAttributes",
        "formtypeParameters",
        "formtypeSettings"
      ]);
      if (checkSettings.to.have.key("initialValue")) {
        const ensureInitialValue = ensureSettings.its("initialValue").type("string");
      }
      if (checkSettings.to.have.key("label")) {
        const ensureHasLabel = ensureSettings.its("label").type(["string", "undefined", "boolean"]);
      }
    }

  }

  class LswFormtypes {

    static class = this;

    constructor() {
      this.$formtypes = new Map();
    }

    static utils = LswFormtypesUtils;

  }

  window.commonFormtypes = new LswFormtypes();

  return LswFormtypes;
  // @code.end: LswFormtypesUtils API

});

// @vuebundler[Lsw_framework_components][133]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-form-builder/lsw-form-builder.html

// @vuebundler[Lsw_framework_components][133]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-form-builder/lsw-form-builder.js
// @code.start: LswFormBuilder API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswFormBuilder component
Vue.component("LswFormBuilder", {
  template: `<div class="lsw-form-builder">
    <div v-if="formMetadata">
        <div v-form.form="formMetadata.form.vForm"
            ref="currentFormElement"></div>
        <button v-if="validate?.text"
            v-on:click="() => \$refs.currentFormElement.\$lswFormMetadata.methods.validate()">{{ validate.text }}</button>
        <button v-if="submit?.text"
            v-on:click="() => \$refs.currentFormElement.\$lswFormMetadata.methods.submit()">{{ submit.text }}</button>
        <div v-form.error="{
            parentScope: formMetadata.form.scope,
            parentId: formMetadata.form.id + '.error'
        }"></div>
        <div :class="field?.css?.classes?.group || {}"
            v-for="field, fieldIndex in formMetadata.fields"
            v-bind:key="'list_of_fields_index_' + fieldIndex">
            <div class="form_field_label"
                v-if="field.label">
                {{ field.label }}
            </div>
            <div v-if="field.component">
                <component :is="field.component.id"
                    v-bind="field.component.props || {}"
                    v-on="field.component.events || {}"></component>
            </div>
            <template v-else-if="field.type">
                <lsw-formtype v-if="Vue.options.components.LswFormtype" :of="field" />
                <div v-if="field.type === 'text'">
                    <input type="text"
                        v-bind="field.input?.props || {}"
                        v-on="field.input?.events || {}"
                        v-form.input="field.vForm" />
                </div>
                <div v-else-if="field.type === 'longtext'">
                    <textarea v-bind="field.input?.props || {}"
                        v-on="field.input?.events || {}"
                        v-form.input="field.vForm"></textarea>
                </div>
                <div v-else-if="field.type === 'point'">
                    <div class="control_upper" v-form.control="field.vForm">
                        <div class="control_lower" v-form.control="field.vFormForPoint">
                            <div v-for="dimension, dimensionIndex in field.dimensions" v-bind:key="'list_' + fieldIndex + '_dimensions_index_' + dimensionIndex">
                                <div class="form_field_label" v-if="dimension.label">{{ dimension.label }}</div>
                                <input type="number"
                                    v-bind="dimension.input?.props || {}"
                                    v-on="dimension.input?.events || {}"
                                    v-form.input="dimension.vForm" />
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>
</div>`,
  props: {
    validate: {
      type: Object,
      default: () => ({})
    },
    submit: {
      type: Object,
      default: () => ({})
    },
    fields: {
      type: Array,
      required: true,
    }
  },
  data() {
    this.$trace("lsw-form-builder.data");
    this.formatFields();
    return {
      formMetadata: false,
    };
  },
  methods: {
    setError(error) {
      this.$trace("lsw-form-builder.setError");
      this.error = error;
    },
    formatFields(value = this.fields) {
      this.$trace("lsw-form-builder.formatFields");
      try {
        const $outterScope = {};
        if (value.length === 0) {
          throw new Error("Required property prop.fields to be an array on LswFormBuilder.props.fields.validator");
        }
        const fields = [];
        const form = {
          scope: $outterScope,
          id: "form.default"
        };
        const metadata = { fields, form, scope: $outterScope };
        form.vForm = {
          selfScope: $outterScope,
          selfId: form.id,
          onValidate: typeof this.validate.onClick === 'function' ? this.validate.onClick : this.$noop,
          onSubmit: typeof this.submit.onClick === 'function' ? this.submit.onClick : this.$noop,
        }
        for (let index = 0; index < value.length; index++) {
          const row = value[index];
          if (typeof row !== "object") {
            throw new Error(`Required all rows on prop.fields to be an object but row ${index} does not on LswFormBuilder.props.fields.validator`)
          }
          if (!("type" in row)) {
            throw new Error(`Required all rows on prop.fields to have property type but row ${index} does not on LswFormBuilder.props.fields.validator`)
          }
          if (typeof row.type !== "string") {
            throw new Error(`Required all rows on prop.fields to have property type as a string but row ${index} does not on LswFormBuilder.props.fields.validator`)
          }
          if (!("name" in row)) {
            throw new Error(`Required all rows on prop.fields to have property name but row ${index} does not on LswFormBuilder.props.fields.validator`)
          }
          if (typeof row.name !== "string") {
            throw new Error(`Required all rows on prop.fields to have property name as a string but row ${index} does not on LswFormBuilder.props.fields.validator`)
          }
          const $innerScope = {};
          row.vForm = {
            parentScope: $outterScope,
            parentId: metadata.form.id,
            selfScope: $innerScope,
            selfId: row.name,
            name: row.name,
          };
          if (row.type === "point") {
            row.dimensions = [];
            row.vFormForPoint = {
              parentScope: $innerScope,
              parentId: row.name,
              selfScope: $innerScope,
              selfId: "point.control",
              name: null,
            };
            row.dimensions = [{
              label: "Axis 1:",
              vForm: {
                parentScope: $innerScope,
                parentId: "point.control",
                name: "axis_1"
              }
            }, {
              label: "Axis 2:",
              vForm: {
                parentScope: $innerScope,
                parentId: "point.control",
                name: "axis_2"
              }
            }];
            if (row.dimensions.length < 2) {
              throw new Error(`Required property row.dimensions to have more than 1 item on row ${index} on adaptRowToVForm`);
            }
            for (let indexDimension = 0; indexDimension < row.dimensions.length; indexDimension++) {

            }
          }
          fields.push(row);
        }
        this.formMetadata = Object.freeze(metadata);
      } catch (error) {
        console.log(error);
        this.setError(error);
      }
    },
    adaptRowToVForm(row, metadata, indexRow) {
      this.$trace("lsw-form-builder.adaptRowToVForm");

    }
  },
  watch: {},
  mount() {
    try {
      this.$trace("lsw-form-builder.mount");
    } catch (error) {
      console.log(error);
    }
  },
  mounted() {
    try {
      this.$trace("lsw-form-builder.mounted");
      this.formatFields();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswFormBuilder API

// @vuebundler[Lsw_framework_components][133]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-form-builder/lsw-form-builder.css

// @vuebundler[Lsw_framework_components][134]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/lsw-formtype.html

// @vuebundler[Lsw_framework_components][134]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/lsw-formtype.js
Vue.component("LswFormtype", {
  template: `<div class="lsw-formtype">
    <component
        v-if="definition.name in Vue.options.components"
        :is="definition.name"
        v-on="definition.events"
        v-bind="definition.props"></component>
    <div v-else>No se encontr tipo {{ definition.name || "-" }}</div>
</div>`,
  props: {
    definition: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    this.$trace("lsw-formtype.data");
    this._validateDefinition(this.definition);
    return {

    };
  },
  methods: {
    _validateDefinition(definitionObject) {
      const ensureDefinition = $ensure(definitionObject);
      ensureDefinition.type("object");
      ensureDefinition.to.have.uniquelyKeys(["name", "props", "events"]);
      ensureDefinition.to.have.key("name");
      ensureDefinition.its("name").type("string");
      if ("props" in definitionObject) {
        ensureDefinition.its("props").type("object");
      }
      if ("events" in definitionObject) {
        ensureDefinition.its("events").type("object");
      }
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-formtype.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});

// @vuebundler[Lsw_framework_components][134]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/lsw-formtype.css

// @vuebundler[Lsw_framework_components][135]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/partials/lsw-control-label/lsw-control-label.html

// @vuebundler[Lsw_framework_components][135]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/partials/lsw-control-label/lsw-control-label.js
// @code.start: LswControlLabel API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswControlLabel component
Vue.component("LswControlLabel", {
  template: `<div class="lsw_control_label">
    <div class="flex_row centered"
        style="margin-bottom:2px;">
        <div class="formtype_enunciate_block flex_100">
            <div class="formtype_label">
                <template v-if="typeof label === 'string'">
                    {{ label }}
                </template>
                <template v-else-if="label !== false">
                    Campo {{ name }}:
                </template>
            </div>
        </div>
        <div class="flex_1 pad_left_1 flex_row" v-if="settings.columns">
            <template v-if="parentFormtype && (parentFormtype.isEditable === true)">
                <button class="supermini margin_left_1" v-on:click="() => parentFormtype.validate()" v-if="settings.column?.hasValidator || true">
                    
                </button>
            </template>
            <button class="supermini margin_left_1" :class="{activated: isShowingDescription}" v-on:click="() => toggleDescription()"></button>
            <template v-if="parentFormtype && (parentFormtype.isEditable === true)">
                <button class="supermini margin_left_1 button_to_uneditable activated" v-on:click="makeUneditable"></button>
            </template>
            <template v-else>
                <button class="supermini margin_left_1 button_to_editable" v-on:click="makeEditable"></button>
            </template>
        </div>
    </div>
    <div class="formtype_enunciate_extra_info" v-if="isShowingDescription">
        : {{ description }}
    </div>
</div>`,
  props: {
    parentFormtype: {
      type: Object,
      required: false,
    },
    settings: {
      type: Object,
      default: () => ({})
    },
  },
  data() {
    this.$trace("lsw-control-label-control.data");
    this.validateSettings();
    return {
      uuid: LswRandomizer.getRandomString(5),
      isShowingDescription: false,
      name: this.settings?.name,
      label: (typeof (this.settings?.label) !== "undefined") ? this.settings.label : this.settings?.column?.hasLabel,
      description: this.settings?.column?.hasDescription
    };
  },
  methods: {
    toggleDescription() {
      this.isShowingDescription = !this.isShowingDescription;
    },
    validateSettings() {
      this.$trace("lsw-control-label-control.methods.validateSettings");
      LswXForm.validateSettings(this.settings);
      const ensureSettings = $ensure(this.settings);
      const checkSettings = $check(this.settings);
      // @OK
    },
    makeEditable() {
      this.$trace("lsw-control-label-control.methods.makeEditable");
      Behaviour_for_controls: {
        const immediateControl = LswVue2.getClosestParent(this, component => {
          return component.$el.classList.contains("lsw_form_control");
        });
        if (immediateControl) {
          immediateControl.isEditable = true;
          // immediateControl.$forceUpdate(true);
        }
      }
      Behaviour_for_schema_forms: {
        
      }
    },
    makeUneditable() {
      this.$trace("lsw-control-label-control.methods.makeUneditable");
      Behaviour_for_controls: {
        const immediateControl = LswVue2.getClosestParent(this, component => {
          return component.$el.classList.contains("lsw_form_control");
        });
        if (immediateControl) {
          immediateControl.isEditable = false;
          // immediateControl.$forceUpdate(true);
        }

      }
      Behaviour_for_schema_forms: {
        
      }
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-control-label-control.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswControlLabel API

// @vuebundler[Lsw_framework_components][135]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/partials/lsw-control-label/lsw-control-label.css

// @vuebundler[Lsw_framework_components][136]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/partials/lsw-control-error/lsw-control-error.html

// @vuebundler[Lsw_framework_components][136]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/partials/lsw-control-error/lsw-control-error.js
// @code.start: LswControlError API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswControlError component
Vue.component("LswControlError", {
  template: `<div class="lsw_control_error">
    <div class="box_error_container position_relative"
        ref="errorBox"
        v-xform.error="{}">
        <div class="position_absolute top_0" style="right: 20px;">
            <div class="pad_1">
                <button v-on:click="removeError"></button>
            </div>
        </div>
        <div class="box_error_content">
            <div class="errorMessage"></div>
        </div>
    </div>
</div>`,
  props: {
    
  },
  data() {
    this.$trace("lsw-control-error-control.data");
    return {
      
    };
  },
  methods: {
    removeError() {
      this.$trace("lsw-control-error-control.methods.removeError");
      this.$refs.errorBox.$xform.$clearError();
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-control-error-control.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswControlError API

// @vuebundler[Lsw_framework_components][136]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/partials/lsw-control-error/lsw-control-error.css

// @vuebundler[Lsw_framework_components][137]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-text-control/lsw-text-control.html

// @vuebundler[Lsw_framework_components][137]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-text-control/lsw-text-control.js
// @code.start: LswTextControl API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswTextControl component
Vue.component("LswTextControl", {
  template: `<div class="lsw_text_control lsw_formtype lsw_form_control">
    <lsw-control-label :settings="settings" :parent-formtype="this" v-if="skipLabel === false" />
    <div v-show="isEditable">
        <div ref="controller" v-xform.control="{
            name: settings.name,
            onValidate: settings.column?.hasValidator || \$noop,
            onSetError: () => {
                isEditable = true;
            }
        }">
            <div class="flex_row">
                <input class="flex_100"
                    type="text"
                    v-model="value"
                    v-on="getSettingsInputEvents"
                    v-bind="getSettingsInputProps"
                    v-xform.input="{name: '*',onValidate: settings.input?.onValidate || \$noop}"
                    spellcheck="false"
                    ref="textInput" />
            </div>
            <lsw-control-error />
        </div>
    </div>
</div>`,
  props: {
    settings: {
      type: Object,
      default: () => ({})
    },
    skipLabel: {
      type: Boolean,
      default: () => false,
    }
  },
  data() {
    this.$trace("lsw-text-control.data");
    this.validateSettings();
    const value = this.settings?.initialValue || this.settings?.column?.hasDefaultValue || "";
    return {
      uuid: LswRandomizer.getRandomString(5),
      value,
      isEditable: true,
    };
  },
  methods: {
    async submit() {
      this.$trace("lsw-text-control.methods.submit");
      return LswFormtypes.utils.submitControl.call(this);
      
    },
    validate() {
      this.$trace("lsw-text-control.methods.validateSettings");
      return LswFormtypes.utils.validateControl.call(this);
    },
    validateSettings() {
      this.$trace("lsw-text-control.methods.validateSettings");
      return LswFormtypes.utils.validateSettings.call(this);
    }
  },
  watch: {},
  computed: {
    getSettingsInputEvents() {
      const base0 = this.settings.input?.events || false;
      if(typeof base0 === "object") {
        return base0;
      }
      return {};
    },
    getSettingsInputProps() {
      const base0 = this.settings.input?.props || false;
      if(typeof base0 === "object") {
        return base0;
      }
      return {};
    }
  },
  mounted() {
    try {
      this.$trace("lsw-text-control.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswTextControl API

// @vuebundler[Lsw_framework_components][137]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-text-control/lsw-text-control.css

// @vuebundler[Lsw_framework_components][138]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-long-text-control/lsw-long-text-control.html

// @vuebundler[Lsw_framework_components][138]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-long-text-control/lsw-long-text-control.js
// @code.start: LswLongTextControl API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswLongTextControl component
Vue.component("LswLongTextControl", {
  template: `<div class="lsw_long_text_control lsw_formtype lsw_form_control">
    <lsw-control-label :settings="settings"
        :parent-formtype="this" />
    <div v-show="isEditable">
        <div ref="controller" v-xform.control="{
            name: settings.name,
            onValidate: settings.column.hasValidator || \$noop,
            onSetError: () => {
                isEditable = true;
            }
        }">
            <div class="flex_row">
                <textarea class="flex_100 nowrap lsw_long_text_control_textarea"
                    type="text"
                    v-model="value"
                    v-on="settings?.input?.events || {}"
                    v-bind="settings?.input?.props || {}"
                    v-xform.input="{name: '*'}"
                    spellcheck="false"
                    ref="textInput" />
            </div>
            <lsw-control-error />
        </div>
    </div>
</div>`,
  props: {
    settings: {
      type: Object,
      default: () => ({})
    },
  },
  data() {
    this.$trace("lsw-long-text-control.data");
    this.validateSettings();
    const value = this.settings?.initialValue || this.settings?.column.hasDefaultValue || "";
    return {
      uuid: LswRandomizer.getRandomString(5),
      value,
      isEditable: true,
    };
  },
  methods: {
    async submit() {
      this.$trace("lsw-text-control.methods.submit");
      return LswFormtypes.utils.submitControl.call(this);
      
    },
    validate() {
      this.$trace("lsw-text-control.methods.validateSettings");
      return LswFormtypes.utils.validateControl.call(this);
    },
    validateSettings() {
      this.$trace("lsw-text-control.methods.validateSettings");
      return LswFormtypes.utils.validateSettings.call(this);
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-long-text-control.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswLongTextControl API

// @vuebundler[Lsw_framework_components][138]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-long-text-control/lsw-long-text-control.css

// @vuebundler[Lsw_framework_components][139]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-date-control/lsw-date-control.html

// @vuebundler[Lsw_framework_components][139]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-date-control/lsw-date-control.js
// @code.start: LswDateControl API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswDateControl component
Vue.component("LswDateControl", {
  template: `<div class="lsw_date_control lsw_formtype lsw_form_control">
    <lsw-control-label :settings="settings"
        :parent-formtype="this" />
    <div v-show="isEditable">
        <div ref="controller" v-xform.control="{
            name: settings.name,
            onValidate: settings.column.hasValidator || \$noop,
            onSetError: () => {
                isEditable = true;
            }
        }">
            <div class="">
                <div class="flex_row">
                    <div class="flex_1 pad_right_1">
                        <button
                            class="has_light_bg"
                            v-on:click="toggleCalendar"
                            :class="{activated: isShowingCalendar}"></button>
                    </div>
                    <div class="flex_100">
                        <input class="width_100" type="text" v-model="value" :placeholder="respectivePlaceholder" v-xform.input="{name:'*'}"/>
                    </div>
                </div>
                <!--pre>{{ \$lsw.utils.stringify(settings) }}</pre-->
            </div>
            <div class="pad_top_1" v-if="isShowingCalendar">
                <lsw-calendario :modo="settings.column.isFormSubtype" :al-cambiar-valor="setValueFromCalendar" :valor-inicial="value" />
            </div>
            <lsw-control-error />
        </div>
    </div>
</div>`,
  props: {
    settings: {
      type: Object,
      default: () => ({})
    },
    mode: {
      type: String,
      default: () => "date" // can be: date, datetime, time
    }
  },
  data() {
    this.$trace("lsw-date-control.data");
    this.validateMode();
    this.validateSettings();
    const respectivePlaceholder = this.generatePlaceholder();
    return {
      uuid: LswRandomizer.getRandomString(5),
      value: this.settings?.initialValue || this.settings?.column?.hasInitialValue?.call() || "",
      isEditable: true,
      isShowingCalendar: false,
      respectivePlaceholder,
      formMode: this.settings?.column?.isFormSubtype || this.mode || "datetime",
    };
  },
  methods: {
    toggleCalendar() {
      this.$trace("LswDateControl.methods.toggleCalendar", arguments);
      this.isShowingCalendar = !this.isShowingCalendar;
    },
    generatePlaceholder() {
      return this.settings.column.isFormSubtype === "date" ? 'Ej: 2025/01/01' :
        this.settings.column.isFormSubtype === "datetime" ? 'Ej: 2025/01/01 00:00' :
        this.settings.column.isFormSubtype === "time" ? 'Ej: 00:00' : ''
    },
    async submit() {
      this.$trace("lsw-text-control.methods.submit");
      return LswFormtypes.utils.submitControl.call(this);
    },
    validate() {
      this.$trace("lsw-text-control.methods.validateSettings");
      return LswFormtypes.utils.validateControl.call(this);
    },
    validateSettings() {
      this.$trace("lsw-text-control.methods.validateSettings");
      return LswFormtypes.utils.validateSettings.call(this);
    },
    validateMode() {
      this.$trace("lsw-date-control.methods.validateSettings");
      $ensure({mode: this.mode}, 1).to.be.oneOf(["date", "time", "datetime"]);
    },
    setValueFromCalendar(v) {
      this.$trace("lsw-date-control.methods.setValueFromCalendar");
      console.log("Valor:", v);
      const value = LswTimer.utils.formatDatestringFromDate(v, false, false, true);
      if(this.formMode === "datetime") {
        this.value = value;
      } else if(this.formMode === "date") {
        this.value = value.split(" ")[0];
      } else if(this.formMode === "time") {
        this.value = value.split(" ")[1];
      } else {
        this.value = value;
      }
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-date-control.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswDateControl API

// @vuebundler[Lsw_framework_components][139]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-date-control/lsw-date-control.css

// @vuebundler[Lsw_framework_components][140]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-duration-control/lsw-duration-control.html

// @vuebundler[Lsw_framework_components][140]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-duration-control/lsw-duration-control.js
// @code.start: LswDurationControl API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswDurationControl component
Vue.component("LswDurationControl", {
  template: `<div class="lsw_duration_control lsw_formtype lsw_form_control">
    <lsw-control-label :settings="settings"
        :parent-formtype="this"
        v-if="skipLabel === false"
    />
    <lsw-error-box v-if="validateError" :error="validateError" />
    <lsw-error-box v-if="submitError" :error="submitError" />
    <div v-show="isEditable" v-else>
        <div ref="controller"
            v-xform.control="{
                name: settings.name,
                onValidate: settings?.column?.hasValidator || \$noop,
                onSetError: () => {
                    isEditable = true;
                }
            }">
            <div class="flex_row">
                <div class="pad_right_1">
                    <button
                    class="has_light_bg"
                    :class="{activated:isShowingDetails}" v-on:click="toggleDetails"></button>
                </div>
                <input class="flex_100"
                    type="text"
                    v-model="value"
                    v-on="settings?.input?.events || {}"
                    v-bind="settings?.input?.props || {}"
                    v-xform.input="{name: '*'}"
                    ref="textInput" />
            </div>
            <div class="duration_control_details_panel" v-if="isShowingDetails">
                <div class="duration_control_option" v-on:click="() => setValue('1min')">1min</div>
                <div class="duration_control_option" v-on:click="() => setValue('5min')">5min</div>
                <div class="duration_control_option" v-on:click="() => setValue('10min')">10min</div>
                <div class="duration_control_option" v-on:click="() => setValue('15min')">15min</div>
                <div class="duration_control_option" v-on:click="() => setValue('20min')">20min</div>
                <div class="duration_control_option" v-on:click="() => setValue('30min')">30min</div>
                <div class="duration_control_option" v-on:click="() => setValue('40min')">40min</div>
                <div class="duration_control_option" v-on:click="() => setValue('45min')">45min</div>
                <div class="duration_control_option" v-on:click="() => setValue('50min')">50min</div>
                <div class="duration_control_option" v-on:click="() => setValue('1h')">1h</div>
                <div class="duration_control_option" v-on:click="() => setValue('2h')">2h</div>
                <div class="duration_control_option" v-on:click="() => setValue('3h')">3h</div>
                <div class="duration_control_option" v-on:click="() => setValue('4h')">4h</div>
                <div class="duration_control_option" v-on:click="() => setValue('5h')">5h</div>
                <div class="duration_control_option" v-on:click="() => setValue('6h')">6h</div>
                <div class="duration_control_option" v-on:click="() => setValue('7h')">7h</div>
                <div class="duration_control_option" v-on:click="() => setValue('8h')">8h</div>
            </div>
            <lsw-control-error />
        </div>
    </div>
</div>`,
  props: {
    settings: {
      type: Object,
      default: () => ({})
    },
    skipLabel: {
      type: Boolean,
      default: () => false,
    }
  },
  data() {
    this.$trace("lsw-duration-control.data");
    this.validateSettings();
    const value = this.settings?.initialValue || this.settings?.column?.hasDefaultValue || "";
    return {
      uuid: LswRandomizer.getRandomString(5),
      value,
      isEditable: true,
      isShowingDetails: true,
      submitError: false,
      validateError: false,
    };
  },
  methods: {
    async submit() {
      this.$trace("lsw-text-control.methods.submit");
      try {
        return LswFormtypes.utils.submitControl.call(this);
      } catch (error) {
        this.submitError = error;
        throw error;
      }
    },
    validate() {
      this.$trace("lsw-text-control.methods.validateSettings");
      try {
        return LswFormtypes.utils.validateControl.call(this);
      } catch (error) {
        this.validateError = error;
        throw error;
      }
    },
    validateSettings() {
      this.$trace("lsw-text-control.methods.validateSettings");
      return LswFormtypes.utils.validateSettings.call(this);
    },
    toggleDetails() {
      this.$trace("lsw-duration-control.methods.toggleDetails");
      this.isShowingDetails = !this.isShowingDetails;
    },
    setValue(v) {
      this.$trace("lsw-duration-control.methods.setValue");
      this.value = v;
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-duration-control.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswDurationControl API

// @vuebundler[Lsw_framework_components][140]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-duration-control/lsw-duration-control.css

// @vuebundler[Lsw_framework_components][141]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-number-control/lsw-number-control.html

// @vuebundler[Lsw_framework_components][141]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-number-control/lsw-number-control.js
// @code.start: LswNumberControl API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswNumberControl component
Vue.component("LswNumberControl", {
  template: `<div class="lsw_number_control">
    number control
</div>`,
  props: {
    configurations: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    this.$trace("lsw-number-control.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-number-control.mounted");
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswNumberControl API

// @vuebundler[Lsw_framework_components][141]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-number-control/lsw-number-control.css

// @vuebundler[Lsw_framework_components][142]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-options-control/lsw-options-control.html

// @vuebundler[Lsw_framework_components][142]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-options-control/lsw-options-control.js
// @code.start: LswOptionsControl API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswOptionsControl component
Vue.component("LswOptionsControl", {
  template: `<div class="lsw_options_control lsw_formtype lsw_form_control" keep-alive="true">
    <lsw-control-label :settings="settings"
        :parent-formtype="this" />
    <div v-show="isEditable">
        <div
            v-show="settings.column.hasFormtypeParameters.type === 'selector'"
            ref="controller"
            v-xform.control="{
                name: settings.name,
                onValidate: settings.column.hasValidator || \$noop,
                onSetError: () => {
                    isEditable = true;
                }
            }">
            <select class="width_100" ref="inputter" v-xform.input="{name:'*'}" v-model="value">
                <option :value="opt"
                    v-for="opt, optIndex in settings.column.hasFormtypeParameters.available"
                    v-bind:key="'option-' + optIndex">
                    {{ opt }}
                </option>
            </select>
            <lsw-control-error />
        </div>
    </div>
</div>`,
  props: {
    settings: {
      type: Object,
      default: () => ({})
    },
  },
  data() {
    this.$trace("lsw-options-control.data");
    this.validateSettings();
    const value = this.settings?.initialValue || this.settings?.column?.hasInitialValue?.call() || "";
    return {
      uuid: LswRandomizer.getRandomString(5),
      value,
      isEditable: true,
      parameters: this.settings?.hasFormtypeParameters || {}
    };
  },
  methods: {
    async submit() {
      this.$trace("lsw-text-control.methods.submit");
      return LswFormtypes.utils.submitControl.call(this);
    },
    validate() {
      this.$trace("lsw-text-control.methods.validateSettings");
      return LswFormtypes.utils.validateControl.call(this);
    },
    validateSettings() {
      this.$trace("lsw-text-control.methods.validateSettings");
      return LswFormtypes.utils.validateSettings.call(this);
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-options-control.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswOptionsControl API

// @vuebundler[Lsw_framework_components][142]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-options-control/lsw-options-control.css

// @vuebundler[Lsw_framework_components][143]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-source-code-control/lsw-source-code-control.html

// @vuebundler[Lsw_framework_components][143]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-source-code-control/lsw-source-code-control.js
// @code.start: LswSourceCodeControl API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswSourceCodeControl component
Vue.component("LswSourceCodeControl", {
  template: `<div class="lsw_source_code_control lsw_formtype lsw_form_control">
    <lsw-control-label :settings="settings"
        :parent-formtype="this"
        v-if="skipLabel === false" />
    <div v-show="isEditable">
        <div ref="controller"
            v-xform.control="{
            name: settings.name,
            onValidate: settings.column?.hasValidator || \$noop,
            onSetError: () => {
                isEditable = true;
            }
        }">
            <div class="">
                <div class="">
                    <textarea class="flex_100 width_100"
                        v-model="value"
                        v-on="settings.input?.events || {}"
                        v-bind="settings.input?.props || {}"
                        v-xform.input="{name: '*',onValidate: settings.input?.onValidate || \$noop}"
                        :style="'font-size: ' + currentFontsize + 'px; font-family: ' + currentFontfamily + ';'"
                        spellcheck="false"
                        ref="textInput"></textarea>
                </div>
                <div class="flex_row pad_top_1">
                    <div class="flex_100"></div>
                    <div class="flex_1">
                        <button class="supermini"
                            v-on:click="() => increaseFontsize(-1)"></button>
                    </div>
                    <div class="flex_1 pad_left_1">
                        <button class="supermini"
                            v-on:click="() => increaseFontsize(1)"></button>
                    </div>
                    <div class="flex_1 pad_left_1">
                        <button class="supermini"
                            v-on:click="() => alternateFontfamily()">|</button>
                    </div>
                </div>
            </div>
            <lsw-control-error />
        </div>
    </div>
</div>`,
  props: {
    settings: {
      type: Object,
      default: () => ({})
    },
    skipLabel: {
      type: Boolean,
      default: () => false,
    }
  },
  data() {
    this.$trace("lsw-source-code-control.data");
    this.validateSettings();
    const value = this.settings?.initialValue || this.settings?.column.hasDefaultValue || "";
    return {
      uuid: LswRandomizer.getRandomString(5),
      value,
      isEditable: true,
      currentFontsize: 10,
      currentFontfamily: "monospace",
    };
  },
  methods: {
    increaseFontsize(points = 1) {
      this.$trace("lsw-source-code-control.methods.increaseFontsize");
      this.currentFontsize += points;
    },
    alternateFontfamily() {
      this.$trace("lsw-source-code-control.methods.alternateFontfamily");
      if(this.currentFontfamily === 'monospace') {
        this.currentFontfamily = 'Arial';
      } else {
        this.currentFontfamily = 'monospace';
      }
    },
    async submit() {
      this.$trace("lsw-source-code-control.methods.submit");
      return LswFormtypes.utils.submitControl.call(this);
      
    },
    validate() {
      this.$trace("lsw-source-code-control.methods.validateSettings");
      return LswFormtypes.utils.validateControl.call(this);
    },
    validateSettings() {
      this.$trace("lsw-source-code-control.methods.validateSettings");
      return LswFormtypes.utils.validateSettings.call(this);
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-source-code-control.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswSourceCodeControl API

// @vuebundler[Lsw_framework_components][143]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-source-code-control/lsw-source-code-control.css

// @vuebundler[Lsw_framework_components][144]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-object-control/lsw-ref-object-control.html

// @vuebundler[Lsw_framework_components][144]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-object-control/lsw-ref-object-control.js
// @code.start: LswRefObjectControl API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswRefObjectControl component
Vue.component("LswRefObjectControl", {
  template: `<div class="lsw_ref_object_control lsw_formtype lsw_form_control">
    <lsw-control-label :settings="settings"
        :parent-formtype="this" />
    <div v-show="isEditable">
        <div ref="controller"
            v-xform.control="{
                name: settings.name,
                onValidate: settings.column.hasValidator || \$noop,
                onSetError: () => {
                    isEditable = true;
                }
            }">
            <div class="flex_row">
                <div class="flex_1 pad_right_1">
                    <button
                        class="has_light_bg"
                        :class="{activated: isShownSelector}"
                        v-on:click="toggleSelector"></button>
                </div>
                <input class="flex_100"
                    type="text"
                    v-model="value"
                    v-xform.input="{name: '*',onValidate: settings.input?.onValidate || \$noop}"
                    :disabled="settings.column.refersTo.constraint"
                    ref="textInput" />
                <div class="flex_1 pad_left_1" v-if="\$window.process.env.NODE_ENV === 'test' && false">
                    <button :class="{activated: isShownInfo}"
                        v-on:click="toggleInfo"></button>
                </div>
            </div>
            <div class="pad_top_1" v-if="isShownInfo">
                <div class="" style="white-space: pre; font-size:12px; border: 1px solid white; background-color: white; color: black;">{{ \$lsw.utils.stringify(settings) }}</div>
            </div>
            <div class=""
                v-if="isShownSelector && isLoaded">
                <lsw-table
                    :initial-input="rows"
                    :initial-settings="{title: \`Un tem de \${settings.column.refersTo.table}.\${settings.column.refersTo.property}:\`, itemsPerPage: 50 }"
                    selectable="one"
                    :on-choose-row="v => value = \$window.console.log('valueee', v) || v"
                    :initial-choosen-value="value"
                    choosable-id="tiene_nombre"></lsw-table>
            </div>
            <lsw-control-error />
        </div>
    </div>
</div>`,
  props: {
    settings: {
      type: Object,
      default: () => ({})
    },
    labelField: {
      type: String,
      required: true,
    }
  },
  data() {
    this.$trace("lsw-ref-object-control.data");
    this.validateSettings();
    return {
      uuid: LswRandomizer.getRandomString(5),
      value: this.settings.initialValue || [],
      isLoaded: false,
      isValueLoaded: false,
      isEditable: true,
      isShownSelector: true,
      isShownInfo: false,
      rows: [],
    };
  },
  methods: {
    toggleSelector() {
      this.$trace("lsw-ref-object-control.methods.toggleSelector");
      this.isShownSelector = !this.isShownSelector;
    },
    toggleInfo() {
      this.$trace("lsw-ref-object-control.methods.toggleInfo");
      this.isShownInfo = !this.isShownInfo;
    },
    async submit() {
      this.$trace("lsw-ref-object-control.methods.submit");
      return LswFormtypes.utils.submitControl.call(this);
      
    },
    validate() {
      this.$trace("lsw-ref-object-control.methods.validateSettings");
      return LswFormtypes.utils.validateControl.call(this);
    },
    validateSettings() {
      this.$trace("lsw-ref-object-control.methods.validateSettings");
      return LswFormtypes.utils.validateSettings.call(this);
    },
    async loadRows() {
      this.$trace("lsw-page-rows.methods.loadRows", arguments);
      const selection = await this.$lsw.database.select(this.settings.column.refersTo.table, it => true);
      this.rows = selection;
      this.isLoaded = true;
      return selection;
    },
    async loadValue() {
      this.$trace("lsw-ref-object-control.methods.loadValue");
      const selection = await this.$lsw.database.select(this.settings.tableId, it => true);
    },
    selectRow(row) {
      this.$trace("lsw-ref-object-control.methods.selectRow");
      this.value = row;
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-ref-object-control.mounted");
      await this.loadRows();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswRefObjectControl API

// @vuebundler[Lsw_framework_components][144]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-object-control/lsw-ref-object-control.css

// @vuebundler[Lsw_framework_components][145]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-object-by-label-control/lsw-ref-object-by-label-control.html

// @vuebundler[Lsw_framework_components][145]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-object-by-label-control/lsw-ref-object-by-label-control.js
// @code.start: LswRefObjectByLabelControl API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswRefObjectByLabelControl component
Vue.component("LswRefObjectByLabelControl", {
  template: `<div class="lsw_ref_object_by_label_control lsw_formtype lsw_form_control">
    <lsw-control-label :settings="settings"
        :parent-formtype="this" />
    <div v-show="isEditable">
        <div ref="controller"
            v-xform.control="{
                name: settings.name,
                onValidate: settings.column.hasValidator || \$noop,
                onSetError: () => {
                    isEditable = true;
                }
            }">
            <div class="flex_row">
                <div class="flex_1 pad_right_1">
                    <button
                        class="has_light_bg"
                        :class="{activated: isShownSelector}"
                        v-on:click="toggleSelector"></button>
                </div>
                <input class="flex_100"
                    type="text"
                    v-model="value"
                    v-xform.input="{name: '*',onValidate: settings.input?.onValidate || \$noop}"
                    :disabled="settings.column.refersTo.constraint"
                    ref="textInput" />
                <div class="flex_1 pad_left_1" v-if="\$window.process.env.NODE_ENV === 'test' && false">
                    <button :class="{activated: isShownInfo}"
                        v-on:click="toggleInfo"></button>
                </div>
            </div>
            <div class="pad_top_1" v-if="isShownInfo">
                <div class="" style="white-space: pre; font-size:12px; border: 1px solid white; background-color: white; color: black;">{{ \$lsw.utils.stringify(settings) }}</div>
            </div>
            <div class=""
                v-if="isShownSelector && isLoaded">
                
                <lsw-inline-tags-picker
                    :from="rows"
                    :field="settings.column.refersTo.property"
                    :on-choose="v => value = v[settings.column.refersTo.property]"
                />
                
                <!--lsw-table
                    :initial-input="rows"
                    :initial-settings="{title: \`Un tem de \${settings.column.refersTo.table}.\${settings.column.refersTo.property}:\`, itemsPerPage: 50 }"
                    selectable="one"
                    :on-choose-row="v => value = \$window.console.log('valueee', v) || v"
                    :initial-choosen-value="value"
                    choosable-id="tiene_nombre"></lsw-table-->
            </div>
            <lsw-control-error />
        </div>
    </div>
</div>`,
  props: {
    settings: {
      type: Object,
      default: () => ({})
    },
  },
  data() {
    this.$trace("lsw-ref-object-by-label-control.data");
    this.validateSettings();
    return {
      uuid: LswRandomizer.getRandomString(5),
      value: this.settings.initialValue || [],
      isLoaded: false,
      isValueLoaded: false,
      isEditable: true,
      isShownSelector: true,
      isShownInfo: false,
      rows: []
    };
  },
  methods: {
    toggleSelector() {
      this.$trace("lsw-ref-object-by-label-control.methods.toggleSelector");
      this.isShownSelector = !this.isShownSelector;
    },
    toggleInfo() {
      this.$trace("lsw-ref-object-by-label-control.methods.toggleInfo");
      this.isShownInfo = !this.isShownInfo;
    },
    async submit() {
      this.$trace("lsw-ref-object-by-label-control.methods.submit");
      return LswFormtypes.utils.submitControl.call(this);
      
    },
    validate() {
      this.$trace("lsw-ref-object-by-label-control.methods.validateSettings");
      return LswFormtypes.utils.validateControl.call(this);
    },
    validateSettings() {
      this.$trace("lsw-ref-object-by-label-control.methods.validateSettings");
      return LswFormtypes.utils.validateSettings.call(this);
    },
    async loadRows() {
      this.$trace("lsw-page-rows.methods.loadRows", arguments);
      const selection = await this.$lsw.database.select(this.settings.column.refersTo.table, it => true);
      this.rows = selection;
      this.isLoaded = true;
      return selection;
    },
    async loadValue() {
      this.$trace("lsw-ref-object-by-label-control.methods.loadValue");
      const selection = await this.$lsw.database.select(this.settings.tableId, it => true);
    },
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-ref-object-by-label-control.mounted");
      await this.loadRows();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswRefObjectByLabelControl API

// @vuebundler[Lsw_framework_components][145]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-object-by-label-control/lsw-ref-object-by-label-control.css

// @vuebundler[Lsw_framework_components][146]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-list-control/lsw-ref-list-control.html

// @vuebundler[Lsw_framework_components][146]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-list-control/lsw-ref-list-control.js
// @code.start: LswRefListControl API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswRefListControl component
Vue.component("LswRefListControl", {
  template: `<div class="lsw_ref_list_control lsw_formtype lsw_form_control">
    <lsw-control-label :settings="settings"
        :parent-formtype="this" />
    <div v-show="isEditable">
        <div ref="controller"
            v-zzzform.control="{
                name: settings.name,
                onValidate: settings.column.hasValidator || \$noop,
                onSetError: () => {
                    isEditable = true;
                }
            }">
            <div class="flex_row">
                <div class="flex_1 pad_right_1">
                    <button
                        class="has_light_bg"
                        :class="{activated: isShownSelector}"
                        v-on:click="toggleSelector"></button>
                </div>
                <input class="flex_100"
                    type="text"
                    v-model="value"
                    v-zzzform.input="{name: '*',onValidate: settings.input?.onValidate || \$noop}"
                    disabled="true"
                    ref="textInput" />
                <div class="flex_1 pad_left_1" v-if="\$window.process.env.NODE_ENV === 'test' && false">
                    <button :class="{activated: isShownInfo}"
                        v-on:click="toggleInfo"></button>
                </div>
            </div>
            <div class="pad_top_1" v-if="isShownInfo">
                <div class="" style="white-space: pre; font-size:12px; border: 1px solid white; background-color: white; color: black;">{{ \$lsw.utils.stringify(settings) }}</div>
            </div>
            <div class=""
                v-if="isShownSelector">
                <lsw-table
                    :initial-input="rows"
                    :initial-settings="{title: \`Un tem de \${settings.column.refersTo.table}.\${settings.column.refersTo.property}:\`, itemsPerPage: 50 }"
                    selectable="many"
                    :on-choose-row="v => value = \$window.console.log('valueee', v) || v"
                    :initial-choosen-value="value"
                    :columns-order="['id']"
                    choosable-id="id"></lsw-table>
            </div>
            <lsw-control-error />
        </div>
    </div>
</div>`,
  props: {
    settings: {
      type: Object,
      default: () => ({})
    },
  },
  data() {
    this.$trace("lsw-ref-list-control.data");
    this.validateSettings();
    return {
      uuid: LswRandomizer.getRandomString(5),
      value: this.settings.initialValue || [],
      isValueLoaded: false,
      isEditable: true,
      isShownSelector: false,
      isShownInfo: false,
      rows: []
    };
  },
  methods: {
    toggleSelector() {
      this.$trace("lsw-ref-list-control.methods.toggleSelector");
      this.isShownSelector = !this.isShownSelector;
    },
    toggleInfo() {
      this.$trace("lsw-ref-list-control.methods.toggleInfo");
      this.isShownInfo = !this.isShownInfo;
    },
    async submit() {
      this.$trace("lsw-ref-list-control.methods.submit");
      return LswFormtypes.utils.submitControl.call(this);
      
    },
    validate() {
      this.$trace("lsw-ref-list-control.methods.validateSettings");
      return LswFormtypes.utils.validateControl.call(this);
    },
    validateSettings() {
      this.$trace("lsw-ref-list-control.methods.validateSettings");
      return LswFormtypes.utils.validateSettings.call(this);
    },
    async loadRows() {
      this.$trace("lsw-page-rows.methods.loadRows", arguments);
      const selection = await this.$lsw.database.select(this.settings.column.refersTo.table, it => true);
      this.rows = selection;
      return selection;
    },
    async loadValue() {
      this.$trace("lsw-ref-list-control.methods.loadValue");
      const selection = await this.$lsw.database.select(this.settings.tableId, it => true);
    },
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-ref-list-control.mounted");
      await this.loadRows();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswRefListControl API

// @vuebundler[Lsw_framework_components][146]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-list-control/lsw-ref-list-control.css

// @vuebundler[Lsw_framework_components][147]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-relation-control/lsw-ref-relation-control.html

// @vuebundler[Lsw_framework_components][147]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-relation-control/lsw-ref-relation-control.js
// @code.start: LswRefRelationControl API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswRefRelationControl component
Vue.component("LswRefRelationControl", {
  template: `<div class="lsw_ref_relation_control">
    Ref relation control
</div>`,
  props: {
    settings: {
      type: Object,
      default: () => ({})
    },
  },
  data() {
    this.$trace("lsw-ref-relation-control.data");
    this.validateSettings();
    return {
      uuid: LswRandomizer.getRandomString(5),
      value: this.settings?.initialValue || "",
      isEditable: true,
    };
  },
  methods: {
    async submit() {
      this.$trace("lsw-ref-relation-control.methods.submit");
      return LswFormtypes.utils.submitControl.call(this);
      
    },
    validate() {
      this.$trace("lsw-ref-relation-control.methods.validateSettings");
      return LswFormtypes.utils.validateControl.call(this);
    },
    validateSettings() {
      this.$trace("lsw-ref-relation-control.methods.validateSettings");
      return LswFormtypes.utils.validateSettings.call(this);
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-ref-relation-control.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswRefRelationControl API

// @vuebundler[Lsw_framework_components][147]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-relation-control/lsw-ref-relation-control.css

// @vuebundler[Lsw_framework_components][148]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-schema-based-form/lsw-schema-based-form.html

// @vuebundler[Lsw_framework_components][148]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-schema-based-form/lsw-schema-based-form.js
// @code.start: LswSchemaBasedForm API | @$section: Vue.js (v2) Components  Lsw SchemaBasedForm API  LswSchemaBasedForm component
Vue.component("LswSchemaBasedForm", {
  template: `<div class="lsw_schema_form">
    <div class="lsw_schema_form_container">
        <div class="lsw_schema_form_content">
            <div class=""
                ref="schemaForm0"
                v-xform.form="{ onSubmit, onValidate }"
                v-if="isLoaded">
                <div class="">
                    <div class="position_relative">
                        <div class="pad_left_1 schema_form_title_box nowrap schema_form_title_text pad_top_2 pad_bottom_2">
                            <div class="flex_row">
                                <div class="flex_100">
                                    <div class="title_box_one_line">
                                        <div class="title_text_cell">
                                            {{ tableDefinition?.hasExtraAttributes?.readableName ?
                                            \$lsw.utils.capitalize(tableDefinition.hasExtraAttributes.readableName) : model.tableId }}
                                            <span v-if="isUpdateOperation">[#{{ model.rowId }}]</span>
                                            <span v-else>[new]</span>
                                        </div>
                                        <div class="title_database_id_cell" style="font-size: 10px;">[{{model.databaseId}}]</div>
                                    </div>
                                </div>
                                <div class="flex_1 flex_row centered pad_left_1 pad_right_1">
                                    <button class="mini danger_button nowrap"
                                        v-if="isUpdateOperation"
                                        v-on:click="deleteRow"> #{{model.rowId}}</button>
                                    <button class="has_light_bg margin_left_1 nowrap" v-on:click="submitForm"></button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="flex_row centered schema_form_top_panel">
                        <div class="flex_1 flex_row centered">
                            <button class="supermini margin_left_1 nowrap"
                                :class="{activated: section === 'campos propios'}"
                                v-on:click="() => selectSection('campos propios')"></button>
                            <button class="supermini margin_left_1 nowrap"
                                :class="{activated: section === 'campos reflejos'}"
                                v-on:click="() => selectSection('campos reflejos')"></button>
                        </div>
                        <div class="flex_100"></div>
                        <div class="flex_1 flex_row centered">
                            <button class="supermini margin_right_1 nowrap"
                                v-on:click="passToPrinter"></button>
                            <button class="supermini margin_right_1 nowrap"
                                v-on:click="validateForm"></button>
                            <button class="supermini margin_right_1 nowrap"
                                :class="{activated: isShowingFormInfo}"
                                v-on:click="toggleFormInfo"></button>
                            <!--button class="supermini margin_right_1 nowrap"
                                v-on:click="openEditables">*</button>
                            <button class="supermini margin_right_1 nowrap"
                                v-on:click="closeEditables">*</button-->
                        </div>
                    </div>
                </div>
                <div v-if="isShowingFormInfo"
                    class="scrollable_text_area">
                    <pre style="background-color: white; color: black; font-family: Arial; font-size: 11px; padding: 4px; margin: 0px; border-top: 1px solid white;">: {{ tableDefinition }}</pre>
                </div>
                <div class="" style="padding: 0px; min-height: 0%;">
                    <div class="pestania"
                        v-if="section === 'campos propios'">
                        <!--div class="subtitle_box">Campos propios:</div-->
                        <table class="collapsed_table lsw_table_itself width_100 translucid_background">
                            <tbody>
                                <tr v-for="column, columnId, columnCounter in columnDefinitions"
                                    v-bind:key="'schema-column-' + columnCounter"
                                    class="row_for_table"
                                    :class="((columnCounter === 0) || (columnCounter % 2 === 0)) ? 'odd' : ''">
                                    <td class="pad_1">
                                        <!--This will load component [typically] placed on:-->
                                        <!--src/lsw-framework/components/lsw-formtype/type/lsw-*-control/lsw-*-control.{html,css,js}-->
                                        <component :is="column.hasFormtypeSettings.id"
                                            v-bind="{}"
                                            :settings="{
                                                name: columnId,
                                                database: model.databaseId,
                                                table: model.tableId,
                                                entity: model.entityId,
                                                column: column,
                                                parentSchemaForm: own,
                                                label: (columnCounter+1) + '. ' + (column.hasLabel || ('Campo ' + columnId + '')),
                                                extraAttributes: column.hasExtraAttributes,
                                                initialValue: ((typeof value !== 'undefined') && (columnId in value)) ? value[columnId] : '',
                                                input: {
                                                    props: {
                                                        ...column.hasFormtypeSettings.input.props,
                                                    },
                                                    events: {
                                                        ...column.hasFormtypeSettings.input.events
                                                    }
                                                },
                                                formtypeParameters: column.hasFormtypeParameters || {},
                                                formtypeSettings: column.hasFormtypeSettings
                                            }" />
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <div class="flex_100">
                            <div class="flex_row centered schema_form_title_box bottom_title_box"
                                style="background-color: #333333; padding-top: 6px; padding-bottom: 4px;">
                                <div class="flex_1 flex_row centered"
                                    v-if="isUpdateOperation">
                                    <button class="mini margin_left_1 nowrap danger_button"
                                        v-on:click="deleteRow"> #{{model.rowId}}</button>
                                </div>
                                <div class="flex_100"></div>
                                <div class="flex_1 flex_row centered pad_right_1">
                                    <button class="mini margin_left_1 nowrap"
                                        v-on:click="submitForm"> Enviar</button>
                                    <button class="mini margin_left_1 nowrap"
                                        v-on:click="validateForm"> Validar</button>
                                    <!--button class="mini margin_left_1 nowrap"
                                        v-on:click="openEditables">*</button>
                                    <button class="mini margin_left_1 nowrap"
                                        v-on:click="closeEditables">*</button-->
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="pestania"
                        v-if="section === 'campos reflejos'">
                        <div class="subtitle_box">Campos reflejos:</div>
                        <table class="collapsed_table lsw_table_itself width_100 translucid_background">
                            <tbody>
                                <tr v-for="externalColumn, externalColumnId, externalColumnCounter in tableDefinition.externalProperties"
                                    v-bind:key="'schema-external-column-' + externalColumnCounter"
                                    class="row_for_table"
                                    :class="((externalColumnCounter === 0) || (externalColumnCounter % 2 === 0)) ? 'odd' : ''">
                                    <td class="pad_1">
                                        <!--This will load component [typically] placed on:-->
                                        <!--src/lsw-framework/components/lsw-formtype/type/lsw-*-control/lsw-*-control.{html,css,js}-->
                                        <template v-if="externalColumn.isType === 'ref-list'">
                                            <lsw-ref-list-control :settings="{
                                                name: externalColumnId,
                                                database: model.databaseId,
                                                table: model.tableId,
                                                entity: model.entityId,
                                                column: externalColumn,
                                                parentSchemaForm: own,
                                                label: (externalColumnCounter+1) + '. ' + (externalColumn.hasLabel || ('Campo ' + externalColumnId + '')),
                                            }" />
                                        </template>
                                        <!--component :is="column.hasFormtypeSettings.id"
                                        v-bind="{}"
                                        :settings="{
                                            name: columnId,
                                            database: model.databaseId,
                                            table: model.tableId,
                                            entity: model.entityId,
                                            column: column,
                                            parentSchemaForm: own,
                                            label: (externalColumnCounter+1) + '. ' + (column.hasLabel || ('Campo ' + columnId + '')),
                                            extraAttributes: column.hasExtraAttributes,
                                            initialValue: ((typeof value !== 'undefined') && (columnId in value)) ? value[columnId] : '',
                                            input: {
                                                props: {
                                                    ...column.hasFormtypeSettings.input.props,
                                                },
                                                events: {
                                                    ...column.hasFormtypeSettings.input.events
                                                }
                                            },
                                            formtypeParameters: column.hasFormtypeParameters || {},
                                            formtypeSettings: column.hasFormtypeSettings
                                        }" /-->
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>`,
  props: {
    model: {
      type: Object,
      required: true,
    },
    onSubmit: {
      type: Function,
      default: () => this.$noop,
    },
    onValidate: {
      type: Function,
      default: () => this.$noop,
    },
    onDeleteRow: {
      type: Function,
      default: () => this.$noop,
    },
    overridenValues: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    this.$trace("lsw-schema-based-form.data");
    this.validateModel(this.model);
    const isOperation = (this.model.row && this.model.row.id) || (this.model.rowId && (this.model.rowId !== -1)) ? "update" : "insert";
    return {
      own: this,
      validFormtypes: [
        "text",
        "long-text",
        "options",
        "boolean",
        "date",
        "duration",
        "ref-object",
        "ref-object-by-label",
        "ref-list",
        "ref-relation",
        "source-code",
      ],
      section: 'campos propios', // 'campos reflejos'
      isShowingFormInfo: false,
      isLoaded: false,
      tableDefinition: false,
      columnDefinitions: false,
      value: this.model.row ?? false,
      editableFields: [],
      minimizedFields: [],
      isOperation,
      isUpdateOperation: isOperation === "update",
      isInsertOperation: isOperation === "insert",
    };
  },
  methods: {
    selectSection(section) {
      this.section = section;
    },
    toggleMinimizedField(field) {
      this.$trace("lsw-schema-based-form.methods.toggleMinimizedField");
      const fieldPos = this.minimizedFields.indexOf(field);
      if (fieldPos === -1) {
        this.minimizedFields.push(field);
      } else {
        this.minimizedFields.splice(fieldPos, 1);
      }
      this.$forceUpdate(true);
    },
    hideMinimizedField(field) {
      this.$trace("lsw-schema-based-form.methods.hideMinimizedField");
      const fieldPos = this.minimizedFields.indexOf(field);
      if (fieldPos === -1) {
        this.minimizedFields.push(field);
      }
      this.$forceUpdate(true);
    },
    showMinimizedField(field) {
      this.$trace("lsw-schema-based-form.methods.showMinimizedField");
      const fieldPos = this.minimizedFields.indexOf(field);
      if (fieldPos !== -1) {
        this.minimizedFields.splice(fieldPos, 1);
      }
      this.$forceUpdate(true);
    },
    toggleEditableField(field) {
      this.$trace("lsw-schema-based-form.methods.toggleEditableField");
      const fieldPos = this.editableFields.indexOf(field);
      if (fieldPos === -1) {
        this.editableFields.push(field);
      } else {
        this.editableFields.splice(fieldPos, 1);
      }
    },
    saveField(field, value) {
      this.$trace("lsw-schema-based-form.methods.saveField");
      console.log("Should save field:", field, value);
      // *@TODO: use $lsw.database.overwrite to send the field only

    },
    validateModel(model) {
      this.$trace("lsw-schema-based-form.methods.validateModel");
      try {
        const ensureModel = $ensure({ model }, 1);
        const checkModel = $check(model);
        Basic_type_and_signature: {
          ensureModel.type("object");
          ensureModel.to.have.uniquelyKeys(["connection", "databaseId", "tableId", "rowId", "row", "databaseExplorer"]);
          ensureModel.to.have.keys(["databaseId", "tableId"]);
          const correctOption = $ensure.$or({
            "has connection and rowId (set -1 for new instances)": () => ensureModel.to.have.key("rowId"),
            "has row": () => ensureModel.to.have.key("row"),
          });
          if (!checkModel.to.have.key("rowId")) {
            ensureModel.to.have.key("row");
          }
        }
        Component_types_and_signatures: {
          if (checkModel.to.have.key("connection")) {
            ensureModel.its("connection").type("object");
          }
          if (checkModel.to.have.key("databaseId")) {
            ensureModel.its("databaseId").type("string");
          }
          if (checkModel.to.have.key("tableId")) {
            ensureModel.its("tableId").type("string");
          }
          if (checkModel.to.have.key("rowId")) {
            ensureModel.its("rowId").type("number");
          }
          if (checkModel.to.have.key("row")) {
            $ensure.$or({
              "row is object": () => ensureModel.its("row").type("object"),
              "row is false": () => ensureModel.its("row").type("boolean").is(false),
            });
          }
          if(checkModel.to.have.key("databaseExplorer")) {
            ensureModel.its("databaseExplorer").type("object");
          }
        }
      } catch (error) {
        console.error("Failed validating model property on lsw-schema-based-form.validateModel");
        console.error(error);
      }
    },
    async loadValue() {
      this.$trace("lsw-schema-based-form.methods.loadValue");
      if (this.model.rowId) {
        const originalValues = await LswDatabase.pickRow(this.model.databaseId, this.model.tableId, this.model.rowId);
        this.value = Object.assign({}, originalValues, this.overridenValues);
      }
    },
    onlyKnownTypes(formtype) {
      if(this.validFormtypes.indexOf(formtype) !== -1) {
        return formtype;
      }
      return "long-text";
    },
    async loadSchema() {
      this.$trace("lsw-schema-based-form.methods.loadSchema");
      const columnIds = Object.keys($lswSchema.$schema.hasTables[this.model.tableId].hasColumns);
      for(let columnId of columnIds) {
        const columnData = $lswSchema.$schema.hasTables[this.model.tableId].hasColumns[columnId];
        Object.assign(columnData, {
          belongsToDatabase: this.model.databaseId,
          belongsToTable: this.model.tableId,
          hasFormtypeSettings: {
            id: 'lsw-' + this.onlyKnownTypes(columnData.isFormType) + '-control',
            name: columnId,
            input: {
              props: {
                placeholder: columnData.hasPlaceholder,
              },
              events: {
                
              }
            },
          }
        })
      }
      this.tableDefinition = $lswSchema.$schema.hasTables[this.model.tableId];
      this.columnDefinitions = this.tableDefinition.hasColumns;
    },
    toggleFormInfo() {
      this.$trace("lsw-schema-based-form.methods.toggleFormInfo");
      this.isShowingFormInfo = !this.isShowingFormInfo;
    },
    closeEditables() {
      this.$trace("lsw-schema-based-form.methods.closeEditables");
      const uneditables = this.$el.querySelectorAll(".lsw_form_control .lsw_control_label .button_to_uneditable");
      for(let index=0; index<uneditables.length; index++) {
        const uneditable = uneditables[index];
        uneditable.click();
      }
    },
    openEditables() {
      this.$trace("lsw-schema-based-form.methods.openEditables");
      const editables = this.$el.querySelectorAll(".lsw_form_control .lsw_control_label .button_to_editable");
      for(let index=0; index<editables.length; index++) {
        const editable = editables[index];
        editable.click();
      }
    },
    validateForm() {
      this.$trace("lsw-schema-based-form.methods.validateForm");
      return this.$refs.schemaForm0.$xform.validate();
    },
    async submitForm(v) {
      this.$trace("lsw-schema-based-form.methods.submitForm");
      return await this.$refs.schemaForm0.$xform.submit();
    },
    passToPrinter() {
      this.$trace("lsw-schema-based-form.methods.passToPrinter");
      const value = this.$refs.schemaForm0.$xform.getValue();
      this.$lsw.dialogs.open({
        title: "Impresin de estado de formulario",
        template: `
          <lsw-data-printer-report :input="input" />
        `,
        factory: { data: { input: value } },
      });
    },
    async deleteRow() {
      this.$trace("lsw-schema-based-form.methods.deleteRow");
      const confirmed = await this.$lsw.dialogs.open({
        id: `eliminar-registro-${this.model.tableId}-${this.model.rowId || this.model.row.id}-${LswRandomizer.getRandomString(5)}`,
        title: "Eliminar registro",
        template: `
          <div>
            <div class="pad_2 font_weight_bold">ATENCIN: </div>
            <div class="pad_2">Seguro que quieres eliminar el registro <b>{{ model.tableId }}</b> cuyo <b>id</b>#<b>{{ model.rowId || model.row.id }}</b>?</div>
            <div class="pad_2">
              <pre class="pad_2 codeblock">{{ JSON.stringify(model.row || rowValue, null, 2) }}</pre>
            </div>
            <hr class="margin_0" />
            <div class="pad_2 text_align_right">
              <button class="supermini danger_button" v-on:click="() => accept(true)">Eliminar</button>
              <button class="supermini " v-on:click="() => accept(false)">Cancelar</button>
            </div>
          </div>
        `,
        factory: {
          data: {
            model: this.model,
            rowValue: this.value
          }
        }
      });
      if(!confirmed) return false;
      const rowIdentifier = this.model.rowId || this.model.row.id;
      await this.$lsw.database.delete(this.model.tableId, rowIdentifier);
      if(this.onDeleteRow) {
        const result = this.onDeleteRow(this.model.rowId, this.model.tableId, true);
        // INTERCEPT REDIRECTION RETURNING FALSE FROM onDeleteRow PARAMETRIC CALLBACK
        if(result === false) return;
      }
      if(this.model.databaseExplorer) {
        if(this.model.databaseExplorer.showBreadcrumb) {
          this.model.databaseExplorer.selectPage("LswPageRows", {
            database: this.model.databaseId,
            table: this.model.tableId,
          });
        } else {
          
        }
      }
    }
  },
  watch: {
    
  },
  async mounted() {
    try {
      this.$trace("lsw-schema-based-form.mounted");
      await this.loadSchema();
      await this.loadValue();
      this.isLoaded = true;
      this.$nextTick(() => {
        window.sf0 = this.$refs.schemaForm0;
      });
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswSchemaBasedForm API

// @vuebundler[Lsw_framework_components][148]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-schema-based-form/lsw-schema-based-form.css

// @vuebundler[Lsw_framework_components][149]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-bars-graph/components/lsw-bars-graph-bar/lsw-bars-graph-bar.html

// @vuebundler[Lsw_framework_components][149]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-bars-graph/components/lsw-bars-graph-bar/lsw-bars-graph-bar.js
// @code.start: LswBarsGraphBar API | @$section: Vue.js (v2) Components  LswBarsGraphBar component
Vue.component("LswBarsGraphBar", {
  template: `<div class="lsw_bars_graph_bar">
    <div class="barra_box"
        v-on:click="onClick">
        <div class="barra_box_2">
            <div class="barra_box_3">
                <div class="barra_filler"
                    :style="{ width: value + '%', backgroundColor: color ?? 'inherit', }"></div>
                <div class="barra_text pad_left_1">
                    <div class="texto_de_barra">{{ text }}</div>
                </div>
            </div>
        </div>
    </div>
</div>`,
  props: {
    value: {
      type: Number,
      required: true,
    },
    text: {
      type: [String, Boolean],
      required: true,
    },
    onClick: {
      type: Function,
      default: () => {},
    },
    color: {
      type: [String, Boolean],
      default: () => false
    }
  },
  data() {
    this.$trace("lsw-bars-graph-bar.data");
    return {
      
    };
  },
  methods: {
    
  },
  mounted() {
    this.$trace("lsw-bars-graph-bar.mounted");
    
  },
  unmount() {
    this.$trace("lsw-bars-graph-bar.unmounted");
  }
});
// @code.end: LswBarsGraphBar API

// @vuebundler[Lsw_framework_components][149]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-bars-graph/components/lsw-bars-graph-bar/lsw-bars-graph-bar.css

// @vuebundler[Lsw_framework_components][150]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-bars-graph/lsw-bars-graph.html

// @vuebundler[Lsw_framework_components][150]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-bars-graph/lsw-bars-graph.js
// @code.start: LswBarsGraph API | @$section: Vue.js (v2) Components  LswBarsGraph component
Vue.component("LswBarsGraph", {
  template: `<div class="lsw_bars_graph">
    <div class="titulo_de_item" v-if="typeof currentPropertyView !== 'undefined'">
        {{ "Segn " + currentSample.numerables[currentPropertyView] + ":" }}
    </div>
    <template v-if="typeof currentPropertyView === 'undefined'">
        <div class=""
            v-for="row, rowIndex in currentSample.output"
            v-bind:key="'bar_graph_row_' + rowIndex">
            <div class="titulo_de_item">
                <b>#{{ rowIndex + 1 }}: </b>
                <span>{{ row.id }}</span>
            </div>
            <div class="bars_of_item"
                v-for="value, valueIndex in row.values"
                v-bind:key="'row_' + rowIndex + '_subvalue_' + valueIndex">
                <div class="" style="min-height: 1px;"></div>
                <lsw-bars-graph-bar 
                    :color="getColor(currentSample.numerables[valueIndex], value)"
                    :value="value"
                    :text="\$lsw.utils.capitalize(currentSample.numerables[valueIndex]) + ': ' + value + '%'"
                    :on-click="() => selectPropertyView(valueIndex)" />
            </div>
        </div>
    </template>
    <template v-else>
        <div class=""
            v-for="row, rowIndex in currentSample.output"
            v-bind:key="'bar_graph_row_' + rowIndex">
            <div class="" style="min-height: 1px;"></div>
            <lsw-bars-graph-bar
                :color="getColor(currentSample.numerables[currentPropertyView], row.values[currentPropertyView])"
                :value="row.values[currentPropertyView]"
                :text="row.values[currentPropertyView] + '%: ' + row.id"
                :on-click="() => selectPropertyView(currentPropertyView)"
            />
            <!--
             -->
        </div>
    </template>
</div>`,
  props: {
    sample: {
      type: Object,
      required: true,
    },
    keys: {
      type: Array,
      required: true,
    },
    negativeKeys: {
      type: Array,
      default: () => [],
    },
    propId: {
      type: String,
      default: () => false,
    },
    propOptions: {
      type: String,
      default: () => "$options",
    },
  },
  data() {
    this.$trace("lsw-bars-graph.data");
    const currentSample = LswBarsGraph.toSample(this.sample, this.propId, this.keys, this.propOptions);
    return {
      currentPropertyView: undefined,
      currentSample,
    };
  },
  methods: {
    selectPropertyView(propIndex) {
      this.$trace("lsw-bars-graph.methods.selectPropertyView");
      const isSame = this.currentPropertyView === propIndex;
      this.currentPropertyView = isSame ? undefined : propIndex;
    },
    selectPropertyViewByName(propId) {
      this.$trace("lsw-bars-graph.methods.selectPropertyView");
      const propIndex = this.keys.indexOf(propId);
      if(propIndex === -1) return;
      const isSame = this.currentPropertyView === propIndex;
      this.currentPropertyView = isSame ? undefined : propIndex;
    },
    getColor(propId, value) {
      this.$trace("lsw-bars-graph.methods.getColor");
      const polaridad = this.negativeKeys.indexOf(propId) === -1;
      if(polaridad) {
        if (value <= 20) {
          return "red" ;
        } else if (value <= 40) {
          return "violet" ;
        } else if (value <= 60) {
          return "white";
        } else if (value <= 80) {
          return "yellow" ;
        } else {
          return "lime" ;
        }
      } else {
        if (value <= 20) {
          return "lime" ;
        } else if (value <= 40) {
          return "yellow" ;
        } else if (value <= 60) {
          return "white" ;
        } else if (value <= 80) {
          return "violet";
        } else {
          return "red" ;
        }
      }
    }
  },
  mounted() {
    this.$trace("lsw-bars-graph.mounted");

  },
  unmount() {
    this.$trace("lsw-bars-graph.unmounted");
  }
});
// @code.end: LswBarsGraph API

// @vuebundler[Lsw_framework_components][150]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-bars-graph/lsw-bars-graph.css

// @vuebundler[Lsw_framework_components][151]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-bars-graph/lsw-bars-graph.api.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswBarsGraph'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswBarsGraph'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  const LswBarsGraph = class {

    static toSample(list, idField = false, numerableFields = [], optionsField = "$options") {
      let output = [];
      Iterating_list:
      for(let indexItem=0; indexItem<list.length; indexItem++) {
        const item = list[indexItem];
        const formatted = {
          id: idField ? item[idField] : indexItem,
          values: [],
        };
        for(let indexNumerables=0; indexNumerables<numerableFields.length; indexNumerables++) {
          const numerableId = numerableFields[indexNumerables];
          let value = 0;
          if(numerableId in item) {
            value = item[numerableId];
          }
          formatted.values.push(value);
        }
        output.push(formatted);
      }
      return {
        id: idField,
        numerables: numerableFields,
        options: optionsField,
        output,
      };
    }

  };

  return LswBarsGraph;

});

// @vuebundler[Lsw_framework_components][152]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-notes/lsw-notes.html

// @vuebundler[Lsw_framework_components][152]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-notes/lsw-notes.js
// @code.start: LswNotes API | @$section: Vue.js (v2) Components  Lsw SchemaBasedForm API  LswNotes component
Vue.component("LswNotes", {
  template: `<div class="lsw_notes pad_0 pad_top_0">
    <template v-if="allNotes && allNotes.length">
        <div class="lista_articulos"
            v-if="isLoaded">
            <template v-for="articulo, articuloIndex in allNotes">
                <div class="item_articulo"
                    :class="{activated: openedNotes.indexOf(articulo.id) !== -1}"
                    v-on:click="() => toggleNote(articulo.id)"
                    v-bind:key="'articulo_de_wiki_' + articulo.id">
                    <div class="flex_column">
                        <div class="flex_1 flex_row">
                            <div class="celda_articulo flex_1">
                                {{ articuloIndex + 1 }}.
                            </div>
                            <div class="celda_articulo flex_100">
                                {{ articulo.tiene_titulo }}
                            </div>
                            <div class="celda_articulo flex_1">
                                {{ articulo.tiene_contenido?.length }}B
                            </div>
                        </div>
                        <div class="flex_1"
                            class="articulo_detalles"
                            v-if="openedNotes.indexOf(articulo.id) !== -1">
                            <div class="celda_articulo">
                                {{ articulo.tiene_contenido }}
                            </div>
                        </div>
                    </div>
                </div>
            </template>

        </div>
    </template>
    <div class="pad_1"
        v-else>No hay notas actualmente.</div>
</div>`,
  props: {
    autoDialog: {
      type: Boolean,
      default: () => false,
    },
    onAutoDialogSuccess: {
      type: Function,
      default: () => {},
    },
    onAutoDialogError: {
      type: Function,
      default: () => {},
    }
  },
  data() {
    this.$trace("lsw-notes.data");
    return {
      isLoaded: false,
      allNotes: false,
      openedNotes: [],
      currentError: this.error,
    };
  },
  methods: {
    setError(error = undefined) {
      this.$trace("lsw-notes.methods.setError");
      this.currentError = error;
    },
    toggleNote(noteId) {
      this.$trace("lsw-notes.methods.toggleNote");
      const pos = this.openedNotes.indexOf(noteId);
      if(pos === -1) {
        this.openedNotes.push(noteId);
      } else {
        this.openedNotes.splice(pos, 1);
      }
    },
    async loadNotes() {
      this.$trace("lsw-notes.methods.loadNotes");
      // *@TODO: seleccionar e importar notes.
      this.isLoaded = false;
      const notes = await this.$lsw.database.selectMany("Nota");
      const notesSorted = notes.sort((n1, n2) => {
        const d1 = LswTimer.utils.getDateFromMomentoText(n1.tiene_fecha);
        const d2 = LswTimer.utils.getDateFromMomentoText(n2.tiene_fecha);
        if(d1 >= d2) return -1;
        return 1;
      });
      this.allNotes = notesSorted;
      this.isLoaded = true;
    },
    async openAddNoteDialog() {
      this.$trace("lsw-notes.methods.openAddNoteDialog");
      const response = await LswUtils.openAddNoteDialog();
      if(typeof response !== "object") {
        return;
      }
      await this.$lsw.database.insert("Nota", response);
      await this.loadNotes();
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-notes.mounted");
      await this.loadNotes();
      if(this.autoDialog) {
        this.openAddNoteDialog();
      }
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswNotes API

// @vuebundler[Lsw_framework_components][152]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-notes/lsw-notes.css

// @vuebundler[Lsw_framework_components][153]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-configurations-page/lsw-configurations-page.html

// @vuebundler[Lsw_framework_components][153]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-configurations-page/lsw-configurations-page.js
// @code.start: LswConfigurationsPage API | @$section: Vue.js (v2) Components  LswConfigurationsPage component
// Change this component at your convenience:
Vue.component("LswConfigurationsPage", {
  template: `<div class="configurations_page">
    <div class="pad_bottom_1">
        <div class="typical_title_1 flex_row centered">
            <div class="flex_100"> Configuraciones:</div>
            <div class="flex_1">
                <button class="visibility_hidden supermini">ok</button>
            </div>
        </div>
    </div>
    <div class="flex_row centered">
        <div class="flex_1 nowrap pad_right_2"> Seccin: </div>
        <select class="flex_100" v-model="selectedSection">
            <option value="datos">Base de datos</option>
            <option value="preferencias">Preferencias de usuario</option>
            <option value="documentacion">Documentacin</option>
        </select>
    </div>
    <div class="section margin_top_1" v-if="selectedSection === 'documentacion'">
        <h3>Configuraciones  Documentacin</h3>
        <hr />
        <h4>Links de documentacin</h4>
        <div class="margin_top_1">
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startCodeReference">Ir a referencia del cdigo</button>
                </div>
                <div class="flex_100 explanation_text">te lleva a la documentacin oficial del cdigo de <a href="https://github.com/allnulled/lsw-one">allnulled@lsw-one</a>.</div>
            </div>
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startGithubHomepage">Ir a repositorio del cdigo</button>
                </div>
                <div class="flex_100 explanation_text">te lleva a la pgina oficial del proyecto de <a href="https://github.com/allnulled/lsw-one">allnulled@lsw-one</a>.</div>
            </div>
        </div>
        <hr />
    </div>
    <div class="section margin_top_1" v-if="selectedSection === 'datos'">
        <h3>Configuraciones  Base de datos</h3>
        <hr />
        <h4>Importar/Exportar base de datos</h4>
        <div class="margin_top_1">
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startExportarAJson">Exportar a JSON</button>
                </div>
                <div class="flex_100 explanation_text">muestra una copia del estado actual en un JSON.</div>
            </div>
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startExportarAJsonFile">Exportar a fichero</button>
                </div>
                <div class="flex_100 explanation_text">descarga una copia del estado actual en un fichero JSON.</div>
            </div>
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startImportarDeJson">Importar de JSON</button>
                </div>
                <div class="flex_100 explanation_text">permite pasar un JSON para insertar masivamente en el estado actual.</div>
            </div>
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startImportarDeJsonFile">Importar de fichero</button>
                </div>
                <div class="flex_100 explanation_text">permite importar un JSON para <u style="color:rgb(63, 12, 12); text-shadow: 0 0 1px white;">insertar masivamente</u> en el estado actual.</div>
            </div>
        </div>
        <hr />
        <h4>Gestionar copia de seguridad de base de datos</h4>
        <div class="margin_top_1">
            <div class="flex_row centered">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="saveBackup">Guardar estado</button>
                </div>
                <div class="flex_100 explanation_text">sobreescribir la copia de seguridad anterior con el estado actual de datos.</div>
            </div>
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="loadBackup">Inyectar copia</button>
                </div>
                <div class="flex_100 explanation_text">insertar los datos de la copia de seguridad anterior en el estado actual de datos.</div>
            </div>
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="showCurrentBackup">Ver copia actual</button>
                </div>
                <div class="flex_100 explanation_text">mostrar en un dilogo el JSON de la copia de seguridad actual.</div>
            </div>
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini danger_button margin_right_1" v-on:click="deleteCurrentBackup">Eliminar copia actual</button>
                </div>
                <div class="flex_100 explanation_text">eliminar la copia de seguridad actual.</div>
            </div>
        </div>
        <hr />
        <h4>Resetear base de datos</h4>
        <div class="margin_top_1">
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1 danger_button" v-on:click="startResetearBaseDeDatos">Resetear</button>
                </div>
                <div class="flex_100 explanation_text">eliminar la base de datos por completo, forzando que al reiniciar se vuelva a crear.</div>
            </div>
        </div>
    </div>
    <div class="section margin_top_1" v-if="selectedSection === 'preferencias'">
        <h3>Configuraciones  Preferencias de usuario</h3>
        <hr />
        <h4>Preferencias de usuario simples</h4>
        <div class="margin_top_1">
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startConfigureUserIdentity">Configurar</button>
                </div>
                <div class="flex_100 explanation_text">permite cambiar el nombre de usuario y otros datos simples (1 lnea) como el mensaje debajo del reloj.</div>
            </div>
        </div>
        <hr />
        <h4>Debugger</h4>
        <div class="margin_top_1">
            <div class="flex_row centered margin_top_1" v-if="isDebuggerLoaded">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="toggleTracer">
                        <span v-if="\$lsw.logger.\$options.active">Activado</span>
                        <span v-else="\$lsw.logger.\$options.active">Desactivado</span>
                    </button>
                </div>
                <div class="flex_100 explanation_text">permite activar/desactivar las trazas de la aplicacin.</div>
            </div>
        </div>
        <hr />
        <h4>Fondos de pantalla</h4>
        <div class="margin_top_1">
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startConfigureBackgrounds">Configurar</button>
                </div>
                <div class="flex_100 explanation_text">permite introducir nuevas URLs para fondos.</div>
            </div>
        </div>
        <hr />
        <h4>Automensajes de fondo</h4>
        <div class="margin_top_1">
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startConfigureAutomessages">Configurar</button>
                </div>
                <div class="flex_100 explanation_text">permite cambiar los automensajes que se muestran en el home.</div>
            </div>
        </div>
        <hr />
        <h4>Acciones randomizables</h4>
        <div class="margin_top_1">
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startConfigureRandomizables">Configurar</button>
                </div>
                <div class="flex_100 explanation_text">permite cambiar las acciones randomizables de la agenda.</div>
            </div>
        </div>
        <hr />
        <h4>Mensaje rutinario</h4>
        <div class="margin_top_1">
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startConfigureRutiner">Configurar</button>
                </div>
                <div class="flex_100 explanation_text">permite cambiar el mensaje que se muestra al cabo de aprox. 2 minutos de estar navegando.</div>
            </div>
        </div>
        <hr />
        <h4>Frecuencia de mensaje rutinario</h4>
        <div class="margin_top_1">
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startConfigureRutinerTimeout">Configurar</button>
                </div>
                <div class="flex_100 explanation_text">permite cambiar la frecuencia (2 minutos, dce) del <b>mensaje rutinario</b>.</div>
            </div>
        </div>
        <hr />
        <h4>Evento de arranque</h4>
        <div class="margin_top_1">
            <div class="flex_row centered margin_top_1">
                <div class="flex_1">
                    <button class="supermini margin_right_1" v-on:click="startConfigureBoot">Configurar</button>
                </div>
                <div class="flex_100 explanation_text">permite inyectar JavaScript al entrar en la app.</div>
            </div>
        </div>
        <hr />
        
    </div>
</div>`,
  props: {
    
  },
  data() {
    this.$trace("lsw-configurations-page.data", arguments);
    return {
      isDebuggerLoaded: true,
      selectedSection: "preferencias", // puede ser: datos, preferencias
      currentBackup: false,
    };
  },
  methods: {
    async showCurrentBackup() {
      this.$trace("lsw-configurations-page.methods.toggleCurrentBackup");
      const currentBackup = await this.$lsw.backuper.getLastBackup();
      this.$lsw.dialogs.open({
        title: "Ver copia de seguridad actual",
        template: `
          <div class="pad_1">
            <div class="flex_row pad_bottom_1">
              <div class="flex_100"></div>
              <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="copySource"> Copiar</button>
              </div>
              <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="downloadSource"> Descargar</button>
              </div>
            </div>
            <pre class="codeblock">{{ source }}</pre>
          </div>
        `,
        factory: {
          data: {
            source: JSON.stringify(currentBackup, null, 2),
          },
          methods: {
            copySource() {
              this.$trace("lsw-configurations-page.methods.copySource");
              this.$window.navigator.clipboard.writeText(this.source);
              this.$lsw.toasts.send({
                title: "Texto copiado",
                text: "El texto fue copiado al portapapeles."
              });
            },
            downloadSource() {
              this.$trace("lsw-configurations-page.methods.downloadSource");
              LswUtils.downloadFile("lsw-backup.json", this.source);
            },
          }
        }
      });
    },
    async deleteCurrentBackup() {
      this.$trace("lsw-configurations-page.methods.deleteCurrentBackup");
      const confirmation = await this.$lsw.dialogs.open({
        title: "Eliminar copia de seguridad actual",
        template: `
          <div class="pad_top_1 pad_left_1">
            <div>Seguro que quieres eliminar la copia de seguridad actual?</div>
            <hr />
            <div class="flex_row centered text_align_right">
              <div class="flex_100"></div>
              <div class="flex_1 pad_left_1">
                <button class="supermini danger_button" v-on:click="accept">Eliminar igual</button>
              </div>
              <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: {},
      });
      if(confirmation !== true) {
        return;
      }
      return this.$lsw.backuper.deleteLastBackup();
    },
    selectSection(seccion) {
      this.$trace("lsw-configurations-page.methods.selectSection");
      this.selectSection = seccion;
    },
    async startExportarAJsonFile() {
      this.$trace("lsw-configurations-page.methods.startExportarAJsonFile");
      const allData = await LswDatabase.exportDatabase("lsw_default_database");
      const minuteUid = LswTimer.utils.formatDatestringFromDate(new Date()).replace(/\/|-|:|\.| /g, ".");
      this.$lsw.utils.downloadFile(`lsw_default_database.${minuteUid}.json`, JSON.stringify(allData, null, 2));
    },
    async startExportarAJson() {
      this.$trace("lsw-configurations-page.methods.startExportarAJson");
      const allData = await LswDatabase.exportDatabase("lsw_default_database");
      this.$dialogs.open({
        title: "Exportar base de datos a JSON",
        template: `<div class="pad_1">
          <div class="flex_row centered">
            <div class="flex_100 pad_1">Exportacin a JSON:</div>
            <div class="flex_1 pad_1">
              <button class="supermini nowrap" v-on:click="copyToClipboard">Copiar</button>
            </div>
          </div>
          <textarea class="width_100" style="min-height: 220px;" v-model="jsonData" disabled="true"></textarea>
          <hr />
          <div class="pad_1 text_align_right">
            <button class="supermini" v-on:click="cancel">Cancelar</button>
          </div>
        </div>`,
        factory: {
          data: {
            jsonData: JSON.stringify(allData, null, 2),
          },
          methods: {
            copyToClipboard() {
              this.$trace("Dialogo.exportar_a_json.methods.copyToClipboard");
              this.$window.navigator.clipboard.writeText(this.jsonData);
              this.$lsw.toasts.send({
                title: "Texto copiado!",
                text: "El texto fue copiado con xito."
              });
            }
          }
        }
      })
    },
    async startImportarDeJsonFile() {
      this.$trace("lsw-configurations-page.methods.startImportarDeJsonFile");
      // @TODO: importar texto de un JSON file con un input type file y tol royo.
      let data = await LswUtils.askForFileText();
      try {
        console.log(data);
        data = JSON.parse(data);
      } catch (error) {
        return this.$lsw.toasts.showError(error);
      }
      const confirmacion = await this.$lsw.dialogs.open({
        title: "Importacin de JSON",
        template: `
          <div class="pad_1">
            <div>Ests a punto de importar los siguientes datos a la base de datos:</div>
            <pre style="max-height: 400px; overflow: scroll; font-size: 10px;">{{ datos }}</pre>
            <div class="flex_row">
              <div class="flex_100"></div>
              <div class="flex_1 pad_left_1 pad_top_1">
                <button class="danger_button supermini" v-on:click="accept">Importar igualmente</button>
              </div>
              <div class="flex_1 pad_left_1 pad_top_1">
                <button class="supermini" v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: {
          data: {
            datos: data,
          }
        }
      });
      if(confirmacion <= 0) {
        return false;
      }
      // @OK:
      return;
      await LswDatabase.importToDatabase("lsw_default_database", data);
      return this.$lsw.toasts.send({
        title: " Importacin completada",
        text: `La importacin fue un xito.`
      });
    },
    async startImportarDeJson() {
      this.$trace("lsw-configurations-page.methods.startImportarDeJson");
      const resultado = await this.$dialogs.open({
        title: "Importar JSON a base de datos",
        template: `<div class="pad_1">
          <div class="flex_row centered">
            <div class="flex_100 pad_1">Importacin de JSON:</div>
          </div>
          <textarea class="width_100" style="min-height: 220px;" v-model="value.importation" placeholder="Por ejemplo: {NombreDeStore:[{},{},{}]}"></textarea>
          <hr />
          <div class="pad_1 text_align_right">
            <button class="supermini danger_button" v-on:click="sendForm">Importar</button>
            <button class="supermini" v-on:click="cancel">Cancelar</button>
          </div>
        </div>`,
        factory: {
          data: {
            value: {
              importation: "",
            }
          },
          methods: {
            sendForm() {
              this.$trace("Dialogo.importar_de_json.methods.sendForm");
              this.validateImportation();
              return this.accept();
            },
            validateImportation() {
              this.$trace("Dialogo.importar_de_json.methods.validateImportation");
              try {
                JSON.parse(this.value.importation);
              } catch (error) {
                this.$lsw.toasts.send({
                  title: " Error al parsear JSON",
                  text: `La importacin se interrumpi.`
                });
                throw error;
              }
            }
          }
        }
      });
      if(typeof resultado !== "object") {
        return false;
      }
      let data = undefined;
      try {
        data = JSON.parse(resultado.importation);
      } catch (error) {
        return this.$lsw.toasts.send({
          title: " Error al parsear JSON",
          text: `La importacin fall.`
        });
      }
      // @OK:
      await LswDatabase.importToDatabase("lsw_default_database", data);
      return this.$lsw.toasts.send({
        title: " Importacin completada",
        text: `La importacin fue un xito.`
      });
    },
    async startResetearBaseDeDatos() {
      this.$trace("lsw-configurations-page.methods.startResetearBaseDeDatos");
      const confirmation = await this.$dialogs.open({
        title: "Resetear la base de datos",
        template: `<div class="pad_1">
          <div class="text_align_center" style="min-height: 90px;">
            <div class="pad_1 font_weight_bold">CUIDADO!</div>
            <div class="pad_1 pad_top_0">Seguro que quieres resetear la base de datos?</div>
            <div class="pad_1 pad_top_0">Considera que perders todos los datos.</div>
          </div>
          <hr />
          <div class="pad_1 text_align_right">
            <button class="supermini danger_button" v-on:click="accept">Aceptar</button>
            <button class="supermini" v-on:click="cancel">Cancelar</button>
          </div>
        </div>`,
        factory: {
          data: { value: {} },
          methods: {}
        }
      });
      if(typeof confirmation !== "object") return;
      await this.$lsw.database.close();
      await LswDatabase.deleteDatabase("lsw_default_database");
      this.$window.location.reload();
    },
    startConfigureBackgrounds() {
      this.$trace("lsw-configurations-page.methods.startConfigureBackgrounds");
      this.$dialogs.open({
        title: "Configurar fondos de pantalla",
        template: `<lsw-filesystem-explorer :absolute-layout="true" opened-by="/kernel/settings/backgrounds.env" />`,
      });
    },
    startConfigureAutomessages() {
      this.$trace("lsw-configurations-page.methods.startConfigureAutomessages");
      this.$dialogs.open({
        title: "Configurar automensajes",
        template: `<lsw-filesystem-explorer :absolute-layout="true" opened-by="/kernel/settings/automessages.env" />`,
      });
    },
    startConfigureRutiner() {
      this.$trace("lsw-configurations-page.methods.startConfigureRutiner");
      this.$dialogs.open({
        title: "Configurar mensaje rutinario",
        template: `<lsw-filesystem-explorer :absolute-layout="true" opened-by="/kernel/settings/rutiner.md" />`,
      });
    },
    startConfigureRutinerTimeout() {
      this.$trace("lsw-configurations-page.methods.startConfigureRutinerTimeout");
      return LswDomIrruptor.configurarRutinerTimeout();
    },
    startConfigureRandomizables() {
      this.$trace("lsw-configurations-page.methods.startConfigureRandomizables");
      this.$dialogs.open({
        title: "Configurar acciones randomizables",
        template: `<lsw-filesystem-explorer :absolute-layout="true" opened-by="/kernel/settings/randomizables.env" />`,
      });
    },
    startConfigureUserIdentity() {
      this.$trace("lsw-configurations-page.methods.startConfigureUserIdentity");
      this.$dialogs.open({
        title: "Configurar identidad de usuario",
        template: `<lsw-filesystem-explorer :absolute-layout="true" opened-by="/kernel/settings/user.env" />`,
      });
    },
    startCodeReference() {
      this.$trace("lsw-configurations-page.methods.startCodeReference");
      this.$window.open("https://allnulled.github.io/lsw-one/reference", "_blank");
    },
    startGithubHomepage() {
      this.$trace("lsw-configurations-page.methods.startGithubHomepage");
      this.$window.open("https://github.com/allnulled/lsw-one", "_blank");
    },
    async saveBackup() {
      this.$trace("lsw-configurations-page.methods.saveBackup");
      const allData = await LswDatabase.exportDatabase("lsw_default_database");
      await this.$lsw.backuper.setLastBackup(allData);
      await this.$lsw.toasts.send({
        title: "Backup exportado",
        text: "La copia de seguridad fue exportada con el estado actual con xito."
      });
    },
    async loadBackup() {
      this.$trace("lsw-configurations-page.methods.loadBackup");
      // @TODO: esta funcin no est terminada.
      const respuesta = await this.$lsw.dialogs.open({
        title: "Importar copia de seguridad",
        template: `
          <div class="pad_1">
            <div class="">Seguro que quieres importar la actual copia de seguridad?</div>
            <hr />
            <div class="text_align_right">
              <button class="supermini danger_button" v-on:click="() => accept(true)">S, importar</button>
              <button class="supermini" v-on:click="close">Cancelar</button>
            </div>
          </div>
        `
      });
      if(respuesta !== true) return;
      const backupData = await this.$lsw.backuper.getLastBackup();
      try {
        for(const tableId in backupData) {
          const tableRows = backupData[tableId];
          await this.$lsw.database.insertMany(tableId, tableRows);
        }
      } catch (error) {
        console.log(error);
        return await this.$lsw.toasts.send({
          title: "Backup con errores",
          text: "La copia de seguridad tuvo errores de importacin: " + error.message,
          background: "rgba(212, 74, 74, 0.62)",
        });
      }
      await this.$lsw.toasts.send({
        title: "Backup importado",
        text: "La copia de seguridad fue importada al estado actual con xito."
      });
    },
    toggleTracer() {
      this.$trace("lsw-configurations-page.methods.toggleTracer");
      this.isDebuggerLoaded = false;
      const isActive = this.$lsw.logger.$options.active;
      if(isActive) {
        this.$lsw.logger.deactivate();
      } else {
        this.$lsw.logger.activate();
      }
      setTimeout(() => {
        this.isDebuggerLoaded = true;
      }, 1);
    },
    startConfigureBoot() {
      this.$trace("lsw-configurations-page.methods.startConfigureBoot");
      this.$dialogs.open({
        title: "Configurar arranque",
        template: `<lsw-filesystem-explorer :absolute-layout="true" opened-by="/kernel/boot.js" />`,
      });
    }
  },
  mounted() {
    this.$trace("lsw-configurations-page.mounter");
    
  },
});
// @code.end: LswConfigurationsPage API

// @vuebundler[Lsw_framework_components][153]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-configurations-page/lsw-configurations-page.css

// @vuebundler[Lsw_framework_components][154]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-automensajes-viewer/lsw-automensajes-viewer.html

// @vuebundler[Lsw_framework_components][154]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-automensajes-viewer/lsw-automensajes-viewer.js
// @code.start: LswAutomensajesViewer API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswAutomensajesViewer API  LswAutomensajesViewer component
Vue.component("LswAutomensajesViewer", {
  template: `<div class="lsw_automensajes_viewer">
    <div class="app_main_topbar">
        <div class="flex_row centered">
            <div class="flex_1 pad_right_1 pad_left_1" v-if="isMounted">
                <lsw-apps-viewer-button :viewer="\$refs.appPanel" />
            </div>
            <div class="flex_100 automensaje_block position_relative" :style="{ fontSize: selectedFontsize + 'px' }" v-on:click="refreshAutomessaging">
                <div class="position_absolute_fixed flex_row centered">
                    <div class="flex_1" v-if="selectedAutomensaje">
                        {{ selectedAutomensaje }}
                    </div>
                    <div class="flex_1" v-else>
                        Eslganes para ti aqu.
                    </div>
                </div>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="main_topbar_button rounded superbig" id="the_picas_button" v-on:click="procedureForPicas">{{ simboloActual }}</button>
            </div>
        </div>
    </div>
    <div class="app_main_panel pad_1">
        <lsw-apps-viewer-panel ref="appPanel" />
    </div>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-automensajes-viewer.data");
    return {
      isMounted: false,
      automensajes: [],
      selectedAutomensaje: undefined,
      selectedFontsize: 12,
      automessagingId: undefined,
      automessagingSeconds: 0,
      simboloActual: "", // "", // "",
      // simboloActual: LswRandomizer.getRandomItem("".split("")),
      
      // simboloActual: LswRandomizer.getRandomItem("".split("")),
    };
  },
  methods: {
    procedureForPicas() {
      this.$trace("LswAutomensajesViewer.methods.procedureForPicas", []);
      this.selectApplication("despues");
    },
    async loadAutomensajes() {
      this.$trace("LswAutomensajesViewer.methods.loadAutomensajes", []);
      const automensajes = await this.$lsw.fs.evaluateAsDotenvFileOrReturn("/kernel/settings/automessages.env", {});
      this.automensajes = Object.keys(automensajes);
    },
    async sendAutomessage() {
      this.$trace("LswAutomensajesViewer.methods.sendAutomessage", []);
      const availableAutomensajes = this.automensajes.filter(a => {
        if(typeof this.selectedAutomensaje !== "string") return true;
        return a !== this.selectedAutomensaje;
      });
      const nextAutomensaje = LswRandomizer.getRandomItem(availableAutomensajes);
      const nextFontsize = this.calculateFontsize(nextAutomensaje);
      this.selectedFontsize = nextFontsize;
      this.selectedAutomensaje = nextAutomensaje;
    },
    calculateFontsize(text) {
      this.$trace("LswAutomensajesViewer.methods.calculateFontsize", []);
      const textLength = text.length;
      if(textLength < 10) {
        return 18;
      } else if(textLength < 20) {
        return 16;
      } else if(textLength < 30) {
        return 14;
      } else {
        return 12;
      }
    },
    async startAutomessaging() {
      this.$trace("LswAutomensajesViewer.methods.startAutomessaging", []);
      await this.loadAutomensajes();
      await this.sendAutomessage();
      await this.continueAutomessaging();
    },
    async continueAutomessaging() {
      this.$trace("LswAutomensajesViewer.methods.continueAutomessaging", []);
      clearTimeout(this.automessagingId);
      this.automessagingSeconds = LswRandomizer.getRandomIntegerBetween(60,120);
      this.automessagingId = setTimeout(() => this.sendAutomessage(), this.automessagingSeconds * 1000);
    },
    stopAutomessaging() {
      this.$trace("LswAutomensajesViewer.methods.stopAutomessaging");
      clearTimeout(this.automessagingId);
    },
    async refreshAutomessaging() {
      this.$trace("LswAutomensajesViewer.methods.refreshAutomessaging", []);
      this.stopAutomessaging();
      this.startAutomessaging();
      this.$window.changeBackgroundImage();
    },
    goToDesktop() {
      this.$trace("LswAutomensajesViewer.methods.goToDesktop", []);
      this.$lsw.windows.hide();
      this.$refs.appPanel.selectApplication("none");
    },
    selectApplication(application) {
      this.$trace("LswAutomensajesViewer.methods.selectApplication", []);
      this.$refs.appPanel.selectApplication(application);
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-automensajes-viewer.mounted");
      this.$window.$automensajesUi = this;
      // this.startAutomessaging();
      this.isMounted = true;
      this.refreshAutomessaging();
    } catch(error) {
      console.log(error);
    }
  },
  unmount() {
    this.$trace("lsw-automensajes-viewer.unmount");
    this.stopAutomessaging();
  }
});
// @code.end: LswAutomensajesViewer API

// @vuebundler[Lsw_framework_components][154]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-automensajes-viewer/lsw-automensajes-viewer.css

// @vuebundler[Lsw_framework_components][155]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-apps-viewer-button/lsw-apps-viewer-button.html

// @vuebundler[Lsw_framework_components][155]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-apps-viewer-button/lsw-apps-viewer-button.js
// @code.start: LswAppsViewerButton API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswAppsViewerButton API  LswAppsViewerButton component
Vue.component("LswAppsViewerButton", {
  template: `<div class="lsw_apps_viewer_button">
    <div class="lsw_apps_button">
        <button
            class="main_topbar_button rounded superbig"
            v-on:click="() => selectApplication('homepage')">
            
        </button>
    </div>

</div>`,
  props: {
    viewer: {
      type: Object,
      required: true,
    }
  },
  data() {
    this.$trace("lsw-apps-viewer-button.data");
    return {
      isOpened: false,
    };
  },
  methods: {
    toggleOpen() {
      this.$trace("lsw-apps-viewer-button.methods.toggleOpen");
      this.isOpened = !this.isOpened;
    },
    open() {
      this.$trace("lsw-apps-viewer-button.methods.open");
      this.isOpened = true;
    },
    close() {
      this.$trace("lsw-apps-viewer-button.methods.close");
      this.isOpened = false;
    },
    selectApplication(application) {
      this.$trace("lsw-apps-viewer-button.methods.selectApplication");
      console.log(this.viewer);
      const isSame = this.viewer.selectedApplication === application;
      if(!isSame) {
        this.viewer.selectApplication(application);
      } else {
        // @NOTHING.
      }
      this.close();
    },
    openHomepage() {
      this.selectApplication("homepage");
    },
    openEventTracker() {
      this.selectApplication("event-tracker");
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-apps-viewer-button.mounted");
    } catch (error) {
      console.log(error);
    }
  },
});
// @code.end: LswAppsViewerButton API

// @vuebundler[Lsw_framework_components][155]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-apps-viewer-button/lsw-apps-viewer-button.css

// @vuebundler[Lsw_framework_components][156]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-apps-viewer-panel/lsw-apps-viewer-panel.html

// @vuebundler[Lsw_framework_components][156]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-apps-viewer-panel/lsw-apps-viewer-panel.js
// @code.start: LswAppsViewerPanel API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswAppsViewer API  LswAppsViewerPanel component
Vue.component("LswAppsViewerPanel", {
  template: `<div class="lsw_apps_viewer_panel">
    <div class="desktop_free_area">
        <div class=""
            v-if="selectedApplication !== 'none'">
            <div class="desktop_free_available_area">
                <div class="pad_1"
                    v-if="selectedApplication === 'antes'"
                    v-bind:key="'app_acciones_anteriores'">
                    <div class="pad_bottom_1">
                        <div class="typical_title_1 flex_row centered">
                            <div class="flex_100">  Antes de las {{ horaActual }}:</div>
                            <div class="flex_1">
                                <button class="supermini"
                                    v-on:click="() => selectApplication('calendario')"></button>
                            </div>
                            <div class="flex_1 pad_left_1">
                                <button class="supermini"
                                    v-on:click="() => selectApplication('despues')"></button>
                            </div>
                        </div>
                    </div>
                    <lsw-agenda-acciones-viewer :initial-date="new Date()"
                        sorter-strategy="antes" />
                    <div v-else
                        class="pad_top_0 pad_bottom_0">No hay acciones anteriores.</div>
                </div>
                <div class="pad_1"
                    v-if="selectedApplication === 'despues'"
                    v-bind:key="'app_acciones_posteriores'">
                    <div class="pad_bottom_1">
                        <div class="typical_title_1 flex_row centered">
                            <div class="flex_100">  Despus de las {{ horaActual }}:</div>
                            <div class="flex_1">
                                <button class="supermini"
                                    v-on:click="() => selectApplication('calendario')"></button>
                            </div>
                            <div class="flex_1 pad_left_1">
                                <button class="supermini"
                                    v-on:click="() => selectApplication('antes')"></button>
                            </div>
                        </div>
                    </div>
                    <lsw-agenda-acciones-viewer :initial-date="new Date()"
                        sorter-strategy="despues" />
                </div>

                <div class="pad_1"
                    v-if="selectedApplication === 'calendario'"
                    v-bind:key="'app_calendario'">
                    <div class="pad_top_0 pad_bottom_1">
                        <div class="typical_title_1">
                            <div class="flex_row centered">
                                <div class="flex_100"> Calendario:</div>
                                <div class="flex_1 pad_left_1">
                                    <button class="supermini"
                                        v-on:click="() => \$refs.agenda.selectConductometria()"></button>
                                </div>
                                <div class="flex_1 pad_left_1">
                                    <button class="supermini"
                                        v-on:click="() => \$refs.agenda.selectCalendario()"></button>
                                </div>
                                <div class="flex_1 pad_left_1">
                                    <button class="supermini"
                                        v-on:click="() => selectApplication('antes')"></button>
                                </div>
                                <div class="flex_1 pad_left_1">
                                    <button class="supermini"
                                        v-on:click="() => selectApplication('despues')"></button>
                                </div>
                            </div>
                        </div>
                        <lsw-agenda ref="agenda" />
                    </div>
                </div>

                <div class="pad_1"
                    v-if="selectedApplication === 'notas'"
                    v-bind:key="'app_nueva_nota'">
                    <div class="pad_top_0 pad_bottom_0">
                        <lsw-spontaneous-table-nota />
                    </div>
                </div>

                <div class="pad_1"
                    v-if="selectedApplication === 'enciclopedia'"
                    v-bind:key="'enciclopedia'">
                    <div class="pad_top_0 pad_bottom_0">
                        <lsw-wiki />
                    </div>
                </div>

                <div class="pad_1"
                    v-if="selectedApplication === 'base de datos'"
                    v-bind:key="'base de datos'">
                    <div class="pad_top_0 pad_bottom_0">
                        <lsw-database-explorer />
                    </div>
                </div>

                <div class="pad_0"
                    v-if="selectedApplication === 'sistema de ficheros'"
                    v-bind:key="'sistema de ficheros'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-filesystem-explorer :absolute-layout="false" />
                    </div>
                </div>

                <div class="pad_0"
                    v-if="selectedApplication === 'automensajes'"
                    v-bind:key="'automensajes'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-spontaneous-table-automensajes />
                    </div>
                </div>

                <div class="pad_0"
                    v-if="selectedApplication === 'recordatorios'"
                    v-bind:key="'recordatorios'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-spontaneous-table-recordatorios />
                    </div>
                </div>

                <div class="pad_0"
                    v-if="selectedApplication === 'listas'"
                    v-bind:key="'listas'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-spontaneous-table-lista />

                    </div>
                </div>

                <div class="pad_0"
                    v-if="selectedApplication === 'nuevo recordatorio'"
                    v-bind:key="'nuevo recordatorio'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-spontaneous-form-recordatorio />
                    </div>
                </div>

                <div class="pad_0"
                    v-if="selectedApplication === 'nueva lista'"
                    v-bind:key="'nueva lista'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-spontaneous-form-lista />
                    </div>
                </div>

                <div class="pad_0"
                    v-if="selectedApplication === 'nueva nota'"
                    v-bind:key="'nueva nota'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-spontaneous-form-nota :on-submitted="() => selectApplication('notas')" />
                    </div>
                </div>

                <div class="pad_0"
                    v-if="selectedApplication === 'nuevo articulo'"
                    v-bind:key="'nuevo articulo'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-spontaneous-form-articulo />
                    </div>
                </div>

                <div class="pad_0"
                    v-if="selectedApplication === 'nueva accion'"
                    v-bind:key="'nuevo accion'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-spontaneous-form-accion />
                    </div>
                </div>

                <div class="pad_1"
                    v-if="selectedApplication === 'configuraciones'"
                    v-bind:key="'configuraciones'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-configurations-page />
                    </div>
                </div>

                <div class="pad_1"
                    v-if="selectedApplication === 'js inspector'"
                    v-bind:key="'js_inspector'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-js-inspector />
                    </div>
                </div>

                <div class="pad_1"
                    v-if="selectedApplication === 'homepage'"
                    v-bind:key="'homepage'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-homepage :apps-viewer="this" />
                    </div>
                </div>

                <div class="pad_1"
                    v-if="selectedApplication === 'binarios'"
                    v-bind:key="'binarios'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-bin-directory directory="/kernel/bin" />
                    </div>
                </div>

                <div class="pad_1"
                    v-if="selectedApplication === 'event-tracker'"
                    v-bind:key="'event-tracker'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-event-tracker />
                    </div>
                </div>

                <div class="pad_1"
                    v-if="selectedApplication === 'nueva feature'"
                    v-bind:key="'nueva-feature'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-nueva-feature />
                    </div>
                </div>

                <div class="pad_1"
                    v-if="selectedApplication === 'app tests'"
                    v-bind:key="'app tests'">
                    <div class="position_relative pad_top_0 pad_bottom_0">
                        <lsw-tests-page />
                    </div>
                </div>
                

            </div>
        </div>
    </div><!-- End of Free Desktop Area -->
</div>`,
  props: {

  },
  data() {
    this.$trace("lsw-apps-viewer-panel.data");
    return {
      isOpened: false,
      selectedApplication: 'despues', // 'antes', 'despues'
      accionesAntes: false,
      accionesDespues: false,
      horaActual: LswTimer.utils.fromDateToHour(new Date()),
    };
  },
  methods: {
    selectApplication(section) {
      this.$trace("lsw-apps-viewer-panel.methods.selectApplication");
      Gestiona_casos_excepcionales: {
        if(section === "js consola") {
          // Activamos eruda en lugar de cambiar de pestaa:
          return LswConsoleHooker.toggleConsole();
        }
      }
      this.$lsw.dialogs.minimizeAll();
      this.selectedApplication = section;
      Cargas_segun_aplicacion: {
        if (["antes", "despues"].indexOf(section) !== -1) {
          this.loadAcciones();
        } else {
          this.$forceUpdate(true);
        }
      }
    },
    getSimboloEstadoAccion(estado) {
      return (estado === "completada") ? "" :
        (estado === "pendiente") ? "" :
          (estado === "fallida") ? "" : "";
    },
    async loadAcciones() {
      this.$trace("lsw-apps-viewer-panel.methods.loadAcciones");
      const output = await this.$lsw.database.selectMany("Accion");
      const estaHora = (() => {
        const d = new Date();
        d.setMinutes(0);
        return d;
      })();
      const accionesAntes = [];
      const accionesDespues = [];
      output.forEach(accion => {
        try {
          const dateAccion = LswTimer.utils.fromDatestringToDate(accion.tiene_inicio);
          const areSameDay = LswTimer.utils.areSameDayDates(dateAccion, estaHora);
          if (!areSameDay) return;
          if (dateAccion >= estaHora) {
            accionesDespues.push(accion);
          } else {
            accionesAntes.push(accion);
          }
        } catch (error) {
          console.log(error);
        }
      });
      this.accionesAntes = accionesAntes.sort(this.getSorterOfAccionesAntes());
      this.accionesDespues = accionesDespues.sort(this.getSorterOfAccionesDespues());
      this.$forceUpdate(true);
    },
    getSorterOfAccionesAntes() {
      this.$trace("lsw-apps-viewer-panel.methods.getSorterOfAccionesAntes");
      return function (accion1, accion2) {
        let inicio1, inicio2;
        try {
          inicio1 = LswTimer.utils.fromDatestringToDate(accion1.tiene_inicio);
        } catch (error) {
          return 1;
        }
        try {
          inicio2 = LswTimer.utils.fromDatestringToDate(accion2.tiene_inicio);
        } catch (error) {
          return -1;
        }
        const firstIsLower = inicio1 < inicio2;
        return firstIsLower ? 1 : -1;
      };
    },
    getSorterOfAccionesDespues() {
      this.$trace("lsw-apps-viewer-panel.methods.getSorterOfAccionesDespues");
      return function (accion1, accion2) {
        let inicio1, inicio2;
        try {
          inicio1 = LswTimer.utils.fromDatestringToDate(accion1.tiene_inicio);
        } catch (error) {
          return 1;
        }
        try {
          inicio2 = LswTimer.utils.fromDatestringToDate(accion2.tiene_inicio);
        } catch (error) {
          return -1;
        }
        const firstIsLower = inicio1 <= inicio2;
        return firstIsLower ? -1 : 1;
      };
    },
    async alternarEstado(accion) {
      this.$trace("lsw-apps-viewer-panel.methods.alternarEstado");
      const nextEstado = accion.tiene_estado === "pendiente" ? "completada" :
        accion.tiene_estado === "completada" ? "fallida" : "pendiente";
      await this.$lsw.database.update("Accion", accion.id, {
        ...accion,
        tiene_estado: nextEstado
      });
      await this.loadAcciones();
    },
    async reloadPanel() {
      this.$trace("lsw-apps-viewer-panel.methods.reloadPanel");
      await this.loadAcciones();
    },
    async openNotaUploader() {
      this.$trace("lsw-apps-viewer-panel.methods.openNotaUploader", arguments);
      const response = await LswUtils.openAddNoteDialog();
      if (typeof response !== "object") {
        return;
      }
      await this.$lsw.database.insert("Nota", response);
    },
    openWikiExplorer() {
      this.$trace("lsw-windows-main-tab.methods.openWikiExplorer", arguments);
      this.$dialogs.open({
        id: "wiki-explorer-" + LswRandomizer.getRandomString(5),
        title: "Wiki explorer",
        template: `<div class="pad_2"><lsw-wiki /></div>`,
      });
    },
    async openArticuloUploader() {
      this.$trace("lsw-windows-main-tab.methods.openArticuloUploader", arguments);
      const response = await LswUtils.openAddArticuloDialog();
      if (typeof response !== "object") {
        return;
      }
      await this.$lsw.database.insert("Articulo", response);
    },
    updateHoraActual() {
      this.$trace("lsw-windows-main-tab.methods.updateHoraActual", arguments);
      this.horaActual = LswTimer.utils.fromDateToHour(new Date());
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-apps-viewer-panel.mounted");
      await this.loadAcciones();
    } catch (error) {
      console.log(error);
    }
  },
});
// @code.end: LswAppsViewerPanel API

// @vuebundler[Lsw_framework_components][156]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-apps-viewer-panel/lsw-apps-viewer-panel.css

// @vuebundler[Lsw_framework_components][157]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-languages/protolang/protolang.js
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root) {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = function(statements) { return deundefinify(statements); },
        peg$c1 = function(st) { return Object.assign({}, st, { $len: text().length, $loc: reduceLoc(location()) })},
        peg$c2 = "inc",
        peg$c3 = peg$literalExpectation("inc", false),
        peg$c4 = function(path) { return { type: "inc", path }; },
        peg$c5 = "def",
        peg$c6 = peg$literalExpectation("def", false),
        peg$c7 = function(names) { return { type: "def", names }; },
        peg$c8 = "fun",
        peg$c9 = peg$literalExpectation("fun", false),
        peg$c10 = function(header, code) {
              return { type: "fun", ...header, code };
          },
        peg$c11 = function(name) { return { name, params: undefined } },
        peg$c12 = ":",
        peg$c13 = peg$literalExpectation(":", false),
        peg$c14 = function(name, params) {
            return { name, params }
          },
        peg$c15 = "{",
        peg$c16 = peg$literalExpectation("{", false),
        peg$c17 = "}",
        peg$c18 = peg$literalExpectation("}", false),
        peg$c19 = function() { return "" },
        peg$c20 = function(code) { return code; },
        peg$c21 = "rel",
        peg$c22 = peg$literalExpectation("rel", false),
        peg$c23 = function(name, rest) {
              return { type: "rel", name, ...(separateEffectsTriggers(rest)) };
          },
        peg$c24 = function(arg) {
            return arg;
          },
        peg$c25 = ">",
        peg$c26 = peg$literalExpectation(">", false),
        peg$c27 = "*",
        peg$c28 = peg$literalExpectation("*", false),
        peg$c29 = function(concept, value, args) { return { type: "effect", prototipo: "multiplicador", consecuencia: concept, ratio: value, argumentos: args || undefined }; },
        peg$c30 = function(args) { return args },
        peg$c31 = ">>",
        peg$c32 = peg$literalExpectation(">>", false),
        peg$c33 = function(expr) { return expr; },
        peg$c34 = function(name, concepts, args) { return { type: "trigger by prototype", prototipo: name, conceptos: concepts || undefined, argumentos: args || undefined }; },
        peg$c35 = function(first, rest) { return [first].concat(rest || [])},
        peg$c36 = ",",
        peg$c37 = peg$literalExpectation(",", false),
        peg$c38 = function(concept) { return concept },
        peg$c39 = "<",
        peg$c40 = peg$literalExpectation("<", false),
        peg$c41 = function() { return { type: "trigger by code", codigo: text().trim() } },
        peg$c42 = function(first, rest) {
              return [first].concat(rest.map(r => r[1]));
          },
        peg$c43 = peg$anyExpectation(),
        peg$c44 = function() { return text().trim() },
        peg$c45 = /^[0-9]/,
        peg$c46 = peg$classExpectation([["0", "9"]], false, false),
        peg$c47 = ".",
        peg$c48 = peg$literalExpectation(".", false),
        peg$c49 = function() { return text(); },
        peg$c50 = peg$otherExpectation("Codeblock"),
        peg$c51 = function() {},
        peg$c52 = function() { return text() },
        peg$c53 = " ",
        peg$c54 = peg$literalExpectation(" ", false),
        peg$c55 = "\t",
        peg$c56 = peg$literalExpectation("\t", false),
        peg$c57 = "\r\n",
        peg$c58 = peg$literalExpectation("\r\n", false),
        peg$c59 = "\r",
        peg$c60 = peg$literalExpectation("\r", false),
        peg$c61 = "\n",
        peg$c62 = peg$literalExpectation("\n", false),

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parsestart() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseMAYSPACES();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsestatement();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsestatement();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMAYSPACES();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsestatement() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseincStatement();
      if (s1 === peg$FAILED) {
        s1 = peg$parsedefStatement();
        if (s1 === peg$FAILED) {
          s1 = peg$parsefunStatement();
          if (s1 === peg$FAILED) {
            s1 = peg$parserelStatement();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseincStatement() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseMAYSPACES();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c2) {
          s2 = peg$c2;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c3); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMINSPACE();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseUNTIL_NEWLINE();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse___();
              if (s5 === peg$FAILED) {
                s5 = peg$parseEOF();
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c4(s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsedefStatement() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseMAYSPACES();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c5) {
          s2 = peg$c5;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c6); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMINSPACE();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifierList();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c7(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsefunStatement() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseMAYSPACES();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c8) {
          s2 = peg$c8;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c9); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMINSPACE();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsefunHeader();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseMAYSPACES();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsefunContent();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c10(s4, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsefunHeader() {
      var s0;

      s0 = peg$parsefunHeaderWithParameters();
      if (s0 === peg$FAILED) {
        s0 = peg$parsefunHeaderWithoutParameters();
      }

      return s0;
    }

    function peg$parsefunHeaderWithoutParameters() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c11(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsefunHeaderWithParameters() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseMAYSPACES();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c12;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseMAYSPACES();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseidentifierList();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c14(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsefunContent() {
      var s0;

      s0 = peg$parsefunContentEmpty();
      if (s0 === peg$FAILED) {
        s0 = peg$parsefunContentFilled();
      }

      return s0;
    }

    function peg$parsefunContentEmpty() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c15;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c16); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseMAYSPACES();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 125) {
            s3 = peg$c17;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c19();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsefunContentFilled() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c15;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c16); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecodeBlock();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse___();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s4 = peg$c17;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c18); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c20(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parserelStatement() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseMAYSPACES();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c21) {
          s2 = peg$c21;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c22); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMINSPACE();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifier();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseMAYSPACES();
              if (s5 !== peg$FAILED) {
                s6 = peg$parserelArguments();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c23(s4, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parserelArguments() {
      var s0, s1;

      s0 = [];
      s1 = peg$parserelArgument();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parserelArgument();
        }
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parserelArgument() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseMAYSPACES();
      if (s1 !== peg$FAILED) {
        s2 = peg$parserelEffect();
        if (s2 === peg$FAILED) {
          s2 = peg$parserelTrigger();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c24(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parserelEffect() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parseMAYSPACES();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s2 = peg$c25;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMAYSPACES();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifier();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseMAYSPACES();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 42) {
                  s6 = peg$c27;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c28); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseMAYSPACES();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsenumber();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseextraArguments();
                      if (s9 === peg$FAILED) {
                        s9 = null;
                      }
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c29(s4, s8, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseextraArguments() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseSTARTING_COMMA();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseUNTIL_NEWLINE();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c30(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parserelTrigger() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseMAYSPACES();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c31) {
          s2 = peg$c31;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c32); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMAYSPACES();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsetriggerExpr();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c33(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsetriggerExpr() {
      var s0;

      s0 = peg$parsetriggerExprByCall();
      if (s0 === peg$FAILED) {
        s0 = peg$parsetriggerExprByCode();
      }

      return s0;
    }

    function peg$parsetriggerExprByCall() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseMAYSPACES();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c12;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseMAYSPACES();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseList_of_concepts();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseSTARTING_COMMA();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseUNTIL_NEWLINE();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse___();
                    if (s8 === peg$FAILED) {
                      s8 = peg$parseEOF();
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c34(s1, s5, s7);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseList_of_concepts() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseIsolated_concept();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseMore_isolated_concepts();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c35(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMore_isolated_concepts() {
      var s0, s1;

      s0 = [];
      s1 = peg$parseAnother_isolated_concept();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parseAnother_isolated_concept();
        }
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAnother_isolated_concept() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseMAYSPACES();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c36;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseIsolated_concept();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c38(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseIsolated_concept() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseMAYSPACES();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 60) {
          s2 = peg$c39;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c40); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseidentifier();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s4 = peg$c25;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c26); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c38(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsetriggerExprByCode() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseUNTIL_NEWLINE();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse___();
        if (s2 === peg$FAILED) {
          s2 = peg$parseEOF();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c41();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseidentifierList() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseSTARTING_COMMA();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseidentifier();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseSTARTING_COMMA();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseidentifier();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c42(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseidentifier() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parse___();
      if (s4 === peg$FAILED) {
        s4 = peg$parseFORBIDDEN_TOKENS_FOR_IDENTIFIERS();
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c43); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse___();
          if (s4 === peg$FAILED) {
            s4 = peg$parseFORBIDDEN_TOKENS_FOR_IDENTIFIERS();
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c43); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c44();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsenumber() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c45.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c46); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c46); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c47;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c46); }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c45.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c46); }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c49();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsecodeBlock() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$currPos;
      s5 = peg$parse___();
      if (s5 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 125) {
          s6 = peg$c17;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        if (s6 !== peg$FAILED) {
          s5 = [s5, s6];
          s4 = s5;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parse___();
        if (s4 === peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c43); }
          }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$currPos;
          s5 = peg$parse___();
          if (s5 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s6 = peg$c17;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c18); }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse___();
            if (s4 === peg$FAILED) {
              if (input.length > peg$currPos) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c43); }
              }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c44();
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }

      return s0;
    }

    function peg$parseSTARTING_COMMA() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseMAYSPACES();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c36;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMAYSPACES();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c51();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFORBIDDEN_TOKENS_FOR_IDENTIFIERS() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 44) {
        s0 = peg$c36;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c37); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 42) {
          s0 = peg$c27;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s0 = peg$c12;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s0 = peg$c15;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s0 = peg$c25;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c26); }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseUNTIL_NEWLINE() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parse___();
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c43); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse___();
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c43); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c52();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseMAYSPACES() {
      var s0, s1;

      s0 = [];
      s1 = peg$parse_();
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parse_();
      }

      return s0;
    }

    function peg$parseMAYSPACE() {
      var s0;

      s0 = peg$parse_();
      if (s0 === peg$FAILED) {
        s0 = null;
      }

      return s0;
    }

    function peg$parseMINSPACE() {
      var s0, s1;

      s0 = [];
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_();
        }
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseEOF() {
      var s0, s1;

      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c43); }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = void 0;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parse_() {
      var s0;

      s0 = peg$parse__();
      if (s0 === peg$FAILED) {
        s0 = peg$parse___();
      }

      return s0;
    }

    function peg$parse__() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 32) {
        s0 = peg$c53;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c54); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 9) {
          s0 = peg$c55;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c56); }
        }
      }

      return s0;
    }

    function peg$parse___() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c57) {
        s0 = peg$c57;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c58); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c59;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c60); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c61;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c62); }
          }
        }
      }

      return s0;
    }


      const reduceLoc = function(loc) {
        return `${loc.start.offset}-${loc.end.offset}|${loc.start.line}:${loc.start.column}-${loc.end.line}:${loc.end.column}`;
      };
      const deundefinify = function(data) {
        return data;
        return JSON.parse(JSON.stringify(data));
      };
      const separateEffectsTriggers = function(all) {
        const effects = [];
        const triggers = [];
        for(let index=0; index<all.length; index++) {
          const item = all[index];
          if(item.type.startsWith("effect")) {
            effects.push(item);
          } else if(item.type.startsWith("trigger")) {
            triggers.push(item);
          }
        }
        return { effects, triggers };
      };


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  root.ProtolangParser = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})(globalThis);

// @vuebundler[Lsw_framework_components][158]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-protolang-editor/lsw-protolang-editor.html

// @vuebundler[Lsw_framework_components][158]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-protolang-editor/lsw-protolang-editor.js
// @code.start: LswProtolangEditor API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswProtolangEditor API  LswProtolangEditor component
Vue.component("LswProtolangEditor", {
  template: `<div class="lsw_protolang_editor">
    <div class="pad_1">
        <div class="flex_row">
            <div class="flex_100"></div>
            <div class="flex_1 pad_right_1">
                <button class="danger_button" v-on:click="validateCode"></button>
            </div>
            <div class="flex_1">
                <button class="danger_button" v-on:click="evaluateCode"></button>
            </div>
        </div>
        <div class="pad_top_1">
            <textarea class="nowrap" v-model="contents" :placeholder="placeholder" style="height: 380px;" spellcheck="false" />
        </div>
        <template v-if="error">
            <lsw-syntax-error-viewer :error="error" :on-clear-error="() => error = false" />
        </template>
        <pre v-if="result" style="font-size:10px;">{{ result }}</pre>
    </div>
</div>`,
  props: {
    initialContents: {
      type: String,
      default: () => ""
    }
  },
  data() {
    this.$trace("lsw-protolang-editor.data");
    return {
      error: false,
      result: false,
      contents: this.initialContents,
      placeholder: `rel correr
  > cardio * 1
  > musculacin * 0.3
  >> propagador de correr * []`
    };
  },
  methods: {
    setError(error) {
      this.$trace("lsw-protolang-editor.methods.setError");
      this.error = error;
    },
    setResult(result) {
      this.$trace("lsw-protolang-editor.methods.setResult");
      this.result = result;
    },
    async validateCode() {
      this.$trace("lsw-protolang-editor.methods.validateCode");
      try {
        const value = this.contents;
        const js = await Protolang.codify(value);
        console.log(js);
        this.setError(false);
        this.setResult(js);
      } catch (error) {
        this.setError(error);
      }
    },
    async evaluateCode() {
      this.$trace("lsw-protolang-editor.methods.evaluateCode");
      try {
        const value = this.contents;
        const js = await Protolang.codify(value);
        console.log(js);
        this.setError(false);
      } catch (error) {
        this.setError(error);
      }
    },
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-protolang-editor.mounted");
      this.$window.protolangEditor = this;
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswProtolangEditor API

// @vuebundler[Lsw_framework_components][158]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-protolang-editor/lsw-protolang-editor.css

// @vuebundler[Lsw_framework_components][159]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-accion/lsw-spontaneous-form-accion.html

// @vuebundler[Lsw_framework_components][159]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-accion/lsw-spontaneous-form-accion.js
// @code.start: LswSpontaneousFormAccion API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswSpontaneousFormAccion API  LswSpontaneousFormAccion component
Vue.component("LswSpontaneousFormAccion", {
  template: `<div class="lsw_spontaneos_form_accion">
    Form of accion
</div>`,
  props: {},
  data() {
    this.$trace("lsw-spontaneous-form-accion.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-spontaneous-form-accion.mounted");
      // 
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswSpontaneousFormAccion API

// @vuebundler[Lsw_framework_components][159]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-accion/lsw-spontaneous-form-accion.css

// @vuebundler[Lsw_framework_components][160]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-articulo/lsw-spontaneous-form-articulo.html

// @vuebundler[Lsw_framework_components][160]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-articulo/lsw-spontaneous-form-articulo.js
// @code.start: LswSpontaneousFormArticulo API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswSpontaneousFormArticulo API  LswSpontaneousFormAccion component
Vue.component("LswSpontaneousFormArticulo", {
  template: `<div class="lsw_spontaneos_form_nota pad_1">
    <h4 class="margin_bottom_1px"> Aadir artculo:</h4>
    <div class="flex_row">
        <div class="flex_100">
            <lsw-fast-datetime-control class="margin_bottom_1px" mode="datetime" :on-change-date="v => tiene_fecha = LswTimer.utils.fromDateToDatestring(v, false)" :initial-value="new Date()"/>
            <input class="width_100 margin_bottom_1px margin_top_0" type="text" placeholder="Ttulo de artculo" v-model="tiene_titulo" />
            <textarea class="width_100 margin_top_0 margin_bottom_1px" placeholder="Contenido de artculo." style="min-height: 230px;" v-model="tiene_contenido" spellcheck="false" ref="tiene_contenido" spellcheck="false"></textarea>
            <textarea class="width_100 margin_bottom_0 margin_top_0" placeholder="categora 1; categoria 2" v-model="tiene_categorias" spellcheck="false"></textarea>
            <textarea class="width_100 margin_bottom_0 margin_top_1" placeholder="tag 1; tag 2; tag 3;" v-model="tiene_tags" spellcheck="false"></textarea>
            <div class="flex_row centered">
                <div class="flex_1">
                    Garanta: 
                </div>
                <div class="flex_100">
                    <select class="width_100 margin_bottom_1 margin_top_1" v-model="tiene_garantia">
                        <option v-for="valor, clave in opcionesGarantia" value="valor">{{ clave }}</option>
                    </select>
                </div>
            </div>
        </div>
        <div class="flex_1 pad_left_1">
            <button class="mini" style="height: 100%; min-width: 30px;" v-on:click="addArticulo"></button>
        </div>
    </div>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-spontaneous-form-articulo.data");
    return {
      ...this.getInitialContents(),
      opcionesGarantia: {
        "ns/nc": "ns/nc",
        "muy inestable": "muy inestable",
        "inestable": "inestable",
        "estable": "estable",
        "muy estable": "muy estable",
        "popular": "popular",
      }
    };
  },
  methods: {
    getInitialContents() {
      return Object.assign({}, {
        tiene_titulo: "",
        tiene_contenido: "",
        tiene_categorias: "",
        tiene_garantia: "ns/ns",
        tiene_fecha: LswTimer.utils.fromDateToDatestring(new Date()),
        tiene_tags: "",
      });
    },
    async addArticulo() {
      this.$trace("lsw-spontaneous-form-articulo.methods.addArticulo");
      try {
      await this.$lsw.database.insert("Articulo", {
        tiene_titulo: this.tiene_titulo,
        tiene_contenido: this.tiene_contenido,
        tiene_categorias: this.tiene_categorias,
        tiene_garantia: this.tiene_garantia,
        tiene_fecha: this.tiene_fecha,
        tiene_tags: this.tiene_tags,
      });
      this.$lsw.toasts.send({
        title: "Artculo insertado",
        message: "El artculo fue insertado con xito."
      });
      Object.assign(this, this.getInitialContents());
    } catch (error) {
      console.log(error);
      this.$lsw.toasts.send({
        title: "Error al insertar artculo",
        message: "Hubo errores al insertar el artculo: " + error.message
      });
    }
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-spontaneous-form-articulo.mounted");
      // 
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswSpontaneousFormArticulo API

// @vuebundler[Lsw_framework_components][160]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-articulo/lsw-spontaneous-form-articulo.css

// @vuebundler[Lsw_framework_components][161]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-lista/lsw-spontaneous-form-lista.html

// @vuebundler[Lsw_framework_components][161]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-lista/lsw-spontaneous-form-lista.js
// @code.start: LswSpontaneousFormLista API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswSpontaneousFormLista API  LswSpontaneousFormAccion component
Vue.component("LswSpontaneousFormLista", {
  template: `<div class="lsw_spontaneos_form_lista">
    Form of lista
</div>`,
  props: {},
  data() {
    this.$trace("lsw-spontaneous-form-lista.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-spontaneous-form-lista.mounted");
      // 
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswSpontaneousFormLista API

// @vuebundler[Lsw_framework_components][161]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-lista/lsw-spontaneous-form-lista.css

// @vuebundler[Lsw_framework_components][162]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-nota/lsw-spontaneous-form-nota.html

// @vuebundler[Lsw_framework_components][162]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-nota/lsw-spontaneous-form-nota.js
// @code.start: LswSpontaneousFormNota API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswSpontaneousFormNota API  LswSpontaneousFormAccion component
Vue.component("LswSpontaneousFormNota", {
  template: `<div class="lsw_spontaneos_form_nota pad_1">
    <h4 class="margin_bottom_1px"> Aadir nota:</h4>
    <div class="flex_row">
        <div class="flex_100">
            <lsw-fast-datetime-control class="margin_bottom_1px" mode="datetime" :on-change-date="v => tiene_fecha = LswTimer.utils.fromDateToDatestring(v, false)" :initial-value="new Date()"/>
            <input class="width_100 margin_bottom_1px margin_top_0" type="text" placeholder="Ttulo de nota" v-model="tiene_titulo" />
            <textarea class="width_100 margin_top_0 margin_bottom_1px" placeholder="Contenido de nota." style="min-height: 230px;" v-model="tiene_contenido" spellcheck="false" ref="tiene_contenido"></textarea>
            <textarea class="width_100 margin_bottom_0 margin_top_0" placeholder="categora 1; categoria 2" v-model="tiene_categorias" spellcheck="false"></textarea>
        </div>
        <div class="flex_1 pad_left_1">
            <button class="mini" style="height: 100%; min-width: 30px;" v-on:click="addNota"></button>
        </div>
    </div>
</div>`,
  props: {
    onSubmitted: {
      type: Function,
      default: () => {}
    }
  },
  data() {
    this.$trace("lsw-spontaneous-form-nota.data");
    return this.getInitialData({

    });
  },
  methods: {
    getInitialData(extendedWith = {}) {
      return Object.assign({
        tiene_titulo: "",
        tiene_contenido: "",
        tiene_fecha: LswTimer.utils.fromDateToDatestring(new Date()),
        tiene_categorias: "",
      }, extendedWith);
    },
    async addNota() {
      this.$trace("lsw-spontaneous-form-nota.methods.addNota");
      const nota = {
        tiene_titulo: this.tiene_titulo,
        tiene_contenido: this.tiene_contenido,
        tiene_fecha: this.tiene_fecha,
        tiene_categorias: this.tiene_categorias,
      };
      if(nota.tiene_titulo.trim() === "") {
        const superaLimite = nota.tiene_contenido.length > 30;
        nota.tiene_titulo = nota.tiene_contenido.substr(0,30) + (superaLimite ? "..." : "");
      }
      const notaId = await this.$lsw.database.insert("Nota", nota);
      Object.assign(this, this.getInitialData());
      this.$forceUpdate(true);
      this.focusContenidos();
      if(this.onSubmitted) {
        this.onSubmitted(notaId, nota, this);
      }
    },
    focusContenidos() {
      this.$trace("lsw-spontaneous-form-nota.methods.addNota");
      // this.$refs.tiene_contenido.focus();
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-spontaneous-form-nota.mounted");
      // 
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswSpontaneousFormNota API

// @vuebundler[Lsw_framework_components][162]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-nota/lsw-spontaneous-form-nota.css

// @vuebundler[Lsw_framework_components][163]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-recordatorio/lsw-spontaneous-form-recordatorio.html

// @vuebundler[Lsw_framework_components][163]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-recordatorio/lsw-spontaneous-form-recordatorio.js
// @code.start: LswSpontaneousFormRecordatorio API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswSpontaneousFormRecordatorio API  LswSpontaneousFormAccion component
Vue.component("LswSpontaneousFormRecordatorio", {
  template: `<div class="lsw_spontaneos_form_recordatorio">
    Form of recordatorio
</div>`,
  props: {},
  data() {
    this.$trace("lsw-spontaneous-form-recordatorio.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-spontaneous-form-recordatorio.mounted");
      // 
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswSpontaneousFormRecordatorio API

// @vuebundler[Lsw_framework_components][163]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-form-recordatorio/lsw-spontaneous-form-recordatorio.css

// @vuebundler[Lsw_framework_components][164]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-accion/lsw-spontaneous-table-accion.html

// @vuebundler[Lsw_framework_components][164]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-accion/lsw-spontaneous-table-accion.js
// @code.start: LswSpontaneousTableAccion API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswSpontaneousTableAccion API  LswSpontaneousTableAccion component
Vue.component("LswSpontaneousTableAccion", {
  template: `<div class="lsw_spontaneos_table_accion">
    Table of accion
</div>`,
  props: {},
  data() {
    this.$trace("lsw-spontaneous-table-accion.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-spontaneous-table-accion.mounted");
      // 
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswSpontaneousTableAccion API

// @vuebundler[Lsw_framework_components][164]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-accion/lsw-spontaneous-table-accion.css

// @vuebundler[Lsw_framework_components][165]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-articulo/lsw-spontaneous-table-articulo.html

// @vuebundler[Lsw_framework_components][165]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-articulo/lsw-spontaneous-table-articulo.js
// @code.start: LswSpontaneousTableArticulo API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswSpontaneousTableArticulo API  LswSpontaneousTableArticulo component
Vue.component("LswSpontaneousTableArticulo", {
  template: `<div class="lsw_spontaneos_table_articulo">
    Table of articulo
</div>`,
  props: {},
  data() {
    this.$trace("lsw-spontaneous-table-articulo.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-spontaneous-table-articulo.mounted");
      // 
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswSpontaneousTableArticulo API

// @vuebundler[Lsw_framework_components][165]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-articulo/lsw-spontaneous-table-articulo.css

// @vuebundler[Lsw_framework_components][166]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-lista/lsw-spontaneous-table-lista.html

// @vuebundler[Lsw_framework_components][166]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-lista/lsw-spontaneous-table-lista.js
// @code.start: LswSpontaneousTableLista API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswSpontaneousTableLista API  LswSpontaneousTableLista component
Vue.component("LswSpontaneousTableLista", {
  template: `<div class="lsw_spontaneos_table_lista">
    Table of lista
</div>`,
  props: {},
  data() {
    this.$trace("lsw-spontaneous-table-lista.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-spontaneous-table-lista.mounted");
      // 
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswSpontaneousTableLista API

// @vuebundler[Lsw_framework_components][166]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-lista/lsw-spontaneous-table-lista.css

// @vuebundler[Lsw_framework_components][167]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-nota/lsw-spontaneous-table-nota.html

// @vuebundler[Lsw_framework_components][167]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-nota/lsw-spontaneous-table-nota.js
// @code.start: LswSpontaneousTableNota API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswSpontaneousTableNota API  LswSpontaneousTableNota component
Vue.component("LswSpontaneousTableNota", {
  template: `<div class="lsw_spontaneos_table_nota">
    <div class="typical_title_1">
        <div class="flex_row centered">
            <div class="flex_100">
                 ltimas notas:
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini"
                    v-on:click="goToAddNota"></button>
            </div>
        </div>
    </div>
    <div class="pad_top_1">
        <div class="flex_row centered">
            <div class="flex_1">
                <button class="supermini"
                    v-on:click="goToFirstPage"></button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini"
                    v-on:click="goToPreviousPage"></button>
            </div>
            <div class="flex_100 text_align_center">
                <span>
                    {{ currentPage+1 }}/{{ totalPages }}
                </span>
                <button class="supermini"
                    v-on:click="loadNotes"></button>
            </div>
            <div class="flex_1">
                <button class="supermini"
                    v-on:click="goToNextPage"></button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini"
                    v-on:click="goToLastPage"></button>
            </div>
        </div>
        <div v-if="currentNotas && currentNotas.length"
            class="pad_bottom_0">
            <div class="pad_top_1"
                v-for="nota, notaIndex in currentNotas"
                v-bind:key="'nota-' + notaIndex">
                <button class="supermini nota_button width_100 text_align_left"
                    v-on:click="toggleNota(nota.id)"
                    :class="{activated: selectedNotas.indexOf(nota.id) !== -1}">
                    <div class="flex_row">
                        <div class="flex_1 smallest_font">#{{ nota.id }}</div>
                        <div class="flex_100 shortable_text nota_title_text pad_left_1 pad_right_1"
                            style="font-size: 11px;">{{ nota.tiene_titulo }}</div>
                        <div class="flex_1"
                            v-if="nota.tiene_estado">
                            <div class="celda_de_estado_de_nota smallest_font"
                                :class="'estado_' + nota.tiene_estado">{{
                                nota.tiene_estado.substr(0,3).toUpperCase() }}
                            </div>
                        </div>
                        <div class="flex_1 pad_left_1 pad_right_1 smallest_font">| {{ nota.tiene_fecha }} |</div>
                        <div class="flex_1 smallest_font text_align_right"
                            style="min-width: 20px;">{{ nota.tiene_contenido?.length }}B</div>
                    </div>
                </button>
                <div class="pad_top_1"
                    v-if="selectedNotas.indexOf(nota.id) !== -1">
                    <div class="position_relative">
                        <div class="texto_markdown"
                            v-html="\$window.marked.parse(nota.tiene_contenido)"
                            style="font-size: 11px;"></div>
                        <div class="position_absolute top_0 right_0 pad_right_1 pad_top_1">
                            <div class="flex_row centered">
                                <button class="supermini margin_right_1"
                                    v-on:click="() => sendNotaToArticulos(nota)">  </button>
                                <button class="supermini margin_right_1"
                                    v-on:click="() => goToDeleteNota(nota)"></button>
                                <button class="supermini"
                                    v-on:click="() => goToEditNota(nota.id)"></button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="flex_row centered pad_top_1">
                <div class="flex_1">
                    <button class="supermini"
                        v-on:click="goToFirstPage"></button>
                </div>
                <div class="flex_1 pad_left_1">
                    <button class="supermini"
                        v-on:click="goToPreviousPage"></button>
                </div>
                <div class="flex_100 text_align_center">
                    <span>
                        {{ currentPage+1 }}/{{ totalPages }}
                    </span>
                    <button class="supermini"
                        v-on:click="loadNotes"></button>

                </div>
                <div class="flex_1">
                    <button class="supermini"
                        v-on:click="goToNextPage"></button>
                </div>
                <div class="flex_1 pad_left_1">
                    <button class="supermini"
                        v-on:click="goToLastPage"></button>
                </div>
            </div>
        </div>
        <div class="pad_top_1"
            v-else-if="currentNotas === false">
            <div>Cargando notas. Un momento, por favor...</div>
        </div>
        <div class="pad_top_1"
            v-else>
            <div>No se encontraron notas.</div>
        </div>
    </div>
</div>`,
  props: {},
  data() {
    this.$trace("lsw-spontaneous-table-nota.data");
    return {
      allNotas: false,
      currentNotas: false,
      currentPage: 0,
      totalPages: 0,
      currentItemsPerPage: 100,
      selectedNotas: [],
    };
  },
  methods: {
    toggleNota(notaId) {
      this.$trace("lsw-spontaneous-table-nota.methods.toggleNota");
      const pos = this.selectedNotas.indexOf(notaId);
      if (pos === -1) {
        this.selectedNotas.push(notaId);
      } else {
        this.selectedNotas.splice(pos, 1);
      }
    },
    goToNextPage() {
      this.$trace("lsw-spontaneous-table-nota.methods.goToNextPage");
      if ((this.currentPage + 1) < this.totalPages) {
        this.currentPage++;
        this.synchronizePagination();
      }
    },
    goToFirstPage() {
      this.$trace("lsw-spontaneous-table-nota.methods.goToFirstPage");
      this.currentPage = 0;
      this.synchronizePagination();
    },
    goToLastPage() {
      this.$trace("lsw-spontaneous-table-nota.methods.goToLastPage");
      this.currentPage = (this.totalPages - 1);
      this.synchronizePagination();
    },
    goToPreviousPage() {
      this.$trace("lsw-spontaneous-table-nota.methods.goToPreviousPage");
      if (this.currentPage > 0) {
        this.currentPage--;
        this.synchronizePagination();
      }
    },
    async loadNotes() {
      this.$trace("lsw-spontaneous-table-nota.methods.loadNotes");
      const allNotas = await this.$lsw.database.selectMany("Nota");
      const sortedNotas = allNotas.sort((n1, n2) => {
        Ordena_por_urgencia: {
          const estado1 = n1.tiene_estado;
          const estado2 = n2.tiene_estado;
          const urgencia1 = estado1 === "urgente" ? 100 : 1;
          const urgencia2 = estado2 === "urgente" ? 100 : 1;
          if (urgencia1 > urgencia2) {
            return -1;
          } else if (urgencia1 < urgencia2) {
            return 1;
          }
        }
        Ordena_por_fecha: {
          const fecha1 = LswTimer.utils.fromDatestringToDate(n1.tiene_fecha);
          const fecha2 = LswTimer.utils.fromDatestringToDate(n2.tiene_fecha);
          if (fecha1 > fecha2) {
            return -1;
          } else if (fecha1 < fecha2) {
            return 1;
          } else {
            return -1;
          }
        }
      });
      this.allNotas = sortedNotas;
      this.synchronizePagination();
    },
    synchronizePagination() {
      this.$trace("lsw-spontaneous-table-nota.methods.synchronizePagination");
      this.totalPages = (() => {
        const totalFullPages = Math.floor(this.allNotas.length / this.currentItemsPerPage);
        const totalResidualPages = this.allNotas.length % this.currentItemsPerPage ? 1 : 0;
        return totalFullPages + totalResidualPages;
      })();
      this.currentNotas = (() => {
        const paginatedNotas = [];
        const minIndex = this.currentPage * this.currentItemsPerPage;
        const maxIndex = (this.currentPage + 1) * this.currentItemsPerPage;
        for (let index = 0; index < this.allNotas.length; index++) {
          const nota = this.allNotas[index];
          const validByMin = index >= minIndex;
          const validByMax = index < maxIndex;
          const isValid = validByMin && validByMax;
          if (isValid) {
            paginatedNotas.push(nota);
          }
        }
        return paginatedNotas;
      })();
    },
    async goToDeleteNota(row) {
      this.$trace("lsw-spontaneous-table-nota.methods.goToDeleteNota");
      const confirmed = await this.$lsw.dialogs.open({
        id: `eliminar-registro-Nota-#${row.id}-${LswRandomizer.getRandomString(5)}`,
        title: "Eliminar registro",
        template: `
          <div>
            <div class="pad_2 font_weight_bold">ATENCIN: </div>
            <div class="pad_2">Seguro que quieres eliminar el registro <b>{{ tableId }}</b> cuyo <b>id</b>#<b>{{ rowId }}</b>?</div>
            <div class="pad_2">
              <pre class="pad_2 codeblock">{{ JSON.stringify(rowValue, null, 2) }}</pre>
            </div>
            <hr class="margin_0" />
            <div class="pad_2 text_align_right">
              <button class="supermini danger_button" v-on:click="() => accept(true)">Eliminar</button>
              <button class="supermini " v-on:click="() => accept(false)">Cancelar</button>
            </div>
          </div>
        `,
        factory: {
          data: {
            tableId: "Nota",
            rowValue: row,
            rowId: row.id
          }
        }
      });
      if (!confirmed) return false;
      await this.$lsw.database.delete("Nota", row.id);
      this.$lsw.toasts.send({
        title: `Registro eliminado`,
        text: `El registro #${this.notaId} de Nota fue eliminado correctamente.`
      });
      this.loadNotes();
    },
    async goToEditNota(notaId) {
      this.$trace("lsw-spontaneous-table-nota.methods.goToEditNota");
      await this.$lsw.dialogs.open({
        title: "Actualizar nota",
        template: `
          <div>
            <lsw-schema-based-form
              :on-submit="(value) => submitCallback(value)"
              :on-delete-row="deleteCallback"
              :model="{
                  connection: $lsw.database,
                  databaseId: 'lsw_default_database',
                  tableId: 'Nota',
                  rowId: notaId,
              }"
            />
          </div>
        `,
        factory: {
          methods: {
            async submitCallback(value) {
              console.log("Submiting form: ", value);
              await this.$lsw.database.update("Nota", notaId, value);
              this.$lsw.toasts.send({
                title: `Nueva actualizacin`,
                text: `El registro #${this.notaId} de Nota fue actualizado correctamente.`
              });
              this.close();
            },
            async deleteCallback() {
              // EL DELETE YA LO HACE DENTRO, POR ALGUNA RAZN, NO ME ACABES DE PREGUNTAR.
              this.close();
            }
          },
          data: {
            notaId,
          }
        }
      });
    },
    goToAddNota() {
      this.$trace("lsw-spontaneous-table-nota.methods.goToEditNota");
      const that = this;
      this.$lsw.dialogs.open({
        title: "Aadir nota",
        template: `<lsw-spontaneous-form-nota :on-submitted="closeAndRefresh" />`,
        factory: {
          methods: {
            closeAndRefresh() {
              this.close();
              that.loadNotes();
            }
          }
        }
      });
    },
    async sendNotaToArticulos(nota) {
      this.$trace("lsw-spontaneous-table-nota.methods.sendNotaToArticulos");
      const respuesta = await this.$lsw.dialogs.open({
        title: "Pasar nota a artculo",
        template: `
          <div class="pad_1">
            <div>Vas a pasar la siguiente nota a artculo: </div>
            <div class="pad_2">
              <pre class="codeblock">{{ nota }}</pre>
            </div>
            <div>Ests seguro?</div>
            <hr/>
            <div class="flex_row centered text_align_right">
              <div class="flex_100"></div>
              <div class="flex_1 pad_right_1">
                <button class="supermini danger_button" v-on:click="accept">Aceptar</button>
              </div>
              <div class="flex_1">
                <button class="supermini" v-on:click="cancel">Cancelar</button>
              </div>
            </div>
          </div>
        `,
        factory: { data: { nota } },
      });
      if(respuesta === -1) return;
      const articuloNew = Object.assign({
        tiene_titulo: '',
        tiene_fecha: '',
        tiene_categorias: '',
        tiene_contenido: '',
        tiene_garantia: '',
        tiene_tags: '',
      }, nota);
      delete articuloNew.id;
      await this.$lsw.database.insert("Articulo", articuloNew);
      await this.$lsw.database.delete("Nota", nota.id);
      this.$lsw.toasts.send({
        title: "Nota a artculo bien",
        text: "La nota ha sido pasada a artculo correctamente",
      });
      this.loadNotes();
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-spontaneous-table-nota.mounted");
      this.loadNotes();
      this.$window.sptt_notas = this;
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswSpontaneousTableNota API

// @vuebundler[Lsw_framework_components][167]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-nota/lsw-spontaneous-table-nota.css

// @vuebundler[Lsw_framework_components][168]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-recordatorio/lsw-spontaneous-table-recordatorio.html

// @vuebundler[Lsw_framework_components][168]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-recordatorio/lsw-spontaneous-table-recordatorio.js
// @code.start: LswSpontaneousTableRecordatorio API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswSpontaneousTableRecordatorio API  LswSpontaneousTableRecordatorio component
Vue.component("LswSpontaneousTableRecordatorio", {
  template: `<div class="lsw_spontaneos_table_recordatorio">
    Table of recordatorio
</div>`,
  props: {},
  data() {
    this.$trace("lsw-spontaneous-table-recordatorio.data");
    return {};
  },
  methods: {},
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-spontaneous-table-recordatorio.mounted");
      // 
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswSpontaneousTableRecordatorio API

// @vuebundler[Lsw_framework_components][168]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-spontaneous-table-recordatorio/lsw-spontaneous-table-recordatorio.css

// @vuebundler[Lsw_framework_components][169]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-fast-datetime-control/lsw-fast-datetime-control.html

// @vuebundler[Lsw_framework_components][169]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-fast-datetime-control/lsw-fast-datetime-control.js
// @code.start: LswFastDateControl API | @$section: Mdulo org.allnulled.lsw-conductometria  Vue.js (v2) Components  LswFastDateControl API  LswFastDateControl component
Vue.component("LswFastDatetimeControl", {
  template: `<div class="lsw_fast_datetime_control">
    <div class="flex_row">
        <div class="flex_1">
            <button :class="{activated: isEditable}" v-on:click="toggleEditable"></button>
        </div>
        <div class="flex_100 pad_left_1">
            <input class="width_100" type="text" v-model="value" />
        </div>
    </div>
    <div class="" v-if="isEditable">
        <lsw-calendario
            :modo="mode"
            :valor-inicial="value"
            :al-cambiar-valor="setValue"
        />
    </div>
</div>`,
  props: {
    mode: {
      type: String,
      default: () => "datetime", // can also be: "date"
    },
    initialValue: {
      type: [Date, String],
      default: null,
    },
    onChangeDate: {
      type: Function,
      default: () => {}
    }
  },
  data() {
    this.$trace("lsw-fast-datetime-control.data");
    return {
      value: this.adaptDate(this.initialValue || new Date()),
      isEditable: false,
    };
  },
  methods: {
    adaptDate(dateInput) {
      this.$trace("lsw-fast-date-control.methods.adaptDate");
      if(dateInput instanceof Date) {
        return LswTimer.utils.fromDateToDatestring(dateInput, this.mode === "date");
      }
      return dateInput;
    },
    getValue() {
      this.$trace("lsw-fast-date-control.methods.getValue");
      return this.value;
    },
    toggleEditable() {
      this.$trace("lsw-fast-datetime-control.methods.toggleEditable");
      this.isEditable = !this.isEditable;
    },
    showEditable() {
      this.$trace("lsw-fast-datetime-control.methods.showEditable");
      this.isEditable = true;
    },
    hideEditable() {
      this.$trace("lsw-fast-datetime-control.methods.hideEditable");
      this.isEditable = false;
    },
    setValue(v) {
      this.$trace("lsw-fast-datetime-control.methods.propagateValue");
      this.value = this.adaptDate(v);
      this.onChangeDate(this.value, this);
      this.hideEditable();
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-fast-datetime-control.mounted");
      // 
    } catch(error) {
      console.log(error);
    }
  }
});
// @code.end: LswFastDateControl API

// @vuebundler[Lsw_framework_components][169]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-fast-datetime-control/lsw-fast-datetime-control.css

// @vuebundler[Lsw_framework_components][170]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-inline-tags-picker/lsw-inline-tags-picker.html

// @vuebundler[Lsw_framework_components][170]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-inline-tags-picker/lsw-inline-tags-picker.js
// @code.start: LswInlineTagsPicker API | @$section: Vue.js (v2) Components  LswInlineTagsPicker component
Vue.component("LswInlineTagsPicker", {
  template: `<div class="lsw_inline_tags_picker">
    <div class="flex_row centered pad_top_1">
        <div class="flex_100">
            <input class="width_100" type="text" v-model="searchText"
                spellcheck="false"
                placeholder="Busca aqu"
                v-on:keyup.enter="digestSearch" />
        </div>
        <div class="flex_1 pad_left_1">
            <button class=""
                v-on:click="digestSearch"></button>
        </div>
    </div>
    <template v-for="row, rowIndex in fromData">
        <div class="display_inline_block pad_top_1 pad_right_1"
            v-bind:key="'row_' + rowIndex">
            <button class="supermini"
                v-on:click="() => selectRow(row)">
                {{ row[field] }}
            </button>
        </div>
    </template>
</div>`,
  props: {
    from: {
      type: Object,
      default: () => []
    },
    field: {
      type: String,
      required: true,
    },
    onChoose: {
      type: [Function, Boolean],
      default: () => false,
    }
  },
  data() {
    this.$trace("lsw-inline-tags-picker.data");
    return {
      fromData: this.from,
      digestedData: [],
      searchText: "",
      selectedRow: false,
    };
  },
  methods: {
    digestSearch() {
      this.$trace("lsw-inline-tags-picker.methods.digestSearch");
      if (this.searchText.trim() === "") {
        this.digestedData = this.fromData;
        return;
      }
      this.digestedData = this.fromData.filter(row => {
        return JSON.stringify(row).toLowerCase().indexOf(this.searchText.toLowerCase()) !== -1;
      });
    },
    selectRow(row) {
      this.$trace("lsw-inline-tags-picker.methods.selectRow");
      this.selectedRow = row;
      if (typeof this.onChoose === "function") {
        this.onChoose(row, this);
      }
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-inline-tags-picker.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswInlineTagsPicker API

// @vuebundler[Lsw_framework_components][170]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-inline-tags-picker/lsw-inline-tags-picker.css

// @vuebundler[Lsw_framework_components][171]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-js-inspector/lsw-js-inspector.api.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswJsInspector'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswJsInspector'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {

  const LswJsInspector = class {

    static async initializeFully() {
      await LswLazyLoads.loadBeautifier();
    }

    static keysFrom(obj) {
      return Object.getOwnPropertyNames(obj);
    }

    static getDefaultOptions() {
      return {
        seen: [],
        level: 0,
        maxLevel: 1,
        maxKeys: 20,
      }
    };

    static $stringifyObject(obj, options, seen) {
      Vue.prototype.$trace("LswJsInspector.$stringifyObject");
      let js = "";
      js += "{";
      let allKeys = undefined;
      let exceedsKeys = undefined;
      Check_max_keys: {
        allKeys = Object.getOwnPropertyNames(obj);
        const maxKeys = options.maxKeys;
        exceedsKeys = allKeys.length > maxKeys;
      }
      let i = -1;
      for (let key in obj) {
        i++;
        if (i !== 0) {
          js += ",";
        }
        const it = obj[key];
        js += JSON.stringify(key);
        js += ":";
        if (exceedsKeys) {
          js += JSON.stringify("::" + typeof (it));
        } else {
          js += this.stringify(it, options, seen);
        }
      }
      js += "}";
      return js;
    }

    static $stringifyArray(arr, options, seen) {
      Vue.prototype.$trace("LswJsInspector.$stringifyArray");
      let js = "";
      js += "[";
      let allKeys = undefined;
      let exceedsKeys = undefined;
      Check_max_keys: {
        allKeys = Object.getOwnPropertyNames(arr);
        const maxKeys = options.maxKeys;
        exceedsKeys = allKeys.length > maxKeys;
      }
      for (let i = 0; i < arr.length; i++) {
        const it = arr[i];
        if (i !== 0) {
          js += ",";
        }
        if (exceedsKeys) {
          js += JSON.stringify("::" + typeof (it));
        } else {
          js += this.stringify(it, options, seen);
        }
      }
      js += "]";
      return js;
    }

    static cloneOptions(options, extender = {}) {
      Vue.prototype.$trace("LswJsInspector.cloneOptions");
      const options2 = Object.assign({}, options, extender);
      const options3 = JSON.parse(JSON.stringify(options2));
      return options3;
    }

    static stringify(cualquierCosa, optionsBrute = {}, seen = []) {
      Vue.prototype.$trace("LswJsInspector.stringify");
      const options = Object.assign({}, this.getDefaultOptions(), optionsBrute);
      const curType = typeof cualquierCosa;
      if (curType === "number") {
        return "" + cualquierCosa;
      }
      if (curType === "string") {
        return JSON.stringify(cualquierCosa);
      }
      if (curType === "boolean") {
        return cualquierCosa ? "true" : "false";
      }
      if (curType === "function") {
        return JSON.stringify("::Function::" + cualquierCosa.toString());
      }
      if (typeof cualquierCosa === "undefined") {
        return "undefined";
      }
      if (curType === "object") {
        if (cualquierCosa === null) {
          return "null";
        }
        if(options.maxLevel >= options.level) {
          return JSON.stringify("::TooDeep");
        }
        if (seen.indexOf(cualquierCosa) !== -1) {
          return JSON.stringify("::Cyclic");
        }
        seen.push(cualquierCosa);
        if (Array.isArray(cualquierCosa)) {
          const nextOptions = this.cloneOptions(options, {
            level: options.level + 1
          });
          return this.$stringifyArray(cualquierCosa, nextOptions, seen);
        } else {
          const nextOptions = this.cloneOptions(options, {
            level: options.level + 1
          });
          return this.$stringifyObject(cualquierCosa, nextOptions, seen);
        }
      }
    }

    static stringifyBeautify(cualquierCosa, options) {
      return JSON.stringify(JSON.parse(this.stringify(cualquierCosa, options)), null, 2);
    }

  };

  return LswJsInspector;

});

// @vuebundler[Lsw_framework_components][172]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-js-inspector/lsw-js-inspector.html

// @vuebundler[Lsw_framework_components][172]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-js-inspector/lsw-js-inspector.js
// @code.start: LswJsInspector API | @$section: Vue.js (v2) Components  Lsw SchemaBasedForm API  LswJsInspector component
(() => {
  const emptyOutput = {};
  const InspectorTab = class {
    constructor(options = {}, inspector) {
      this.inspector = inspector;
      this.uid = LswRandomizer.getRandomString(5);
      this.id = inspector.tabs.length;
      // this.inputSource = "Vue.options.components.LswCalendario.options.template";
      this.inputSource = "Vue";
      this.pathSource = '';
      this.transformerSource = '';
      this.searchSource = '';
      Object.assign(this, options);
    }
  }
  Vue.component("LswJsInspector", {
    template: `<div class="lsw_js_inspector">
    <div class="flex_row centered">
        <div class="flex_100"> JS inspector</div>
        <div class="flex_1">
            <button class="supermini"
                v-on:click="openConsole"></button>
        </div>
    </div>
    <div class="flex_row centered pad_top_1">
        <div class="flex_1">: </div>
        <div class="flex_100 pad_left_1">
            <select class="width_100 supermini"
                v-model="selectedTab">
                <option v-for="tab, tabIndex in tabs"
                    v-bind:key="'js_inspector_tab_option_' + tabIndex"
                    :value="tab.uid">
                    {{ tab.id }} ({{ tab.uid }})
                </option>
            </select>
        </div>
        <div class="flex_1 pad_left_1">
            <button class="supermini"
                v-on:click="cloneTab">
                
            </button>
        </div>
        <div class="flex_1 pad_left_1">
            <button class="supermini"
                v-on:click="addTab">
                
            </button>
        </div>
    </div>
    <div>
        <div class="inspector_tabs"
            v-for="tab, tabIndex in tabs"
            v-bind:key="'js_inspector_tab_option_' + tabIndex">
            <template v-if="selectedTab === tab.uid">
                <div class="flex_row pad_top_1">
                    <div class="flex_100">
                        <div>
                            <div>
                                <div class="flex_row centered">
                                    <div class="flex_100 flex_row centered">
                                        <div class="flex_1 pad_right_1">#: </div>
                                        <div class="flex_100">
                                            <input class="width_100 supermini"
                                                type="text"
                                                v-model="tab.id"
                                                v-on:keypress.enter="digestInput" />
                                        </div>
                                        <div class="flex_1 pad_left_1">
                                            <button class="supermini"
                                                v-on:click="() => resetTabId(tabIndex)"></button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div>
                                <div class="flex_row centered pad_top_1">
                                    <div class="flex_1 pad_right_1 align_self_start">
                                        :
                                    </div>
                                    <div class="flex_1 pad_right_1 align_self_start">
                                        <button class="supermini"
                                            v-on:click="() => backProperty(tabIndex)"></button>
                                    </div>
                                    <div class="flex_100">
                                        <input class="width_100 supermini"
                                            type="text"
                                            v-model="tab.inputSource"
                                            v-on:keypress.enter="digestInput" />
                                    </div>
                                    <div class="flex_1 pad_left_1">
                                        <button class="supermini"
                                            v-on:click="() => resetTabInput(tabIndex)"></button>
                                    </div>
                                </div>
                                <lsw-error-box v-if="errorGettingInput"
                                    :error="errorGettingInput"
                                    :on-clear-error="() => errorGettingInput = false" />
                            </div>
                            <div v-if="(typeof outputValue === 'object') || (typeof outputValue === 'function')">
                                <div>
                                    <div class="flex_row centered pad_top_1">
                                        <div class="flex_1 pad_right_1 align_self_start pad_top_1">
                                            :
                                        </div>
                                        <div class="flex_100">
                                            <input class="supermini width_100"
                                                type="text"
                                                v-model="tab.pathSource"
                                                placeholder="Jmespath, ej: list.*.property"
                                                v-on:keypress.enter="digestInput" />
                                        </div>
                                        <div class="flex_1 pad_left_1">
                                            <button class="supermini"
                                                v-on:click="() => resetTabPath(tabIndex)"></button>
                                        </div>
                                    </div>
                                    <template v-if="errorPathingInput">
                                        <lsw-error-box :error="errorPathingInput"
                                            :on-clear-error="() => errorPathingInput = false" />
                                    </template>
                                </div>
                                <div>
                                    <div class="flex_row pad_top_1">
                                        <div class="flex_1 pad_right_1 align_self_start pad_top_1">
                                            :
                                        </div>
                                        <div class="flex_100">
                                            <textarea class=""
                                                spellcheck="false"
                                                v-model="tab.transformerSource"
                                                placeholder="Js transformer, ej: return it.map(row => row.field)"
                                                v-on:keypress.ctrl.enter="digestInput" />
                                        </div>
                                        <div class="flex_1 pad_left_1 align_self_stretch">
                                            <button class="supermini height_100"
                                                v-on:click="() => resetTabTransformer(tabIndex)"></button>
                                        </div>
                                    </div>
                                    <lsw-error-box v-if="errorTransformingInput"
                                        :error="errorTransformingInput"
                                        :on-clear-error="() => errorTransformingInput = false" />
                                </div>
                                <div>
                                    <div class="flex_row centered pad_top_1">
                                        <div class="flex_1 pad_right_1 align_self_start pad_top_1">
                                            :
                                        </div>
                                        <div class="flex_100">
                                            <input class="width_100 supermini"
                                                type="text"
                                                :value="tab.searchSource"
                                                placeholder="Filtra propiedades por texto"
                                                v-on:input="(e) => updateSearchWithDelay(tab, e.target.value)"
                                                v-on:keypress.enter="digestInput" />
                                        </div>
                                        <div class="flex_1 pad_left_1">
                                            <button class="supermini"
                                                v-on:click="() => resetTabSearch(tabIndex)"></button>
                                        </div>
                                    </div>
                                    <lsw-error-box v-if="errorTransformingInput"
                                        :error="errorTransformingInput"
                                        :on-clear-error="() => errorTransformingInput = false" />
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="flex_1 pad_left_1"
                        style="min-width: 30px;">
                        <button class="supermini"
                            style="min-width: 26px; left: 4px; height: 100%;"
                            v-on:click="digestInput">
                            
                        </button>
                    </div>
                </div>
                <div class="pad_top_1"
                    v-if="isDigesting">
                    Cargando nuevas referencias. Por favor, aguarde...
                </div>
                <div v-else>
                    <div class="flex_row centered pad_top_1"
                        v-if="output !== emptyOutput">
                        <div class="flex_1 pad_right_1 align_self_start pad_top_1">
                            :
                        </div>
                        <div class="flex_100">
                            <button class="supermini vertical_align_top margin_bottom_1"
                                :class="'colorize_for_type_default'"
                                v-on:click="() => backProperty(tabIndex)">
                                 Ir a anterior
                            </button>
                            <template v-if="typeof outputValue === 'object' && outputValue === null">
                                <span class="colorize_for_type_object">null</span>
                            </template>
                            <template v-else-if="(typeof outputValue === 'function') || (typeof outputValue === 'object')">
                                <template v-for="outputKey, outputIndex in LswJsInspector.keysFrom(outputValue)">
                                    <div class="display_inline_block pad_bottom_1 pad_right_1"
                                        v-if="(tab.searchSource.trim() === '') || (outputKey.toLowerCase().indexOf(tab.searchSource.toLowerCase()) !== -1)"
                                        v-bind:key="'tab_' + tabIndex + '_function_prop_' + outputIndex">
                                        <button class="supermini"
                                            :class="'colorize_for_type_' + typeof outputValue[outputKey]"
                                            v-on:click="() => openProperty(tabIndex, outputKey)">
                                            <span class="property_enumerator">[{{ outputIndex }}]</span>
                                            <span>{{ outputKey }}</span>
                                        </button>
                                    </div>
                                </template>
                                <div v-if="typeof outputValue === 'function'">
                                    <div class="js_inspector_typeof_box"
                                        :class="'colorize_for_type_' + typeof outputValue">Type of <b>{{ typeof outputValue }}</b>:</div>
                                    <div>
                                        <lsw-js-viewer :source="beautifier.js(outputValue.toString())" />
                                    </div>
                                </div>
                            </template>
                            <template v-else>
                                <div class="">
                                    <div class="js_inspector_typeof_box"
                                        :class="'colorize_for_type_' + typeof outputValue">Type of <b>{{ typeof outputValue }}:</b></div>
                                        <template>
                                            <div class="js_inspector_value_box"
                                                :class="'colorize_for_type_' + typeof outputValue"
                                                v-if="typeof outputValue !== 'string'">{{ output }}</div>
                                            <template v-else>
                                                <lsw-js-viewer :source="outputValue" />
                                            </template>
                                        </template>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>
</div>`,
    props: {
      initialBase: {
        type: [],
        default: () => window,
      }
    },
    data() {
      this.$trace("lsw-js-inspector.data");
      return {
        isDigesting: false,
        selectedTab: undefined,
        base: this.initialBase,
        tabs: [],
        errorGettingInput: false,
        errorPathingInput: false,
        errorTransformingInput: false,
        output: emptyOutput,
        emptyOutput: emptyOutput,
        digestTimeoutId: undefined,
        digestTimeoutMilliseconds: 1000,
      };
    },
    methods: {
      addTab(specifications = {}) {
        this.$trace("lsw-js-inspector.methods.addTab");
        const anotherTab = new InspectorTab(specifications, this);
        this.tabs.push(anotherTab);
        this.selectedTab = anotherTab.uid;
        return anotherTab;
      },
      cloneTab() {
        const specifications = {
          input: this.inputSource,
          path: this.pathSource,
          transformer: this.transformerSource,
          search: this.searchSource,
        };
        const anotherTab = new InspectorTab(specifications, this);
        this.tabs.push(anotherTab);
        this.selectedTab = anotherTab.uid;
        return anotherTab;
      },
      async digestInput() {
        try {
          this.$trace("lsw-js-inspector.methods.digestInput");
          this.isDigesting = true;
          clearTimeout(this.digestTimeoutId);
          const currentTab = this.tabs.filter(tab => tab.uid === this.selectedTab)[0];
          let transformedInput = undefined;
          Getting_input: {
            try {
              if (currentTab.inputSource.trim() === "") {
                throw new Error("Este campo es requerido para iniciar la exploracin");
              }
              const callback = LswUtils.createAsyncFunction("return " + currentTab.inputSource, ["it"])
              transformedInput = await callback.call(this, transformedInput);
            } catch (error) {
              this.errorGettingInput = error;
              throw error;
            }
          }
          Pathing_input: {
            try {
              if (currentTab.pathSource.trim() === "") {
                break Pathing_input;
              }
              transformedInput = jmespath.search(transformedInput, currentTab.pathSource);
            } catch (error) {
              this.errorPathingInput = error;
              throw error;
            }
          }
          Transforming_input: {
            try {
              if (currentTab.transformerSource.trim() === "") {
                break Transforming_input;
              }
              transformedInput = await LswUtils.createAsyncFunction(currentTab.transformerSource, ["it"]).call(this, transformedInput);
            } catch (error) {
              this.errorTransformingInput = error;
              throw error;
            }
          }
          Set_output: {
            this.outputValue = transformedInput;
            this.output = LswJsInspector.stringifyBeautify(transformedInput);
          }
        } catch (error) {
          console.log(error);
          this.$lsw.toasts.showError(error);
        } finally {
          this.isDigesting = false;
        }
      },
      backProperty(tabIndex) {
        this.$trace("lsw-js-inspector.methods.backProperty");
        const tab = this.tabs[tabIndex];
        const propPath = tab.inputSource.trim();
        let newPath = undefined;
        let pos = undefined;
        if (propPath.endsWith("]")) {
          pos = propPath.lastIndexOf("[");
        } else {
          pos = propPath.lastIndexOf(".");
        }
        const shouldOpenGlobal = (pos === 0) || (propPath.trim() === '');
        const shouldIgnore = (pos === -1) && (propPath.trim() !== '');
        if (shouldIgnore) {
          return;
        } else if (shouldOpenGlobal) {
          tab.inputSource = "window";
        } else {
          newPath = propPath.slice(0, pos);
          tab.inputSource = newPath;
        }
        this.digestInput();
      },
      openProperty(tabIndex, propId) {
        this.$trace("lsw-js-inspector.methods.openProperty");
        const tab = this.tabs[tabIndex];
        const propRegex = /^[A-Za-z$_][A-Za-z0-9$_]*$/g;
        const byString = !propRegex.test(propId);
        const appendment = byString ? `[${JSON.stringify(propId)}]` : `.${propId}`;
        tab.inputSource += appendment;
        this.digestInput();
      },
      updateSearchWithDelay(tab, searchSource) {
        this.$trace("lsw-js-inspector.methods.updateSearchWithDelay");
        clearTimeout(this.digestTimeoutId);
        this.digestTimeoutId = setTimeout(() => {
          tab.searchSource = searchSource;
          this.digestInput();
        }, this.digestTimeoutMilliseconds);
      },
      resetTabId(tabIndex) {
        this.$trace("lsw-js-inspector.methods.resetTabId");
        this.tabs[tabIndex].idSource = '';
        this.digestInput();
      },
      resetTabInput(tabIndex) {
        this.$trace("lsw-js-inspector.methods.resetTabInput");
        this.tabs[tabIndex].inputSource = '';
        this.digestInput();
      },
      resetTabPath(tabIndex) {
        this.$trace("lsw-js-inspector.methods.resetTabPath");
        this.tabs[tabIndex].pathSource = '';
        this.digestInput();
      },
      resetTabTransformer(tabIndex) {
        this.$trace("lsw-js-inspector.methods.resetTabTransformer");
        this.tabs[tabIndex].transformerSource = '';
        this.digestInput();
      },
      resetTabSearch(tabIndex) {
        this.$trace("lsw-js-inspector.methods.resetTabSearch");
        this.tabs[tabIndex].searchSource = '';
        this.digestInput();
      },
      openConsole() {
        this.$trace("lsw-js-inspector.methods.openConsole");
        this.$consoleHooker.toggleConsole();
      },
    },
    watch: {
      selectedTab() {
        this.digestInput();
      }
    },
    async mounted() {
      try {
        this.$trace("lsw-js-inspector.mounted");
        await LswLazyLoads.loadBeautifier();
        await LswLazyLoads.loadJmespath();
        await LswJsInspector.initializeFully();
        if (this.tabs.length === 0) {
          this.selectedTab = this.addTab({
            id: "Principal",
          }).uid;
        }
        await this.digestInput();
      } catch (error) {
        console.log(error);
      }
    }
  });
})();
// @code.end: LswJsInspector API

// @vuebundler[Lsw_framework_components][172]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-js-inspector/lsw-js-inspector.css

// @vuebundler[Lsw_framework_components][173]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-languages/weeklang/weeklang.bundled.js
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root) {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { WeekLang: peg$parseWeekLang },
        peg$startRuleFunction  = peg$parseWeekLang,

        peg$c0 = function(ast) { return flatScript(ast) },
        peg$c1 = function(range, rules) { return flatSentence({ range: range || { from: "*", to: "*" }, rules }) },
        peg$c2 = "-",
        peg$c3 = peg$literalExpectation("-", false),
        peg$c4 = ":",
        peg$c5 = peg$literalExpectation(":", false),
        peg$c6 = function(token0, dateSrc, token1, dateDst, token2) { return { from: dateSrc, to: dateDst } },
        peg$c7 = "*",
        peg$c8 = peg$literalExpectation("*", false),
        peg$c9 = "/",
        peg$c10 = peg$literalExpectation("/", false),
        peg$c11 = function() { return text() },
        peg$c12 = /^[0-9]/,
        peg$c13 = peg$classExpectation([["0", "9"]], false, false),
        peg$c14 = function(rules) { return rules.flat() },
        peg$c15 = "{",
        peg$c16 = peg$literalExpectation("{", false),
        peg$c17 = "}",
        peg$c18 = peg$literalExpectation("}", false),
        peg$c19 = function(token1, frequency, token2, rules, token3) { return flatRules(frequency, rules) },
        peg$c20 = "lun",
        peg$c21 = peg$literalExpectation("lun", false),
        peg$c22 = "mar",
        peg$c23 = peg$literalExpectation("mar", false),
        peg$c24 = "mie",
        peg$c25 = peg$literalExpectation("mie", false),
        peg$c26 = "jue",
        peg$c27 = peg$literalExpectation("jue", false),
        peg$c28 = "vie",
        peg$c29 = peg$literalExpectation("vie", false),
        peg$c30 = "sab",
        peg$c31 = peg$literalExpectation("sab", false),
        peg$c32 = "dom",
        peg$c33 = peg$literalExpectation("dom", false),
        peg$c34 = function(frequency) { return frequency },
        peg$c35 = "set",
        peg$c36 = peg$literalExpectation("set", false),
        peg$c37 = "=",
        peg$c38 = peg$literalExpectation("=", false),
        peg$c39 = function(token1, moment, duration, token2, concept) { return { type: "SET", concept, duration, ...moment } },
        peg$c40 = function(token1, duration) { return duration },
        peg$c41 = function(token1, hour, minute) { return { hour, minute: minute ? minute[1] : "00" } },
        peg$c42 = "req",
        peg$c43 = peg$literalExpectation("req", false),
        peg$c44 = function(token1, tokens) { return tokens },
        peg$c45 = function(concept, limit, urgency) { return { type: "REQ", concept, ...limit, urgency: urgency || 0 } },
        peg$c46 = ">",
        peg$c47 = peg$literalExpectation(">", false),
        peg$c48 = "<",
        peg$c49 = peg$literalExpectation("<", false),
        peg$c50 = function(limit, value) { return { limit, value: value.trim().trim(), condition: text().trim() } },
        peg$c51 = "!",
        peg$c52 = peg$literalExpectation("!", false),
        peg$c53 = function(op, value) { return value.trim() },
        peg$c54 = function() { return text().trim() },
        peg$c55 = "|",
        peg$c56 = peg$literalExpectation("|", false),
        peg$c57 = function() { return text().substr(1).trim() },
        peg$c58 = peg$anyExpectation(),
        peg$c59 = "*/",
        peg$c60 = peg$literalExpectation("*/", false),
        peg$c61 = " ",
        peg$c62 = peg$literalExpectation(" ", false),
        peg$c63 = "\t",
        peg$c64 = peg$literalExpectation("\t", false),
        peg$c65 = "\r\n",
        peg$c66 = peg$literalExpectation("\r\n", false),
        peg$c67 = "\r",
        peg$c68 = peg$literalExpectation("\r", false),
        peg$c69 = "\n",
        peg$c70 = peg$literalExpectation("\n", false),
        peg$c71 = "//",
        peg$c72 = peg$literalExpectation("//", false),
        peg$c73 = "/*",
        peg$c74 = peg$literalExpectation("/*", false),

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parseWeekLang() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseanyspace();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseSentence();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseSentence();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseanyspace();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSentence() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseDate_header();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseRules_block();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDate_header() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFull_date_till_day_or_asterisk();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseanyspace();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s5 = peg$c2;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c3); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseanyspace();
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseFull_date_till_day_or_asterisk();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s5 = peg$c4;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c5); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1, s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFull_date_till_day_or_asterisk() {
      var s0;

      s0 = peg$parseFull_date_till_day();
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 42) {
          s0 = peg$c7;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
      }

      return s0;
    }

    function peg$parseFull_date_till_day() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseYear();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s2 = peg$c9;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMonth();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s4 = peg$c9;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c10); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDay();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseYear() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (peg$c12.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c13); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c12.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c13); }
        }
        if (s2 !== peg$FAILED) {
          if (peg$c12.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          if (s3 !== peg$FAILED) {
            if (peg$c12.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c13); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c11();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMonth() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c12.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c13); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c12.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c13); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c11();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDay() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c12.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c13); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c12.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c13); }
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c11();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseRules_block() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseFull_rule();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseFull_rule();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c14(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseFull_rule() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parseanyspace();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFrequency_v1();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseanyspace();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s5 = peg$c15;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseanyspace();
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseInner_sentence();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseInner_sentence();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parseanyspace();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s7 = peg$c17;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c18); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseanyspace();
                  if (s8 !== peg$FAILED) {
                    s6 = [s6, s7, s8];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c19(s1, s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFrequency_v1() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 42) {
        s1 = peg$c7;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c20) {
          s1 = peg$c20;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c21); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c22) {
            s1 = peg$c22;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c23); }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c24) {
              s1 = peg$c24;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c25); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c26) {
                s1 = peg$c26;
                peg$currPos += 3;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c27); }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c28) {
                  s1 = peg$c28;
                  peg$currPos += 3;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c29); }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c30) {
                    s1 = peg$c30;
                    peg$currPos += 3;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c31); }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c32) {
                      s1 = peg$c32;
                      peg$currPos += 3;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c33); }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c34(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseInner_sentence() {
      var s0;

      s0 = peg$parseSentence_req();
      if (s0 === peg$FAILED) {
        s0 = peg$parseSentence_set();
      }

      return s0;
    }

    function peg$parseSentence_set() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseanyspace();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c35) {
          s3 = peg$c35;
          peg$currPos += 3;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsespace();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFull_hour();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDuration_del_set();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parseanyspace();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s6 = peg$c37;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c38); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parseanyspace();
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseToken_para_el_set();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c39(s1, s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDuration_del_set() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseanyspace();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 42) {
          s3 = peg$c7;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseanyspace();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseToken_para_el_duration_del_set();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFull_hour() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseanyspace();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseHour();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c4;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c5); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseMinute();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c41(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseHour() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c12.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c13); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c12.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c13); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c11();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMinute() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c12.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c13); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c12.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c13); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c11();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSentence_req() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseanyspace();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c42) {
          s3 = peg$c42;
          peg$currPos += 3;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c43); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsespace();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseLine_of_tokens();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c44(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseLine_of_tokens() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseToken_para_el_req();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseLimite_para_el_req();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseUrgencia_para_el_req();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c45(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseLimite_para_el_req() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 62) {
        s1 = peg$c46;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 60) {
          s1 = peg$c48;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c49); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseToken_para_el_req();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c50(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseUrgencia_para_el_req() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 33) {
        s1 = peg$c51;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c52); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseToken_para_el_req();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c53(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseLine_of_tokens_first() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseToken_para_el_req();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c54();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseLine_of_tokens_next() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 124) {
        s1 = peg$c55;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseToken_para_el_req();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c57();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseToken_para_el_req() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 62) {
        s4 = peg$c46;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }
      if (s4 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 60) {
          s4 = peg$c48;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c49); }
        }
        if (s4 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 33) {
            s4 = peg$c51;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c52); }
          }
          if (s4 === peg$FAILED) {
            s4 = peg$parse___();
          }
        }
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c58); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 62) {
          s4 = peg$c46;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c47); }
        }
        if (s4 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 60) {
            s4 = peg$c48;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c49); }
          }
          if (s4 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 33) {
              s4 = peg$c51;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
            if (s4 === peg$FAILED) {
              s4 = peg$parse___();
            }
          }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c58); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c54();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseToken_para_el_set() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parse___();
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c58); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse___();
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c58); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c54();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseToken_para_el_duration_del_set() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parse___();
      if (s4 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s4 = peg$c37;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c58); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse___();
          if (s4 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s4 = peg$c37;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c38); }
            }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c58); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c54();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseToken_para_el_comentario() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parse___();
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c58); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse___();
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c58); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c54();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseToken_para_el_comentario_multilinea() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parse___();
      if (s4 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c59) {
          s4 = peg$c59;
          peg$currPos += 2;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c60); }
        }
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c58); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse___();
          if (s4 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c59) {
              s4 = peg$c59;
              peg$currPos += 2;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c60); }
            }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c58); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c54();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseanyspace() {
      var s0, s1;

      s0 = [];
      s1 = peg$parse_();
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parse_();
      }

      return s0;
    }

    function peg$parsespace() {
      var s0, s1;

      s0 = [];
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_();
        }
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseEOS() {
      var s0;

      s0 = peg$parse___();
      if (s0 === peg$FAILED) {
        s0 = peg$parseEOF();
      }

      return s0;
    }

    function peg$parseEOF() {
      var s0, s1;

      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c58); }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = void 0;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parse_() {
      var s0;

      s0 = peg$parse__();
      if (s0 === peg$FAILED) {
        s0 = peg$parse___();
        if (s0 === peg$FAILED) {
          s0 = peg$parseComment();
        }
      }

      return s0;
    }

    function peg$parse__() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 32) {
        s0 = peg$c61;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c62); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 9) {
          s0 = peg$c63;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c64); }
        }
      }

      return s0;
    }

    function peg$parse___() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c65) {
        s0 = peg$c65;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c66); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c67;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c68); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c69;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c70); }
          }
        }
      }

      return s0;
    }

    function peg$parseComment() {
      var s0;

      s0 = peg$parseComment_oneline();
      if (s0 === peg$FAILED) {
        s0 = peg$parseComment_multiline();
      }

      return s0;
    }

    function peg$parseComment_oneline() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c71) {
        s1 = peg$c71;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c72); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseToken_para_el_comentario();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c11();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseComment_multiline() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c73) {
        s1 = peg$c73;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c74); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseToken_para_el_comentario_multilinea();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c59) {
            s3 = peg$c59;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c60); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c11();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }


        const flatRules = (fecha, reglas) => {
            let out = [];
            for(let index=0; index<reglas.length; index++) {
              const regla = reglas[index];
              out.push({
                weekday: fecha,
                ...regla,
              });
            }
            return out;
        };
        const flatSentence = (sentence) => {
            const output = [];
            for(let indexRule=0; indexRule<sentence.rules.length; indexRule++) {
              const rule = sentence.rules[indexRule];
              output.push({
                ...sentence.range,
                ...rule,
              });
            }
            return output;
        };
        const flatScript = function(ast) {
            return ast.flat();
        }


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  root.WeekLang = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})(globalThis);

(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswWeekLang'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswWeekLang'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  return {
    parser: WeekLang,
  }

});

// @vuebundler[Lsw_framework_components][174]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-week-planner/lsw-week-planner.html

// @vuebundler[Lsw_framework_components][174]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-week-planner/lsw-week-planner.js
// @code.start: LswWeekPlanner API | @$section: Vue.js (v2) Components  Lsw Week Planner API  LswWeekPlanner component
Vue.component("LswWeekPlanner", {
  template: `<div class="lsw_week_planner">
    <lsw-filesystem-explorer opened-by="/kernel/goals/goals.week" :absolute-layout="true" />
</div>`,
  props: {},
  data() {
    return {
      scriptContent: "",
      scriptOutput: "",
    };
  },
  methods: {
    parsear() {
      try {
        const ast = WeekLang.parse(this.scriptContent);
        this.scriptOutput = JSON.stringify(ast, null, 2);
      } catch (error) {
        this.scriptOutput = JSON.stringify({
          error: true,
          name: error.name,
          message: error.message,
          stack: error.stack,
        }, null, 2);
      }
    }
  },
  watch: {},
  mounted() {
    
  }
});
// @code.end: LswWeekPlanner API

// @vuebundler[Lsw_framework_components][174]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-week-planner/lsw-week-planner.css

// @vuebundler[Lsw_framework_components][175]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-languages/mermoid/mermoid.bundled.js
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root) {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = "graph",
        peg$c1 = peg$literalExpectation("graph", false),
        peg$c2 = function(token1, direction, token2, statements, token3) { return { type: "graph", direction, statements }; },
        peg$c3 = "TD",
        peg$c4 = peg$literalExpectation("TD", false),
        peg$c5 = "LR",
        peg$c6 = peg$literalExpectation("LR", false),
        peg$c7 = "BT",
        peg$c8 = peg$literalExpectation("BT", false),
        peg$c9 = "RL",
        peg$c10 = peg$literalExpectation("RL", false),
        peg$c11 = function(token1, sentencia) { return sentencia },
        peg$c12 = function(from, label, arrow, to) { return { type: "link", from, to, arrow, label }; },
        peg$c13 = "-->",
        peg$c14 = peg$literalExpectation("-->", false),
        peg$c15 = "---",
        peg$c16 = peg$literalExpectation("---", false),
        peg$c17 = "-.->",
        peg$c18 = peg$literalExpectation("-.->", false),
        peg$c19 = "==>",
        peg$c20 = peg$literalExpectation("==>", false),
        peg$c21 = "-.-",
        peg$c22 = peg$literalExpectation("-.-", false),
        peg$c23 = "--",
        peg$c24 = peg$literalExpectation("--", false),
        peg$c25 = function(token1, l, token2) { return l; },
        peg$c26 = "-",
        peg$c27 = peg$literalExpectation("-", false),
        peg$c28 = peg$anyExpectation(),
        peg$c29 = function() { return text(); },
        peg$c30 = function(id, shape) { return { id, shape }; },
        peg$c31 = "(",
        peg$c32 = peg$literalExpectation("(", false),
        peg$c33 = ")",
        peg$c34 = peg$literalExpectation(")", false),
        peg$c35 = function(text) { return { type: "default", text }; },
        peg$c36 = "[",
        peg$c37 = peg$literalExpectation("[", false),
        peg$c38 = "]",
        peg$c39 = peg$literalExpectation("]", false),
        peg$c40 = function(text) { return { type: "rect", text }; },
        peg$c41 = "{",
        peg$c42 = peg$literalExpectation("{", false),
        peg$c43 = "}",
        peg$c44 = peg$literalExpectation("}", false),
        peg$c45 = function(text) { return { type: "diamond", text }; },
        peg$c46 = /^[a-zA-Z0-9_]/,
        peg$c47 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false),
        peg$c48 = function() { return text() },
        peg$c49 = "subgraph",
        peg$c50 = peg$literalExpectation("subgraph", false),
        peg$c51 = "end",
        peg$c52 = peg$literalExpectation("end", false),
        peg$c53 = function(token1, id, token2, body, token3) { return { type: "subgraph", id, body }; },
        peg$c54 = " ",
        peg$c55 = peg$literalExpectation(" ", false),
        peg$c56 = "\t",
        peg$c57 = peg$literalExpectation("\t", false),
        peg$c58 = "\r\n",
        peg$c59 = peg$literalExpectation("\r\n", false),
        peg$c60 = "\r",
        peg$c61 = peg$literalExpectation("\r", false),
        peg$c62 = "\n",
        peg$c63 = peg$literalExpectation("\n", false),

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parsestart() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseanyspace();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 5) === peg$c0) {
          s3 = peg$c0;
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c1); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseanyspace();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsedirection();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseanyspace();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsestatementList();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseanyspace();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c2(s1, s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsedirection() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c3) {
        s0 = peg$c3;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c4); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c5) {
          s0 = peg$c5;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c6); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c7) {
            s0 = peg$c7;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c8); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c9) {
              s0 = peg$c9;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c10); }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsestatementList() {
      var s0, s1;

      s0 = [];
      s1 = peg$parsestatementUnit();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsestatementUnit();
        }
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsestatementUnit() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseanyspace();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsestatement();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c11(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsestatement() {
      var s0;

      s0 = peg$parselink();
      if (s0 === peg$FAILED) {
        s0 = peg$parsesubgraph();
        if (s0 === peg$FAILED) {
          s0 = peg$parsenode();
        }
      }

      return s0;
    }

    function peg$parselink() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parsenode();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseanyspace();
        if (s2 !== peg$FAILED) {
          s3 = peg$parselabel();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseanyspace();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsearrow();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseanyspace();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsenode();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c12(s1, s3, s5, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsearrow() {
      var s0;

      if (input.substr(peg$currPos, 3) === peg$c13) {
        s0 = peg$c13;
        peg$currPos += 3;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c16); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c17) {
            s0 = peg$c17;
            peg$currPos += 4;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c19) {
              s0 = peg$c19;
              peg$currPos += 3;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c20); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c21) {
                s0 = peg$c21;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c22); }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parselabel() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c23) {
        s1 = peg$c23;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c24); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parselabelText();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c13) {
            s3 = peg$c13;
            peg$currPos += 3;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c25(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parselabelText() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 45) {
        s4 = peg$c26;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c27); }
      }
      if (s4 === peg$FAILED) {
        s4 = peg$parse___();
        if (s4 === peg$FAILED) {
          s4 = peg$parseeof();
        }
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 45) {
            s4 = peg$c26;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c27); }
          }
          if (s4 === peg$FAILED) {
            s4 = peg$parse___();
            if (s4 === peg$FAILED) {
              s4 = peg$parseeof();
            }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c28); }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c29();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsenode() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseshapeText();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c30(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseshapeText() {
      var s0;

      s0 = peg$parseshapeText_v1();
      if (s0 === peg$FAILED) {
        s0 = peg$parseshapeText_v2();
        if (s0 === peg$FAILED) {
          s0 = peg$parseshapeText_v3();
        }
      }

      return s0;
    }

    function peg$parseshapeText_v1() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c31;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenegateText_v1();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c33;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseshapeText_v2() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c36;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c37); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenegateText_v2();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s3 = peg$c38;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c39); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c40(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseshapeText_v3() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c41;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenegateText_v3();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 125) {
            s3 = peg$c43;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c44); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c45(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsenegateText_v1() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 41) {
        s4 = peg$c33;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      if (s4 === peg$FAILED) {
        s4 = peg$parse___();
        if (s4 === peg$FAILED) {
          s4 = peg$parseeof();
        }
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 41) {
          s4 = peg$c33;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c34); }
        }
        if (s4 === peg$FAILED) {
          s4 = peg$parse___();
          if (s4 === peg$FAILED) {
            s4 = peg$parseeof();
          }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c28); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c29();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsenegateText_v2() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 93) {
        s4 = peg$c38;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c39); }
      }
      if (s4 === peg$FAILED) {
        s4 = peg$parse___();
        if (s4 === peg$FAILED) {
          s4 = peg$parseeof();
        }
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 93) {
          s4 = peg$c38;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c39); }
        }
        if (s4 === peg$FAILED) {
          s4 = peg$parse___();
          if (s4 === peg$FAILED) {
            s4 = peg$parseeof();
          }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c28); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c29();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsenegateText_v3() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 125) {
        s4 = peg$c43;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c44); }
      }
      if (s4 === peg$FAILED) {
        s4 = peg$parse___();
        if (s4 === peg$FAILED) {
          s4 = peg$parseeof();
        }
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 125) {
          s4 = peg$c43;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c44); }
        }
        if (s4 === peg$FAILED) {
          s4 = peg$parse___();
          if (s4 === peg$FAILED) {
            s4 = peg$parseeof();
          }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c28); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c29();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseeof() {
      var s0, s1;

      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = void 0;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseidentifier() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c46.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c46.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c47); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c48();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsesubgraph() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c49) {
        s2 = peg$c49;
        peg$currPos += 8;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseanyspace();
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesubgraphId();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseanyspace();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsestatementList();
            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c51) {
                s5 = peg$c51;
                peg$currPos += 3;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c52); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c53(s1, s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsesubgraphId() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parse___();
      if (s4 === peg$FAILED) {
        s4 = peg$parseeof();
      }
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse___();
        if (s4 === peg$FAILED) {
          s4 = peg$parseeof();
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c28); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c48();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseanyspace() {
      var s0, s1;

      s0 = [];
      s1 = peg$parsespace();
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsespace();
      }

      return s0;
    }

    function peg$parsespace() {
      var s0, s1;

      s0 = [];
      s1 = peg$parseonespace();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parseonespace();
        }
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseonespace() {
      var s0;

      s0 = peg$parse__();
      if (s0 === peg$FAILED) {
        s0 = peg$parse___();
      }

      return s0;
    }

    function peg$parse__() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 32) {
        s0 = peg$c54;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 9) {
          s0 = peg$c56;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c57); }
        }
      }

      return s0;
    }

    function peg$parse___() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c58) {
        s0 = peg$c58;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c59); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c60;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c61); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c62;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c63); }
          }
        }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  root.MermoidParser = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})(globalThis);



// @vuebundler[Lsw_framework_components][176]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-mermoid-viewer/lsw-mermoid-viewer.html

// @vuebundler[Lsw_framework_components][176]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-mermoid-viewer/lsw-mermoid-viewer.js
// @code.start: LswMermoidViewer API | @$section: Vue.js (v2) Components  Lsw SchemaBasedForm API  LswMermoidViewer component
Vue.component("LswMermoidViewer", {
  template: `<div class="lsw_mermoid_viewer">
    lsw mermoid viewer:
    <pre class="codeblock">{{ source }}</pre>
</div>`,
  props: {
    source: {
      type: String,
      required: true,
    }
  },
  data() {
    this.$trace("lsw-mermoid-viewer.data");
    return {
      isLoaded: false,
    };
  },
  methods: {
    composeVisualTree() {
      this.$trace("lsw-mermoid-viewer.methods.composeVisualTree");
      // ...
      console.log("composeVisualTree:", this.source);
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-mermoid-viewer.mounted");
      
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswMermoidViewer API

// @vuebundler[Lsw_framework_components][176]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-mermoid-viewer/lsw-mermoid-viewer.css

// @vuebundler[Lsw_framework_components][177]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-pegjs-tester/lsw-pegjs-tester.html

// @vuebundler[Lsw_framework_components][177]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-pegjs-tester/lsw-pegjs-tester.js
// @code.start: LswPegjsTester API | @$section: Vue.js (v2) Components  Lsw SchemaBasedForm API  LswPegjsTester component
Vue.component("LswPegjsTester", {
  template: `<div class="lsw_pegjs_tester">
    <div class="flex_row"
        v-if="showingPaneOf === 'parser'">
        <div class="flex_100">
            <textarea placeholder="// PEGjs syntax here"
                spellcheck="false"
                v-model="currentParserSource" />
        </div>
        <div class="flex_1 position_relative"
            style="min-width:44px;">
            <button class="height_100 position_absolute_fixed"
                style="left:3px;"
                v-on:click="compileParser">
                
            </button>
        </div>
        <lsw-syntax-error-viewer
            ref="parserErrorViewer"
            :error="false" />
    </div>
    <div v-if="showingPaneOf === 'snippet'">
        <div class="flex_row">
            <div class="flex_1 position_relative"
                style="min-width:44px;">
                <button class="height_100 position_absolute_fixed"
                    style="right:3px;"
                    v-on:click="() => showingPaneOf = 'parser'">
                    
                </button>
            </div>
            <div class="flex_100">
                <textarea placeholder="// Your syntax snippet here"
                    spellcheck="false"
                    v-model="currentSnippet" />
            </div>
            <div class="flex_1 position_relative"
                style="min-width:44px;">
                <button class="height_100 position_absolute_fixed"
                    style="left:3px;"
                    v-on:click="testSnippet">
                    
                </button>
            </div>
        </div>
        <div class="width_100"
            v-if="currentAst">
            <div class="">Salida:</div>
            <pre class="codeblock">{{ currentAst }}</pre>
        </div>
        <lsw-syntax-error-viewer
            ref="snippetErrorViewer"
            :error="false" />
    </div>
</div>`,
  props: {
    source: {
      type: String,
      default: () => 'Example = "0"',
    }
  },
  data() {
    this.$trace("lsw-pegjs-tester.data");
    return {
      isLoaded: false,
      currentAst: false,
      currentParserSource: this.source,
      currentParser: false,
      currentSnippet: "0",
      currentParserSyntaxError: false,
      currentSnippetSyntaxError: false,
      showingPaneOf: 'parser',
    };
  },
  methods: {
    async loadDependencies() {
      await LswLazyLoads.loadPegjs();
    },
    showParserError(error) {
      this.$refs.parserErrorViewer.setError(error);
    },
    showSnippetError(error) {
      this.$refs.snippetErrorViewer.setError(error);
    },
    compileSyntax() {
      this.$trace("lsw-pegjs-tester.methods.compileSyntax");
      try {
        this.currentParser = PEG.buildParser(this.currentParserSource);
        this.showParserError(false);
      } catch (error) {
        this.showParserError(error);
        this.$lsw.toasts.showError(error);
        throw error;
      }
    },
    compileParser() {
      this.$trace("lsw-pegjs-tester.methods.compileParser");
      this.compileSyntax();
      this.showingPaneOf = 'snippet';
    },
    resetState() {
      this.$trace("lsw-pegjs-tester.methods.resetState");
      this.currentSnippetSyntaxError = false;
      this.currentAst = false;
    },
    testSnippet() {
      this.$trace("lsw-pegjs-tester.methods.testSnippet");
      try {
        this.resetState();
        Check_it_has_parser: {
          if (!this.currentParser) {
            throw new Error("No parser selected on testSnippet");
          }
        }
        Parse_contents: {
          try {
            this.currentAst = this.currentParser.parse(this.currentSnippet);
            this.currentSnippetSyntaxError = false;
            this.showSnippetError(false);
          } catch (error) {
            this.showSnippetError(error);
            throw error;
          }
        }
      } catch (error) {
        this.$lsw.toasts.showError(error);
      }
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-pegjs-tester.mounted");
      await this.loadDependencies();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswPegjsTester API

// @vuebundler[Lsw_framework_components][177]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-pegjs-tester/lsw-pegjs-tester.css

// @vuebundler[Lsw_framework_components][178]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-nueva-feature/lsw-nueva-feature.html

// @vuebundler[Lsw_framework_components][178]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-nueva-feature/lsw-nueva-feature.js
// @code.start: LswNuevaFeature API | @$section: Vue.js (v2) Components  LswNuevaFeature component
Vue.component("LswNuevaFeature", {
  template: `<div class="lsw_nueva_feature">
    <!--lsw-pegjs-tester /-->
    <div> Esta seccin est reservada para el desarrollo</div>
    <lsw-book-factory />
    <lsw-book-library />
    <lsw-microdata-explorer />
</div>`,
  props: {},
  data() {
    this.$trace("lsw-nueva-feature.data");
    
    return {
      
    };
  },
  methods: {
    async load() {



      const output = await LswTester.create().define({
        id: "lsw.test.api.intro",
        fromCallback: function() {
          console.log("lsw.test.api.into");
        }
      }).run();

      console.log(output);



    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-nueva-feature.mounted");
      this.load();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswNuevaFeature API

// @vuebundler[Lsw_framework_components][178]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-nueva-feature/lsw-nueva-feature.css

// @vuebundler[Lsw_framework_components][179]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-error-box/lsw-error-box.html

// @vuebundler[Lsw_framework_components][179]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-error-box/lsw-error-box.js
// @code.start: LswErrorBox API | @$section: Vue.js (v2) Components  LswErrorBox component
Vue.component("LswErrorBox", {
  template: `<div class="">
    <div class="lsw_error_box_container">
        <div class="lsw_error_box">
            <div class="position_absolute_fixed"
                style="bottom: auto; left: auto; top: 0px; right: 0px;">
                <div class="flex_row centered pad_1">
                    <div class="flex_1">
                        <button class="supermini"
                            v-on:click="toggleTrace">
                            <span>{{ isShowingTrace ? '' : '' }}</span>
                        </button>
                    </div>
                    <div class="flex_1 pad_left_1"
                        v-if="typeof onClearError === 'function'">
                        <button class="supermini"
                            v-on:click="clearError"></button>
                    </div>
                </div>
            </div>
            <div v-if="typeof error === 'object'">
                <div v-if="typeof error.location !== 'undefined'">
                    <lsw-syntax-error-viewer :error="error" />
                </div>
                <div v-else-if="error instanceof Error">
                    <div class="error_clue">
                        <div class="error_topbar">
                            <button class="supermini"
                                v-on:click="toggleTrace">
                                <span></span>
                            </button>
                            <span v-if="context">  {{context}}.</span>
                        </div>
                        <div class="error_main_block">
                            <span class="error_name">{{ error.name }}: </span>
                            <span class="error_message">
                                {{ error.message }}
                            </span>
                        </div>
                    </div>
                    <div class="error_stack"
                        v-if="isShowingTrace">
                        <div v-for="line, lineIndex in error.summarized().stack"
                            v-bind:key="'error_line_' + lineIndex">
                            <div>
                                <div>{{ line[1] }} @ {{ line[0] }}</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div v-else>
                    <pre class="codeblock">Error (non-error) of type {{ typeof error }}: {{ error }}</pre>
                </div>
            </div>
            <div v-else>
                <pre class="codeblock">Error (non-object) of type {{ typeof error }}: {{ error }}</pre>
            </div>
        </div>
    </div>
</div>`,
  props: {
    error: {
      type: [Object, Boolean],
      default: () => false,
    },
    onClearError: {
      type: [Function, Boolean],
      default: () => false,
    },
    context: {
      type: String,
      default: () => {},
    }
  },
  data() {
    this.$trace("lsw-error-box.data");
    return {
      isShowingTrace: false,
    };
  },
  methods: {
    toggleTrace() {
      this.$trace("lsw-error-box.methods.toggleTrace");
      this.isShowingTrace = !this.isShowingTrace;
    },
    clearError() {
      this.$trace("lsw-error-box.methods.clearError");
      this.onClearError();
    }
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-error-box.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswErrorBox API

// @vuebundler[Lsw_framework_components][179]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-error-box/lsw-error-box.css

// @vuebundler[Lsw_framework_components][180]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-syntax-error-viewer/lsw-syntax-error-viewer.html

// @vuebundler[Lsw_framework_components][180]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-syntax-error-viewer/lsw-syntax-error-viewer.js
// @code.start: LswSyntaxErrorViewer API | @$section: Vue.js (v2) Components  Lsw Formtypes API  LswSyntaxErrorViewer component
Vue.component("LswSyntaxErrorViewer", {
  template: `<div class="lsw_error_viewer">
    <div class="position_relative">
        <div class="position_absolute top_0" style="right: 20px;">
            <div class="pad_1">
                <button v-on:click="() => setError()"></button>
            </div>
        </div>
        <div class="">
            <div class="errorMessage">
                <div v-if="typeof currentError.location !== 'undefined'">
                    <span>{{ currentError.name }}</span>
                    <span>{{ currentError.location.start.offset }}-{{ currentError.location.end.offset }}</span>
                    <span> | </span>
                    <span></span>
                    <span>{{ currentError.location.start.line }}:{{ currentError.location.start.column }}-{{ currentError.location.end.line }}:{{ currentError.location.end.column }}</span>
                    <span>{{ currentError.found }}</span>
                    <span>{{ currentError.message }}</span>
                    <pre style="font-size:10px;">  - {{ currentError.expected.map(it => JSON.stringify(it.text)).join("\n  - ") }}</pre>
                </div>
                <div v-else>
                    <div>{{ currentError }}</div>
                </div>
            </div>
        </div>
    </div>
</div>`,
  props: {
    error: {
      type: [Object, Boolean],
      default: () => false
    },
    onClearError: {
      type: Function,
      default: () => {}
    }
  },
  data() {
    this.$trace("lsw-syntax-error-viewer.data");
    return {
      currentError: this.error,
    };
  },
  methods: {
    setError(error = undefined) {
      this.$trace("lsw-syntax-error-viewer.methods.setError");
      this.currentError = error;
      if(typeof error === "undefined") {
        this.onClearError();
      }
    },
  },
  watch: {},
  mounted() {
    try {
      this.$trace("lsw-syntax-error-viewer.mounted");
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswSyntaxErrorViewer API

// @vuebundler[Lsw_framework_components][180]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-syntax-error-viewer/lsw-syntax-error-viewer.css

// @vuebundler[Lsw_framework_components][181]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-tests-page/lsw-tests-page.html

// @vuebundler[Lsw_framework_components][181]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-tests-page/lsw-tests-page.js
// @code.start: LswTestsPage API | @$section: Vue.js (v2) Components  Lsw Unit Test Page  LswTestsPage component
Vue.component("LswTestsPage", {
  template: `<div class="lsw_tests_page">
    <div class="" v-if="initializationError">
        <lsw-error-box :error="initializationError" />
    </div>
    <div v-if="selectedSection === 'coverage'">
        <div class="typical_title_1">
            <div class="flex_row centered">
                <div class="flex_100"> Cobertura de cdigo</div>
                <div class="flex_1">
                    <button class="supermini" v-on:click="() => selectedSection = 'tests'"></button>
                </div>
            </div>
        </div>
    </div>
    <div v-show="selectedSection === 'tests'">
        <template v-if="choosenTester">
            <lsw-tester-viewer :tester="choosenTester" :tests-page="this" />
        </template>
        <template v-else>
             Un momento: el realizador de pruebas est en curso... 
        </template>
    </div>
    <div v-show="selectedSection === 'coverage'">
        <lsw-coverage-viewer />
    </div>
</div>`,
  props: {

  },
  data() {
    return {
      selectedSection: "coverage",
      initializationError: false,
      choosenTester: false,
    };
  },
  methods: {
    selectSection(subsection) {
      this.$trace("lsw-tests-page.methods.selectSection");
      this.selectedSection = subsection;
    },
    async initializeTester() {
      this.$trace("lsw-tests-page.methods.initializeTester");
      try {
        this.choosenTester = LswTester.create().define({
          id: "lsw.test.main",
          fromCollection: [{
            id: "lsw.test.main.intro",
            fromCallback: async function (context) {
              const { assert } = context;
              assert.as("some assertion").that(true);
              await LswDom.waitForMilliseconds(500);
              assert.as("some assertion").that(true);
              await LswDom.waitForMilliseconds(500);
              assert.as("some assertion").that(true);
              await LswDom.waitForMilliseconds(500);
              assert.as("some assertion").that(true);
              throw new Error("algo pas aqu")
              await LswDom.waitForMilliseconds(500);
              assert.as("some assertion").that(true);
              await LswDom.waitForMilliseconds(500);
              console.log("lsw.test.main.intro");
            },
          }, {
            id: "lsw.test.main.body",
            fromCollection: [{
              id: "lsw.test.main.body.check-globals",
              fromCallback: async function (context) {
                const { assert } = context;
                assert.as("some assertion").that(true);
                await LswDom.waitForMilliseconds(500);
                assert.as("some assertion").that(true);
                await LswDom.waitForMilliseconds(500);
                assert.as("some assertion").that(true);
                await LswDom.waitForMilliseconds(500);
                assert.as("some assertion").that(true);
                await LswDom.waitForMilliseconds(500);
                assert.as("some assertion").that(true);
                await LswDom.waitForMilliseconds(500);
                console.log("lsw.test.main.body.check-globals");
              }
            }, {
              id: "lsw.test.main.body.check-vue",
              fromCallback: async function (context) {
                const { assert } = context;
                assert.as("some assertion").that(true);
                await LswDom.waitForMilliseconds(500);
                assert.as("some assertion").that(true);
                await LswDom.waitForMilliseconds(500);
                assert.as("some assertion").that(true);
                await LswDom.waitForMilliseconds(500);
                assert.as("some assertion").that(true);
                await LswDom.waitForMilliseconds(500);
                assert.as("some assertion").that(true);
                await LswDom.waitForMilliseconds(500);
                console.log("lsw.test.main.body.check-vue");
              }
            }],
          }, {
            id: "lsw.test.main.end",
            fromCallback: async function (context) {
              const { assert } = context;
              assert.as("some assertion").that(true);
              await LswDom.waitForMilliseconds(500);
              assert.as("some assertion").that(true);
              await LswDom.waitForMilliseconds(500);
              assert.as("some assertion").that(true);
              await LswDom.waitForMilliseconds(500);
              assert.as("some assertion").that(true);
              await LswDom.waitForMilliseconds(500);
              assert.as("some assertion").that(true);
              await LswDom.waitForMilliseconds(500);
              console.log("lsw.test.main.end");
            },
          }]
        }).options({
          onAnything(event) {
            console.log("eventuated:", event);
          }
        });
      } catch (error) {
        this.initializationError = error;
        this.$lsw.toasts.showError(error);
        console.log(error);
        throw error;
      }
    }
  },
  watch: {},
  async mounted() {
    this.$trace("lsw-tests-page.mounted");
    await this.initializeTester();
  }
});
// @code.end: LswTestsPage API

// @vuebundler[Lsw_framework_components][181]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-tests-page/lsw-tests-page.css

// @vuebundler[Lsw_framework_components][182]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-tester-viewer/lsw-tester-viewer.html

// @vuebundler[Lsw_framework_components][182]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-tester-viewer/lsw-tester-viewer.js
// @code.start: LswTesterViewer API | @$section: Vue.js (v2) Components  Lsw Unit Test Page  LswTesterViewer component
const LswTesterViewerUtils = {};
LswTesterViewerUtils.getEventSourceId = function(eventData) {
  return eventData?.value?.id || "tester";
};
LswTesterViewerUtils.initModule = function(component, id) {
  if(!(id in component.states)) {
    component.states[id] = "not started";
  }
};
LswTesterViewerUtils.registerEvent = function(component, eventType, id, eventData) {
  LswTesterViewerUtils.initModule(component, id);
  Notify_new_state_to_tester: {
    if(eventType === "onStartModule") {
      component.states[id] = "started";
    } else if(eventType === "onSuccessModule") {
      component.states[id] = "passed";
      Notify_to_submodule: {
        const selector = `[data-test-module=${JSON.stringify(id)}]`;
        const moduleComponent = LswDom.findVue(selector, false, component.$refs.esquema_de_tests);
        if(!moduleComponent) {
          break Notify_new_state_to_tester;
        }
        moduleComponent.changeState("passed");
      }
    } else if(eventType === "onErrorModule") {
      component.states[id] = "failed";
      Notify_to_submodule: {
        const selector = `[data-test-module=${JSON.stringify(id)}]`;
        const moduleComponent = LswDom.findVue(selector, false, component.$refs.esquema_de_tests);
        if(!moduleComponent) {
          break Notify_new_state_to_tester;
        }
        moduleComponent.changeState("failed");
      }
    }
  }
  Append_assertion: {
    if((eventType === "onSuccessAssertion") || (eventType === "onErrorAssertion")) {
      const selector = `[data-test-module=${JSON.stringify(id)}]`;
      const moduleComponent = LswDom.findVue(selector, false, component.$refs.esquema_de_tests);
      if(!moduleComponent) {
        break Append_assertion;
      }
      moduleComponent.addAssertion({
        text: eventData.assertionText,
        result: eventData.assertionResult,
      });
    }
  }
};
Vue.component("LswTesterViewer", {
  template: `<div class="lsw_tester_viewer">
    <div class="typical_title_1 margin_bottom_1">
        <div class="flex_row centered">
            <div class="flex_100"> Tests de <b><u>{{ tester.\$composition.id }}</u></b></div>
            <div class="flex_1 pad_left_1" v-if="loadingError || runningError || isRun">
                <button class="supermini" v-on:click="resetTester"></button>
            </div>
            <div class="flex_1 pad_left_1" v-if="isCompleted && isSuccessfullyCompleted">
                <button class="supermini" disabled="true"> </button>
            </div>
            <div class="flex_1 pad_left_1" v-else-if="isCompleted && (!isSuccessfullyCompleted)">
                <button class="supermini" disabled="true"> </button>
            </div>
            <div class="flex_1 pad_left_1" v-if="loadingError || runningError">
                <button class="supermini" disabled="true"> Crashing</button>
            </div>
            <div class="flex_1 pad_left_1" v-if="(!isRun) && (!isStarted)">
                <button class="supermini" v-on:click="runTester"> </button>
            </div>
            <div class="flex_1 pad_left_1" v-if="(!isRun) && (isStarted)">
                <button class="supermini" v-on:click="runTester" disabled="true"> </button>
            </div>
            <div class="flex_1 pad_left_1">
                <button class="supermini" v-on:click="goToCoverage"></button>
            </div>
        </div>
    </div>
    <div v-if="isLoaded">
        <table class="width_100">
            <tbody>
                <tr>
                    <td class="nowrap" style="min-width: 114px;"># Identificador: </td>
                    <td class="width_100">{{ tester.\$composition.id }}</td>
                </tr>
                <tr>
                    <td class="nowrap"> Tipo: </td>
                    <td>{{ tester.\$composition.fromType }}</td>
                </tr>
                <tr>
                    <td class="nowrap"> Cargado: </td>
                    <td>{{ tester.\$isLoaded ? "s" : "no" }}</td>
                </tr>
                <tr>
                    <td class="nowrap"> Corrido: </td>
                    <td>{{ tester.\$isExecuted ? "s" : "no" }}</td>
                </tr>
                <tr>
                    <td class="nowrap"> En errores: </td>
                    <td>{{ tester.\$options.continueOnErrors ? 'continuar reportando errores' : 'interrumpir el test' }}</td>
                </tr>
                <tr>
                    <td class="nowrap" style="vertical-align: top;"> Submdulos: </td>
                    <td class="">
                        {{ Object.keys(tester.\$definitions).length }} submdulos
                        <span class="like_link dark"
                            :class="{activated:isShowingSubmodules}"
                            v-on:click="toggleSubmodules">(ver)</span>
                    </td>
                </tr>
                <tr v-show="isShowingSubmodules">
                    <td class="small_font" colspan="100">
                        <ul class="list_style_0">
                            <li v-for="definition, definitionId in Object.keys(tester.\$definitions)"
                                v-bind:key="'test_definition_id_' + definitionId">
                                 "{{ definition }}"
                            </li>
                        </ul>
                    </td>
                </tr>
                <template>
                    <tr class="pad_top_1">
                        <td class="nowrap">
                            <div class="pad_bottom_1"> Eventos del test: 
                        </td>
                        <td>
                            <span class="like_link dark"
                                :class="{activated:isShowingEventsConsole}"
                                v-on:click="toggleEventsConsole">(ver)</span>
                        </td>
                    </tr>
                    <tr class="pad_top_1" v-show="isShowingEventsConsole">
                        <td class="width_100" colspan="2">
                            <pre class="consola_de_eventos_de_test codeblock pad_1" style="max-height: 75px;" ref="eventsConsole">[Consola de eventos de tester]</pre>
                        </td>
                    </tr>
                </template>
                <tr class="pad_top_1">
                    <td class="nowrap">
                        <span> Fallos acumulados:</span>
                    </td>
                    <td>
                        <span>{{ currentErrors.length }}</span>
                        <span class="like_link dark"
                            :class="{activated:isShowingErrors}"
                            v-on:click="toggleErrors">(ver)</span>
                    </td>
                </tr>
            </tbody>
        </table>
        <div class="pad_left_1">
            <div class="pad_top_1" v-if="isShowingErrors">
                <div class="pad_left_2 pad_bottom_2" v-if="!currentErrors.length">
                    No hay errores acumulados.
                </div>
                <div class="errors_box" v-else>
                    <div v-for="event, eventIndex in currentErrors"
                        v-bind:key="'tester_error_' + eventIndex"
                        class="pad_top_1">
                        <template v-if="(typeof event.error === 'object') && event.error.name && event.error.message && event.error.stack">
                            <lsw-error-box
                                :error="event.error"
                                :context="'Error ' + (eventIndex+1) + ' en: ' + event.value.id + ''"
                            />
                        </template>
                        <template v-else>
                            {{ eventIndex }}. ({{ typeof event }}) {{ event }}
                        </template>
                    </div>
                </div>
            </div>
        </div>
        <div class="pad_left_1">
            <div class="pad_top_1"> Estado de tests: {{ currentState }}</div>
            <div class="esquema_de_tests" ref="esquema_de_tests">
                <lsw-tester-module-viewer
                    :test="tester.\$composition"
                    :tester="this"
                    :data-test-module="tester.\$composition.id"
                />
            </div>
        </div>
    </div>
    <div v-else>
        <div> El tester est siendo cargado. Un momento, por favor... </div>
    </div>
    <lsw-error-box
        v-if="loadingError"
        :error="loadingError"
        context="Fase de carga de tests"
        :on-clear-error="() => loadingError = false"
    />
    <lsw-error-box
        v-if="runningError"
        :error="runningError"
        context="Fase de ejecucin de tests"
        :on-clear-error="() => runningError = false"
    />
    <div v-if="isRun">
        <div v-if="isCompleted && isSuccessfullyCompleted">
            <button class="supermini width_100" disabled="true"> Tests correctos </button>
        </div>
        <div v-else-if="isCompleted && (!isSuccessfullyCompleted)">
            <button class="supermini width_100" disabled="true">  Tests fallando </button>
        </div>
    </div>
</div>`,
  props: {
    tester: {
      type: Object,
      required: true,
    },
    testsPage: {
      type: Object,
      default: () => false
    }
  },
  data() {
    return this.getInitialState();
  },
  methods: {
    getInitialState() {
      this.$trace("lsw-tests-page.methods.getInitialState");
      return {
        isRun: false,
        isStarted: false,
        isLoaded: false,
        isShowingSubmodules: false,
        isShowingErrors: false,
        isShowingEventsConsole: false,
        isSuccessfullyCompleted: false,
        currentErrors: [],
        loadingError: false,
        runningError: false,
        temporizer: LswTemporizer.create(),
        states: {},
      };
    },
    goToCoverage() {
      this.$trace("lsw-tests-page.methods.goToCoverage");
      if(this.testsPage) {
        this.testsPage.selectSection("coverage");
      }
    },
    addEvent(event, eventData) {
      this.$trace("lsw-tests-page.methods.addEvent");
      if(event.eventType === "onStartTester") {
        this.temporizer.start();
      } else if(event.eventType === "onEndTester") {
        this.isSuccessfullyCompleted = this.currentErrors.length === 0;
      } else if((event.eventType === "onErrorModule") || (event.eventType === "onErrorAssertion")) {
        this.currentErrors.push({
          errorType: event.eventType,
          ...eventData
        });
      }
      const id = LswTesterViewerUtils.getEventSourceId(eventData);
      The_magic_should_happen_mostly_here: {
        eventData.timeoff = this.temporizer.getTime();
        LswTesterViewerUtils.registerEvent(this, event.eventType, id, eventData);
      }
      this.$refs.eventsConsole.textContent = `>> ${id} > ${ event.eventType } @${eventData.timeoff}\n${ this.$refs.eventsConsole.textContent }`;
    },
    toggleEventsConsole() {
      this.$trace("lsw-tests-page.methods.toggleEventsConsole");
      this.isShowingEventsConsole = !this.isShowingEventsConsole;
    },
    toggleErrors() {
      this.$trace("lsw-tests-page.methods.toggleErrors");
      this.isShowingErrors = !this.isShowingErrors;
    },
    toggleSubmodules() {
      this.$trace("lsw-tests-page.methods.toggleSubmodules");
      this.isShowingSubmodules = !this.isShowingSubmodules;
    },
    validateTester() {
      this.$trace("lsw-tests-page.methods.validateTester");
      $ensure(this.tester).to.be.instanceOf(LswTester);
    },
    async loadTester() {
      this.$trace("lsw-tests-page.methods.loadTester");
      try {
        this.validateTester();
        await this.tester.options({}).load();
      } catch (error) {
        this.loadingError = error;
        this.$lsw.toasts.showError(error);
        console.log(error);
      } finally {
        this.isLoaded = true;
      }
    },
    async runTester() {
      this.$trace("lsw-tests-page.methods.runTester");
      try {
        this.isStarted = true;
        const viewer = this;
        await this.tester.options({
          trace: true,
          onAnything(event, ...args) {
            console.log("Notify to widget event:", event, args);
            viewer.addEvent(event, ...args);
          }
        }).run(1);
      } catch (error) {
        this.runningError = error;
        this.$lsw.toasts.showError(error);
        console.log(error);
      } finally {
        this.isRun = true;
      }
    },
    resetTester() {
      this.$trace("lsw-tests-page.methods.resetTester");
      LswDomIrruptor.abrirTestsDeAplicacion();
    }
  },
  watch: {},
  computed: {
    isSuccessfullyCompleted() {

    },
    isCompleted() {
      return this.tester.$isExecuted;
    },
    currentState() {
      return !this.isLoaded ? "to be loaded" :
        !this.isStarted ? "loaded" :
        !this.isRun ? "running" : "finished";
    }
  },
  async mounted() {
    this.$trace("lsw-tests-page.mounted");
    this.loadTester();
    window.testerviewer = this;
  }
});
// @code.end: LswTesterViewer API

// @vuebundler[Lsw_framework_components][182]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-tester-viewer/lsw-tester-viewer.css

// @vuebundler[Lsw_framework_components][183]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-tester-module-viewer/lsw-tester-module-viewer.html

// @vuebundler[Lsw_framework_components][183]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-tester-module-viewer/lsw-tester-module-viewer.js
// @code.start: LswTesterModuleViewer API | @$section: Vue.js (v2) Components  Lsw Unit Test Page  LswTesterModuleViewer component
window.asserters = [];
Vue.component("LswTesterModuleViewer", {
  template: `<div class="lsw_tester_module_viewer" keep-alive>
    <div class="flex_row centered">
        <div class="flex_1 pad_right_1">
            <div v-if="tester.states[test.id] === 'not started'"></div>
            <div v-else-if="tester.states[test.id] === 'started'"></div>
            <div v-else-if="tester.states[test.id] === 'ignored'"></div>
            <div v-else-if="tester.states[test.id] === 'passed'"></div>
            <div v-else-if="tester.states[test.id] === 'failed'"></div>
            <div v-else></div>
        </div>
        <div class="flex_100">
            {{ test.id }} <span class="smallest_font">[{{ test.fromType }}]</span>
        </div>
    </div>
    <ul class="list_style_1">
        <li v-for="assertion, assertionIndex in assertions"
            v-bind:key="'assertion_' + assertionIndex">
            <div class="">{{ assertion.result ? "" : "" }}: {{ assertion.text }} {{ assertion.timeoff }}</div>
        </li>
    </ul>
    <div v-if="test.fromType === 'collection'">
        <div v-for="submodule, submoduleIndex in test.fromCollection"
            v-bind:key="'test_module_' + submoduleIndex">
            <lsw-tester-module-viewer
                :test="submodule"
                :tester="tester"
                :data-test-module="submodule.id"
            />
        </div>
    </div>
    <div v-else-if="test.fromType === 'callback'">
        <!--div>Function test</div-->
    </div>
    <div v-else-if="test.fromType === 'url'">
        <!--div>URL test: {{ test.fromUrl }}</div-->
    </div>
    <div v-else-if="test.fromType === 'file'">
        <!--div>File test: {{ test.fromFile }}</div-->
    </div>
    <div v-else style="white-space: pre-wrap;">
        {{ test }}
    </div>
</div>`,
  props: {
    tester: {
      type: Object,
      required: true,
    },
    test: {
      type: Object,
      required: true,
    }
  },
  data() {
    return {
      state: "not started", // "started", "ignored", "passed" or "failed"
      assertions: [],
    };
  },
  methods: {
    addAssertion(assertionData) {
      this.$trace("lsw-tester-module-viewer.methods.addAssertion");
      this.assertions = [].concat(this.assertions).concat([assertionData]);
      this.$forceUpdate(true);
    },
    changeState(newState) {
      this.$trace("lsw-tester-module-viewer.methods.changeState");
      this.state = newState;
      this.$forceUpdate(true);
    }
  },
  watch: {},
  async mounted() {
    this.$trace("lsw-tests-page.mounted");
    asserters.push(this);
  }
});
// @code.end: LswTesterModuleViewer API

// @vuebundler[Lsw_framework_components][183]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-tester-module-viewer/lsw-tester-module-viewer.css

// @vuebundler[Lsw_framework_components][184]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-js-viewer/lsw-js-viewer.html

// @vuebundler[Lsw_framework_components][184]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-js-viewer/lsw-js-viewer.js
// @code.start: LswJsViewer API | @$section: Vue.js (v2) Components  Lsw SchemaBasedForm API  LswJsViewer component
Vue.component("LswJsViewer", {
  template: `<div class="lsw_js_viewer">
    <div class="position_relative">
        <div class="position_absolute_fixed" style="left: auto; right: 7px; top: 7px;">
            <button class="supermini"
                :class="{activated:isExpanded}"
                v-on:click="toggleExpansion">
                
            </button>
        </div>
        <div v-if="isLoaded"
            class="js_viewer_tag hljs"
            :class="isExpanded ? 'expanded' : ''"
            ref="sourceTag"
            v-on:dblclick="toggleExpansion">{{ beautifiedSource || source }}</div>
        <div class="pad_1" v-else>
            Cargando...
        </div>
    </div>
</div>`,
  props: {
    source: {
      type: String,
      required: true,
    },
  },
  data() {
    this.$trace("lsw-js-viewer.data");
    return {
      isLoaded: false,
      isExpanded: false,
      beautifiedSource: false,
    };
  },
  methods: {
    toggleExpansion() {
      this.isExpanded = !this.isExpanded;
    },
    async load() {
      await LswLazyLoads.loadHighlightJs();
      await LswLazyLoads.loadBeautifier();
      try {
        this.beautifiedSource = beautifier.js(this.source);
      } catch (error) {
        // @BADLUCK!
        this.beautifiedSource = this.source;
      } finally {
        this.isLoaded = true;
      }
      this.$nextTick(() => {
        hljs.highlightElement(this.$refs.sourceTag);
      });
    }
  },
  watch: {},
  async mounted() {
    try {
      this.$trace("lsw-js-viewer.mounted");
      await this.load();
    } catch (error) {
      console.log(error);
    }
  }
});
// @code.end: LswJsViewer API

// @vuebundler[Lsw_framework_components][184]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-js-viewer/lsw-js-viewer.css

// @vuebundler[Lsw_framework_components][185]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-android/lsw-android.js
(function (factory) {
  const mod = factory();
  if (typeof window !== 'undefined') {
    window['LswAndroid'] = mod;
  }
  if (typeof global !== 'undefined') {
    global['LswAndroid'] = mod;
  }
  if (typeof module !== 'undefined') {
    module.exports = mod;
  }
})(function () {
  
  const LswAndroid = class {

    static handleError(error) {
      Vue.prototype.$lsw.toasts.showError(error);
    }

    static async evalFile(filepath) {
      Vue.prototype.$trace("LswAndroid.evalFile");
      if(typeof cordova === "undefined") {
        throw new Error("Required cordova api on LswAndroid.evalFile");
      }
      const fileContents = await Vue.prototype.$lsw.fs.read_file(filepath);
      return await this.eval(fileContents);
    }

    static async eval(callbackOrCode) {
      Vue.prototype.$trace("LswAndroid.eval");
      if(typeof cordova === "undefined") {
        throw new Error("Required cordova api on LswAndroid.eval");
      }
      const fileContents = (typeof callbackOrCode === "function") ? `(${callbackOrCode.toString()})()` : callbackOrCode;
      try {
        await LswLazyLoads.loadBabel();
        const es6code = fileContents;
        const es5code = Babel.transform(es6code, {
          presets: []
        }).code;
        Vue.prototype.$lsw.toasts.send({
          title: "Evaluating android/rhino:",
          text: es5code,
        });
        cordova.plugins.Rhinobridge.evaluate(es5code);
        Vue.prototype.$lsw.toasts.send({
          title: "Android eval ok",
          text: "It terminated normally",
        });
      } catch (error) {
        this.handleError(error);
      }
    }

  }

  return LswAndroid;

});

// @vuebundler[Lsw_framework_components][186]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Accion.js
$proxifier.define("org.allnulled.lsw-conductometria.Accion", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Accion@SchemaEntity";
    }
    static getName() {
      return "Accion";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        en_concepto: {
          refersTo: {
            entity: "org.allnulled.lsw-conductometria.Concepto@SchemaEntity",
            table: "Concepto",
            property: "tiene_nombre",
            constraint: false,
          },
          isType: "ref-object-by-label",
          isFormType: "ref-object-by-label",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator(v) {
            if(v.trim() === '') throw new Error("Cannot be empty");
          },
          hasFormatter: false,
          hasLabel: "En concepto de:",
          hasDescription: "Nombre del concepto al que se atribuye la impresin",
          hasPlaceholder: "Ej: Correr",
          hasExtraAttributes: {},
        },
        tiene_estado: {
          isType: "text",
          isFormType: "options",
          isIndexed: true,
          hasFormtypeParameters: {
            type: "selector",
            available: ["pendiente", "completada", "fallida", "trackeada"],
            selectable: 1, // could be: number or "*" to all options
          },
          hasValidator(v) {
            if(v === "fallida") {
              throw new Error("No losers, por favor");
            }
          },
          hasDefaultValue: "pendiente",
          hasFormatter: false,
          hasLabel: "Tiene estado:",
          hasDescription: "Estado en el que se encuentra la accin. Puede ser pendiente, completada o fallida",
          hasPlaceholder: false,
          hasExtraAttributes: {},
        },
        tiene_inicio: {
          isType: "text",
          isFormType: "date",
          isFormSubtype: "datetime",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator: function (v) {
            LswTimer.utils.isDatetimeOrThrow(v);
          },
          hasFormatter: function (v) {
            return LswTimer.utlis.getDateFromMomentoText(v);
          },
          hasLabel: "Tiene inicio:",
          hasDescription: "Momento en que empieza la accin",
          hasPlaceholder: false,
          hasExtraAttributes: {},
        },
        tiene_duracion: {
          isType: "text",
          isFormType: "duration",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasDefaultValue: "1h",
          hasValidator(v) {
            LswTimer.utils.isDurationOrThrow(v);
          },
          hasFormatter(v) {
            return LswTimer.parser.parse(v)[0];
          },
          hasLabel: "Tiene duracin:",
          hasDescription: "Cantidad de tiempo que dura la accin",
          hasPlaceholder: "Ej: 1h 20min",
          hasExtraAttributes: {},
        },
        tiene_parametros: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene parmetros:",
          hasDescription: "",
          hasPlaceholder: "Ej: leche, trigo, arroz",
          hasExtraAttributes: {},
        },
        tiene_resultados: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene resultados:",
          hasDescription: "Resultados notorios asociados a esta accin",
          hasPlaceholder: "Ej:\n- Cog fuerzas hasta el almuerzo\n- Disfrut de un buen desayuno",
          hasExtraAttributes: {},
        },
        tiene_comentarios: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene comentarios:",
          hasDescription: "Comentarios asociados a esta accin",
          hasPlaceholder: "Esta accin me tom varios intentos porque...",
          hasExtraAttributes: {},
        }
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Accion@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "accin"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][187]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Banco_de_datos_principal.js
$proxifier.define("org.allnulled.lsw-conductometria.Banco_de_datos_principal", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Banco_de_datos_principal@SchemaEntity";
    }
    static getName() {
      return "Banco_de_datos_principal";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        datatype: {
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tipo de dato:",
          hasDescription: "El tipo de dato asociado al concepto",
          hasPlaceholder: "Ej: persona, empresa, pas, idioma, idea, categora abstracta (lo que quieras)",
          hasExtraAttributes: {},
        }
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Banco_de_datos_principal@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "concepto"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][188]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Accion_virtual.js
$proxifier.define("org.allnulled.lsw-conductometria.Accion_virtual", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Accion_virtual@SchemaEntity";
    }
    static getName() {
      return "Accion_virtual";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        en_concepto: {
          refersTo: {
            entity: "org.allnulled.lsw-conductometria.Concepto@SchemaEntity",
            table: "Concepto",
            property: "tiene_nombre",
            constraint: false,
          },
          isType: "ref-object",
          isFormType: "ref-object",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator(v) {
            if(v.trim() === '') throw new Error("Cannot be empty");
          },
          hasFormatter: false,
          hasLabel: "En concepto de:",
          hasDescription: "Nombre del concepto al que se atribuye la impresin",
          hasPlaceholder: "Ej: Correr",
          hasExtraAttributes: {},
        },
        tiene_estado: {
          isType: "text",
          isFormType: "options",
          isIndexed: true,
          hasFormtypeParameters: {
            type: "selector",
            available: ["pendiente", "completada", "fallida"],
            selectable: 1, // could be: number or "*" to all options
          },
          hasValidator(v) {
            if(v === "fallida") {
              throw new Error("No losers, por favor");
            }
          },
          hasDefaultValue: "pendiente",
          hasFormatter: false,
          hasLabel: "Tiene estado:",
          hasDescription: "Estado en el que se encuentra la accin virtual. Puede ser pendiente, completada o fallida",
          hasPlaceholder: false,
          hasExtraAttributes: {},
        },
        tiene_inicio: {
          isType: "text",
          isFormType: "date",
          isFormSubtype: "datetime",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator: function (v) {
            LswTimer.utils.isDatetimeOrThrow(v);
          },
          hasFormatter: function (v) {
            return LswTimer.utlis.getDateFromMomentoText(v);
          },
          hasLabel: "Tiene inicio:",
          hasDescription: "Momento en que empieza la accin virtual",
          hasPlaceholder: false,
          hasExtraAttributes: {},
        },
        tiene_duracion: {
          isType: "text",
          isFormType: "duration",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasDefaultValue: "1h",
          hasValidator(v) {
            LswTimer.utils.isDurationOrThrow(v);
          },
          hasFormatter(v) {
            return LswTimer.parser.parse(v)[0];
          },
          hasLabel: "Tiene duracin:",
          hasDescription: "Cantidad de tiempo que dura la accin virtual",
          hasPlaceholder: "Ej: 1h 20min",
          hasExtraAttributes: {},
        },
        tiene_parametros: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene parmetros:",
          hasDescription: "",
          hasPlaceholder: "Ej: leche, trigo, arroz",
          hasExtraAttributes: {},
        },
        tiene_resultados: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene resultados:",
          hasDescription: "Resultados notorios asociados a esta accin virtual",
          hasPlaceholder: "Ej:\n- Cog fuerzas hasta el almuerzo\n- Disfrut de un buen desayuno",
          hasExtraAttributes: {},
        },
        tiene_comentarios: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene comentarios:",
          hasDescription: "Comentarios asociados a esta accin virtual",
          hasPlaceholder: "Esta accin virtual me tom varios intentos porque...",
          hasExtraAttributes: {},
        }
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Accion_virtual@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "accin virtual"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][189]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Concepto.js
$proxifier.define("org.allnulled.lsw-conductometria.Concepto", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Concepto@SchemaEntity";
    }
    static getName() {
      return "Concepto";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        tiene_nombre: {
          refersTo: false,
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          isUnique: true,
          hasValidator(v) {
            if(v.trim() === '') throw new Error("Cannot be empty");
          },
          hasFormatter: false,
          hasLabel: "Nombre nico del concepto:",
          hasDescription: "Nombre del concepto en s",
          hasPlaceholder: "Ej: Desayunar",
          hasExtraAttributes: {}
        },
        tiene_comentarios: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene comentarios:",
          hasDescription: "Comentarios asociados a este concepto",
          hasPlaceholder: "Ej: este concepto puede ser ambiguo porque...",
          hasExtraAttributes: {},
        }
      }
    }
    static getExternalProperties() {
      return {
        tiene_limitadores: {
          isType: "ref-list",
          refersTo: {
            entity: "org.allnulled.lsw-conductometria.Limitador@SchemaEntity",
            table: "Limitador",
            property: "id",
          },
          hasLabel: "Tiene limitadores",
          hasDescription: "Limitadores asociados a este concepto",
          hasPlaceholder: ""
        }
      };
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Concepto@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "concepto"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][190]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Categoria_de_concepto.js
$proxifier.define("org.allnulled.lsw-conductometria.Categoria_de_concepto", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Categoria_de_concepto@SchemaEntity";
    }
    static getName() {
      return "Categoria_de_concepto";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        tiene_nombre: {
          refersTo: false,
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          isUnique: true,
          hasValidator(v) {
            if(v.trim() === '') throw new Error("Cannot be empty");
          },
          hasFormatter: false,
          hasLabel: "Nombre de la categora de concepto:",
          hasDescription: "Una categora es una agrupacin de conceptos desde una perspectiva de rea o campo de conocimiento.",
          hasPlaceholder: "Ej: Programacin",
          hasExtraAttributes: {}
        },
        tiene_descripcion: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene descripcin:",
          hasDescription: "Descripcin de la categora de conceptos con ms detalle.",
          hasPlaceholder: "La programacin es el campo de...",
          hasExtraAttributes: {},
        }
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Categoria_de_concepto@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "concepto"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][191]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Propagador_prototipo.js
$proxifier.define("org.allnulled.lsw-conductometria.Propagador_prototipo", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Propagador_prototipo@SchemaEntity";
    }
    static getName() {
      return "Propagador_prototipo";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        tiene_nombre: {
          refersTo: false,
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          isUnique: true,
          hasValidator(v) {
            if(v.trim() === '') throw new Error("Cannot be empty");
          },
          hasFormatter: false,
          hasLabel: "Nombre nico del propagador prototipo:",
          hasDescription: "Nombre del propagador prototipo en s",
          hasPlaceholder: "Ej: al desayunar",
          hasExtraAttributes: {}
        },
        tiene_funcion: {
          isType: "text",
          isFormType: "code",
          isIndexed: false,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene funcin:",
          hasDescription: "Cdigo JavaScript asociado al propagador prototipo",
          hasPlaceholder: "console.log('Hello from propagador', arguments)",
          hasExtraAttributes: {},
        },
        tiene_parametros: {
          isType: "text",
          isFormType: "code",
          isIndexed: false,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene parmetros:",
          hasDescription: "Array de strings en JSON para los parmetros de la funcin (raw injection)",
          hasPlaceholder: "argument0, argument1, argument2",
          hasExtraAttributes: {},
        }
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Propagador_prototipo@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "propagador prototipo"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][192]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Propagador_de_concepto.js
$proxifier.define("org.allnulled.lsw-conductometria.Propagador_de_concepto", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Propagador_de_concepto@SchemaEntity";
    }
    static getName() {
      return "Propagador_de_concepto";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        tiene_propagador_prototipo: {
          refersTo: {
            entity: "org.allnulled.lsw-conductometria.Propagador_prototipo@SchemaEntity",
            table: "Propagador_prototipo",
            property: "tiene_nombre",
            constraint: false,
          },
          isType: "ref-object",
          isFormType: "ref-object",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator(v) {
            if(v.trim() === '') throw new Error("Cannot be empty");
          },
          hasFormatter: false,
          hasLabel: "Propagador prototipo:",
          hasDescription: "Nombre del propagador prototipo que tiene la funcin propagativa correspondiente a esta propagacin de concepto concreta",
          hasPlaceholder: "Ej: al desayunar",
          hasExtraAttributes: {},
        },
        tiene_concepto_disparador: {
          refersTo: {
            entity: "org.allnulled.lsw-conductometria.Concepto@SchemaEntity",
            table: "Concepto",
            property: "tiene_nombre",
            constraint: false,
          },
          isType: "ref-object",
          isFormType: "ref-object",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator(v) {
            if(v.trim() === '') throw new Error("Cannot be empty");
          },
          hasFormatter: false,
          hasLabel: "Tiene concepto disparador:",
          hasDescription: "Nombre del concepto disparador en esta relacin propagativa",
          hasPlaceholder: "Ej: Desayunar",
          hasExtraAttributes: {},
        },
        tiene_concepto_destino: {
          refersTo: {
            entity: "org.allnulled.lsw-conductometria.Concepto@SchemaEntity",
            table: "Concepto",
            property: "tiene_nombre",
            constraint: false,
          },
          isType: "ref-object",
          isFormType: "ref-object",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator(v) {
            if(v.trim() === '') throw new Error("Cannot be empty");
          },
          hasFormatter: false,
          hasLabel: "Tiene concepto destino:",
          hasDescription: "Nombre del concepto destino en esta relacin propagativa",
          hasPlaceholder: "Ej: Recuperar energa",
          hasExtraAttributes: {},
        },
        tiene_parametros: {
          isType: "text",
          isFormType: "code",
          isIndexed: false,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene parmetros:",
          hasDescription: "Array de valores en JSON para los parmetros de la funcin (raw injection)",
          hasPlaceholder: "\"concept-x\", 2, [], {}",
          hasExtraAttributes: {},
        },
        tiene_parametros_extra: {
          isType: "text",
          isFormType: "code",
          isIndexed: false,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene parmetros extra:",
          hasDescription: "JavaScript con los parmetros extra (raw injection)",
          hasPlaceholder: "{msg:0}, 500, function() {}",
          hasExtraAttributes: {},
        },
        tiene_codigo: {
          isType: "text",
          isFormType: "code",
          isIndexed: false,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene cdigo directo:",
          hasDescription: "Cdigo JavaScript que se usar directo como propagador",
          hasPlaceholder: "{}",
          hasExtraAttributes: {},
        }
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Propagador_de_concepto@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "Propagador de concepto"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][193]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Limitador.js
$proxifier.define("org.allnulled.lsw-conductometria.Limitador", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Limitador@SchemaEntity";
    }
    static getName() {
      return "Limitador";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        en_concepto: {
          refersTo: {
            entity: "org.allnulled.lsw-conductometria.Concepto@SchemaEntity",
            table: "Concepto",
            property: "tiene_nombre",
            constraint: false,
          },
          isType: "ref-object",
          isFormType: "ref-object",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator(v) {
            if(v.trim() === '') throw new Error("Cannot be empty");
          },
          hasFormatter: false,
          hasLabel: "En concepto de:",
          hasDescription: "Nombre del concepto al que se atribuye el limitador",
          hasPlaceholder: "Ej: Dormir",
          hasExtraAttributes: {},
        },
        tiene_funcion: {
          isType: "text",
          isFormType: "code",
          isIndexed: false,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene funcin:",
          hasDescription: "Cdigo JavaScript asociado al limitador",
          hasPlaceholder: "...",
          hasExtraAttributes: {},
        },
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Limitador@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "limitador"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][194]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Impresion.js
$proxifier.define("org.allnulled.lsw-conductometria.Impresion_de_concepto", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Impresion_de_concepto@SchemaEntity";
    }
    static getName() {
      return "Impresion_de_concepto";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        en_concepto: {
          refersTo: {
            entity: "org.allnulled.lsw-conductometria.Concepto@SchemaEntity",
            table: "Concepto",
            property: "tiene_nombre",
            constraint: false,
          },
          isType: "ref-object",
          isFormType: "ref-object",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator(v) {
            if(v.trim() === '') throw new Error("Cannot be empty");
          },
          hasFormatter: false,
          hasLabel: "En concepto de:",
          hasDescription: "Nombre del concepto al que se atribuye la impresin",
          hasPlaceholder: "Ej: Correr",
          hasExtraAttributes: {},
        },
        tiene_valores: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene valores:",
          hasDescription: "Valores asociados a esta impresin",
          hasPlaceholder: "Ej: 1000p, 50h",
          hasExtraAttributes: {},
        },
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Impresion_de_concepto@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "impresin de concepto"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][195]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Nota.js
$proxifier.define("org.allnulled.lsw-conductometria.Nota", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Nota@SchemaEntity";
    }
    static getName() {
      return "Nota";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        tiene_titulo: {
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene ttulo:",
          hasDescription: "El ttulo que se asociar a la nota",
          hasPlaceholder: "Ttulo de la nota",
          hasExtraAttributes: {},
        },
        tiene_fecha: {
          isType: "text",
          isFormType: "date",
          isFormSubtype: "datetime",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator: function (v) {
            LswTimer.utils.isDatetimeOrThrow(v);
          },
          hasFormatter: function (v) {
            return LswTimer.utlis.getDateFromMomentoText(v);
          },
          hasLabel: "Tiene fecha:",
          hasDescription: "Momento en que se cre la nota",
          hasPlaceholder: false,
          hasExtraAttributes: {},
        },
        tiene_categorias: {
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene categorias:",
          hasDescription: "El categoras de esta nota, separadas por ; entre s.",
          hasPlaceholder: "Categora 1; categora 2; categora 3",
          hasExtraAttributes: {},
        },
        tiene_estado: {
          isType: "text",
          isFormType: "options",
          isIndexed: true,
          hasFormtypeParameters: {
            type: "selector",
            available: ["", "creada", "urgente", "dudosa", "procesada", "desestimada"],
            selectable: 1, // could be: number or "*" to all options
            defaultValue: "",
          },
          hasValidator(v) {
            
          },
          hasFormatter: false,
          hasLabel: "Tiene estado:",
          hasDescription: "Estado de la nota. Puede ser creada, procesada, dudosa o desestimada",
          hasPlaceholder: false,
          hasExtraAttributes: {},
        },
        tiene_contenido: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene contenido:",
          hasDescription: "El contenido de esta nota. Permite markdown.",
          hasPlaceholder: "El **contenido** de tu nota o artculo.",
          hasExtraAttributes: {},
        }
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Nota@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "nota"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][196]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Automensaje.js
$proxifier.define("org.allnulled.lsw-conductometria.Automensaje", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Automensaje@SchemaEntity";
    }
    static getName() {
      return "Automensaje";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        tiene_contenido: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene contenido:",
          hasDescription: "El contenido de este automensaje. Permite markdown.",
          hasPlaceholder: "El **contenido** de tu automensaje o artculo.",
          hasExtraAttributes: {},
        }
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Automensaje@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "automensaje"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][197]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Lista.js
$proxifier.define("org.allnulled.lsw-conductometria.Lista", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Lista@SchemaEntity";
    }
    static getName() {
      return "Lista";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        tiene_titulo: {
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene ttulo:",
          hasDescription: "El ttulo que se asociar a la lista",
          hasPlaceholder: "Ttulo de la lista",
          hasExtraAttributes: {},
        },
        tiene_fecha: {
          isType: "text",
          isFormType: "date",
          isFormSubtype: "datetime",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator: function (v) {
            LswTimer.utils.isDatetimeOrThrow(v);
          },
          hasFormatter: function (v) {
            return LswTimer.utlis.getDateFromMomentoText(v);
          },
          hasLabel: "Tiene fecha:",
          hasDescription: "Momento en que se cre la lista",
          hasPlaceholder: false,
          hasExtraAttributes: {},
        },
        tiene_categorias: {
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene categorias:",
          hasDescription: "El categoras de esta lista, separadas por ; entre s.",
          hasPlaceholder: "Categora 1; categora 2; categora 3",
          hasExtraAttributes: {},
        },
        tiene_estado: {
          isType: "text",
          isFormType: "options",
          isIndexed: true,
          hasFormtypeParameters: {
            type: "selector",
            available: ["creada", "procesada", "dudosa", "desestimada"],
            selectable: 1, // could be: number or "*" to all options
            defaultValue: "creada",
          },
          hasValidator(v) {
            
          },
          hasFormatter: false,
          hasLabel: "Tiene estado:",
          hasDescription: "Estado de la lista. Puede ser creada, procesada, dudosa o desestimada",
          hasPlaceholder: false,
          hasExtraAttributes: {},
        },
        tiene_contenido: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene contenido:",
          hasDescription: "El contenido de esta lista. Permite markdown.",
          hasPlaceholder: "El **contenido** de tu lista.",
          hasExtraAttributes: {},
        }
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Lista@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "lista"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][198]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Recordatorio.js
$proxifier.define("org.allnulled.lsw-conductometria.Recordatorio", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Recordatorio@SchemaEntity";
    }
    static getName() {
      return "Recordatorio";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        tiene_titulo: {
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene ttulo:",
          hasDescription: "El ttulo que se asociar a el recordatorio",
          hasPlaceholder: "Ttulo del recordatorio",
          hasExtraAttributes: {},
        },
        tiene_fecha: {
          isType: "text",
          isFormType: "date",
          isFormSubtype: "datetime",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator: function (v) {
            LswTimer.utils.isDatetimeOrThrow(v);
          },
          hasFormatter: function (v) {
            return LswTimer.utlis.getDateFromMomentoText(v);
          },
          hasLabel: "Tiene fecha:",
          hasDescription: "Momento en que se cre el recordatorio",
          hasPlaceholder: false,
          hasExtraAttributes: {},
        },
        tiene_categorias: {
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene categorias:",
          hasDescription: "El categoras de este recordatorio, separadas por ; entre s.",
          hasPlaceholder: "Categora 1; categora 2; categora 3",
          hasExtraAttributes: {},
        },
        tiene_contenido: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene contenido:",
          hasDescription: "El contenido de este recordatorio. Permite markdown.",
          hasPlaceholder: "El **contenido** de tu recordatorio.",
          hasExtraAttributes: {},
        }
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Recordatorio@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "recordatorio"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][199]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxies/Articulo.js
$proxifier.define("org.allnulled.lsw-conductometria.Articulo", {
  Item: class extends $proxifier.AbstractItem {

  },
  List: class extends $proxifier.AbstractList {

  },
  SchemaEntity: class extends $proxifier.AbstractSchemaEntity {
    static getEntityId() {
      return "org.allnulled.lsw-conductometria.Articulo@SchemaEntity";
    }
    static getName() {
      return "Articulo";
    }
    static getVersion() {
      return "1.0.0";
    }
    static getMethods() {
      return {};
    }
    static getProperties() {
      return {
        tiene_titulo: {
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          hasValidator(v) {
            if(v.trim() === "") {
              throw new Error("Ttulo no puede estar vaco");
            }
          },
          hasFormatter: false,
          hasLabel: "Tiene ttulo:",
          hasDescription: "El ttulo que se asociar a el artculo",
          hasPlaceholder: "Ttulo de el artculo",
          hasExtraAttributes: {},
        },
        tiene_fecha: {
          isType: "text",
          isFormType: "date",
          isFormSubtype: "datetime",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator: function (v) {
            LswTimer.utils.isDatetimeOrThrow(v);
          },
          hasFormatter: function (v) {
            return LswTimer.utlis.getDateFromMomentoText(v);
          },
          hasInitialValue: function() {
            return LswTimer.utils.fromDateToDatestring(new Date(), false, false, true);
          },
          hasLabel: "Tiene fecha:",
          hasDescription: "Momento en que se cre el artculo",
          hasPlaceholder: false,
          hasExtraAttributes: {},
        },
        tiene_categorias: {
          isType: "text",
          isFormType: "text",
          isIndexed: true,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene categorias:",
          hasDescription: "El categoras de este artculo, separadas por ; entre s.",
          hasPlaceholder: "Categora 1; categora 2; categora 3",
          hasExtraAttributes: {},
        },
        tiene_contenido: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene contenido:",
          hasDescription: "El contenido de este artculo. Permite markdown.",
          hasPlaceholder: "El **contenido** de tu artculo o artculo.",
          hasExtraAttributes: {},
        },
        tiene_garantia: {
          isType: "text",
          isFormType: "options",
          isIndexed: true,
          hasFormtypeParameters: {
            type: "selector",
            available: ["muy inestable", "inestable", "ns/nc", "estable", "muy estable", "popular"],
            selectable: 1, // could be: number or "*" to all options
            defaultValue: "ns/nc",
          },
          hasInitialValue: function() {
            return "ns/nc";
          },
          hasValidator(v) {
            
          },
          hasFormatter: false,
          hasLabel: "Tiene garanta:",
          hasDescription: "Garanta de verdad del artculo. Puede ser muy inestable, inestable, ns/nc, estable, muy estable, popular",
          hasPlaceholder: false,
          hasExtraAttributes: {},
        },
        tiene_tags: {
          isType: "text",
          isFormType: "long-text",
          isIndexed: false,
          hasFormtypeParameters: {},
          hasValidator(v) {
            // Ok.
          },
          hasFormatter: false,
          hasLabel: "Tiene tags:",
          hasDescription: "Una lnea por cada tag",
          hasPlaceholder: "tag 1\ntag 2\ntag 3",
          hasExtraAttributes: {},
        },
      }
    }
    static getVirtualizerId() {
      return "org.allnulled.lsw-conductometria.Articulo@Virtualizer";
    }
    static getFormSettings() {
      return {};
    }
    static getExtraAttributes() {
      return {
        readableName: "artculo"
      };
    }
  },
  Virtualizer: class extends $proxifier.AbstractVirtualizer {

  }
});

// @vuebundler[Lsw_framework_components][200]=/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/lsw-api.js


// @vuebundler[Lsw_framework_components][201]=/home/carlos/Escritorio/lsw-one/src/modules/app/app.html

// @vuebundler[Lsw_framework_components][201]=/home/carlos/Escritorio/lsw-one/src/modules/app/app.js
(() => {
  let isFirstTime = true;
  const initialCode = `
inc /wherever/you/choose.proto

def correr {
  "definicion": @definicion "Correr es tal"
}

add 2025/01/01
  00:00 correr * 1h
  00:00 saltar * 5min
  00:00 comer * @alimentos [["leche","0.3L"],["cacao","2g"]]

fun yo.correr {
  // Nolose, aqu JS.
}

rel correr
  > cardio * 2
  >> yo.correr

`.trim();
  // Change this component at your convenience:
  Vue.component("App", {
    template: `<div class="app app_component position_relative">
    <lsw-automensajes-viewer ref="desktop" />
    <div class="home_bottom_panel">
        <button class="" v-on:click="goToEventTracker"></button>
        <button class="" v-on:click="goToAddArticulo">+</button>
        <button class="" v-on:click="goToAddNota">+</button>
        <!--button class="" v-on:click="goToCalendario"></button>
        <button class="" v-on:click="goToAddArticulo">+ </button>
        <button class="" v-on:click="goToAddRecordatorio">+ </button-->
    </div>
    <lsw-console-hooker />
    <lsw-windows-viewer />
    <lsw-debugger />
    <lsw-toasts />
    <div class="home_mobile_off_panel_container">
        <div class="home_mobile_off_panel">
            <!--div class="mobile_off_panel_cell" v-on:click="clickPicas"></div-->
            <div class="mobile_off_panel_cell" v-on:click="goToEventTracker">
                <div class="mobile_off_panel_button"></div>
            </div>
            <div class="mobile_off_panel_cell" v-on:click="goToFilesystem">
                <div class="mobile_off_panel_button"></div>
            </div>
            <div class="mobile_off_panel_cell" v-on:click="goToCalendario">
                <div class="mobile_off_panel_button"></div>
            </div>
            <div class="mobile_off_panel_cell" v-on:click="goToEnciclopedia">
                <div class="mobile_off_panel_button"></div>
            </div>
            <div class="mobile_off_panel_cell" v-on:click="goToNotas">
                <div class="mobile_off_panel_button"></div>
            </div>
        </div>
    </div>
    <lsw-clockwatcher />
    <div style="min-height: 100px;"></div>
</div>`,
    props: {
      uuid: {
        type: String,
        default: () => {
          return Vue.prototype.$lsw.utils.getRandomString(10);
        }
      }
    },
    data() {
      return {
        isMounted: false,
        formScope: {},
        userScope: {},
        conductometria: [],
        conductometria_minified_days: [],
        initialContents: initialCode
      };
    },
    methods: {
      goToDocs() {
        this.$trace("App.methods.goToDocs");
        const confirmation = this.$window.confirm("Saldrs de la aplicacin con una pestaa nueva, y es un poco incmodo. Ests seguro?");
        if(!confirmation) return;
        this.$window.open("reference/index.html");
      },
      async resetDatabase() {
        this.$trace("App.methods.resetDatabase");
        const confirmacion = this.$window.confirm("Ests seguro que quieres resetear la base de datos?");
        if(!confirmacion) return;
        const reconfirmacion = this.$window.confirm("Seguro, eh?");
        if(!reconfirmacion) return;
        try {
          await this.$lsw.database.close();
        } catch (error) {
          console.log(error);
        }
        try {
          await LswDatabase.deleteDatabase("lsw_default_database");
        } catch (error) {
          console.log(error);
        }
        try {
          this.$lsw.database = await LswDatabase.open("lsw_default_database");
        } catch (error) {
          console.log(error);
        }
      },
      minimizeDialogs() {
        this.$trace("App.methods.minimizeDialogs");
        this.$lsw.dialogs.minimizeAll();
      },
      goToAddNota() {
        this.$trace("App.methods.goToAddNota");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("nueva nota");
      },
      goToAddArticulo() {
        this.$trace("App.methods.goToAddArticulo");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("nuevo articulo");
      },
      goToAddRecordatorio() {
        this.$trace("App.methods.goToAddRecordatorio");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("nuevo recordatorio");
      },
      goToAddAccion() {
        this.$trace("App.methods.goToAddAccion");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("nueva accion");
      },
      goToCalendario() {
        this.$trace("App.methods.goToCalendario");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("calendario");
      },
      goToDesktop() {
        this.$trace("App.methods.goToDesktop");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("none");
      },
      goToNotas() {
        this.$trace("App.methods.goToNotas");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("notas");
      },
      goToEnciclopedia() {
        this.$trace("App.methods.goToEnciclopedia");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("enciclopedia");
      },
      clickPicas() {
        this.$trace("App.methods.clickPicas");
        this.minimizeDialogs();
        document.querySelector("#the_picas_button").click();
      },
      goToBinaries() {
        this.$trace("App.methods.goToBinaries");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("binarios");
      },
      goToHomepage() {
        this.$trace("App.methods.goToHomepage");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("homepage");
      },
      goToFilesystem() {
        this.$trace("App.methods.goToFilesystem");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("sistema de ficheros");
      },
      goToEventTracker() {
        this.$trace("App.methods.goToEventTracker");
        this.minimizeDialogs();
        this.$refs.desktop.selectApplication("event-tracker");
      },
      async initializeFilesystemForLsw() {
        this.$trace("lsw-filesystem-explorer.methods.initializeFilesystemForLsw");
        await this.$lsw.fs.ensureFile("/kernel/settings/rutiner.md", LswConstants.global.pick("rutiner.md"));
        await this.$lsw.fs.ensureFile("/kernel/settings/rutiner.config.env", LswConstants.global.pick("/kernel/settings/rutiner.config.env"));
        await this.$lsw.fs.ensureFile("/kernel/settings/randomizables.env", LswConstants.global.pick("randomizables.env"));
        await this.$lsw.fs.ensureFile("/kernel/settings/backgrounds.env", LswConstants.global.pick("backgrounds.env"));
        await this.$lsw.fs.ensureFile("/kernel/settings/automessages.env", LswConstants.global.pick("automessages.env"));
        await this.$lsw.fs.ensureFile("/kernel/settings/user.env", LswConstants.global.pick("user.env"));
        await this.$lsw.fs.ensureFile("/kernel/settings/trackables.env", LswConstants.global.pick("/kernel/settings/trackables.env"));
        await this.$lsw.fs.ensureDirectory("/kernel/wiki/libros");
        await this.$lsw.fs.ensureFile("/kernel/wiki/categorias.tri", LswConstants.global.pick("categorias.tri"));
        await this.$lsw.fs.ensureFile("/kernel/agenda/report/inicio.js", LswConstants.global.pick("report/inicio.js"));
        await this.$lsw.fs.ensureFile("/kernel/agenda/proto/boot.proto", LswConstants.global.pick("boot.proto"));
        await this.$lsw.fs.ensureDirectory("/kernel/agenda/proto/concepto");
        await this.$lsw.fs.ensureDirectory("/kernel/agenda/proto/funcion");
        await this.$lsw.fs.ensureDirectory("/kernel/agenda/proto/relacion");
        await this.$lsw.fs.ensureFile("/kernel/agenda/proto/funcion/multiplicador.js", LswConstants.global.pick("multiplicador.js"));
        await this.$lsw.fs.ensureDirectory("/kernel/settings/table/storage");
        await this.$lsw.fs.ensureDirectory("/kernel/goals/records");
        await this.$lsw.fs.ensureDirectory("/kernel/goals/todos");
        await this.$lsw.fs.ensureDirectory("/kernel/bin");
        await this.$lsw.fs.ensureFile("/kernel/apps/example/load.js", LswConstants.global.pick("/kernel/apps/example/load.js"));
        await this.$lsw.fs.ensureFile("/kernel/android/boot.js", LswConstants.global.pick("/kernel/android/boot.js"));
        /*
        await this.$lsw.fs.ensureFile("/kernel/settings/goals/factory/fisico-3-veces.js", LswConstants.global.pick("/kernel/settings/goals/factory/fisico-3-veces.js"));
        await this.$lsw.fs.ensureFile("/kernel/settings/goals/factory/fisico-4h.js", LswConstants.global.pick("/kernel/settings/goals/factory/fisico-4h.js"));
        //*/
        await this.$lsw.fs.ensureFile("/kernel/goals/goals.week", LswConstants.global.pick("/kernel/goals/goals.week"));
        
        
        await this.$lsw.fs.ensureDirectory("/kernel/components");
        await this.$lsw.fs.ensureFile("/kernel/boot.js", LswConstants.global.pick("boot.js"));
      },
    },
    async mounted() {
      console.log("[*] Application mounted.");
      this.isMounted = true;
      if (isFirstTime) {
        Vue.prototype.$app = this;
        isFirstTime = false;
        window.dispatchEvent(new CustomEvent("lsw_app_mounted", {
          applicationUuid: this.uuid,
          $lsw: this.$lsw,
          appComponent: this,
        }));
        await this.initializeFilesystemForLsw();
        await LswLifecycle.onApplicationMounted();
      }
    }
  });
})(); 

// @vuebundler[Lsw_framework_components][201]=/home/carlos/Escritorio/lsw-one/src/modules/app/app.css
});
