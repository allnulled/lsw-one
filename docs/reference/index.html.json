{
  "comments": [
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-circuiter/async-circuit.js",
      "$location": {
        "start": {
          "offset": 290,
          "line": 14,
          "column": 3
        },
        "end": {
          "offset": 508,
          "line": 25,
          "column": 6
        }
      },
      "$section": "Lsw Circuiter API » LswCircuiter class\n",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswCircuiter",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-circuiter/async-circuit.js",
      "$location": {
        "start": {
          "offset": 509,
          "line": 26,
          "column": 1
        },
        "end": {
          "offset": 598,
          "line": 27,
          "column": 1
        }
      },
      "$section": "Lsw Circuiter API » LswCircuiter class",
      "$code": "  class AsyncCircuit {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor() {\n      this.middlewares = [];\n    }\n\n    hook(callback) {\n      this.middlewares.push(callback);\n      return this;\n    }\n\n    prehook(callback) {\n      this.middlewares.unshift(callback);\n      return this;\n    }\n\n    unhook(callback) {\n      const pos = this.middlewares.indexOf(callback);\n      if(pos !== -1) {\n        this.middlewares.splice(pos, 1);\n      }\n      return this;\n    }\n\n    // Función principal para parsear el árbol\n    parse(node) {\n      // Si el nodo es un array (ejecutar en paralelo)\n      if (Array.isArray(node)) {\n        const code = node.map(cb => this.parse(cb)).join(',');\n        return `Promise.all([${code}])`; // Convertimos todo en un Promise.all\n      }\n\n      // Si es un objeto con $type y $callbacks\n      if (node && typeof node === 'object') {\n        Inject_middlewares: {\n          for(let index__middleware=0; index__middleware<this.middlewares.length; index__middleware++) {\n            const middleware = this.middlewares[index__middleware];\n            const result = middleware(node);\n          }\n        }\n        const { $type, $callbacks } = node;\n        const callbacks = $callbacks.map(cb => (typeof cb === 'function' ? `(${cb.toString()})()` : this.parse(cb)));\n        // Dependiendo del tipo, generamos el código adecuado\n        switch ($type) {\n          case 'parallel':\n            return `Promise.all([\\n  ${callbacks.join(',')}\\n  ])`; // Ejecutar en paralelo\n          case 'serie':\n            return `(async () => {\\n  ${callbacks.map(cb => `await ${cb}`).join('; ')}\\n  })()`; // Ejecutar en serie\n          case 'race':\n            return `Promise.race([\\n  ${callbacks.join(',')}\\n  ])`; // Ejecutar en carrera\n          case 'sync':\n            return `(() => {\\n  ${callbacks.join(';\\n  ')};\\n  return Promise.resolve();\\n  })()`; // Ejecutar síncrono\n          default:\n            throw new Error(`Required property «$type» to be one known but found «${$type}» on «this.parse»`);\n        }\n      }\n\n      // Si el nodo es una función, la transformamos directamente\n      if (typeof node === 'function') {\n        return `(${node.toString()})()`; // Convertimos la función en una llamada inmediata\n      }\n\n      throw new Error(`Required argument «node» to be of known type but found «${typeof $type}» on «this.parse»`);\n    }\n\n    // Método que ejecuta el código generado por eval\n    async execute(node, externalScope = {}) {\n      const code = this.parse(node);\n      const AsyncFunction = (async function() {}).constructor;\n      const argKeys = Object.keys(externalScope).join(\", \");\n      const argValues = Object.values(externalScope);\n      const asyncFunction = new AsyncFunction(argKeys, code);\n      return await asyncFunction(...argValues); // Ejecutamos el código generado con eval\n    }\n  }\n",
      "$code.label": "LswCircuiter class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-class-register/lsw-class-register.js",
      "$location": {
        "start": {
          "offset": 300,
          "line": 14,
          "column": 3
        },
        "end": {
          "offset": 530,
          "line": 25,
          "column": 6
        }
      },
      "$section": "Lsw ClassRegister API » LswClassRegister class\n",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswClassRegister",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-class-register/lsw-class-register.js",
      "$location": {
        "start": {
          "offset": 531,
          "line": 26,
          "column": 1
        },
        "end": {
          "offset": 632,
          "line": 27,
          "column": 1
        }
      },
      "$section": "Lsw ClassRegister API » LswClassRegister class",
      "$code": "  class LswClassRegister {\n\n    constructor() {\n      this.$classes = {};\n    }\n\n    register(id, classDefinition, forceOverwrite = false) {\n      $ensure({id},1).type(\"string\");\n      $ensure({classDefinition},1).type(\"function\");\n      if(!forceOverwrite) {\n        $ensure({$classes:this.$classes},1).to.not.have.key(id);\n      }\n      this.$classes[id] = classDefinition;\n    }\n\n    unregister(id, silenceError = false) {\n      if(!silenceError) {\n        $ensure({$classes:this.$classes},1).to.have.key(id);\n      }\n      delete this.$classes[id];\n    }\n\n    instantiate(id, ...args) {\n      $ensure({id},1).type(\"string\");\n      $ensure({$classes:this.$classes},1).to.have.key(id);\n      const clazz = this.$classes[id];\n      const objeto = new clazz(...args);\n      return objeto;\n    }\n\n    async initialize(id, ...args) {\n      $ensure({id},1).type(\"string\");\n      $ensure({$classes:this.$classes},1).to.have.key(id);\n      const clazz = this.$classes[id];\n      const objeto = new clazz(...args);\n      if(typeof objeto.initialize === \"function\") {\n        await objeto.initialize();\n      }\n      return objeto;\n    }\n\n  }\n",
      "$code.label": "LswClassRegister class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-commander/url-command.js",
      "$location": {
        "start": {
          "offset": 797,
          "line": 31,
          "column": 3
        },
        "end": {
          "offset": 1015,
          "line": 42,
          "column": 6
        }
      },
      "$section": "Lsw Commander API » LswCommander class\n",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswCommander",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-commander/url-command.js",
      "$location": {
        "start": {
          "offset": 1016,
          "line": 43,
          "column": 1
        },
        "end": {
          "offset": 1105,
          "line": 44,
          "column": 1
        }
      },
      "$section": "Lsw Commander API » LswCommander class",
      "$code": "  const LswCommander = class {\n\n    static from(...args) {\n      return new this(...args);\n    }\n\n    onRun(callback, args) {\n      try {\n        let output = undefined;\n        if (typeof this.$beforeRun === \"function\") {\n          this.$beforeRun(...args);\n        }\n        output = callback(...args);\n        if (typeof this.$afterRun === \"function\") {\n          this.$afterRun(...args);\n        }\n        return output;\n      } catch (error) {\n        if (typeof this.$onError === \"function\") {\n          const output = this.$onError(error);\n          if (typeof output !== \"undefined\") {\n            return output;\n          }\n        }\n        throw error;\n      }\n    }\n\n    constructor(handlers) {\n      this.$handlers = handlers;\n      this.$beforeRun = undefined;\n      this.$afterRun = undefined;\n      this.$onError = undefined;\n      this.command = (url, queryParamsExtender = {}) => {\n        if (!url) throw new Error(\"URL is required\");\n        if (typeof url !== \"string\") throw new Error(\"URL must be a string\");\n        if (typeof this.$handlers !== \"object\" || this.$handlers === null) {\n          throw new Error(\"Handlers must be a valid object\");\n        }\n        const [path, queryString] = url.split(\"?\");\n        const queryParams = queryString ? Object.fromEntries(new URLSearchParams(queryString).entries()) : {};\n        Object.assign(queryParams, queryParamsExtender);\n        const pathParts = path.split(\"/\").filter(Boolean);\n        let currentHandler = this.$handlers;\n        for (const part of pathParts) {\n          if (currentHandler[part] === undefined) {\n            throw new Error(`Handler for path \"${path}\" not found`);\n          }\n          currentHandler = currentHandler[part];\n        }\n        if (typeof currentHandler !== \"function\") {\n          throw new Error(`Handler at path \"${path}\" is not a function`);\n        }\n        const isSpreadable = isOnlyConsecutiveNumbers(queryParams);\n        if (isSpreadable && isSpreadable.length) {\n          return this.onRun(currentHandler, isSpreadable);\n        } else if (queryParams.argumentsOrder) {\n          const args = [];\n          const argKeys = queryParams.argumentsOrder.split(\",\").map(arg => arg.trim());\n          for (let index = 0; index < argKeys.length; index++) {\n            const argKey = argKeys[index];\n            const argValue = queryParams[argKey] || null;\n            args.push(argValue);\n          }\n          return this.onRun(currentHandler, args);\n        } else {\n          return this.onRun(currentHandler, [queryParams]);\n        }\n      };\n    }\n    get run() {\n      return this.command;\n    }\n    beforeRun(callback) {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"Required parameter «callback» to be a function on «beforeRun»\");\n      }\n      this.$beforeRun = callback;\n    }\n    afterRun(callback) {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"Required parameter «callback» to be a function on «afterRun»\");\n      }\n      this.$afterRun = callback;\n    }\n    onError(callback) {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"Required parameter «callback» to be a function on «onError»\");\n      }\n      this.$onError = callback;\n    }\n  };\n",
      "$code.label": "LswCommander class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
      "$location": {
        "start": {
          "offset": 294,
          "line": 14,
          "column": 3
        },
        "end": {
          "offset": 524,
          "line": 25,
          "column": 6
        }
      },
      "$section": "Lsw ClassRegister API » LswClassRegister class\n",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswClassRegister",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
      "$location": {
        "start": {
          "offset": 525,
          "line": 26,
          "column": 1
        },
        "end": {
          "offset": 625,
          "line": 27,
          "column": 1
        }
      },
      "section": "Lsw ClassRegister API » LswClassRegister class",
      "$code": "  Promise_extensions: {\n    \n    globalThis.Promise.prototype.chain = function (nextPromise) {\n      return this.then(() => nextPromise);\n    };\n  }\n",
      "$code.label": "LswClassRegister class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
      "$location": {
        "start": {
          "offset": 816,
          "line": 35,
          "column": 3
        },
        "end": {
          "offset": 1039,
          "line": 45,
          "column": 6
        }
      },
      "$section": "Lsw Compromiser API » LswCompromiser class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswCompromiser",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
      "$location": {
        "start": {
          "offset": 1040,
          "line": 46,
          "column": 1
        },
        "end": {
          "offset": 1134,
          "line": 47,
          "column": 1
        }
      },
      "section": "Lsw Compromiser API » LswCompromiser class",
      "$code": "  class PromiseMap {\n\n    constructor(keys) {\n      this.promises = new Map();\n\n      keys.forEach(key => {\n        this.set(key);\n      });\n    }\n\n    static create(keys) {\n      return new this(keys);\n    }\n\n    has(key) {\n      return this.promises.has(key);\n    }\n\n    get(key) {\n      if (!this.has(key)) {\n        throw new Error(`Required argument «key» to be an existing key (not «${key}») on «PromiseMap.get»`);\n      }\n      return this.promises.get(key);\n    }\n\n    set(key) {\n      if (this.has(key)) {\n        throw new Error(`Required argument «key» to not be an existing key (not «${key}») on «PromiseMap.set»`);\n      }\n      let resolve, reject;\n      const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n      this.promises.set(key, { promise, resolve, reject });\n    }\n\n    unset(key) {\n      if (!this.has(key)) {\n        throw new Error(`Required argument «key» to be an existing key (not «${key}») on «PromiseMap.unset»`);\n      }\n      this.promises.delete(key);\n    }\n\n    on(key) {\n      if (!this.has(key)) {\n        throw new Error(`Required argument «key» to be an existing key (not «${key}») on «PromiseMap.on»`);\n      }\n      return this.promises.get(key).promise;\n    }\n\n    bind(key, key2) {\n      this.on(key).then(output => this.get(key2).resolve(output));\n    }\n\n    propagate(key) {\n      return {\n        to: (key2) => {\n          this.bind(key, key2);\n          return this.propagate(key2);\n        }\n      }\n    }\n\n  }\n",
      "$code.label": "LswCompromiser class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-configurer/lsw-configurer.js",
      "$location": {
        "start": {
          "offset": 294,
          "line": 14,
          "column": 3
        },
        "end": {
          "offset": 514,
          "line": 24,
          "column": 6
        }
      },
      "$section": "Lsw Configurer API » LswConfigurer class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswConfigurer",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-configurer/lsw-configurer.js",
      "$location": {
        "start": {
          "offset": 515,
          "line": 25,
          "column": 1
        },
        "end": {
          "offset": 606,
          "line": 26,
          "column": 1
        }
      },
      "section": "Lsw Configurer API » LswConfigurer class",
      "$code": "  const LswConfigurer = class {\n\n    constructor(parentConfigurer = null) {\n      this.$parent = parentConfigurer;\n      this.$state = {};\n    }\n\n    configure(stateOptions = {}) {\n      Object.assign(this.$state, stateOptions);\n    }\n\n    get(key, defaultValue = undefined) {\n      let target = this;\n      Iterating_parents:\n      while(!!target) {\n        if(key in target.$state) {\n          return target.$state[key];\n        }\n        target = target.$parent;\n      }\n      return defaultValue;\n    }\n\n  }\n",
      "$code.label": "LswConfigurer class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-cycler/lsw-cycler.js",
      "$location": {
        "start": {
          "offset": 312,
          "line": 17,
          "column": 3
        },
        "end": {
          "offset": 520,
          "line": 27,
          "column": 6
        }
      },
      "$section": "Lsw Cycler API » LswCycler class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswCycler",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-cycler/lsw-cycler.js",
      "$location": {
        "start": {
          "offset": 521,
          "line": 28,
          "column": 1
        },
        "end": {
          "offset": 600,
          "line": 29,
          "column": 1
        }
      },
      "section": "Lsw Cycler API » LswCycler class",
      "$code": "  class LswCyclerSet {\n    constructor(value) {\n      this.value = value;\n    }\n  }\n\n  class LswCyclerReturn {\n    constructor(value) {\n      this.value = value;\n    }\n  }\n\n  class LswCyclerReturner {\n    constructor(value) {\n      if(typeof value !== \"function\") {\n        throw new Error(\"Required argument «value» to be a function on «LswCyclerReturner.constructor»\");\n      }\n      this.value = value;\n    }\n  }\n\n  class LswCycler {\n\n    static Return = LswCyclerReturn;\n    static Returner = LswCyclerReturner;\n    static Set = LswCyclerSet;\n\n    static returner(value) {\n      return new this.Returner(value);\n    }\n\n    static return(value) {\n      return new this.Return(value);\n    }\n\n    static set(value) {\n      return new this.Set(value);\n    }\n\n    constructor($object, exposedProps = []) {\n      this.$object = $object;\n      if(exposedProps === \"*\") {\n        Object.assign(this, $object);\n      } else {\n        for(let index=0; index<exposedProps.length; index++) {\n          const exposedProp = exposedProps[index];\n          this[exposedProp] = $object[exposedProp];\n        }\n      }\n    }\n\n    static from(...args) {\n      return new this(...args);\n    }\n\n    async run(steps, parameters) {\n      let original = [];\n      let output = original;\n      Iterate_cycle:\n      for (let j = 0; j < steps.length; j++) {\n        let step = steps[j];\n        let fn = this.$object[step];\n        if (typeof fn !== \"function\") {\n          throw new Error(\"Required step «\" + step + \"» to be a function on round \" + j + \" on «LswCycler.run»\");\n        }\n        const result = await fn.call(this.$object, parameters);\n        Apply_intercycle_signals: {\n          if (result instanceof this.constructor.Set) {\n            output = await result.value;\n          } else if (result instanceof this.constructor.Return) {\n            return result.value;\n          } else if (result instanceof this.constructor.Returner) {\n            return result.value(output, original);\n          }\n        }\n        Append_result_if_not_changed_output: {\n          original.push(result);\n        }\n      }\n      return output;\n    }\n\n  }\n",
      "$code.label": "LswCycler class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database/browsie.unbundled.js",
      "$location": {
        "start": {
          "offset": 287,
          "line": 15,
          "column": 3
        },
        "end": {
          "offset": 501,
          "line": 25,
          "column": 6
        }
      },
      "$section": "Lsw Database API » LswDatabase class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswDatabase",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database/browsie.unbundled.js",
      "$location": {
        "start": {
          "offset": 502,
          "line": 26,
          "column": 1
        },
        "end": {
          "offset": 587,
          "line": 27,
          "column": 1
        }
      },
      "section": "Lsw Database API » LswDatabase class",
      "$code": "  class BrowsieCheckersAPI {\n\n    static mustBeString(obj, method = \"Browsie.mustBeString\", id = \"?\") {\n      if (typeof obj !== \"string\") {\n        throw new Error(`Required «${id}» to be a string on «${method}»`);\n      }\n    }\n\n    static mustBeArray(obj, method = \"Browsie.mustBeArray\", id = \"?\") {\n      if (!Array.isArray(obj)) {\n        throw new Error(`Required «${id}» to be an array on «${method}»`);\n      }\n    }\n\n    static mustBeObject(obj, method = \"Browsie.mustBeObject\", id = \"?\") {\n      if (typeof obj !== \"object\") {\n        throw new Error(`Required «${id}» to be an object on «${method}»`);\n      }\n    }\n\n    static mustBeGreaterThan(obj, comparison = 0, method = \"Browsie.mustBeObject\", id = \"?\") {\n      if (obj <= comparison) {\n        throw new Error(`Required «${id}» to be greater than «${comparison}» on «${method}»`);\n      }\n    }\n  }\n\n  class BrowsieStaticAPI extends BrowsieCheckersAPI {\n\n    static openedConnections = [];\n\n    static _trace = true;\n\n    static trace(methodName, args = []) {\n      if (this._trace) {\n        console.log(\"[browsie][\" + methodName + \"]\", args.length + \" args: \" + Array.from(args).map(arg => typeof (arg)).join(\", \"));\n      }\n    }\n\n    static async listDatabases() {\n      this.trace(\"Browsie.listDatabases\", arguments);\n      try {\n        const databases = await indexedDB.databases();\n        console.log('Bases de datos disponibles:', databases);\n        return databases;\n      } catch (error) {\n        console.error('Error al obtener las bases de datos:', error);\n      }\n    }\n\n    static createDatabase(dbName, schemaDefinition = null, version = 1, versionUpgrades = {}) {\n      this.trace(\"Browsie.createDatabase\", arguments);\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName, version);\n        request.onsuccess = () => {\n          console.log(`[SUCCESS] Database \"${dbName}\" created/opened successfully.`);\n          request.result.close();\n          resolve(request.result);\n        };\n        request.onerror = (error) => {\n          console.error(`[ERROR] Failed to create/open database \"${dbName}\":`, error);\n          reject(error);\n        };\n        request.onupgradeneeded = async (event) => {\n          const db = event.target.result;\n          console.log(`[UPGRADE] Upgrading database \"${dbName}\" from version ${event.oldVersion} to ${version}.`);\n          // Si hay una definición de esquema inicial, crear los almacenes e índices\n          if (schemaDefinition && event.oldVersion === 0) {\n            console.log(\"[SCHEMA] Applying initial schema definition.\");\n            Object.keys(schemaDefinition).forEach((storeName) => {\n              if (!db.objectStoreNames.contains(storeName)) {\n                const objectStore = db.createObjectStore(storeName, {\n                  keyPath: \"id\",\n                  autoIncrement: true,\n                });\n                if (!Array.isArray(schemaDefinition[storeName])) {\n                  console.log(schemaDefinition);\n                  throw new Error(`Required property «schemaDefinition.${storeName}» to be an array on «LswDatabase.createDatabase»`);\n                }\n                schemaDefinition[storeName].forEach((index) => {\n                  const indexName = index.replace(/^\\!/, \"\");\n                  objectStore.createIndex(indexName, indexName, {\n                    unique: index.startsWith(\"!\")\n                  });\n                });\n              }\n            });\n          }\n          // Aplicar las transformaciones de esquema para cada versión\n          for (let v = event.oldVersion + 1; v <= version; v++) {\n            if (versionUpgrades[v]) {\n              console.log(`[VERSION ${v}] Applying upgrade function.`);\n              await versionUpgrades[v](db);\n            } else {\n              console.log(`[VERSION ${v}] No upgrade function defined.`);\n            }\n          }\n        };\n      });\n    }\n\n    // Obtener todos los datos de un store\n    static async getAllDataFromStore(dbName, storeName) {\n      this.trace(\"Browsie.getAllDataFromStore\", arguments);\n      return await new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName);\n\n        request.onsuccess = (event) => {\n          const db = event.target.result;\n          const transaction = db.transaction(storeName, 'readonly');\n          const store = transaction.objectStore(storeName);\n\n          const getAllRequest = store.getAll();\n          getAllRequest.onsuccess = () => resolve(getAllRequest.result);\n          getAllRequest.onerror = () => {\n            db.close();\n            reject(new Error('Error al obtener los datos del store'));\n          };\n        };\n\n        request.onerror = () => {\n          reject(new Error('Error al abrir la base de datos'));\n        };\n      });\n    }\n\n    // Insertar datos en un store\n    static async insertDataIntoStore(dbName, storeName, data) {\n      this.trace(\"Browsie.insertDataIntoStore\", arguments);\n      return await new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName);\n\n        request.onsuccess = (event) => {\n          const db = event.target.result;\n          const transaction = db.transaction(storeName, 'readwrite');\n          const store = transaction.objectStore(storeName);\n\n          data.forEach(item => store.add(item));\n\n          transaction.oncomplete = () => resolve();\n          transaction.onerror = () => {\n            db.close();\n            reject(new Error('Error al insertar los datos en el store'));\n          };\n        };\n\n        request.onerror = () => {\n          reject(new Error('Error al abrir la base de datos'));\n        };\n      });\n    }\n\n    // Eliminar una base de datos\n    static deleteDatabase(dbName) {\n      this.trace(\"Browsie.deleteDatabase\", arguments);\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.deleteDatabase(dbName);\n\n        request.onblocked = () => {\n          // db.close();\n          reject(new Error(\"Error al eliminar la base de datos porque está bloqueada\"));\n        };\n        request.onsuccess = () => resolve();\n        request.onerror = () => {\n          // db.close();\n          reject(new Error('Error al eliminar la base de datos'));\n        };\n      }).then(() => {\n        console.log(`[!] Base de datos «${dbName}» eliminada correctamente.`);\n      });\n    }\n\n    static async getSchema(dbName) {\n      this.trace(\"Browsie.getSchema\", arguments);\n      let db = undefined;\n      try {\n        // Abrir la base de datos en modo solo lectura\n        const request = indexedDB.open(dbName);\n\n        db = await new Promise((resolve, reject) => {\n          request.onsuccess = (event) => resolve(event.target.result);\n          request.onerror = () => {\n            reject(new Error('Error al abrir la base de datos'));\n          };\n        });\n\n        // Construir el esquema a partir de los almacenes\n        const schema = {};\n        const objectStoreNames = Array.from(db.objectStoreNames); // Lista de stores\n\n        objectStoreNames.forEach(storeName => {\n          const transaction = db.transaction(storeName, 'readonly');\n          const store = transaction.objectStore(storeName);\n\n          const storeInfo = {\n            keyPath: store.keyPath,\n            autoIncrement: store.autoIncrement,\n            indexes: []\n          };\n\n          // Recorrer los índices del store\n          const indexNames = Array.from(store.indexNames); // Lista de índices\n          indexNames.forEach(indexName => {\n            const index = store.index(indexName);\n            storeInfo.indexes.push({\n              name: index.name,\n              keyPath: index.keyPath,\n              unique: index.unique,\n              multiEntry: index.multiEntry\n            });\n          });\n\n          schema[storeName] = storeInfo;\n        });\n\n        return schema;\n      } catch (error) {\n        console.error('Error al obtener el esquema:', error);\n        throw error;\n      } finally {\n        if (db) {\n          db.close();\n        }\n      }\n    }\n\n    static async pickRow(databaseId, tableId, rowId) {\n      this.trace(\"Browsie.pickRow\", arguments);\n      $ensure(databaseId).type(\"string\");\n      $ensure(tableId).type(\"string\");\n      $ensure(rowId).type(\"number\");\n      let connection = undefined;\n      try {\n        connection = await this.open(databaseId);\n        const rows = await connection.selectMany(tableId, v => v.id === rowId);\n        if (rows.length === 1) {\n          return rows[0];\n        } else if (rows.length === 0) {\n          return undefined;\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        try {\n          await connection.close();\n        } catch (error) {\n          console.log(\"Could not close connection on picking row\");\n        }\n      }\n    }\n\n  }\n\n  class BrowsieTriggersAPI extends BrowsieStaticAPI {\n\n    static globMatch = TriggersClass.globMatch;\n\n    triggers = new TriggersClass();\n\n  }\n\n\n  class BrowsieCrudAPI extends BrowsieTriggersAPI {\n\n    static async open(...args) {\n      this.trace(\"Browsie.open\", arguments);\n      const db = new this(...args);\n      await db.open();\n      return db;\n    }\n\n    // Constructor que abre la base de datos\n    constructor(dbName, trace = false) {\n      super();\n      this.$dbName = dbName;\n      this.$db = null;\n      this.$innerSchema = null;\n      this._trace = trace;\n    }\n\n    getInnerSchema() {\n      this.constructor.trace(\"browsie.getInnerSchema\", arguments);\n      return this.$innerSchema;\n    }\n\n    setInnerSchema(innerSchema) {\n      this.constructor.trace(\"browsie.setInnerSchema\", arguments);\n      if (!(innerSchema instanceof LswSchema)) {\n        throw new Error(`Required parameter «innerSchema» to be an instance of LswSchema on «browsie.setInnerSchema»`);\n      }\n      this.$innerSchema = innerSchema;\n    }\n\n    // Abre la base de datos\n    open() {\n      this.constructor.trace(\"browsie.open\", arguments);\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.$dbName);\n\n        request.onsuccess = () => {\n          this.$db = request.result;\n          resolve(this.$db);\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.open» operation over database «${this.$dbName}»: `));\n      });\n    }\n\n    close(...args) {\n      this.constructor.trace(\"browsie.close\", arguments);\n      return this.$db.close(...args);\n    }\n\n    // Método para seleccionar 1 elemento de un store con un filtro\n    select(store, filter = {}) {\n      this.constructor.trace(\"browsie.select\", arguments);\n      this.triggers.emit(`crud.select.one.${store}`, { store, filter });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readonly');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.getAll();\n        request.onsuccess = () => {\n          const result = request.result.filter(item => {\n            return Object.keys(filter).every(key => item[key] === filter[key]);\n          });\n          resolve(result);\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.select» operation over store «${store}»: `));\n      });\n    }\n\n    // Método para insertar un solo item en un store\n    insert(store, item) {\n      this.constructor.trace(\"browsie.insert\", arguments);\n      this.triggers.emit(`crud.insert.one.${store}`, { store, item });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.add(item);\n\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.insert» operation over store «${store}»: `));\n      });\n    }\n\n    // Método para actualizar un item en un store\n    update(store, id, item) {\n      this.constructor.trace(\"browsie.update\", arguments);\n      this.triggers.emit(`crud.update.one.${store}`, { store, id, item });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.put({ ...item, id });\n\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.update» operation over store «${store}»: `));\n      });\n    }\n\n    // Método tipo upsert: que cambia solo los campos que le proporcionas (hace entre 1 y 2 queries)\n    async overwrite(store, idOrItem, item) {\n      this.constructor.trace(\"browsie.overwrite\", arguments);\n      this.triggers.emit(`crud.overwrite.one.${store}`, { store, idOrItem, item });\n      const isId = (typeof idOrItem === \"string\") || (typeof idOrItem === \"number\");\n      const isItem = typeof idOrItem === \"object\";\n      let previousItem = undefined;\n      if (isItem) {\n        previousItem = idOrItem;\n      } else if (isId) {\n        const matches = await this.select(store, it => it.id === idOrItem);\n        if (matches.length === 0) {\n          throw new Error(`Zero rows on overwrite operator. Cannot overwrite a row that does not exist on «browsie.overwrite»`);\n        } else if (matches.length > 1) {\n          throw new Error(`Multiple rows on overwrite operation. Cannot overwrite multiple rows. Ensure store «${store}» is using index «id» as unique value to complete this operation`);\n        }\n        previousItem = matches[0];\n      } else {\n        throw new Error(`Required parameter «idOrItem» to be a string or an object on «browsie.overwrite»`);\n      }\n      const newItem = Object.assign({}, previousItem, item);\n      return await this.update(store, newItem.id, newItem);\n    }\n\n    // Método para eliminar un item de un store por ID\n    delete(store, id) {\n      this.constructor.trace(\"browsie.delete\", arguments);\n      this._ensureIntegrity(store, id);\n      this.triggers.emit(`crud.delete.one.${store}`, { store, id });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.delete(id);\n        request.onsuccess = () => resolve();\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.delete» operation over store «${store}»: `));\n      });\n    }\n\n    _getSchemaEntityByStoreName(store) {\n      this.constructor.trace(\"browsie._ensureIntegrity\", arguments);\n      const innerSchema = this.getInnerSchema().$schema;\n      const tableIds = Object.keys(innerSchema.hasTables);\n      Iterating_tables:\n      for (let indexTables = 0; indexTables < tableIds.length; indexTables++) {\n        const tableId = tableIds[indexTables];\n        if (tableId === store) {\n          return innerSchema.hasTables[tableId];\n        }\n      }\n      return undefined;\n    }\n\n    _ensureIntegrity(store, id) {\n      this.constructor.trace(\"browsie._ensureIntegrity\", arguments);\n      const innerSchema = this.getInnerSchema().$schema;\n      const tableIds = Object.keys(innerSchema.hasTables);\n      const sourceEntity = innerSchema.hasTables[store];\n      const sourceEntityId = sourceEntity.hasEntityId;\n      const boundColumns = [];\n      Iterating_tables:\n      for (let indexTables = 0; indexTables < tableIds.length; indexTables++) {\n        const tableId = tableIds[indexTables];\n        const tableData = innerSchema.hasTables[tableId];\n        const columnIds = Object.keys(tableData.hasColumns);\n        Iterating_columns:\n        for (let indexColumns = 0; indexColumns < columnIds.length; indexColumns++) {\n          const columnId = columnIds[indexColumns];\n          const columnData = tableData.hasColumns[columnId];\n          When_it_has_references: {\n            if (!columnData.refersTo) {\n              break When_it_has_references;\n            }\n            const { entity: schemaEntityId, property: entityColumnId, constraint = true } = columnData.refersTo;\n            if (!constraint) {\n              break When_it_has_references;\n            }\n            const isSameEntity = schemaEntityId === sourceEntityId;\n            if (!isSameEntity) {\n              break When_it_has_references;\n            }\n            boundColumns.push({\n              source: [store, entityColumnId],\n              mustCheck: [tableId, columnId]\n            });\n          }\n        }\n      }\n      console.log(`BOUND COLUMNS to ${store}:`, boundColumns);\n    }\n\n    _expandError(errorObject, baseMessage = false) {\n      this.constructor.trace(\"browsie._expandError\", arguments);\n      let error = errorObject;\n      if (errorObject instanceof Error) {\n        error = errorObject;\n      } else if (errorObject.target && errorObject.target.error) {\n        error = errorObject.target.error;\n      } else {\n        error = new Error(errorObject);\n      }\n      if (baseMessage) {\n        const errorTemp = new Error(error.message ?? error);\n        Object.assign(errorTemp, error);\n        errorTemp.message = baseMessage + errorTemp.message;\n        error = errorTemp;\n      }\n      return error;\n    }\n\n    // Método para seleccionar elementos de un store con un filtro\n    select(store, filter) {\n      this.constructor.trace(\"browsie.select\", arguments);\n      this.triggers.emit(`crud.select.one.${store}`, { store, filter });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readonly');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.getAll();\n\n        request.onsuccess = () => {\n          const result = request.result.filter(item => {\n            try {\n              return filter(item);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «browsie.select»\");\n              return false;\n            }\n          });\n          resolve(result);\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.select» operation over store «${store}»: `));\n      });\n    }\n\n    selectMany(store, filterFn = i => true) {\n      this.constructor.trace(\"browsie.selectMany\", arguments);\n      this.triggers.emit(`crud.select.many.${store}`, { store, filterFn });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readonly');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria\n        const results = [];\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            let isAccepted = undefined;\n            try {\n              isAccepted = filterFn(cursor.value);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «browsie.selectMany»\");\n            }\n            if (isAccepted) { // Aplica la función de filtro\n              results.push(cursor.value);\n            }\n            cursor.continue(); // Avanza al siguiente registro\n          } else {\n            resolve(results); // Se terminó el recorrido\n          }\n        };\n        request.onerror = (error) =>\n          reject(this._expandError(error, `Error on «browsie.selectMany» operation over store «${store}»: `));\n      });\n    }\n\n    // Método para insertar varios items en un store\n    insertMany(store, items) {\n      this.constructor.trace(\"browsie.insertMany\", arguments);\n      this.triggers.emit(`crud.insert.many.${store}`, { store, items });\n      this.constructor.mustBeString(store, \"insertMany\", \"arguments[0]\");\n      this.constructor.mustBeArray(items, \"insertMany\", \"arguments[1]\");\n      return new Promise((resolve, reject) => {\n        if (items.length === 0) {\n          return resolve(false);\n        }\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        let insertedCount = 0;\n        items.forEach(item => {\n          const request = objectStore.add(item);\n          request.onsuccess = () => {\n            insertedCount++;\n            if (insertedCount === items.length) resolve();\n          };\n          request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.insertMany» operation over store «${store}» inserting «${items.length}» items: `));\n        });\n      });\n    }\n\n    // Método para actualizar varios items en un store\n    updateMany(store, filter, item) {\n      this.constructor.trace(\"browsie.updateMany\", arguments);\n      this.triggers.emit(`crud.update.many.${store}`, { store, filter, item });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.openCursor();\n        let updatedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (cursor) {\n            if (Object.keys(filter).every(key => cursor.value[key] === filter[key])) {\n              const updatedItem = { ...cursor.value, ...item };\n              const updateRequest = cursor.update(updatedItem);\n              updateRequest.onsuccess = () => {\n                updatedCount++;\n                if (updatedCount === cursor.value.length) resolve();\n              };\n            }\n            cursor.continue();\n          }\n        };\n\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.updateMany» operation over store «${store}»: `));\n      });\n    }\n\n    // Método a tipo upsertAll para llenar los valores pero dejar los que no\n    async overwriteMany(store, filter, item) {\n      this.constructor.trace(\"browsie.overwriteMany\", arguments);\n      this.triggers.emit(`crud.overwrite.many.${store}`, { store, filter, item });\n      const allMatches = await this.selectMany(store, filter);\n      const allResults = [];\n      for (let indexRow = 0; indexRow < allMatches.length; indexRow++) {\n        const row = allMatches[indexRow];\n        const result = await this.overwrite(store, row, item);\n        allResults.push(result);\n      }\n      return allResults;\n    }\n\n    // Método para eliminar varios items de un store según un filtro\n    deleteMany(store, filterCallback) {\n      this.constructor.trace(\"browsie.deleteMany\", arguments);\n      this.triggers.emit(`crud.delete.many.${store}`, { store, filterCallback });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.openCursor();\n        let deletedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (!cursor) {\n            return resolve();\n          }\n          const isAccepted = filterCallback(cursor.value);\n          if (isAccepted) {\n            const deleteRequest = cursor.delete();\n            deleteRequest.onsuccess = () => {\n              deletedCount++;\n              if (deletedCount === cursor.value.length) {\n                return resolve();\n              }\n            };\n            deleteRequest.onerror = (error) => reject(this._expandError(error, `Error on «browsie.deleteMany» operation over store «${store}» and id «${cursor.value.id}»: `));\n          }\n          cursor.continue();\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.deleteMany» operation over store «${store}»: `));\n      });\n    }\n  }\n\n  // @TOCONTINUEFROM\n  class BrowsieMigration {\n\n    static from(...args) {\n      return new this(...args);\n    }\n\n    static createTable(arg) {\n      return this.from({\n        operation: \"createTable\",\n        parameters: arg\n      });\n    }\n\n    static renameTable(arg) {\n      return this.from({\n        operation: \"renameTable\",\n        parameters: arg\n      });\n    }\n\n    static deleteTable(arg) {\n      return this.from({\n        operation: \"deleteTable\",\n        parameters: arg\n      });\n    }\n\n    static createColumn(arg) {\n      return this.from({\n        operation: \"createColumn\",\n        parameters: arg\n      });\n    }\n\n    static renameColumn(arg) {\n      return this.from({\n        operation: \"renameColumn\",\n        parameters: arg\n      });\n    }\n\n    static deleteColumn(arg) {\n      return this.from({\n        operation: \"deleteColumn\",\n        parameters: arg\n      });\n    }\n\n    constructor(options = {}) {\n      LswDatabase.trace(\"LswDatabaseMigration.constructor\");\n      const { operation, parameters } = options;\n      this.$validateOperation(operation);\n      this.$validateParameters(parameters);\n      this.operation = operation;\n      this.parameters = parameters;\n      this.config = {\n        temporaryDatabase: this.parameters.fromDatabase + \"_\" + this.$getRandomString(5),\n      };\n      this.migrated = false;\n    }\n\n    $getRandomString(len = 10) {\n      LswDatabase.trace(\"LswDatabaseMigration.$getRandomString\");\n      const alphabet = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\n      let out = \"\";\n      while (out.length < len) {\n        out += alphabet[Math.floor(Math.random() * alphabet.length)];\n      }\n      return out;\n    };\n\n    $validateOperation(operation) {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateOperation\");\n      if ([\"createTable\", \"renameTable\", \"deleteTable\", \"createColumn\", \"renameColumn\", \"deleteColumn\", \"cloneDatabase\", \"moveDatabase\"].indexOf(operation) === -1) {\n        throw new Error(\"Required «operation» to be a valid operation on «LswDatabaseMigration.$validateOperation»\");\n      }\n    }\n\n    $validateParameters(parameters) {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateParameters\");\n      if (typeof parameters !== \"object\") {\n        throw new Error(\"Required «parameters» to be an object on «LswDatabaseMigration.$validateParameters»\");\n      }\n    }\n\n    async $$transferBackTemporaryDatabase() {\n      await LswDatabase.deleteDatabase(this.parameters.fromDatabase);\n      await this.$replicateSchema({\n        fromDatabase: this.config.temporaryDatabase,\n        toDatabase: this.parameters.fromDatabase,\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.config.temporaryDatabase,\n        toDatabase: this.parameters.fromDatabase,\n      });\n      await LswDatabase.deleteDatabase(this.config.temporaryDatabase);\n    }\n\n    commit() {\n      LswDatabase.trace(\"LswDatabaseMigration.commit\");\n      return this[\"$$\" + this.operation].call(this).finally(() => {\n        this.migrated = true;\n      });\n    }\n\n    $validateCreateTableParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateCreateTableParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateCreateTableParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateCreateTableParameters»\");\n      }\n      if (typeof this.parameters.tableDefinition !== \"object\") {\n        throw new Error(\"Required «parameters.tableDefinition» to be an object on «LswDatabaseMigration.$validateCreateTableParameters»\");\n      }\n    }\n\n    async $$cloneDatabase() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$cloneDatabase\");\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n    }\n\n    async $$moveDatabase() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$moveDatabase\");\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n      await LswDatabase.deleteDatabase(this.parameters.fromDatabase);\n    }\n\n    async $$createTable() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$createTable\");\n      this.$validateCreateTableParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          schema[this.parameters.table] = this.parameters.tableDefinition;\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateDeleteTableParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateDeleteTableParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n    }\n\n    async $$deleteTable() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$deleteTable\");\n      this.$validateDeleteTableParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          delete schema[this.parameters.table];\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateRenameTableParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateRenameTableParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n      if (typeof this.parameters.tableSource !== \"string\") {\n        throw new Error(\"Required «parameters.tableSource» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n      if (typeof this.parameters.tableDestination !== \"string\") {\n        throw new Error(\"Required «parameters.tableDestination» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n    }\n\n    async $$renameTable() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$renameTable\");\n      this.$validateRenameTableParameters();\n      const currentSchema = await LswDatabase.getSchema(this.parameters.fromDatabase);\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          delete schema[this.parameters.tableSource];\n          const tableInput = this.$adaptSchemaTableAsSchemaDefinition(currentSchema[this.parameters.tableSource]);\n          schema[this.parameters.tableDestination] = tableInput;\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: tableId => {\n          return this.parameters.tableDestination;\n        },\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateCreateColumnParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateCreateColumnParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n      if (typeof this.parameters.column !== \"string\") {\n        throw new Error(\"Required «parameters.column» to be a string on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n      if (typeof this.parameters.columnDefinition !== \"object\") {\n        throw new Error(\"Required «parameters.columnDefinition» to be an object on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n    }\n\n    async $$createColumn() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$createColumn\");\n      this.$validateCreateColumnParameters();\n      const isUnique = !!this.parameters.columnDefinition.isUnique;\n      const columnSymbol = `${isUnique ? \"!\" : \"\"}${this.parameters.column}`;\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        table: this.parameters.table,\n        onAlterSchema: schema => {\n          schema[this.parameters.table].push(columnSymbol);\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateDeleteColumnParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateDeleteColumnParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateDeleteColumnParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateDeleteColumnParameters»\");\n      }\n      if (typeof this.parameters.column !== \"string\") {\n        throw new Error(\"Required «parameters.column» to be a string on «LswDatabaseMigration.$validateDeleteColumnParameters»\");\n      }\n    }\n\n    async $$deleteColumn() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$deleteColumn\");\n      this.$validateDeleteColumnParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          console.log(schema);\n          const columnPosition = schema[this.parameters.table].indexOf(this.parameters.column);\n          schema[this.parameters.table].splice(columnPosition, 1);\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        // !@TOCONFIGURE: $$deleteColumn needs a specific hook (or none).\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateRenameColumnParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateRenameColumnParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n      if (typeof this.parameters.columnSource !== \"string\") {\n        throw new Error(\"Required «parameters.columnSource» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n      if (typeof this.parameters.columnDestination !== \"string\") {\n        throw new Error(\"Required «parameters.columnDestination» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n    }\n\n    async $$renameColumn() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$renameColumn\");\n      this.$validateRenameColumnParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          console.log(schema);\n          const columnPosition = schema[this.parameters.table].indexOf(this.parameters.columnSource);\n          schema[this.parameters.table].splice(columnPosition, 1);\n          schema[this.parameters.table].push(this.parameters.columnDestination);\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: (columnId) => {\n          return columnId;\n        },\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $adaptSchemaAsSchemaDefinition(schemaDefinition) {\n      const output = {};\n      const tableIds = Object.keys(schemaDefinition);\n      for (let index = 0; index < tableIds.length; index++) {\n        const storeId = tableIds[index];\n        const tableDefinition = schemaDefinition[storeId];\n        const columns = tableDefinition.indexes;\n        if (!(storeId in output)) {\n          output[storeId] = [];\n        }\n        for (let indexColumn = 0; indexColumn < columns.length; indexColumn++) {\n          const column = columns[indexColumn];\n          const columnId = column.name;\n          const columnInput = this.$adaptSchemaColumnAsSchemaDefinition(column, columnId);\n          output[storeId].push(columnInput);\n        }\n      }\n      return output;\n    }\n\n    $adaptSchemaTableAsSchemaDefinition(tableDefinition) {\n      const output = [];\n      const columns = tableDefinition.indexes;\n      for (let indexColumn = 0; indexColumn < columns.length; indexColumn++) {\n        const column = columns[indexColumn];\n        const columnId = column.name;\n        const columnInput = this.$adaptSchemaColumnAsSchemaDefinition(column, columnId);\n        output.push(columnInput);\n      }\n      return output;\n    }\n\n    $adaptSchemaColumnAsSchemaDefinition(column, columnId) {\n      if (column.unique) {\n        return \"!\" + columnId;\n      } else {\n        return columnId;\n      }\n    }\n\n    async $replicateSchema(scenario) {\n      LswDatabase.trace(\"LswDatabaseMigration.$replicateSchema\");\n      const { fromDatabase, toDatabase, onAlterSchema } = scenario;\n      console.log(`⌛️ Replicating database from «${fromDatabase}» to «${toDatabase}» on «LswDatabaseMigration.$replicateSchema»`);\n      const schemaDefinition = await LswDatabase.getSchema(fromDatabase);\n      const schemaInput = this.$adaptSchemaAsSchemaDefinition(schemaDefinition);\n      let alteredSchema = schemaInput;\n      if (onAlterSchema) {\n        alteredSchema = onAlterSchema(schemaInput);\n        if (typeof alteredSchema === \"undefined\") {\n          throw new Error(\"Required «onAlterSchema» to return an object on «LswDatabaseMigration.$replicateSchema»\")\n        }\n      }\n      console.log(\"Replicated schema:\", alteredSchema);\n      await LswDatabase.createDatabase(toDatabase, alteredSchema);\n    }\n\n    async $populateDatabase(scenario) {\n      LswDatabase.trace(\"LswDatabaseMigration.$populateDatabase\");\n      const { fromDatabase, toDatabase, onMapTableId = false, onMapColumnId = false } = scenario;\n      console.log(`⌛️ Populating database from «${fromDatabase}» to «${toDatabase}» on «LswDatabaseMigration.$populateDatabase»`);\n      const schemaDefinition = await LswDatabase.getSchema(fromDatabase);\n      const tableIds = Object.keys(schemaDefinition);\n      let fromConnection = undefined;\n      let toConnection = undefined;\n      let indexTable = 0;\n      let indexColumn = 0;\n      let tableId = undefined;\n      let alteredTableId = undefined;\n      try {\n        fromConnection = new LswDatabase(fromDatabase);\n        toConnection = new LswDatabase(toDatabase);\n        await fromConnection.open();\n        await toConnection.open();\n        for (indexTable = 0; indexTable < tableIds.length; indexTable++) {\n          tableId = tableIds[indexTable];\n          console.log(\"table:\", tableId);\n          Transfering_tables: {\n            console.log(`⌛️ Transfering table «${tableId}» on «LswDatabaseMigration.$populateDatabase»`);\n            let allRows = await fromConnection.selectMany(tableId, v => true);\n            console.log(\"[*] Getting table id\");\n            alteredTableId = tableId;\n            if (onMapTableId) {\n              alteredTableId = onMapTableId(tableId);\n            }\n            console.log(\"[*] Getting column id\");\n            if (onMapColumnId) {\n              allRows = allRows.reduce((output, row) => {\n                const allKeys = Object.keys(row);\n                const alteredRow = {};\n                for (let indexKeys = 0; indexKeys < allKeys.length; indexKeys++) {\n                  console.log(\"column:\", indexKeys);\n                  const columnId = allKeys[indexKeys];\n                  const alteredColumnId = onMapColumnId(columnId, tableId, alteredTableId, {\n                    fromConnection,\n                    toConnection\n                  }) || columnId;\n                  alteredRow[alteredColumnId] = row[columnId];\n                }\n                output.push(alteredRow);\n                return output;\n              }, []);\n            }\n            console.log(\"[*] Got:\", alteredTableId, allRows);\n            await toConnection.insertMany(alteredTableId, allRows);\n            console.log(\"What??? 444\")\n          }\n        }\n      } catch (error) {\n        console.log(`💥 Error while populating database on table ${tableId || \"-\"} (alias «${alteredTableId}»):`, error);\n      } finally {\n        try {\n          await fromConnection.close();\n        } catch (error) {\n          console.log(error);\n        }\n        try {\n          await toConnection.close();\n        } catch (error) {\n          console.log(error);\n        }\n        console.log(`[*] Database «${toDatabase}» population finished successfully.`);\n      }\n    }\n\n  }\n\n  class LswDatabaseMigration extends BrowsieMigration {\n\n  }\n\n  LswDatabaseMigration.default = LswDatabaseMigration;\n  window.LswDatabaseMigration = LswDatabaseMigration;\n  window.BrowsieMigration = BrowsieMigration;\n\n  class BrowsieMigrable extends BrowsieCrudAPI {\n\n    static migration = LswDatabaseMigration;\n\n  }\n\n  window.Browsie = BrowsieMigrable;\n  Browsie.default = BrowsieMigrable;\n\n  /* Extended API */\n\n  class LswDatabase extends BrowsieMigrable {\n\n    class = this.constructor;\n\n  }\n\n  LswDatabase.default = LswDatabase;\n  window.LswDatabase = LswDatabase;\n",
      "$code.label": "LswDatabase class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database-virtualizer/lsw-database-virtualizer.js",
      "$location": {
        "start": {
          "offset": 310,
          "line": 14,
          "column": 1
        },
        "end": {
          "offset": 428,
          "line": 15,
          "column": 1
        }
      },
      "section": "Lsw DatabaseVirtualizer API » LswDatabaseVirtualizer class",
      "$code": "  const LswDatabaseVirtualizer = class {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    static start(...args) {\n      const virtualization = new this(...args);\n      return virtualization;\n    }\n\n    $lifecycle = [\n      \"onStart\",\n      \"onStartValidation\",\n      \"onValidateConnection\",\n      \"onValidateSchema\",\n      \"onFinishValidation\",\n      \"onDeleteVirtualDatabase\",\n      \"onStartClonation\",\n      \"onCloneDatabase\",\n      \"onFinishClonation\",\n      \"onStartVirtualization\",\n      \"onVirtualizeSchema\",\n      \"onVirtualizeTables\",\n      \"onVirtualizeColumns\",\n      \"onFinishVirtualization\",\n      \"onStartFormalization\",\n      \"onFormalizeColumns\",\n      \"onFormalizeTables\",\n      \"onFormalizeSchema\",\n      \"onReport\",\n      \"onFinishFormalization\",\n      \"onFinish\",\n    ];\n\n    $defaultConfigurations = {\n      trace: true,\n    };\n\n    $trace(method, args) {\n      if(this.$configurations.trace) {\n        const methodArgs = Array.from(args);\n        console.log(`[trace][lsw-database-virtualizer] ${method}: (${methodArgs.length}) ${methodArgs.map(e => typeof e).join(\", \")}`);\n      }\n    }\n\n    constructor(configurations = {}) {\n      this.$configurations = Object.assign({}, this.$defaultConfigurations, configurations || {});\n      this.$trace(\"constructor\", arguments);\n      this.triggers = new TriggersClass();\n      this.physicalConnection = undefined;\n      this.virtualConnection = undefined;\n      this.schema = undefined;\n    }\n\n    configure(options = {}) {\n      this.$trace(\"configure\", arguments);\n      $ensure({ options }, 1).to.have.uniquelyKeys([\"physicalConnection\", \"virtualConnection\", \"schema\"]);\n      Object.assign(this, options);\n      return this;\n    }\n\n    setPhysicalConnection(physicalConnection) {\n      this.$trace(\"setPhysicalConnection\", arguments);\n      this.physicalConnection = physicalConnection;\n      return this;\n    }\n\n    setVirtualConnection(virtualConnection) {\n      this.$trace(\"setVirtualConnection\", arguments);\n      this.virtualConnection = virtualConnection;\n      return this;\n    }\n\n    setSchema(schema) {\n      this.$trace(\"setSchema\", arguments);\n      this.schema = schema;\n      return this;\n    }\n\n    start() {\n      this.$trace(\"start\", arguments);\n      return LswCycler.from(this, \"*\").run(this.$lifecycle);\n    }\n\n    async onStart() {\n      this.$trace(\"onStart\", arguments);\n      // *@TODO:\n    }\n\n    async onStartValidation() {\n      this.$trace(\"onStartValidation\", arguments);\n      // *@TODO:\n    }\n\n    async onValidateConnection() {\n      this.$trace(\"onValidateConnection\", arguments);\n      // *@TODO:\n    }\n\n    async onValidateSchema() {\n      this.$trace(\"onValidateSchema\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishValidation() {\n      this.$trace(\"onFinishValidation\", arguments);\n      // *@TODO:\n    }\n\n    async onDeleteVirtualDatabase() {\n      this.$trace(\"onDeleteVirtualDatabase\", arguments);\n      // *@TODO:\n    }\n\n    async onStartClonation() {\n      this.$trace(\"onStartClonation\", arguments);\n      // *@TODO:\n    }\n\n    async onCloneDatabase() {\n      this.$trace(\"onCloneDatabase\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishClonation() {\n      this.$trace(\"onFinishClonation\", arguments);\n      // *@TODO:\n    }\n\n    async onStartVirtualization() {\n      this.$trace(\"onStartVirtualization\", arguments);\n      // *@TODO:\n    }\n\n    async onVirtualizeSchema() {\n      this.$trace(\"onVirtualizeSchema\", arguments);\n      // *@TODO:\n    }\n\n    async onVirtualizeTables() {\n      this.$trace(\"onVirtualizeTables\", arguments);\n      // *@TODO:\n    }\n\n    async onVirtualizeColumns() {\n      this.$trace(\"onVirtualizeColumns\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishVirtualization() {\n      this.$trace(\"onFinishVirtualization\", arguments);\n      // *@TODO:\n    }\n\n    async onStartFormalization() {\n      this.$trace(\"onStartFormalization\", arguments);\n      // *@TODO:\n    }\n\n    async onFormalizeColumns() {\n      this.$trace(\"onFormalizeColumns\", arguments);\n      // *@TODO:\n    }\n\n    async onFormalizeTables() {\n      this.$trace(\"onFormalizeTables\", arguments);\n      // *@TODO:\n    }\n\n    async onFormalizeSchema() {\n      this.$trace(\"onFormalizeSchema\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishFormalization() {\n      this.$trace(\"onFinishFormalization\", arguments);\n      // *@TODO:\n    }\n\n    async onReport() {\n      this.$trace(\"onReport\", arguments);\n      // *@TODO:\n    }\n\n    async onFinish() {\n      this.$trace(\"onFinish\", arguments);\n      // *@TODO:\n    }\n\n  }\n",
      "$code.label": "LswDatabaseVirtualizer class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-depender/lsw-depender.js",
      "$location": {
        "start": {
          "offset": 288,
          "line": 14,
          "column": 3
        },
        "end": {
          "offset": 502,
          "line": 24,
          "column": 6
        }
      },
      "$section": "Lsw Depender API » LswDepender class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswDepender",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-depender/lsw-depender.js",
      "$location": {
        "start": {
          "offset": 503,
          "line": 25,
          "column": 1
        },
        "end": {
          "offset": 588,
          "line": 26,
          "column": 1
        }
      },
      "section": "Lsw Depender API » LswDepender class",
      "$code": "  const Definition = class {\n    constructor({ id, dependencies = [] }) {\n      this.id = id;\n      this.dependencies = dependencies;\n    }\n  };\n\n  const LswDepender = class {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor(definitions = {}) {\n      this.$definitions = definitions;\n    }\n\n    hasDefined(name) {\n      if (name in this.$definitions) {\n        if (this.$definitions[name] instanceof Definition) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    define(...args) {\n      if (typeof args[0] === \"string\") {\n        return this.addDefinition(...args);\n      }\n      return this.addUniqueDefinitions(...args);\n    }\n\n    resolve(idsInput = this, defs = this.$definitions) {\n      const ids = idsInput === this ? Object.keys(this.$definitions) : idsInput;\n      let resolved = new Set();\n      let resultado = [];\n      const resolverNodo = function(id) {\n        console.log(\"resolviendo nodo:\", id, defs);\n        if (resolved.has(id)) return;\n        if (!defs[id]) return; // Si no está definido, lo ignoramos\n        for (let dep of defs[id].dependencies || []) {\n          resolverNodo(dep);\n        }\n        resolved.add(id);\n        resultado.push(id);\n      }\n      for (let id of [].concat(ids)) {\n        resolverNodo(id);\n      }\n      return resultado;\n    }\n\n    addDefinition(name, definition, shouldFailOnRedundancy = 1, shouldOverrideOnRedundancy = 1) {\n      Validation: {\n        if (this.hasDefined(name)) {\n          if (shouldFailOnRedundancy) {\n            throw new Error(`Dependency «${name}» is already defined and should not redund on «LswDepender.define»`);\n          } else if (!shouldOverrideOnRedundancy) {\n            return false; // !@BREAK: the fallback must not override it\n          } else if (shouldOverrideOnRedundancy) {\n            // !@OK: the fallback will override it\n          } else {\n            throw new Error(\"Cannot logically happen (1)\");\n          }\n        }\n      }\n      Define_it: {\n        if (typeof definition !== \"object\") {\n          throw new Error(`Required definition of «${name}» to be an object on «LswDepender.define»`);\n        } else if (typeof definition.id !== \"string\") {\n          definition.id = name;\n        } else if (Array.isArray(definition.dependencies)) {\n          throw new Error(`Required definition of «${name}» its property «dependencies» to be a array on «LswDepender.define»`);\n        } else {\n          for (let indexDependency = 0; indexDependency < definition.dependencies.length; indexDependency++) {\n            const dependencyRef = definition.dependencies[indexDependency];\n            if (typeof dependencyRef !== \"string\") {\n              throw new Error(`Required definition of «${name}» its property «dependencies» on its index «${indexDependency}» to be a string on «LswDepender.define»`);\n            }\n          }\n        }\n        this.$definitions[name] = new Definition(definition);\n      }\n    }\n\n    addUniqueDefinitions(moreDefinitions = {}) {\n      const definitionIds = Object.keys(moreDefinitions);\n      for (let indexId = 0; indexId < definitionIds.length; indexId++) {\n        const definitionId = definitionIds[indexId];\n        const definitionInstance = moreDefinitions[definitionId];\n        this.define(definitionId, definitionInstance, 1);\n      }\n    }\n\n    addMissingDefinitions(moreDefinitions = {}) {\n      const definitionIds = Object.keys(moreDefinitions);\n      for (let indexId = 0; indexId < definitionIds.length; indexId++) {\n        const definitionId = definitionIds[indexId];\n        const definitionInstance = moreDefinitions[definitionId];\n        this.define(definitionId, definitionInstance, 0, 0);\n      }\n    }\n\n    resetDefinitions(moreDefinitions = {}) {\n      const definitionIds = Object.keys(moreDefinitions);\n      for (let indexId = 0; indexId < definitionIds.length; indexId++) {\n        const definitionId = definitionIds[indexId];\n        const definitionInstance = moreDefinitions[definitionId];\n        this.define(definitionId, definitionInstance, 0, 1);\n      }\n    }\n\n    deleteDefinitions(definitionsInput = []) {\n      const definitions = Array.isArray(definitionsInput) ? definitionsInput : [definitionsInput];\n      for (let indexDefinition = 0; indexDefinition < definitions.length; indexDefinition++) {\n        const definitionId = definitions[indexDefinition];\n        delete this.$definitions[definitionId];\n      }\n    }\n\n  }\n\n  LswDepender.default = LswDepender;\n",
      "$code.label": "LswDepender class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-dom.js",
      "$location": {
        "start": {
          "offset": 281,
          "line": 15,
          "column": 3
        },
        "end": {
          "offset": 480,
          "line": 25,
          "column": 6
        }
      },
      "$section": "Lsw Dom API » LswDom class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswDom",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-dom.js",
      "$location": {
        "start": {
          "offset": 481,
          "line": 26,
          "column": 1
        },
        "end": {
          "offset": 551,
          "line": 27,
          "column": 1
        }
      },
      "section": "Lsw Dom API » LswDom class",
      "$code": "  const LswDom = class {\n\n    static collectLeaves(originalCollection, selectorSequence = []) {\n      $ensure(originalCollection).type(\"object\");\n      $ensure(selectorSequence).type(\"object\").to.be.array();\n      let collection = Array.isArray(originalCollection) ? originalCollection : [originalCollection];\n      const mapperFactory = selector => element => {\n        return [].concat(element.querySelectorAll(selector));\n      };\n      for(let indexSelector=0; indexSelector<selectorSequence.length; indexSelector++) {\n        const selector = selectorSequence[indexSelector];\n        const subnodes = collection.map(mapperFactory(selector)).flat();\n        collection = [].concat(subnodes);\n      }\n      return collection;\n    }\n\n    static getClosestParent(originalElement, selector) {\n      $ensure(originalElement).type(\"object\").to.be.instanceOf(HTMLElement);\n      $ensure(selector).type(\"string\");\n      let element = originalElement.parentElement;\n      while(element && (element !== document)) {\n        if(element.matches(selector)) {\n          return element;\n        }\n        element = element.parentElement;\n      }\n      return null;\n    }\n\n    static getClosestChildren(originalElement, selector) {\n      $ensure(originalElement).type(\"object\").to.be.instanceOf(HTMLElement);\n      $ensure(selector).type(\"string\");\n      return [...originalElement.querySelectorAll(selector)].filter(element => {\n        return this.getClosestParent(element, selector) === originalElement;\n      });\n    }\n\n  };\n",
      "$code.label": "LswDom class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-vue2.js",
      "$location": {
        "start": {
          "offset": 280,
          "line": 14,
          "column": 3
        },
        "end": {
          "offset": 482,
          "line": 24,
          "column": 6
        }
      },
      "$section": "Lsw Vue2 API » LswVue2 class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswVue2",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-vue2.js",
      "$location": {
        "start": {
          "offset": 483,
          "line": 25,
          "column": 1
        },
        "end": {
          "offset": 556,
          "line": 26,
          "column": 1
        }
      },
      "section": "Lsw Vue2 API » LswVue2 class",
      "$code": "  const LswVue2 = class {\n\n    static getClosestParent(component, filterCallback) {\n      $ensure(component).type(\"object\");\n      $ensure(filterCallback).type(\"function\");\n      let parentOf = component;\n      do {\n        parentOf = parentOf.$parent;\n        const isValid = filterCallback(parentOf);\n        if (isValid) {\n          return parentOf;\n        }\n      } while (typeof parentOf !== \"undefined\");\n      return undefined;\n    }\n\n    static extendComponent(baseComponent = {}) {\n      const extendedComponent = Object.assign({}, baseComponent);\n      extendedComponent.props = Object.assign({}, baseComponent.props || {});\n      extendedComponent.methods = Object.assign({}, baseComponent.methods || {});\n      extendedComponent.watch = Object.assign({}, baseComponent.watch || {});\n      extendedComponent.computed = Object.assign({}, baseComponent.computed || {});\n      return extendedComponent;\n    }\n\n  }\n",
      "$code.label": "LswVue2 class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-ensurer/ensure.js",
      "$location": {
        "start": {
          "offset": 286,
          "line": 14,
          "column": 3
        },
        "end": {
          "offset": 497,
          "line": 24,
          "column": 6
        }
      },
      "$section": "Lsw Ensurer API » LswEnsurer class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswEnsurer",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-ensurer/ensure.js",
      "$location": {
        "start": {
          "offset": 498,
          "line": 25,
          "column": 1
        },
        "end": {
          "offset": 580,
          "line": 26,
          "column": 1
        }
      },
      "section": "Lsw Ensurer API » LswEnsurer class",
      "$code": "  class AssertionError extends Error {\n\n    constructor(...args) {\n      super(...args);\n      this.name = \"AssertionError\";\n    }\n\n  }\n\n  class Ensurement {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor(source, asLabeledObject = 0) {\n      Resolve_subject: {\n        if ((asLabeledObject === 1) && (typeof source === \"object\")) {\n          const sourceKeys = Object.keys(source);\n          if (sourceKeys.length !== 1) {\n            throw new Error(`The first parameter of $ensure or $check {when $2 is literally 1} must have 1 property (not ${sourceKeys.length}) on «Ensurement.constructor»`);\n          }\n          this.$subjectId = sourceKeys[0];\n          this.$subject = source[this.$subjectId];\n        } else if(typeof asLabeledObject === \"string\") {\n          this.$subjectId = asLabeledObject;\n          this.$subject = source;\n        } else {\n          this.$subjectId = \"@\";\n          this.$subject = source;\n        }\n      }\n      this.$operation = undefined;\n      this.$objectation = undefined;\n      this.asBoolean = false;\n    }\n    type(value) {\n      this.$operation = \"is of type\";\n      this.$objectation = value;\n      if(typeof value === \"string\") {\n        if (typeof this.$subject !== value) {\n          return this.$asFailed();\n        }\n      } else if(Array.isArray(value)) {\n        if(value.indexOf(typeof this.$subject) === -1) {\n          return this.$asFailed();\n        }\n      } else {\n        throw new Error(`Bad parameter on «$ensure(...).type(?)» (${typeof value} not admitted)`);\n      }\n      return this.$asResolved();\n    }\n    notType(value) {\n      this.$operation = \"is not of type\";\n      this.$objectation = value;\n      if (typeof this.$subject === value) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    is(value) {\n      this.$operation = \"is\";\n      this.$objectation = value;\n      if (this.$subject !== value) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    isnt(value) {\n      this.$operation = \"is not\";\n      this.$objectation = value;\n      if (this.$subject === value) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    can(value) {\n      this.$operation = \"can\";\n      this.$objectation = value;\n      if (!value(this.$subject)) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    cant(value) {\n      this.$operation = \"cant\";\n      this.$objectation = value;\n      if (value(this.$subject)) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    throws(value) {\n      this.$operation = \"throws\";\n      this.$objectation = value;\n      try {\n        objectation(this.$subject);\n        return this.$asFailed();\n      } catch (error) {\n        return this.$asResolved();\n      }\n    }\n    doesntThrow(value) {\n      this.$operation = \"doesntThrow\";\n      this.$objectation = value;\n      try {\n        value(this.$subject);\n        return this.$asFailed();\n      } catch (error) {\n        return this.$asResolved();\n      }\n    }\n    $asFailed(operation = this.$operation) {\n      if (this.asBoolean) {\n        return false;\n      }\n      throw new AssertionError(\"could not ensure «\" + this.$subjectId + \"» \" + operation + (this.$objectation ? \" «\" + this.$getObjectationAsString() + \"»\": \"\") + \"\");\n    }\n    $getObjectationAsString() {\n      return JSON.stringify(this.$objectation);\n    }\n    $asResolved() {\n      if (this.asBoolean) {\n        return true;\n      } else {\n        return this;\n      }\n    }\n  };\n\n  const BasicToBeInterface = class {\n    $isNegated = false;\n    set $operation(value) {\n      this.$ensurement.$operation = value;\n    }\n    get $operation() {\n      return this.$ensurement.$operation;\n    }\n    set $objectation(value) {\n      this.$ensurement.$objectation = value;\n    }\n    get $objectation() {\n      return this.$ensurement.$objectation;\n    }\n    constructor(ensurement) {\n      this.$ensurement = ensurement;\n      this.$subject = this.$ensurement.$subject;\n    }\n    $makeNegable(condition) {\n      return this.$isNegated === true ? !condition : condition;\n    }\n    $asFailed() {\n      return this.$ensurement.$asFailed();\n    }\n    $resolveNegableString(text) {\n      return text.replace(/\\{not\\?\\} */g, this.$isNegated ? \"not \" : \"\");\n    }\n  };\n\n  const ToBeInterface = class extends BasicToBeInterface {\n    string() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be string\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"string\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    number() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be number\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"number\") || Number.isNaN(this.$subject)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    object() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be object\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"object\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    null() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be null\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== null)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    undefined() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be undefined\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"undefined\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    boolean() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be boolean\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"boolean\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    instanceOf(clazz) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be instanceOf\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(!(this.$subject instanceof clazz))) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    array() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be array\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(!Array.isArray(this.$subject))) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    function() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be function\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof (this.$subject) !== \"function\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    empty() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be empty\");\n      this.$objectation = undefined;\n      const isEmpty = (() => {\n        const s = this.$subject;\n        if (Array.isArray(s)) {\n          return s.length === 0;\n        } else if (typeof s === \"object\") {\n          return s === null || Object.keys(s).length === 0;\n        } else if (typeof s === \"string\") {\n          return s === \"\";\n        } else if (typeof s === \"number\") {\n          return s === 0;\n        } else if (typeof s === \"boolean\") {\n          return s === false;\n        } else {\n          return true;\n        }\n      })();\n      if (this.$makeNegable(!isEmpty)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    equalTo(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be equal to\");\n      this.$objectation = value;\n      let isEqual = this.$subject === value;\n      if (this.$makeNegable(!isEqual)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    equalOrGreaterThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be equal or greater than\");\n      this.$objectation = value;\n      let isGreaterOrEqual = this.$subject >= value;\n      if (this.$makeNegable(!isGreaterOrEqual)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    greaterThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be greater than\");\n      this.$objectation = value;\n      let isGreater = this.$subject > value;\n      if (this.$makeNegable(!isGreater)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    greaterOrEqualTo(...args) {\n      return this.equalOrGreaterThan(...args);\n    }\n    equalOrLowerThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} equal or lower than\");\n      this.$objectation = value;\n      let isGreaterOrEqual = this.$subject <= value;\n      if (this.$makeNegable(!isGreaterOrEqual)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    lowerThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be lower than\");\n      this.$objectation = value;\n      let isGreater = this.$subject < value;\n      if (this.$makeNegable(!isGreater)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    lowerOrEqualTo(value) {\n      return this.equalOrLowerThan(...args);\n    }\n    oneOf(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be one of\");\n      this.$objectation = value;\n      if(!Array.isArray(value)) {\n        throw new Error(`Required on «$ensure(...).to.be.oneOf(!)» to provide an array on «ToBeInterface.oneOf»`);\n      }\n      let isOne = this.$objectation.indexOf(this.$subject) !== -1;\n      if (this.$makeNegable(!isOne)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n  };\n\n  const ToNotBeInterface = class extends ToBeInterface {\n    $isNegated = true;\n  };\n\n  const ToHaveInterface = class extends BasicToBeInterface {\n\n    text(prop) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have text\");\n      this.$objectation = prop;\n      const hasSubstring = this.$subject.indexOf(prop) !== -1;\n      if (this.$makeNegable(!hasSubstring)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    \n    key(prop) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have key\");\n      this.$objectation = prop;\n      const keys = Object.keys(this.$subject);\n      const hasKey = keys.indexOf(prop) !== -1;\n      if (this.$makeNegable(!hasKey)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    value(prop) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have value\");\n      this.$objectation = prop;\n      const values = Object.values(this.$subject);\n      const hasValue = values.indexOf(prop) !== -1;\n      if (this.$makeNegable(!hasValue)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    onlyPotentialKeys(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have only potential keys\");\n      this.$objectation = props;\n      const keys = Object.keys(this.$subject);\n      let hasOnly = true;\n      Iterating_props:\n      for (let index = 0; index < keys.length; index++) {\n        const key = keys[index];\n        if (props.indexOf(key) === -1) {\n          hasOnly = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasOnly)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    keys(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have keys\");\n      this.$objectation = props;\n      const keys = Object.keys(this.$subject);\n      let hasKeys = true;\n      Iterating_props:\n      for (let index = 0; index < props.length; index++) {\n        const prop = props[index];\n        if (keys.indexOf(prop) === -1) {\n          hasKeys = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasKeys)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    values(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have values\");\n      this.$objectation = props;\n      const values = Object.values(this.$subject);\n      let hasValues = true;\n      Iterating_props:\n      for (let index = 0; index < props.length; index++) {\n        const prop = props[index];\n        if (values.indexOf(prop) === -1) {\n          hasValues = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasValues)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    uniquelyKeys(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have uniquelyKeys\");\n      this.$objectation = props;\n      const keys = Object.keys(this.$subject);\n      let hasKeys = true;\n      Iterating_props:\n      for (let index = 0; index < keys.length; index++) {\n        const key = keys[index];\n        if (props.indexOf(key) === -1) {\n          hasKeys = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasKeys)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    uniquelyValues(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have uniquelyValues\");\n      this.$objectation = props;\n      const values = Object.values(this.$subject);\n      let hasValues = true;\n      Iterating_props:\n      for (let index = 0; index < values.length; index++) {\n        const value = values[index];\n        if (props.indexOf(value) === -1) {\n          hasValues = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasValues)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n  };\n\n  const ToNotHaveInterface = class extends ToHaveInterface {\n    $isNegated = true;\n  };\n\n  const EnsurementV1 = class extends Ensurement {\n\n    selfExtend(obj) {\n      return Object.assign(this, obj);\n    }\n\n    get $toNotBe() {\n      return new ToNotBeInterface(this);\n    }\n\n    get $toNotHave() {\n      return new ToNotHaveInterface(this);\n    }\n\n    get $toNot() {\n      return {\n        be: this.$toNotBe,\n        have: this.$toNotHave,\n      }\n    }\n\n    get $toBe() {\n      return new ToBeInterface(this);\n    }\n\n    get $toHave() {\n      return new ToHaveInterface(this);\n    }\n\n    get to() {\n      return {\n        be: this.$toBe,\n        have: this.$toHave,\n        not: this.$toNot,\n      };\n    }\n\n    its(id) {\n      return this.constructor.create({\n        [id]: this.$subject[id]\n      }, 1).selfExtend({\n        $parent: this,\n        asBoolean: this.asBoolean,\n      });\n    }\n\n    getSubject() {\n      return this.$subject;\n    }\n\n    safelyBack(levels = 1) {\n      for (let index = 0; index < levels; index++) {\n        try {\n          parent = this.$parent;\n        } catch (error) {\n          // @OK.\n        }\n      }\n    }\n\n    back(levels = 1) {\n      let parent = this;\n      for (let index = 0; index < levels; index++) {\n        try {\n          parent = this.$parent;\n        } catch (error) {\n          throw new Error(`Ensurement could not go «back» reaching parent on level «${index}» on «ensure(...).back»`);\n        }\n      }\n      return parent;\n    }\n\n    static $or(options) {\n      let correctOption = undefined;\n      const allIds = Object.keys(options);\n      const orError = new Error(`could not ensure «or» group with options: «${allIds.join(\"», «\")}»`);\n      for(let index=0; index<allIds.length; index++) {\n        const currentId = allIds[index];\n        const currentOptionCallback = options[currentId];\n        try {\n          currentOptionCallback();\n          return currentId;\n        } catch (error) {\n          orError.appendError(error);\n        }\n      }\n      throw orError.unified();\n    }\n\n    static ensure(...args) {\n      return this.create(...args);\n    }\n\n    static check(...args) {\n      return this.create(...args).selfExtend({\n        asBoolean: true\n      });\n    }\n\n    static assert(condition, errorMessage = \"Assertion error happened\") {\n      if (!condition) {\n        throw new AssertionError(errorMessage);\n      }\n      return true;\n    }\n\n    static fails(callback, errorMessage = \"Assertion error happened\") {\n      let passes = true;\n      try {\n        callback();\n        passes = false;\n      } catch (error) {\n        return true;\n      }\n      if (!passes) {\n        throw new AssertionError(errorMessage);\n      }\n    }\n\n    static AssertionError = AssertionError;\n\n  };\n\n  Export_to_globals: {\n    globalThis.$fails = EnsurementV1.fails.bind(EnsurementV1);\n    globalThis.$ensure = EnsurementV1.ensure.bind(EnsurementV1);\n    globalThis.$check = EnsurementV1.check.bind(EnsurementV1);\n    globalThis.$assert = EnsurementV1.assert.bind(EnsurementV1);\n    // globalThis.AssertionError = AssertionError;\n    globalThis.$ensure.$or = EnsurementV1.$or;\n  }\n  \n  return EnsurementV1;\n",
      "$code.label": "LswEnsurer class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-error-manager/lsw-error-manager.js",
      "$location": {
        "start": {
          "offset": 2,
          "line": 3,
          "column": 1
        },
        "end": {
          "offset": 208,
          "line": 13,
          "column": 4
        }
      },
      "$section": "Lsw ErrorManager API » LswErrorManager class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswErrorManager",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-error-manager/lsw-error-manager.js",
      "$location": {
        "start": {
          "offset": 209,
          "line": 14,
          "column": 1
        },
        "end": {
          "offset": 304,
          "line": 15,
          "column": 1
        }
      },
      "section": "Lsw ErrorManager API » LswErrorManager class",
      "$code": "\nglobalThis.ErrorSummary = class {\n  constructor(data) {\n    Object.assign(this, data);\n  }\n  toString() {\n    return JSON.stringify(this, null, 2);\n  }\n}\n\nglobalThis.Error = class AccumulableError extends Error {\n  constructor(...args) {\n    super(...args);\n    this.$accumulatedErrors = [];\n  }\n  toString() {\n    return JSON.stringify(this, null, 2);\n  }\n  toJSON() {\n    const data = {\n      name: this.name || \"Error\",\n      message: this.message || \"\",\n      stack: this.stack ? this.stack.split(\"\\n    at \") : \"\",\n      ...this,\n    };\n    if (this.$accumulatedErrors && this.$accumulatedErrors.length) {\n      data.$accumulatedErrors = this.$accumulatedErrors;\n    }\n    return data;\n  }\n  unified() {\n    this.message = this.message + \"\\n\" + this.$accumulatedErrors.map((e, i) => (i + 1) + ': ' + e.name + ': ' + e.message).join(\"\\n\");\n    this.$accumulatedErrors = [];\n    return this;\n  }\n  prependError(error) {\n    this.$accumulatedErrors.unshift(error);\n    return this;\n  }\n  appendError(error) {\n    this.$accumulatedErrors.push(error);\n    return this;\n  }\n  summarized() {\n    let uniqueTraces = [];\n    let commonTraces = [];\n    // Recopilar las trazas de la pila de errores acumulados\n    const allStacks = this.$accumulatedErrors.map(\n      (error) => (error.stack ? error.stack.split(\"\\n    at \") : [])\n    );\n    // Si no hay acumulados, no hay comunes ni únicos\n    if (allStacks.length === 0) {\n      return new ErrorSummary({\n        name: this.name,\n        message: this.message,\n        stack: this.stack ? this.stack.split(\"\\n    at \") : [],\n        uniqueTraces: uniqueTraces,\n        commonTraces: commonTraces,\n      });\n    }\n    // Identificar trazas comunes\n    const firstStack = allStacks[0];\n    for (let i = 0; i < firstStack.length; i++) {\n      const trace = firstStack[i];\n      let isCommon = true;\n      for (let j = 1; j < allStacks.length; j++) {\n        if (!allStacks[j].includes(trace)) {\n          isCommon = false;\n          break;\n        }\n      }\n      if (isCommon) {\n        commonTraces.push(trace);\n      }\n    }\n    // Identificar trazas únicas\n    for (let i = 0; i < allStacks.length; i++) {\n      const uniqueForStack = [];\n      for (let j = 0; j < allStacks[i].length; j++) {\n        const trace = allStacks[i][j];\n        if (!commonTraces.includes(trace)) {\n          uniqueForStack.push(trace);\n        }\n      }\n      uniqueTraces.push(uniqueForStack);\n    }\n    return new ErrorSummary({\n      ...this,\n      name: this.name,\n      message: this.message,\n      stack: this.stack ? this.stack.split(\"\\n    at \") : [],\n      uniqueTraces: uniqueTraces,\n      commonTraces: commonTraces,\n    });\n  }\n\n}\n\n",
      "$code.label": "LswErrorManager class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-filesystem/ufs-v1.0.2.js",
      "$location": {
        "start": {
          "offset": 326,
          "line": 9,
          "column": 1
        },
        "end": {
          "offset": 408,
          "line": 10,
          "column": 1
        }
      },
      "section": "UFS Manager API » UFS_manager class",
      "$code": "(function (factory) {\n  const name = \"UFS_manager\";\n  const modulo = factory();\n  if (typeof window !== 'undefined') {\n    window[name] = modulo;\n  }\n  if (typeof module !== 'undefined') {\n    module.exports = modulo;\n  }\n  if (typeof global !== 'undefined') {\n    global[name] = modulo;\n  }\n  return modulo;\n})(function () {\n  const FilesystemError = class extends Error {\n    constructor(...args) {\n      super(...args);\n      this.name = \"FilesystemError\";\n    }\n  }\n  const UFS_manager_for_node = class {\n    constructor() {\n      // @OK\n    }\n    init() {\n      return this;\n    }\n    trace(method, args = []) {\n      console.log(\"[ufs][node-driver][\" + method + \"]\", Array.from(args).map(arg => typeof (arg) + \": \" + arg).join(\", \"));\n    }\n    resolve_path(...args) {\n      this.trace(\"resolve_path\", arguments);\n      return require(\"path\").resolve(...args);\n    }\n    get_current_directory() {\n      this.trace(\"get_current_directory\", arguments);\n      return process.cwd();\n    }\n    change_directory(node) {\n      this.trace(\"change_directory\", arguments);\n      return process.chdir(node);\n    }\n    rename(node, node2) {\n      this.trace(\"rename\", arguments);\n      return require(\"fs\").renameSync(node, node2);\n    }\n    read_directory(node) {\n      this.trace(\"read_directory\", arguments);\n      return require(\"fs\").readdirSync(node).reduce((out, item) => {\n        const subnode_fullpath = require(\"path\").resolve(node, item);\n        out[item] = require(\"fs\").lstatSync(subnode_fullpath).isFile() ? \"...\" : {};\n        return out;\n      }, {});\n    }\n    read_file(node) {\n      this.trace(\"read_file\", arguments);\n      return require(\"fs\").readFileSync(node).toString();\n    }\n    make_directory(node) {\n      this.trace(\"make_directory\", arguments);\n      return require(\"fs\").mkdirSync(node);\n    }\n    write_file(node, contents) {\n      this.trace(\"write_file\", arguments);\n      return require(\"fs\").writeFileSync(node, contents);\n    }\n    exists(node) {\n      this.trace(\"exists\", arguments);\n      return require(\"fs\").existsSync(node);\n    }\n    is_file(node) {\n      this.trace(\"is_file\", arguments);\n      return require(\"fs\").lstatSync(node).isFile();\n    }\n    is_directory(node) {\n      this.trace(\"is_directory\", arguments);\n      return require(\"fs\").lstatSync(node).isDirectory();\n    }\n    delete_file(node) {\n      this.trace(\"delete_file\", arguments);\n      return require(\"fs\").unlinkSync(node);\n    }\n    delete_directory(node) {\n      this.trace(\"delete_directory\", arguments);\n      return require(\"fs\").rmdirSync(node, { recursive: true });\n    }\n  }\n\n  const UFS_manager_for_localstorage = class extends UFS_manager_for_node {\n    constructor(storage_id = \"ufs_main_storage\") {\n      super();\n      this.storage_id = storage_id;\n      this.current_directory = this.environment === \"node\" ? process.cwd : \"/\";\n    }\n    trace(method, args = []) {\n      console.log(\"[ufs][ls-driver][\" + method + \"]\", Array.from(args).map(arg => typeof (arg) + \": \" + arg).join(\", \"));\n    }\n    get_persisted_data() {\n      this.trace(\"get_persisted_data\", arguments);\n      if (!(this.storage_id in localStorage)) {\n        localStorage[this.storage_id] = '{\"files\":{}}';\n      }\n      const data = JSON.parse(localStorage[this.storage_id]);\n      return data;\n    }\n    set_persisted_data(data) {\n      this.trace(\"set_persisted_data\", arguments);\n      localStorage[this.storage_id] = JSON.stringify(data);\n    }\n    remove_slash_end(txt) {\n      // this.trace(\"remove_slash_end\", arguments);\n      const txt2 = txt.replace(/\\/$/g, \"\");\n      if (txt2.length === 0) {\n        return \"/\";\n      }\n      return txt2;\n    }\n    remove_repeated_slahes(txt) {\n      // this.trace(\"remove_repeated_slahes\", arguments);\n      return txt.replace(/\\/(\\/)+/g, \"/\");\n    }\n    resolve_path(...args) {\n      this.trace(\"resolve_path\", arguments);\n      Validate_args: {\n        if (args.length === 0) {\n          throw new Error(\"Method «resolve_path» requires 1 or more parameters\");\n        }\n        for (let index_parameter = 0; index_parameter < args.length; index_parameter++) {\n          const arg = args[index_parameter];\n          if (typeof arg !== \"string\") {\n            throw new Error(\"Method «resolve_path» requires only strings as parameters (on index «\" + index_parameter + \"»)\");\n          }\n        }\n      }\n      let path_parts = [];\n      Format_path: {\n        const replace_last_slash_for_nothing = arg => this.remove_slash_end(arg);\n        path_parts = args.map(replace_last_slash_for_nothing);\n        if (!path_parts[0].startsWith(\"/\")) {\n          path_parts.unshift(this.current_directory.replace(/\\/$/g, \"\"));\n        }\n      }\n      let path_text = \"\";\n      Join_path: {\n        const replace_fist_slash_for_nothing = arg => arg.replace(/^\\//g, \"\");\n        for (let index_part = 0; index_part < path_parts.length; index_part++) {\n          const path_part = path_parts[index_part];\n          if (path_part.startsWith(\"/\")) {\n            path_text = path_part;\n          } else {\n            if (path_text !== \"/\") {\n              path_text += \"/\";\n            }\n            path_text += path_part.replace(replace_fist_slash_for_nothing);\n          }\n        }\n      }\n      Fix_slash_repetitions: {\n        path_text = this.remove_repeated_slahes(path_text);\n      }\n      Resolve_double_dots: {\n        const parts = path_text.split(\"/\");\n        const stack = [];\n        Iterating_parts:\n        for (const part of parts) {\n          if (part === \"\" || part === \".\") {\n            continue Iterating_parts;\n          } else if (part === \"..\") {\n            if (stack.length > 0) {\n              stack.pop();\n            }\n          } else {\n            stack.push(part);\n          }\n        }\n        path_text = \"/\" + stack.join(\"/\");\n      }\n      return path_text;\n    }\n    get_current_directory() {\n      this.trace(\"get_current_directory\", arguments);\n      return this.resolve_path(this.current_directory);\n    }\n    change_directory(node) {\n      this.trace(\"change_directory\", arguments);\n      const is_directory = this.exists(node);\n      if (!is_directory) {\n        throw new FilesystemError(\"Cannot «change_directory» because destination does not exist at: «\" + this.resolve_path(node) + \"»\");\n      }\n      this.current_directory = this.resolve_path(node);\n      return this.current_directory;\n    }\n    operate_on_node(node, callback, should_persist = true) {\n      this.trace(\"operate_on_node\", arguments);\n      const data = this.get_persisted_data();\n      const node_solved = this.resolve_path(node);\n      const node_parts = node_solved.split(\"/\").filter(p => p !== \"\");\n      const root = data.files;\n      const current_index = [\"data\"];\n      let pivot = root;\n      let output = undefined;\n      if (node_parts.length === 0) {\n        output = callback(data, \"files\", current_index);\n      } else {\n        for (let index_part = 0; index_part < node_parts.length; index_part++) {\n          const node_part = node_parts[index_part];\n          if (index_part === (node_parts.length - 1)) {\n            output = callback(pivot, node_part, current_index);\n          } else {\n            pivot = pivot[node_part];\n          }\n          current_index.push(node_part);\n        }\n      }\n      if (should_persist) {\n        this.set_persisted_data(data);\n      }\n      return output;\n    }\n    read_directory(node) {\n      this.trace(\"read_directory\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          throw new FilesystemError(\"Cannot «read_directory» because node does not exist at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"object\") {\n          throw new FilesystemError(\"Cannot «read_directory» because node is a file at: «\" + this.resolve_path(node) + \"»\");\n        }\n        return pivot[last_property];\n      });\n    }\n    read_file(node) {\n      this.trace(\"read_file\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          throw new FilesystemError(\"Cannot «read_file» because node does not exist at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"string\") {\n          throw new FilesystemError(\"Cannot «read_file» because node is a directory at: «\" + this.resolve_path(node) + \"»\");\n        }\n        return pivot[last_property];\n      });\n    }\n    make_directory(node) {\n      this.trace(\"make_directory\", arguments);\n      this.operate_on_node(node, (pivot, last_property, index) => {\n        if (last_property in pivot) {\n          throw new FilesystemError(\"Cannot «make_directory» because node already exists at: «\" + this.resolve_path(node) + \"»\");\n        }\n        pivot[last_property] = {};\n      });\n    }\n    write_file(node, contents) {\n      this.trace(\"write_file\", arguments);\n      this.operate_on_node(node, (pivot, last_property, index) => {\n        if (last_property in pivot) {\n          if (typeof pivot[last_property] !== \"string\") {\n            throw new FilesystemError(\"Cannot «write_file» because node is a directory at: «\" + this.resolve_path(node) + \"»\");\n          }\n        }\n        pivot[last_property] = contents;\n      });\n    }\n    exists(node) {\n      this.trace(\"exists\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          return false;\n        }\n        return true;\n      }, false);\n    }\n    is_file(node) {\n      this.trace(\"is_file\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          return false;\n        }\n        if (typeof pivot[last_property] !== \"string\") {\n          return false;\n        }\n        return true;\n      }, false);\n    }\n    is_directory(node) {\n      this.trace(\"is_directory\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          return false;\n        }\n        if (typeof pivot[last_property] !== \"object\") {\n          return false;\n        }\n        return true;\n      }, false);\n    }\n    delete_file(node) {\n      this.trace(\"delete_file\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (typeof pivot[last_property] === \"undefined\") {\n          throw new FilesystemError(\"Cannot «delete_file» because node does not exist at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"string\") {\n          throw new FilesystemError(\"Cannot «delete_file» because node is a directory at: «\" + this.resolve_path(node) + \"»\");\n        }\n        delete pivot[last_property];\n        return true;\n      }, true);\n    }\n    delete_directory(node) {\n      this.trace(\"delete_directory\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (typeof pivot[last_property] === \"undefined\") {\n          console.log(pivot);\n          console.log(last_property);\n          throw new FilesystemError(\"Cannot «delete_directory» because does not exists at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"object\") {\n          throw new FilesystemError(\"Cannot «delete_directory» because node is a file at: «\" + this.resolve_path(node) + \"»\");\n        }\n        delete pivot[last_property];\n        return true;\n      }, true);\n    }\n    rename(node, node2) {\n      this.trace(\"rename\", arguments);\n      const last_name = this.resolve_path(node2).split(\"/\").filter(p => p !== \"\").pop();\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (typeof pivot[last_property] === \"undefined\") {\n          throw new FilesystemError(\"Cannot «rename» because does not exists at: «\" + this.resolve_path(node) + \"»\");\n        }\n        pivot[last_name] = pivot[last_property];\n        pivot[last_property] = undefined;\n        delete pivot[last_property];\n        return true;\n      }, true);\n    }\n\n  }\n\n  const UFS_manager_for_idb = class extends UFS_manager_for_localstorage {\n\n    constructor(db_name = \"ufs_db\") {\n      super();\n      this.db_name = db_name;\n      this.db = null;\n      this.current_directory = \"/\";\n    }\n\n    trace(method, args = []) {\n      console.log(\"[ufs][idb-driver][\" + method + \"]\", Array.from(args).map(arg => typeof (arg) + \": \" + arg).join(\", \"));\n    }\n\n    init() {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.db_name, 1);\n        request.onupgradeneeded = (event) => {\n          let db = event.target.result;\n          if (!db.objectStoreNames.contains(\"ufs\")) {\n            let store = db.createObjectStore(\"ufs\", {\n              keyPath: \"id\",\n              autoIncrement: true,\n            });\n            store.createIndex(\"filepath\", \"filepath\", { unique: true });\n          }\n        };\n        request.onsuccess = (event) => {\n          this.db = event.target.result;\n          resolve();\n        };\n        request.onerror = (event) => reject(event.target.error);\n      });\n    }\n\n    _get_filename(somepath) {\n      return somepath.split(\"/\").filter(p => typeof (p) !== \"undefined\").pop();\n    }\n\n    isImmediateSubpathFrom(subpath, matchable) {\n      const matchablePos = matchable.length;\n      const coincidesParentPath = subpath.substr(0, matchablePos) === matchable;\n      if (!coincidesParentPath) return false;\n      const hasNoMoreSlashes = subpath.substr(matchablePos).indexOf(\"/\") === -1;\n      if (!hasNoMoreSlashes) return false;\n      return true;\n    }\n\n    read_directory(parentIdInput = \"/\") {\n      this.trace(\"read_directory\", arguments);\n      const parentId = this.resolve_path(parentIdInput);\n      return new Promise((resolve, reject) => {\n        The_previous_process: {\n          break The_previous_process;\n          const transaction = this.db.transaction(\"ufs\", \"readonly\");\n          const store = transaction.objectStore(\"ufs\");\n          const index = store.index(\"filepath\");\n          const request = index.getAll(parentId);\n          request.onsuccess = () => {\n            let result = {};\n            for (let item of request.result) {\n              result[item.name] = item.type === \"file\" ? \"...\" : {};\n            }\n            resolve(result);\n          };\n        }\n        const transaction = this.db.transaction(\"ufs\", 'readonly');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria\n        const results = [];\n        const matchableSubpath = (parentId === \"/\") ? parentId : (parentId + \"/\");\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            let isAccepted = false;\n            try {\n              isAccepted = cursor.value.filepath.startsWith(matchableSubpath);\n              isAccepted = isAccepted && this.isImmediateSubpathFrom(cursor.value.filepath, matchableSubpath);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «browsie.selectMany»\", error);\n            }\n            if (isAccepted) {\n              // Añade a la colección de salida\n              results.push(cursor.value);\n            }\n            cursor.continue(); // Avanza al siguiente registro\n          } else {\n            // Se formatean los resultados:\n            const formattedResults = {};\n            results.forEach(row => {\n              const rowName = this._get_filename(row.filepath);\n              formattedResults[rowName] = row.type === \"file\" ? \"...\" : {};\n            });\n            resolve(formattedResults);\n          }\n        };\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    read_file(nodeInput) {\n      this.trace(\"read_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => {\n          resolve(request.result ? request.result.content : null);\n        };\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    async write_file(nodeInput, contents) {\n      this.trace(\"write_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      const file = await this.$filepath(node);\n      return await new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readwrite\");\n        const store = transaction.objectStore(\"ufs\");\n        const filedata = { filepath: node, type: \"file\", content: contents };\n        if (file) {\n          filedata.id = file.id;\n        }\n        store.put(filedata);\n        transaction.oncomplete = () => resolve();\n        transaction.onerror = () => reject(transaction.error);\n      });\n    }\n\n    async make_directory(nodeInput) {\n      this.trace(\"make_directory\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return await new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readwrite\");\n        const store = transaction.objectStore(\"ufs\");\n        store.put({ filepath: node, type: \"directory\" });\n        transaction.oncomplete = () => resolve();\n        transaction.onerror = () => reject(transaction.error);\n      });\n    }\n\n    exists(nodeInput) {\n      this.trace(\"exists\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => resolve(!!request.result);\n        request.onerror = () => resolve(false);\n      });\n    }\n\n    is_file(nodeInput) {\n      this.trace(\"is_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => resolve(request.result ? request.result.type === \"file\" : false);\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    is_directory(nodeInput) {\n      this.trace(\"is_directory\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => resolve(request.result ? request.result.type === \"directory\" : false);\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    delete_file(nodeInput) {\n      this.trace(\"delete_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return this.$deleteMany(file => {\n        return (file.type === \"file\") && (file.filepath === node);\n      });\n    }\n\n    async delete_directory(nodeInput) {\n      this.trace(\"delete_directory\", arguments);\n      const node = this.resolve_path(nodeInput);\n      await this.$deleteMany(file => file.filepath.startsWith(node));\n      await this.$deleteMany(file => file.filepath === node);\n    }\n\n    $updateMany(filterCallback, expanderCallback) {\n      this.trace(\"$updateMany\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readwrite');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor();\n        let updatedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (cursor) {\n            const isAccepted = filterCallback(cursor.value, cursor);\n            if (isAccepted) {\n              const expanderItem = expanderCallback({ ...cursor.value }, cursor);\n              const updatedItem = { ...cursor.value, ...expanderItem };\n              const updateRequest = cursor.update(updatedItem);\n              updateRequest.onsuccess = () => {\n                updatedCount++;\n              };\n            }\n            cursor.continue();\n          } else {\n            return resolve(updatedCount);\n          }\n        };\n        request.onerror = () => reject(transaction.error);\n      });\n    }\n\n    $deleteMany(filterCallback) {\n      this.trace(\"$deleteMany\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readwrite');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor();\n        let deletedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (cursor) {\n            const isAccepted = filterCallback(cursor.value, cursor);\n            if (isAccepted) {\n              const deleteRequest = cursor.delete();\n              deleteRequest.onsuccess = () => {\n                deletedCount++;\n              };\n            }\n            cursor.continue();\n          } else {\n            return resolve(deletedCount);\n          }\n        };\n        request.onerror = () => reject(transaction.error);\n      });\n    }\n\n    rename(nodeInput, newName) {\n      this.trace(\"rename\", arguments);\n      const node = this.resolve_path(nodeInput);\n      const newNode = node.split(\"/\").slice(0, -1).concat(newName).join(\"/\") || \"/\";\n      const pathBegin = node.replace(/\\/$/g, \"\") + \"/\";\n      const newNodeBegin = newNode.replace(/\\/$/g, \"\") + \"/\";\n      console.log(\"Buscando nodos que empiecen por: «\" + pathBegin + \"»\");\n      const renameSubnodes = async () => {\n        const allSubnodes = await this.$selectMany(file => file.filepath.startsWith(pathBegin));\n        const allPromises = [];\n        for (let index = 0; index < allSubnodes.length; index++) {\n          const subnode = allSubnodes[index];\n          const newSubpath = subnode.filepath.replace(pathBegin, newNodeBegin);;\n          console.log(\"Reemplazando a:\", subnode.filepath, \"Por:\", newSubpath);\n          const subpromise = this.$update(subnode.id, { filepath: newSubpath });\n          allPromises.push(subpromise);\n        }\n        return await Promise.all(allPromises);\n      };\n      const renameNode = () => new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readwrite\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => {\n          if (!request.result) {\n            reject(new Error(\"Node not found\"));\n            return;\n          }\n          const data = request.result;\n          data.filepath = newNode;\n          store.put(data);\n          transaction.oncomplete = () => resolve();\n          transaction.onerror = () => reject(transaction.error);\n        };\n        request.onerror = () => reject(request.error);\n      });\n      return Promise.all([\n        renameNode().then(() => renameSubnodes()),\n      ]);\n    }\n\n    async $filepath(filepath) {\n      const selection = await this.$selectMany(file => file.filepath === filepath);\n      if (selection.length === 1) {\n        return selection[0];\n      } else if (selection.length > 1) {\n        return selection;\n      }\n      return null;\n    }\n\n    $selectMany(filterCallback) {\n      this.trace(\"$selectMany\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readonly');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria\n        const results = [];\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            let isAccepted = undefined;\n            try {\n              isAccepted = filterCallback(cursor.value);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «selectMany»\", error);\n            }\n            if (isAccepted) { // Aplica la función de filtro\n              results.push(cursor.value);\n            }\n            cursor.continue(); // Avanza al siguiente registro\n          } else {\n            resolve(results); // Se terminó el recorrido\n          }\n        };\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    $update(id, item) {\n      this.trace(\"$update\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readwrite');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request0 = objectStore.get(id);\n        request0.onsuccess = () => {\n          const originalState = request0.result;\n          if (!originalState) return reject(`No item found by id «${id}» on «$update»`);\n          const request = objectStore.put({ ...originalState, ...item, id });\n          request.onsuccess = () => resolve(request.result);\n          request.onerror = () => reject(request.error);\n        };\n        request0.onerror = () => reject(request0.error);\n      });\n    }\n\n  }\n\n  const api = {\n    node_driver: UFS_manager_for_node,\n    localstorage_driver: UFS_manager_for_localstorage,\n    idb_driver: UFS_manager_for_idb,\n    create(...args) {\n      const clazz = typeof global !== \"undefined\" ? UFS_manager_for_node : UFS_manager_for_localstorage;\n      return new clazz(...args);\n    },\n    driver(id) {\n      const driverId = id.toLowerCase() + \"_driver\";\n      if (!(driverId in api)) {\n        throw new Error(`Cannot find driver «${driverId}» on «UFS_manager.driver»`);\n      }\n      return {\n        create(...args) {\n          const clazz = api[driverId];\n          return new clazz(...args);\n        }\n      }\n    }\n  };\n\n  return api;\n",
      "$code.label": "UFS_manager class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-lifecycle/lsw-lifecycle.js",
      "$location": {
        "start": {
          "offset": 290,
          "line": 14,
          "column": 3
        },
        "end": {
          "offset": 501,
          "line": 24,
          "column": 6
        }
      },
      "$section": "Lsw LswCycler API » LswCycler class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswCycler",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-lifecycle/lsw-lifecycle.js",
      "$location": {
        "start": {
          "offset": 502,
          "line": 25,
          "column": 1
        },
        "end": {
          "offset": 584,
          "line": 26,
          "column": 1
        }
      },
      "section": "Lsw LswCycler API » LswCycler class",
      "$code": "  const cycle = LswCycler.from({\n\n    steps: [\n      \"onStarted\",\n      \"onInitialize\",\n      \"onInitialized\",\n      \"onBoot\",\n      \"onBooted\",\n      \"onLoadModules\",\n      \"onModulesLoaded\",\n      \"onInstallModules\",\n      \"onModulesInstalled\",\n      \"onLoadSchema\",\n      \"onSchemaLoaded\",\n      \"onLoadDatabase\",\n      \"onDatabaseLoaded\",\n      \"onLoadApplication\",\n      \"onApplicationLoaded\",\n      \"onAllLoaded\",\n      \"onFinished\",\n    ],\n\n    hooks: TriggersClass.create(),\n\n    $trace: function(method, args) {\n      if(Vue.prototype.$trace) {\n        Vue.prototype.$trace(\"lsw-app-lifecycle.\" + method, args);\n      }\n    },\n\n    onStarted: function () {\n      this.$trace(\"onStarted\", []);\n      return this.hooks.emit(\"app:started\");\n    },\n\n    onInitialize: function () {\n      this.$trace(\"onInitialize\", []);\n      return this.hooks.emit(\"app:initialize\");\n    },\n\n    onInitialized: function () {\n      this.$trace(\"onInitialized\", []);\n      return this.hooks.emit(\"app:initialized\");\n    },\n\n    onBoot: function () {\n      this.$trace(\"onBoot\", []);\n      return this.hooks.emit(\"app:boot\");\n    },\n\n    onBooted: function () {\n      this.$trace(\"onBooted\", []);\n      return this.hooks.emit(\"app:booted\");\n    },\n\n    onLoadModules: function () {\n      this.$trace(\"onLoadModules\", []);\n      return this.hooks.emit(\"app:load_modules\");\n    },\n\n    onModulesLoaded: function () {\n      this.$trace(\"onModulesLoaded\", []);\n      return this.hooks.emit(\"app:modules_loaded\");\n    },\n    onInstallModules: function () {\n      this.$trace(\"onInstallModules\", []);\n      return this.hooks.emit(\"app:install_modules\");\n    },\n    onModulesInstalled: function () {\n      this.$trace(\"onModulesInstalled\", []);\n      return this.hooks.emit(\"app:modules_installed\");\n    },\n    onLoadSchema: async function () {\n      this.$trace(\"onLoadSchema\", []);\n      if (process.env.LSW_RESET_DATABASE) {\n        await LswDatabase.deleteDatabase(\"lsw_default_database\");\n      }\n      $lswSchema.loadSchemaByProxies(\"SchemaEntity\");\n      const databaseSchema = await $lswSchema.getDatabaseSchemaForLsw();\n      console.log(\"[*] Creating database from schema by proxies:\", Object.keys(databaseSchema).join(\", \"));\n      return await this.hooks.emit(\"app:load_schema\");\n    },\n    onSchemaLoaded: function () {\n      this.$trace(\"onSchemaLoaded\", []);\n      return this.hooks.emit(\"app:schema_loaded\");\n    },\n    onSeedDatabase: async function () {\n      this.$trace(\"onSeedDatabase\", []);\n      Fill_with_your_own_requirements: {\n        // @TOFILLIFNEEDED:\n      }\n      return await this.hooks.emit(\"app:seed_database\");\n    },\n    onDatabaseSeeded: async function () {\n      this.$trace(\"onDatabaseSeeded\", []);\n      Fill_with_your_own_requirements: {\n        // @TOFILLIFNEEDED:\n      }\n      return await this.hooks.emit(\"app:database_seeded\");\n    },\n    onLoadDatabase: async function () {\n      this.$trace(\"onLoadDatabase\", []);\n      Load_database_connection: {\n        Vue.prototype.$lsw.database = await LswDatabase.open(\"lsw_default_database\");\n        Vue.prototype.$lsw.database.setInnerSchema($lswSchema);\n      }\n      if(process.env.LSW_RESET_DATABASE) {\n        await this.onSeedDatabase();\n        await this.onDatabaseSeeded();\n      }\n      return await this.hooks.emit(\"app:load_database\");\n    },\n    onDatabaseLoaded: function () {\n      this.$trace(\"onDatabaseLoaded\", []);\n      return this.hooks.emit(\"app:database_loaded\");\n    },\n    onLoadApplication: function () {\n      this.$trace(\"onLoadApplication\", []);\n      return this.hooks.emit(\"app:load_application\");\n    },\n    onApplicationLoaded: function () {\n      this.$trace(\"onApplicationLoaded\", []);\n      return this.hooks.emit(\"app:application_loaded\");\n    },\n\n    onAllLoaded: function () {\n      this.$trace(\"onAllLoaded\", []);\n      return this.hooks.emit(\"app:all_loaded\");\n    },\n\n    onFinished: function () {\n      this.$trace(\"onFinished\", []);\n      return this.hooks.emit(\"app:finished\");\n    },\n\n    loadModule: function (moduleId) {\n      this.$trace(\"loadModule\", []);\n      return Vue.prototype.$lsw.importer.scriptAsync(`modules/${moduleId}/load.js`);\n    },\n\n    loadSubmodule: function (moduleId, subpath) {\n      this.$trace(\"loadSubmodule\", []);\n      return Vue.prototype.$lsw.importer.scriptAsync(`modules/${moduleId}/${subpath}`);\n    },\n\n    start: function () {\n      this.$trace(\"start\", []);\n      return this.run(this.steps);\n    },\n\n  }, \"*\");\n",
      "$code.label": "LswCycler class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-logger/superlogger.unbundled.js",
      "$location": {
        "start": {
          "offset": 377,
          "line": 17,
          "column": 3
        },
        "end": {
          "offset": 590,
          "line": 27,
          "column": 6
        }
      },
      "$section": "Superlogger API » Superlogger class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "Superlogger",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-logger/superlogger.unbundled.js",
      "$location": {
        "start": {
          "offset": 591,
          "line": 28,
          "column": 1
        },
        "end": {
          "offset": 676,
          "line": 29,
          "column": 1
        }
      },
      "$section": "Superlogger API » Superlogger class",
      "$code": "  const Superlogger = class {\n\n    static create(id, options) {\n      return new this(id, options);\n    }\n\n    static levels = {\n      trace: 4,\n      debug: 3,\n      log: 2,\n      warn: 1,\n      error: 0,\n    };\n\n    static defaultOptions = {\n      active: true,\n      level: \"trace\"\n    };\n\n    static loggers = {};\n\n    static alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\n    static generateRandomString(len /* istanbul ignore next */  = 5) {\n      let out = \"\";\n      while(out.length < len) {\n        out += this.alphabet[Math.floor(Math.random() * this.alphabet.length - 1)];\n      }\n      return out;\n    }\n\n    constructor(idInput = false, options = {}) {\n      const id = idInput || this.constructor.generateRandomString(10);\n      if (typeof id !== \"string\") {\n        throw new Error(\"Required parameter «id» to be a string on «Superlogger.constructor»\");\n      }\n      if (id in this.constructor.loggers) {\n        throw new Error(\"Required parameter «id» to be a unique string on «Superlogger.constructor»\");\n      }\n      if (typeof options !== \"object\") {\n        throw new Error(\"Required parameter «options» to be an object on «Superlogger.constructor»\");\n      }\n      this.$id = id;\n      this.$options = Object.assign({}, this.constructor.defaultOptions, options);\n      this.$source = undefined;\n      this.$events = {};\n      this.$callbacks = {\n        before: undefined,\n        after: undefined,\n      };\n      this.resetEvents();\n      this.resetCallbacks();\n      this.constructor.loggers[id] = this;\n    }\n\n    activate() {\n      this.$options.active = true;\n    }\n\n    deactivate() {\n      this.$options.active = false;\n    }\n\n    setSource(source) {\n      this.source = source;\n    }\n\n    setLevel(level) {\n      if (!(level in this.constructor.levels)) {\n        throw new Error(\"Required parameter «level» to be a recognized level on «Superlogger.setLevel»\");\n      }\n      this.$options.level = this.constructor.levels[level];\n    }\n\n    setEvent(id, callback) {\n      this.$events[id] = callback;\n    }\n\n    resetEvents() {\n      this.$events = {\n        trace: undefined,\n        debug: undefined,\n        log: undefined,\n        warn: undefined,\n        error: undefined,\n      };\n    }\n\n    setBefore(callback) {\n      this.$callbacks.before = callback;\n    }\n\n    setAfter(callback) {\n      this.$callbacks.after = callback;\n    }\n\n    resetCallbacks() {\n      this.$callbacks = {\n        after: undefined,\n        before: undefined,\n      };\n    }\n\n    replacerFactory() {\n      const visited = new WeakMap();\n      return (key, value) => {\n        if (typeof value === \"function\") {\n          return \"[Function] \" + value.toString();\n        }\n        if (typeof value === \"object\" && value !== null) {\n          if (visited.has(value)) {\n            return \"[Circular]\";\n          }\n          visited.set(value, true);\n        } else /* istanbul ignore else */ {}\n        return value;\n      }\n    }\n\n    stringifyForDebugging(obj) {\n      return JSON.stringify(obj, this.replacerFactory(), 2);\n    }\n\n    $emit(event, args) {\n      if(!(event in this.$events)) {\n        return \"void::event not defined\";\n      }\n      const callback = this.$events[event];\n      if(typeof callback === \"undefined\") {\n        return \"void::callback not defined\";\n      }\n      return callback(this, args);\n    }\n\n    $log(levelId, elements, methodId = false) {\n      if(!(levelId in this.constructor.levels)) {\n        throw new Error(\"Required parameter «levelId» to be an identified level on «Superlogger.$log»\");\n      }\n      const level = this.constructor.levels[levelId];\n      if (!this.$options.active) {\n        return \"void::currently active=false state\";\n      }\n      if (this.$options.level < level) {\n        return \"void::level of tracing out of bounds\";\n      }\n      let message = `[${this.$id}][${levelId}]`;\n      if (methodId !== false) {\n        message += `[${methodId}]`;\n      }\n      for (let index = 0; index < elements.length; index++) {\n        const element = elements[index];\n        const stringification = typeof element === \"string\" ? element : this.stringifyForDebugging(element);\n        message += \" \" + stringification;\n      }\n      Event_triggering: {\n        if(typeof this.$callbacks.before !== \"undefined\") {\n          this.$callbacks.before(message, this, levelId, elements, methodId);\n        }\n        console.log(message);\n        if(typeof this.$callbacks.after !== \"undefined\") {\n          this.$callbacks.after(message, this, levelId, elements, methodId);\n        }\n        this.$emit(levelId, {elements, methodId});\n      }\n    }\n\n    trace(methodId, ...data) {\n      return this.$log(\"trace\", data, methodId);\n    }\n\n    debug(...data) {\n      return this.$log(\"debug\", data);\n    }\n\n    log(...data) {\n      return this.$log(\"log\", data);\n    }\n\n    warn(...data) {\n      return this.$log(\"warn\", data);\n    }\n\n    error(...data) {\n      return this.$log(\"error\", data);\n    }\n\n  };\n",
      "$code.label": "Superlogger class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxifier/proxifier.unbundled.js",
      "$location": {
        "start": {
          "offset": 290,
          "line": 14,
          "column": 3
        },
        "end": {
          "offset": 506,
          "line": 24,
          "column": 6
        }
      },
      "$section": "LswProxifier API » LswProxifier class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswProxifier",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxifier/proxifier.unbundled.js",
      "$location": {
        "start": {
          "offset": 507,
          "line": 25,
          "column": 1
        },
        "end": {
          "offset": 595,
          "line": 26,
          "column": 1
        }
      },
      "$section": "LswProxifier API » LswProxifier class",
      "$code": "  class BaseClass {\n    initialize(...args) {\n      const promise = this.onInitialize(...args);\n      if (promise instanceof Promise) {\n        return promise.then(output => {\n          return this;\n        });\n      }\n      return this;\n    }\n    onInitialize() {\n      return this;\n    }\n  }\n\n  const AbstractProxy = class {\n    constructor(value) {\n      this.value = value;\n    }\n  }\n  class AbstractVirtualizer extends AbstractProxy {}\n  class AbstractSchemaEntity extends AbstractProxy {\n    static toObject() {\n      return {\n        entityId: this.getEntityId(),\n        name: this.getName(),\n        version: this.getVersion(),\n        properties: this.getProperties(),\n        externalProperties: this.getExternalProperties(),\n        methods: this.getMethods(),\n        virtualizerId: this.getVirtualizerId(),\n        formSettings: this.getFormSettings(),\n        extraAttributes: this.getExtraAttributes(),\n      };\n    }\n    static getEntityId() {\n      throw new Error(`Required method «getEntityId» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getEntityId»`);\n    }\n    static getName() {\n      throw new Error(`Required method «getName» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getName»`);\n    }\n    static getVersion() {\n      throw new Error(`Required method «getVersion» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getVersion»`);\n    }\n    static getProperties() {\n      throw new Error(`Required method «getProperties» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getProperties»`);\n    }\n    static getExternalProperties() {\n      return {};\n    }\n    static getMethods() {\n      throw new Error(`Required method «getMethods» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getMethods»`);\n    }\n    static getVirtualizerId() {\n      throw new Error(`Required method «getVirtualizerId» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getVirtualizerId»`);\n    }\n    static getFormSettings() {\n      throw new Error(`Required method «getFormSettings» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getFormSettings»`);\n    }\n    static getExtraAttributes() {\n      throw new Error(`Required method «getExtraAttributes» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getExtraAttributes»`);\n    }\n  }\n  class AbstractItem { }\n  class AbstractList {\n    constructor(value) {\n      this.value = Array.isArray(value) ? value : [];\n    }\n    forEach(callback) {\n      this.value.forEach(callback);\n      return this;\n    }\n    filter(callback) {\n      this.value = this.value.filter(callback);\n      return this;\n    }\n    map(callback) {\n      this.value = this.value.map(callback);\n      return this;\n    }\n    reduce(callback, initialValue = []) {\n      this.value = this.value.reduce(callback, initialValue);\n      return this;\n    }\n    modify(callback) {\n      this.value = callback(this.value);\n      return this;\n    }\n    concat(...lists) {\n      this.value = this.value.concat(...lists);\n      return this;\n    }\n    onlyProp(prop) {\n      this.value = this.value.map(it => it[prop]);\n      return this;\n    }\n    onlyProps(props) {\n      this.value = this.value.map(it => {\n        const out = {};\n        props.forEach(prop => {\n          out[prop] = it[prop];\n        });\n        return out;\n      });\n      return this;\n    }\n    removeProp(prop) {\n      return this.removeProps([prop]);\n    }\n    removeProps(props) {\n      this.value = this.value.map(it => {\n        const out = {};\n        const keys = Object.keys(it).filter(prop => {\n          return props.indexOf(prop) === -1;\n        });\n        keys.forEach(key => {\n          out[key] = it[key];\n        });\n        return out;\n      });\n      return this;\n    }\n    deduplicate() {\n      const out = [];\n      this.value.forEach(it => {\n        if (out.indexOf(it) === -1) {\n          out.push(it);\n        }\n      });\n      this.value = out;\n      return this;\n    }\n    sort(callback) {\n      this.value = this.value.sort(callback);\n      return this;\n    }\n  };\n\n  class LswProxifier {\n    static create(...args) {\n      return new this(...args);\n    }\n    AbstractProxy = AbstractProxy;\n    AbstractSchemaEntity = AbstractSchemaEntity;\n    AbstractVirtualizer = AbstractVirtualizer;\n    AbstractItem = AbstractItem;\n    AbstractList = AbstractList;\n    constructor(mainInjection = {}) {\n      this.$definitions = {};\n      this.$mainInjection = mainInjection;\n      this.$splitterChar = \"@\";\n    }\n    define(name, classesDef) {\n      if(!(name in this.$definitions)) {\n        this.$definitions[name] = {};\n      }\n      if(typeof classesDef !== \"object\") {\n        throw new Error(`Required parameter «classesDef» to be a class on «LswProxifier.define»`)\n      }\n      const classesIds = Object.keys(classesDef);\n      for(let index=0; index<classesIds.length; index++) {\n        const classId = classesIds[index];\n        const classDef = classesDef[classId];\n        if(typeof classDef !== \"function\") {\n          throw new Error(`Required proxy class «${classId}» to be a class on «LswProxifier.define»`)\n        }\n      }\n      Object.assign(this.$definitions[name], classesDef);\n    }\n    find(selector) {\n      const [name, aspectId = false] = selector.split(this.$splitterChar);\n      if(!(name in this.$definitions)) {\n        throw new Error(`Could not find proxy classes from name «${name}» on «LswProxifier.find»`);\n      }\n      if(!aspectId) {\n        return this.$definitions[name];\n      }\n      if(!(aspectId in this.$definitions[name])) {\n        throw new Error(`Could not find proxy aspect «${aspectId}» from class «${name}» on «LswProxifier.find»`);\n      }\n      return this.$definitions[name][aspectId];\n    }\n    getFactory() {\n      return this.proxify.bind(this);\n    }\n    proxify(obj) {\n      return {\n        as: (typeSelector = \"\", proxyExtraArguments = []) => {\n          if(typeof typeSelector !== \"string\") {\n            throw new Error(`Required parameter «typeSelector» to be a string on «proxify(@).as(@)»`);\n          }\n          const [definitionId, aspectId = \"Item\"] = typeSelector.split(this.$splitterChar);\n          if(!(definitionId in this.$definitions)) {\n            throw new Error(`Required parameter «definitionId» [«${definitionId}»] to exist in «proxifier.$definitions» but it does not on «proxify(@).as(@)`);\n          }\n          if(!(aspectId in this.$definitions[definitionId])) {\n            throw new Error(`Required parameter «aspectId» [«${aspectId}»] to exist in «proxifier.$definitions[${JSON.stringify(definitionId)}]» but it does not on «proxify(@).as(@)`);\n          }\n          const proxyClass = this.$definitions[definitionId][aspectId];\n          const proxyInstance = new proxyClass(obj, ...proxyExtraArguments);\n          if(typeof this.$mainInjection === \"function\") {\n            this.$mainInjection(proxyInstance, proxyClass);\n          } else if(typeof this.$mainInjection === \"object\") {\n            Object.assign(proxyInstance, this.$mainInjection);\n          }\n          return proxyInstance;\n        }\n      };\n    }\n  };\n\n  LswProxifier.default = LswProxifier;\n\n  globalThis.$proxifier = LswProxifier.create();\n",
      "$code.label": "LswProxifier class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-randomizer/lsw-randomizer.js",
      "$location": {
        "start": {
          "offset": 293,
          "line": 15,
          "column": 3
        },
        "end": {
          "offset": 512,
          "line": 25,
          "column": 6
        }
      },
      "$section": "LswRandomizer API » LswRandomizer class",
      "type": "class",
      "extends": "Object",
      "vendor": "lsw",
      "namespace": "LswRandomizer",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-randomizer/lsw-randomizer.js",
      "$location": {
        "start": {
          "offset": 513,
          "line": 26,
          "column": 1
        },
        "end": {
          "offset": 604,
          "line": 27,
          "column": 1
        }
      },
      "$section": "LswRandomizer API » LswRandomizer class",
      "$code": "  const LswRandomizer = class {\n\n    static $defaultAlphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\n    static getRandomIntegerBetween(start = 0, end = 100) {\n      return Math.round(Math.random() * (end - start)) + start;\n    }\n\n    static getRandomString(len, alphabet = this.$defaultAlphabet) {\n      let out = \"\";\n      while (out.length < len) {\n        out += alphabet[Math.floor(Math.random() * alphabet.length)];\n      }\n      return out;\n    }\n\n    static getRandomItem(list) {\n      return list[Math.floor(Math.random() * list.length)];\n    }\n\n    static getRandomObject(totalProps = [0, 10], listOf = false) {\n      let randomProps = totalProps;\n      if (Array.isArray(totalProps)) {\n        randomProps = this.getRandomIntegerBetween(...totalProps);\n      }\n      const buildRandomObject = () => {\n        const randomObject = {};\n        while (Object.keys(randomObject).length < randomProps) {\n          const key = this.getRandomString(5);\n          const value = this.getRandomString(10);\n          randomObject[key] = value;\n        }\n        return randomObject;\n      };\n      if (listOf === false) {\n        return buildRandomObject();\n      }\n      const randomList = [];\n      for(let index=0; index<listOf; index++) {\n        const randomObject = buildRandomObject();\n        randomList.push(randomObject);\n      }\n      return randomList;\n    }\n\n  }\n\n  return LswRandomizer;\n",
      "$code.label": "LswRandomizer class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-reloader/reloadable.js",
      "$location": {
        "start": {
          "offset": 0,
          "line": 1,
          "column": 1
        },
        "end": {
          "offset": 95,
          "line": 2,
          "column": 1
        }
      },
      "$section": "LswReloader API » LswReloadable injection",
      "$code": "const serverUrl = 'http://127.0.0.1';\nconst serverPort = 3000;\n\nif (process?.env?.NODE_ENV === \"test\") {\n  const socket = io(`${serverUrl}:${serverPort}`);\n  socket.on('refrescar', () => {\n    console.log('Recibida la señal de refrescar desde el servidor');\n    location.reload();\n  });\n}\n",
      "$code.label": "LswReloadable injection",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-returner/controlled-function.js",
      "$location": {
        "start": {
          "offset": 300,
          "line": 14,
          "column": 1
        },
        "end": {
          "offset": 409,
          "line": 15,
          "column": 1
        }
      },
      "$section": "ControlledFunction API » ControlledFunction classes",
      "$code": "\n  const ReturnControl = class {\n    constructor(value) {\n      this.value = value;\n    }\n  };\n\n  const MutateControl = class {\n    constructor(mutator = {}) {\n      this.mutator = mutator;\n    }\n  };\n\n  const ReturnController = class {\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor() {\n      this.results = new Map();\n      this.functions = new Map();\n      this.middlewares = [];\n      this.properties = new Map();\n    }\n\n    prehook(middleware) {\n      this.middlewares.unshift(middleware);\n      return this;\n    }\n\n    hook(middleware) {\n      this.middlewares.push(middleware);\n      return this;\n    }\n\n    unhook(middleware) {\n      this.middlewares = this.middlewares.filter(m => m !== middleware);\n      return this;\n    }\n\n    prop(properties = {}) {\n      Object.assign(this.properties, properties);\n      return this;\n    }\n\n    hasProp(id) {\n      return this.properties.has(id);\n    }\n\n    getProp(id, defaultValue = undefined) {\n      if (!this.properties.has(id)) {\n        return defaultValue;\n      }\n      return this.properties.get(id);\n    }\n\n    setProp(id, value) {\n      this.properties.set(id, value);\n      return this;\n    }\n\n    load(functions) {\n      this.functions = new Map(Object.entries(functions));\n      return this;\n    }\n\n    solved(name) {\n      return this.results.get(name);\n    }\n\n    pipe(outputName, functionNames, parameters = []) {\n      for (let fnName of functionNames) {\n        const fnCallback = this.functions.get(fnName);\n        if (fnCallback) {\n          const result = fnCallback(...parameters);\n          if (this.processResult(result, outputName)) {\n            return this.solved(outputName);\n          }\n        }\n        for (const middleware of this.middlewares) {\n          const result = middleware(this);\n          if (this.processResult(result, outputName)) {\n            return this.solved(outputName);\n          }\n        }\n      }\n      return null;\n    }\n\n    processResult(result, outputName) {\n      if (result instanceof ReturnControl) {\n        this.results.set(outputName, result.value);\n        return true;\n      } else if (result instanceof MutateControl) {\n        const mutator = result.mutator;\n        if (typeof mutator === \"function\") {\n          const mutatorResult = mutator(this);\n          if (typeof mutatorResult === \"object\") {\n            Object.assign(this.properties, mutatorResult);\n          } else if (mutatorResult !== undefined) {\n            throw new Error(\n              `MutateControl's function mutator must return an object or undefined, found: ${typeof mutatorResult}`\n            );\n          }\n        } else if (typeof mutator === \"object\") {\n          Object.assign(this, mutator);\n        } else {\n          throw new Error(\n            `MutateControl's mutator must be a function or object, found: ${typeof mutator}`\n          );\n        }\n      }\n      return false;\n    }\n\n    reset() {\n      this.results.clear();\n      this.properties.clear();\n      return this;\n    }\n  };\n\n  const ControlledFunction = {\n    MutateControl,\n    ReturnControl,\n    ReturnController,\n  };\n\n  ControlledFunction.default = ControlledFunction;\n\n  return ControlledFunction;\n",
      "$code.label": "ControlledFunction global",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-schema/lsw-schema.js",
      "$location": {
        "start": {
          "offset": 627,
          "line": 30,
          "column": 3
        },
        "end": {
          "offset": 807,
          "line": 38,
          "column": 6
        }
      },
      "$section": "Lsw Schema API » LswSchema class",
      "type": "Class",
      "vendor": "lsw",
      "namespace": "LswSchema",
      "source code": "La clase está definida así:\n",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-schema/lsw-schema.js",
      "$location": {
        "start": {
          "offset": 808,
          "line": 39,
          "column": 1
        },
        "end": {
          "offset": 887,
          "line": 40,
          "column": 1
        }
      },
      "section": "Lsw Schema API » LswSchema class",
      "$code": "  const LswSchema = class {\n\n    $trace(methodId, argsList) {\n      if(this.$options && this.$options.trace) {\n        console.log(\"[trace][lsw-schema][\" + methodId + \"] \" + argsList.length);\n      }\n    }\n\n    static Signature = LswSchemaSignature;\n\n    static createSignature(creatorCallback, creatorParameters, creatorScope) {\n      return this.Signature.create(creatorCallback, creatorParameters, creatorScope);\n    }\n\n    onValidateSchema(schema) {\n      this.$trace(\"onValidateSchema\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onValidateTable(id, definition, schema) {\n      this.$trace(\"onValidateTable\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onValidateColumn(id, definition, tableId, schema) {\n      this.$trace(\"onValidateColumn\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onFusionateSchema(schema) {\n      this.$trace(\"onFusionateSchema\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onFusionateTable(table, tableId, schema) {\n      this.$trace(\"onFusionateTable\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onFusionateColumn(column, columnId, tableId, schema) {\n      this.$trace(\"onFusionateColumn\", arguments);\n      // @OVERRIDABLE\n    }\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor(options = {}) {\n      this.$cache = {\n        schemaForLsw: null\n      };\n      this.$schema = {\n        hasTables: {\n\n        }\n      };\n      this.$options = options;\n    }\n    \n    getDatabaseSchemaForLsw(refresh = false) {\n      this.$trace(\"getDatabaseSchemaForLsw\", arguments);\n      if(refresh) {\n        this.$cache.schemaForLsw = null;\n      }\n      if(this.$cache.schemaForLsw) {\n        return this.$cache.schemaForLsw;\n      }\n      const schemaForLsw = {};\n      for(let tableId in this.$schema.hasTables) {\n        const tableData = this.$schema.hasTables[tableId];\n        let tableSchema = [];\n        for(let columnId in tableData.hasColumns) {\n          const columnData = tableData.hasColumns[columnId];\n          const prefix = columnData.isUnique ? \"!\" : \"\";\n          tableSchema.push(prefix + columnId);\n        }\n        schemaForLsw[tableId] = tableSchema;\n      }\n      this.$cache.schemaForLsw = schemaForLsw;\n      return schemaForLsw;\n    }\n\n    loadSchemaByProxies(aspectId = \"SchemaEntity\") {\n      this.$trace(\"loadSchemaByProxies\", arguments);\n      const schema = this.getSchemaByProxies(aspectId);\n      return this.registerSchema(schema);\n    }\n\n    getSchemaByProxies(aspectId = \"SchemaEntity\") {\n      this.$trace(\"getSchemaByProxies\", arguments);\n      const allSchemaEntities = Object.values($proxifier.$definitions).filter(d => d[aspectId]).map(d => d[aspectId]);\n      const schemaTemp = new LswSchema();\n      for(let index=0; index<allSchemaEntities.length; index++) {\n        const SchemaEntityClass = allSchemaEntities[index];\n        const lswDatabaseSchema = this.adaptSchemaEntityToDatabaseSchema(SchemaEntityClass);\n        schemaTemp.registerSchema(lswDatabaseSchema);\n      }\n      return schemaTemp.$schema;\n    }\n\n    adaptSchemaEntityToDatabaseSchema(SchemaEntityClass) {\n      this.$trace(\"adaptSchemaEntityToDatabaseSchema\", arguments);\n      const schema = { hasTables: {} };\n      const data = SchemaEntityClass.toObject();\n      schema.hasTables[data.name] = {\n        ...data,\n        hasEntityId: SchemaEntityClass.getEntityId(),\n        hasColumns: data.properties,\n        hasExtraAttributes: data.extraAttributes,\n      };\n      return schema;\n    }\n\n    registerSchema(partialSchema = {}) {\n      this.$trace(\"registerSchema\", arguments);\n      if (typeof partialSchema !== \"object\") {\n        throw new Error(\"Required parameter «partialSchema» to be an object on «LswSchema.registerSchema»\");\n      }\n      this.$validateSchema(partialSchema);\n      this.$fusionateSchema(partialSchema);\n      return this;\n    }\n\n    $validateSchema(schema) {\n      this.$trace(\"$validateSchema\", arguments);\n      Native: {\n        this.$validateSchemaNative(schema);\n      }\n      Core_process: {\n        if (\"hasTables\" in schema) {\n          const tableIds = Object.keys(schema.hasTables);\n          Iterating_tables:\n          for (let indexTable = 0; indexTable < tableIds.length; indexTable++) {\n            const tableId = tableIds[indexTable];\n            const table = schema.hasTables[tableId];\n            this.$validateTableNative(table, tableId, schema);\n            if (!(\"hasColumns\" in table)) {\n              continue Iterating_tables;\n            }\n            const columnIds = Object.keys(table.hasColumns);\n            Iterating_columns:\n            for (let indexColumn = 0; indexColumn < columnIds.length; indexColumn++) {\n              const columnId = columnIds[indexColumn];\n              const column = table.hasColumns[columnId];\n              this.$validateColumnNative(column, columnId, tableId, schema);\n            }\n          }\n        }\n      }\n      User: {\n        this.onValidateSchema(schema);\n      }\n    }\n\n    $fusionateSchema(partialSchema) {\n      this.$trace(\"$fusionateSchema\", arguments);\n      const tableIds = Object.keys(partialSchema?.hasTables || {});\n      Debug_purposes: {\n        const columnIds = tableIds.map(tableId => Object.keys(partialSchema.hasTables[tableId].hasColumns || {}).map(columnId => [tableId, columnId].join(\".\")));\n        const tablesMessage = tableIds.length === 0 ? \"No tables to fusionate\" : \"Tables to fusionate:\\n - \" + tableIds.join(\"\\n - \");\n        const columnsMessage = columnIds.length === 0 ? \"No columns to fusionate\" : \"Columns to fusionate:\\n - \" + columnIds.join(\"\\n - \");\n        this.$trace(`[*] ${tablesMessage}`, []);\n        this.$trace(`[*] ${columnsMessage}`, []);\n      }\n      this.$fusionateSchemaNative(partialSchema);\n      Iterating_tables:\n      for (let indexTable = 0; indexTable < tableIds.length; indexTable++) {\n        const tableId = tableIds[indexTable];\n        const tableInfo = partialSchema.hasTables[tableId];\n        this.$fusionateTableNative(tableInfo, tableId, partialSchema);\n        const columnIds = Object.keys(tableInfo.columns || {});\n        Iterating_columns:\n        for (let indexColumn = 0; indexColumn < columnIds.length; indexColumn++) {\n          const columnId = columnIds[indexColumn];\n          const columnInfo = tableInfo.columns[columnId];\n          this.$fusionateColumnNative(columnInfo, columnId, tableId, partialSchema);\n        }\n      }\n    }\n\n    $validateSchemaNative(schema) {\n      this.$trace(\"$validateSchemaNative\", arguments);\n      Native: {\n        const ensureSchema = $ensure(schema).type(\"object\").to.have.key(\"hasTables\");\n        ensureSchema.its(\"hasTables\").type(\"object\");\n      }\n      User: {\n        this.onValidateSchema(schema);\n      }\n    }\n\n    $validateTableNative(definition, id, schema) {\n      this.$trace(\"$validateTableNative\", arguments);\n      Native: {\n        const ensureTable = $ensure(definition).type(\"object\").to.have.key(\"hasColumns\");\n        const ensureHasColumns = ensureTable.its(\"hasColumns\").type(\"object\");\n        const columnIds = Object.keys(ensureHasColumns.$subject);\n        for(let index=0; index<columnIds.length; index++) {\n          const columnId = columnIds[index];\n          const ensureColumn = ensureHasColumns.its(columnId).type(\"object\");\n          ensureColumn.its(\"isType\").type(\"string\");\n          ensureColumn.its(\"isUnique\").type([\"boolean\", \"undefined\"]);\n          ensureColumn.its(\"refersTo\").type([\"object\", \"undefined\", \"boolean\"]);\n          if(typeof ensureColumn.$subject.refersTo === \"object\") {\n            const ensureRefersTo = ensureColumn.its(\"refersTo\").type(\"object\");\n            ensureRefersTo.to.have.keys([\"entity\", \"property\"]);\n            ensureRefersTo.its(\"entity\").type(\"string\");\n            ensureRefersTo.its(\"property\").type(\"string\");\n          }\n          ensureColumn.its(\"isFormType\").type(\"string\");\n          ensureColumn.its(\"hasValidator\").type([\"string\", \"boolean\", \"function\", \"undefined\"]);\n          ensureColumn.its(\"hasFormatter\").type([\"string\", \"boolean\", \"function\", \"undefined\"]);\n          ensureColumn.its(\"hasLabel\").type([\"string\", \"boolean\", \"undefined\"]);\n          ensureColumn.its(\"hasDescription\").type([\"string\", \"boolean\", \"undefined\"]);\n          ensureColumn.its(\"hasPlaceholder\").type([\"string\", \"boolean\", \"undefined\"]);\n        }\n      }\n      User: {\n        this.onValidateTable(id, definition, schema);\n      }\n    }\n\n    $validateColumnNative(id, definition, tableId, schema) {\n      this.$trace(\"$validateColumnNative\", arguments);\n      Native: {\n        // !@OK: the validation is already made on the $validateTableNative\n      }\n      User: {\n        this.onValidateColumn(id, definition, tableId, schema);\n      }\n    }\n\n    $fusionateSchemaNative(partialSchema) {\n      this.$trace(\"$fusionateSchemaNative\", arguments);\n      Native_fusion: {\n        \n      }\n      User_fusion: {\n        this.onFusionateSchema(partialSchema);\n      }\n    }\n\n    $fusionateTableNative(tableInfo, tableId, partialSchema) {\n      this.$trace(\"$fusionateTableNative\", arguments);\n      Native_fusion: {\n        const isKnown = tableId in this.$schema.hasTables;\n        if(!isKnown) {\n          this.$schema.hasTables[tableId] = tableInfo;\n        } else {\n          throw new Error(`Schema cannot fusionate table «${tableId}» to schema for second time on «$fusionateTableNative»`);\n        }\n      }\n      User_fusion: {\n        this.onFusionateTable(tableInfo, tableId, partialSchema);\n      }\n    }\n\n    $fusionateColumnNative(columnInfo, columnId, tableId, partialSchema) {\n      this.$trace(\"$fusionateColumnNative\", arguments);\n      Native_fusion: {\n        const isKnown = columnId in this.$schema.hasTables[tableId].hasColumns;\n        if(!isKnown) {\n          this.$schema.hasTables[tableId].hasColumns[columnId] = columnInfo;\n        } else {\n          throw new Error(`Schema cannot fusionate column «${tableId}.${columnId}» to schema for second time on «$fusionateTableNative»`);\n        }\n      }\n      User_fusion: {\n        this.onFusionateColumn(columnInfo, columnId, tableId, partialSchema);\n      }\n    }\n\n  };\n  \n  // Last global injection for a unique main instance:\n  window.$lswSchema = LswSchema.create();\n",
      "$code.label": "LswSchema class",
      "$output": "index.html"
    },
    {
      "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-utils/lsw-utils.js",
      "$location": {
        "start": {
          "offset": 280,
          "line": 14,
          "column": 1
        },
        "end": {
          "offset": 352,
          "line": 15,
          "column": 1
        }
      },
      "section": "Lsw Utils API » Lsw Utils global",
      "$code": "  const LswUtils = {};\n\n  LswUtils.hello = () => console.log(\"Hello!\");\n\n  ///////////////////////////////////////////////////////\n  // API de Excel: usa SheetJS\n  Object.assign(LswUtils, {\n    readFileAsArrayBuffer(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = event => resolve(event.target.result);\n        reader.onerror = error => reject(error);\n        reader.readAsArrayBuffer(file);\n      });\n    },\n    readFileAsText(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = event => resolve(event.target.result);\n        reader.onerror = error => reject(error);\n        reader.readAsText(file);\n      });\n    },\n    readFileAsBinaryString(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = event => resolve(event.target.result);\n        reader.onerror = error => reject(error);\n        reader.readAsBinaryString(file);\n      });\n    },\n    selectFile() {\n      return new Promise(resolve => {\n        const inputHtml = document.createElement(\"input\");\n        inputHtml.setAttribute(\"type\", \"file\");\n        inputHtml.setAttribute(\"accept\", \".ods,.xlsx,.xls,.csv\");\n        inputHtml.style.display = \"none\";\n        document.body.appendChild(inputHtml);\n        inputHtml.addEventListener(\"change\", event => {\n          try {\n            const file = event.target.files[0];\n            if (file) {\n              return resolve(file);\n            } else {\n              return resolve(undefined);\n            }\n          } catch (error) {\n            console.log(\"This should not happen :(\", error);\n          } finally {\n            inputHtml.remove();\n          }\n        });\n        inputHtml.click();\n      });\n    },\n    sheetToArray(sheet) {\n      // Obtener el rango de celdas activo de la hoja\n      const range = sheet['!ref']; // Ejemplo: 'A1:C3'\n      // Extraer las coordenadas de la celda inicial y final del rango\n      const [startCell, endCell] = range.split(':');\n      const startCol = startCell.match(/[A-Z]+/)[0]; // Columna de la primera celda (por ejemplo, 'A')\n      const startRow = parseInt(startCell.match(/\\d+/)[0], 10); // Fila de la primera celda (por ejemplo, 1)\n      const endCol = endCell.match(/[A-Z]+/)[0]; // Columna de la última celda (por ejemplo, 'C')\n      const endRow = parseInt(endCell.match(/\\d+/)[0], 10); // Fila de la última celda (por ejemplo, 3)\n      const data = [];\n      // Iterar sobre las filas y columnas dentro del rango\n      for (let row = startRow; row <= endRow; row++) {\n        const rowData = [];\n        for (let col = startCol.charCodeAt(0); col <= endCol.charCodeAt(0); col++) {\n          const cellAddress = String.fromCharCode(col) + row;\n          const cell = sheet[cellAddress]; // Obtener la celda\n          rowData.push(cell ? cell.v : null); // Si la celda existe, tomar su valor. Si no, agregar `null`\n        }\n        data.push(rowData); // Agregar la fila al array de datos\n      }\n      return data;\n    }\n  });\n\n  ///////////////////////////////////////////////////////\n  // API de Conductometria: usa API de Excel (so: SheetJS)\n  Object.assign(LswUtils, {\n    isDatePassed(date, time, currentDate = new Date()) {\n      const [day, month, year] = date.split(\"/\").map(Number);\n      const [hour, minute, second] = time.split(\":\").map(Number);\n      const targetDate = new Date(year, month-1, day, hour, minute, second);\n      return currentDate > targetDate;\n    },\n    sheetToRegistros(sheet, asObjectIsOkay = false) {\n      const raw = this.sheetToArray(sheet);\n      const byDate = {};\n      let lastDate = undefined;\n      const currentDate = new Date();\n      Compact_by_date_using_last_date: {\n        for (let index = 0; index < raw.length; index++) {\n          const cells = raw[index];\n          const [time, content] = cells;\n          const isDate = time.match(/[0-9][0-9]\\/[0-9][0-9]\\/[0-9][0-9]/g);\n          if (isDate) {\n            if (!(time in byDate)) {\n              byDate[time] = {};\n            }\n            lastDate = time;\n          } else {\n            if (typeof content === \"string\") {\n              if (!(time in byDate[lastDate])) {\n                byDate[lastDate][time] = [];\n              }\n              Add_properties_to_hour: {\n              }\n              const items = content.split(\".\").filter(l => l !== \"\");\n              for (let indexItem = 0; indexItem < items.length; indexItem++) {\n                const item = items[indexItem];\n                const [name, details] = item.split(\":\").filter(l => l !== \"\");\n                let event = {};\n                Add_properties_to_event: {\n                  Object.assign(event, { name });\n                  Object.assign(event, details ? { details: details.trim() } : {});\n                }\n                byDate[lastDate][time].push(event);\n              }\n            }\n          }\n        }\n      }\n      if (asObjectIsOkay) {\n        return byDate;\n      }\n      const output = [];\n      Format_to_pure_array_to_avoid_confusions: {\n        const daysSorted = Object.keys(byDate).sort();\n        for (let index_day = 0; index_day < daysSorted.length; index_day++) {\n          const day_id = daysSorted[index_day];\n          const day_data = byDate[day_id];\n          const day_output = {\n            day: day_id,\n            hours: []\n          };\n          const hoursSorted = Object.keys(day_data).sort();\n          for (let index_hour = 0; index_hour < hoursSorted.length; index_hour++) {\n            const hour_id = hoursSorted[index_hour];\n            const hour_data = day_data[hour_id];\n            const hour_is_passed = this.isDatePassed(day_id, hour_id, currentDate);\n            const hour_is_current = hour_is_passed && (() => {\n              const [hours, minutes, seconds] = hour_id.split(\":\").map(Number);\n              const hour_next_id = [hours + 1, minutes, seconds].map(t => (\"\" + t).padStart(2, \"0\")).join(\":\");\n              console.log(hour_next_id);\n              return !this.isDatePassed(day_id, hour_next_id, currentDate);\n            })();\n            const hour_output = {\n              hour: hour_id,\n              events: [],\n              passed: hour_is_passed,\n              current: hour_is_current,\n            };\n            for (let index_item = 0; index_item < hour_data.length; index_item++) {\n              const item = hour_data[index_item];\n              hour_output.events.push(item);\n            }\n            day_output.hours.push(hour_output);\n          }\n          output.push(day_output);\n        }\n      }\n      return output;\n    },\n    async loadConductometriaByExcelFile() {\n      try {\n        const file = await this.selectFile();\n        const data = await this.readFileAsBinaryString(file);\n        const workbook = XLSX.read(data, { type: \"binary\", cellDates: false });\n        const sheet = workbook.Sheets[\"Tracking\"];\n        const registros = this.sheetToRegistros(sheet);\n        return { registros };\n      } catch (error) {\n        console.log(error);\n      }\n    },\n  });\n\n  // API de LSW:\n  LswUtils.toPlainObject = function(obj) {\n    const seen = new WeakSet();\n    return JSON.parse(JSON.stringify(obj, (key, value) => {\n      if (typeof value === \"object\" && value !== null) {\n        if (seen.has(value)) return undefined; // Ignora referencias circulares\n        seen.add(value);\n      }\n      return value;\n    }));\n  };\n\n\n  LswUtils.stringify = function(argInput, avoidedIndexes = []) {\n    const seen = new WeakSet();\n    return JSON.stringify(argInput, function (key, value) {\n      if(avoidedIndexes.indexOf(key) !== -1) {\n        return;\n      }\n      if (typeof value === \"object\") {\n        if(value.$el) {\n          return `[VueComponent:${value?.$options?.name}]`;\n        }\n        if (seen.has(value)) {\n          return \"[Circular]\";\n        }\n        if (value !== null) {\n          seen.add(value);\n        }\n      }\n      return value;\n    }, 2);\n  };\n\n  LswUtils.pluralizar = function(singular, plural, contexto, cantidad) {\n    return contexto.replace(\"%s\", cantidad === 1 ? singular : plural).replace(\"%i\", cantidad);\n  };\n\n  LswUtils.getRandomString = function(len = 10) {\n    const alphabet = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\n    let out = \"\";\n    while(out.length < len) {\n      out += alphabet[Math.floor(Math.random() * alphabet.length)];\n    }\n    return out;\n  };\n\n  LswUtils.hello = function() {\n    console.log(\"hello\");\n  };\n\n  LswUtils.waitForMilliseconds = function(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  };\n\n  LswUtils.splitStringOnce = function(text, splitter) {\n    if(typeof text !== \"string\") {\n      throw new Error(\"Required parameter «text» to be a string on «LswUtils.splitStringOnce»\");\n    }\n    if(typeof splitter !== \"string\") {\n      throw new Error(\"Required parameter «text» to be a string on «LswUtils.splitStringOnce»\");\n    }\n    const pos = text.indexOf(splitter);\n    if(pos === -1) return [undefined, text];\n    const parts = text.split(\"\");\n    return [[...parts].splice(0, pos).join(\"\"), [...parts].splice(pos+1).join(\"\")];\n  };\n\n  LswUtils.reverseString = function(text) {\n    return text.split(\"\").reverse().join(\"\");\n  };\n\n  LswUtils.capitalize = function(text) {\n    return text.substr(0,1).toUpperCase() + text.substr(1);\n  };\n\n  LswUtils.startThread = function(callback) {\n    setTimeout(callback, 0);\n  };\n",
      "$code.label": "LswUtils",
      "$output": "index.html"
    }
  ],
  "book": {
    "files": {
      "index.html": {
        "sections": {
          "0. Prelude": [],
          "Lsw Circuiter API » LswCircuiter class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-circuiter/async-circuit.js",
              "$location": {
                "start": {
                  "offset": 290,
                  "line": 14,
                  "column": 3
                },
                "end": {
                  "offset": 508,
                  "line": 25,
                  "column": 6
                }
              },
              "$section": "Lsw Circuiter API » LswCircuiter class\n",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswCircuiter",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-circuiter/async-circuit.js",
              "$location": {
                "start": {
                  "offset": 509,
                  "line": 26,
                  "column": 1
                },
                "end": {
                  "offset": 598,
                  "line": 27,
                  "column": 1
                }
              },
              "$section": "Lsw Circuiter API » LswCircuiter class",
              "$code": "  class AsyncCircuit {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor() {\n      this.middlewares = [];\n    }\n\n    hook(callback) {\n      this.middlewares.push(callback);\n      return this;\n    }\n\n    prehook(callback) {\n      this.middlewares.unshift(callback);\n      return this;\n    }\n\n    unhook(callback) {\n      const pos = this.middlewares.indexOf(callback);\n      if(pos !== -1) {\n        this.middlewares.splice(pos, 1);\n      }\n      return this;\n    }\n\n    // Función principal para parsear el árbol\n    parse(node) {\n      // Si el nodo es un array (ejecutar en paralelo)\n      if (Array.isArray(node)) {\n        const code = node.map(cb => this.parse(cb)).join(',');\n        return `Promise.all([${code}])`; // Convertimos todo en un Promise.all\n      }\n\n      // Si es un objeto con $type y $callbacks\n      if (node && typeof node === 'object') {\n        Inject_middlewares: {\n          for(let index__middleware=0; index__middleware<this.middlewares.length; index__middleware++) {\n            const middleware = this.middlewares[index__middleware];\n            const result = middleware(node);\n          }\n        }\n        const { $type, $callbacks } = node;\n        const callbacks = $callbacks.map(cb => (typeof cb === 'function' ? `(${cb.toString()})()` : this.parse(cb)));\n        // Dependiendo del tipo, generamos el código adecuado\n        switch ($type) {\n          case 'parallel':\n            return `Promise.all([\\n  ${callbacks.join(',')}\\n  ])`; // Ejecutar en paralelo\n          case 'serie':\n            return `(async () => {\\n  ${callbacks.map(cb => `await ${cb}`).join('; ')}\\n  })()`; // Ejecutar en serie\n          case 'race':\n            return `Promise.race([\\n  ${callbacks.join(',')}\\n  ])`; // Ejecutar en carrera\n          case 'sync':\n            return `(() => {\\n  ${callbacks.join(';\\n  ')};\\n  return Promise.resolve();\\n  })()`; // Ejecutar síncrono\n          default:\n            throw new Error(`Required property «$type» to be one known but found «${$type}» on «this.parse»`);\n        }\n      }\n\n      // Si el nodo es una función, la transformamos directamente\n      if (typeof node === 'function') {\n        return `(${node.toString()})()`; // Convertimos la función en una llamada inmediata\n      }\n\n      throw new Error(`Required argument «node» to be of known type but found «${typeof $type}» on «this.parse»`);\n    }\n\n    // Método que ejecuta el código generado por eval\n    async execute(node, externalScope = {}) {\n      const code = this.parse(node);\n      const AsyncFunction = (async function() {}).constructor;\n      const argKeys = Object.keys(externalScope).join(\", \");\n      const argValues = Object.values(externalScope);\n      const asyncFunction = new AsyncFunction(argKeys, code);\n      return await asyncFunction(...argValues); // Ejecutamos el código generado con eval\n    }\n  }\n",
              "$code.label": "LswCircuiter class",
              "$output": "index.html"
            }
          ],
          "Lsw ClassRegister API » LswClassRegister class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-class-register/lsw-class-register.js",
              "$location": {
                "start": {
                  "offset": 300,
                  "line": 14,
                  "column": 3
                },
                "end": {
                  "offset": 530,
                  "line": 25,
                  "column": 6
                }
              },
              "$section": "Lsw ClassRegister API » LswClassRegister class\n",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswClassRegister",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-class-register/lsw-class-register.js",
              "$location": {
                "start": {
                  "offset": 531,
                  "line": 26,
                  "column": 1
                },
                "end": {
                  "offset": 632,
                  "line": 27,
                  "column": 1
                }
              },
              "$section": "Lsw ClassRegister API » LswClassRegister class",
              "$code": "  class LswClassRegister {\n\n    constructor() {\n      this.$classes = {};\n    }\n\n    register(id, classDefinition, forceOverwrite = false) {\n      $ensure({id},1).type(\"string\");\n      $ensure({classDefinition},1).type(\"function\");\n      if(!forceOverwrite) {\n        $ensure({$classes:this.$classes},1).to.not.have.key(id);\n      }\n      this.$classes[id] = classDefinition;\n    }\n\n    unregister(id, silenceError = false) {\n      if(!silenceError) {\n        $ensure({$classes:this.$classes},1).to.have.key(id);\n      }\n      delete this.$classes[id];\n    }\n\n    instantiate(id, ...args) {\n      $ensure({id},1).type(\"string\");\n      $ensure({$classes:this.$classes},1).to.have.key(id);\n      const clazz = this.$classes[id];\n      const objeto = new clazz(...args);\n      return objeto;\n    }\n\n    async initialize(id, ...args) {\n      $ensure({id},1).type(\"string\");\n      $ensure({$classes:this.$classes},1).to.have.key(id);\n      const clazz = this.$classes[id];\n      const objeto = new clazz(...args);\n      if(typeof objeto.initialize === \"function\") {\n        await objeto.initialize();\n      }\n      return objeto;\n    }\n\n  }\n",
              "$code.label": "LswClassRegister class",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
              "$location": {
                "start": {
                  "offset": 294,
                  "line": 14,
                  "column": 3
                },
                "end": {
                  "offset": 524,
                  "line": 25,
                  "column": 6
                }
              },
              "$section": "Lsw ClassRegister API » LswClassRegister class\n",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswClassRegister",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
              "$location": {
                "start": {
                  "offset": 525,
                  "line": 26,
                  "column": 1
                },
                "end": {
                  "offset": 625,
                  "line": 27,
                  "column": 1
                }
              },
              "section": "Lsw ClassRegister API » LswClassRegister class",
              "$code": "  Promise_extensions: {\n    \n    globalThis.Promise.prototype.chain = function (nextPromise) {\n      return this.then(() => nextPromise);\n    };\n  }\n",
              "$code.label": "LswClassRegister class",
              "$output": "index.html"
            }
          ],
          "Lsw Commander API » LswCommander class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-commander/url-command.js",
              "$location": {
                "start": {
                  "offset": 797,
                  "line": 31,
                  "column": 3
                },
                "end": {
                  "offset": 1015,
                  "line": 42,
                  "column": 6
                }
              },
              "$section": "Lsw Commander API » LswCommander class\n",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswCommander",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-commander/url-command.js",
              "$location": {
                "start": {
                  "offset": 1016,
                  "line": 43,
                  "column": 1
                },
                "end": {
                  "offset": 1105,
                  "line": 44,
                  "column": 1
                }
              },
              "$section": "Lsw Commander API » LswCommander class",
              "$code": "  const LswCommander = class {\n\n    static from(...args) {\n      return new this(...args);\n    }\n\n    onRun(callback, args) {\n      try {\n        let output = undefined;\n        if (typeof this.$beforeRun === \"function\") {\n          this.$beforeRun(...args);\n        }\n        output = callback(...args);\n        if (typeof this.$afterRun === \"function\") {\n          this.$afterRun(...args);\n        }\n        return output;\n      } catch (error) {\n        if (typeof this.$onError === \"function\") {\n          const output = this.$onError(error);\n          if (typeof output !== \"undefined\") {\n            return output;\n          }\n        }\n        throw error;\n      }\n    }\n\n    constructor(handlers) {\n      this.$handlers = handlers;\n      this.$beforeRun = undefined;\n      this.$afterRun = undefined;\n      this.$onError = undefined;\n      this.command = (url, queryParamsExtender = {}) => {\n        if (!url) throw new Error(\"URL is required\");\n        if (typeof url !== \"string\") throw new Error(\"URL must be a string\");\n        if (typeof this.$handlers !== \"object\" || this.$handlers === null) {\n          throw new Error(\"Handlers must be a valid object\");\n        }\n        const [path, queryString] = url.split(\"?\");\n        const queryParams = queryString ? Object.fromEntries(new URLSearchParams(queryString).entries()) : {};\n        Object.assign(queryParams, queryParamsExtender);\n        const pathParts = path.split(\"/\").filter(Boolean);\n        let currentHandler = this.$handlers;\n        for (const part of pathParts) {\n          if (currentHandler[part] === undefined) {\n            throw new Error(`Handler for path \"${path}\" not found`);\n          }\n          currentHandler = currentHandler[part];\n        }\n        if (typeof currentHandler !== \"function\") {\n          throw new Error(`Handler at path \"${path}\" is not a function`);\n        }\n        const isSpreadable = isOnlyConsecutiveNumbers(queryParams);\n        if (isSpreadable && isSpreadable.length) {\n          return this.onRun(currentHandler, isSpreadable);\n        } else if (queryParams.argumentsOrder) {\n          const args = [];\n          const argKeys = queryParams.argumentsOrder.split(\",\").map(arg => arg.trim());\n          for (let index = 0; index < argKeys.length; index++) {\n            const argKey = argKeys[index];\n            const argValue = queryParams[argKey] || null;\n            args.push(argValue);\n          }\n          return this.onRun(currentHandler, args);\n        } else {\n          return this.onRun(currentHandler, [queryParams]);\n        }\n      };\n    }\n    get run() {\n      return this.command;\n    }\n    beforeRun(callback) {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"Required parameter «callback» to be a function on «beforeRun»\");\n      }\n      this.$beforeRun = callback;\n    }\n    afterRun(callback) {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"Required parameter «callback» to be a function on «afterRun»\");\n      }\n      this.$afterRun = callback;\n    }\n    onError(callback) {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"Required parameter «callback» to be a function on «onError»\");\n      }\n      this.$onError = callback;\n    }\n  };\n",
              "$code.label": "LswCommander class",
              "$output": "index.html"
            }
          ],
          "Lsw Compromiser API » LswCompromiser class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
              "$location": {
                "start": {
                  "offset": 816,
                  "line": 35,
                  "column": 3
                },
                "end": {
                  "offset": 1039,
                  "line": 45,
                  "column": 6
                }
              },
              "$section": "Lsw Compromiser API » LswCompromiser class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswCompromiser",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
              "$location": {
                "start": {
                  "offset": 1040,
                  "line": 46,
                  "column": 1
                },
                "end": {
                  "offset": 1134,
                  "line": 47,
                  "column": 1
                }
              },
              "section": "Lsw Compromiser API » LswCompromiser class",
              "$code": "  class PromiseMap {\n\n    constructor(keys) {\n      this.promises = new Map();\n\n      keys.forEach(key => {\n        this.set(key);\n      });\n    }\n\n    static create(keys) {\n      return new this(keys);\n    }\n\n    has(key) {\n      return this.promises.has(key);\n    }\n\n    get(key) {\n      if (!this.has(key)) {\n        throw new Error(`Required argument «key» to be an existing key (not «${key}») on «PromiseMap.get»`);\n      }\n      return this.promises.get(key);\n    }\n\n    set(key) {\n      if (this.has(key)) {\n        throw new Error(`Required argument «key» to not be an existing key (not «${key}») on «PromiseMap.set»`);\n      }\n      let resolve, reject;\n      const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n      this.promises.set(key, { promise, resolve, reject });\n    }\n\n    unset(key) {\n      if (!this.has(key)) {\n        throw new Error(`Required argument «key» to be an existing key (not «${key}») on «PromiseMap.unset»`);\n      }\n      this.promises.delete(key);\n    }\n\n    on(key) {\n      if (!this.has(key)) {\n        throw new Error(`Required argument «key» to be an existing key (not «${key}») on «PromiseMap.on»`);\n      }\n      return this.promises.get(key).promise;\n    }\n\n    bind(key, key2) {\n      this.on(key).then(output => this.get(key2).resolve(output));\n    }\n\n    propagate(key) {\n      return {\n        to: (key2) => {\n          this.bind(key, key2);\n          return this.propagate(key2);\n        }\n      }\n    }\n\n  }\n",
              "$code.label": "LswCompromiser class",
              "$output": "index.html"
            }
          ],
          "Lsw Configurer API » LswConfigurer class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-configurer/lsw-configurer.js",
              "$location": {
                "start": {
                  "offset": 294,
                  "line": 14,
                  "column": 3
                },
                "end": {
                  "offset": 514,
                  "line": 24,
                  "column": 6
                }
              },
              "$section": "Lsw Configurer API » LswConfigurer class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswConfigurer",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-configurer/lsw-configurer.js",
              "$location": {
                "start": {
                  "offset": 515,
                  "line": 25,
                  "column": 1
                },
                "end": {
                  "offset": 606,
                  "line": 26,
                  "column": 1
                }
              },
              "section": "Lsw Configurer API » LswConfigurer class",
              "$code": "  const LswConfigurer = class {\n\n    constructor(parentConfigurer = null) {\n      this.$parent = parentConfigurer;\n      this.$state = {};\n    }\n\n    configure(stateOptions = {}) {\n      Object.assign(this.$state, stateOptions);\n    }\n\n    get(key, defaultValue = undefined) {\n      let target = this;\n      Iterating_parents:\n      while(!!target) {\n        if(key in target.$state) {\n          return target.$state[key];\n        }\n        target = target.$parent;\n      }\n      return defaultValue;\n    }\n\n  }\n",
              "$code.label": "LswConfigurer class",
              "$output": "index.html"
            }
          ],
          "Lsw Cycler API » LswCycler class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-cycler/lsw-cycler.js",
              "$location": {
                "start": {
                  "offset": 312,
                  "line": 17,
                  "column": 3
                },
                "end": {
                  "offset": 520,
                  "line": 27,
                  "column": 6
                }
              },
              "$section": "Lsw Cycler API » LswCycler class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswCycler",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-cycler/lsw-cycler.js",
              "$location": {
                "start": {
                  "offset": 521,
                  "line": 28,
                  "column": 1
                },
                "end": {
                  "offset": 600,
                  "line": 29,
                  "column": 1
                }
              },
              "section": "Lsw Cycler API » LswCycler class",
              "$code": "  class LswCyclerSet {\n    constructor(value) {\n      this.value = value;\n    }\n  }\n\n  class LswCyclerReturn {\n    constructor(value) {\n      this.value = value;\n    }\n  }\n\n  class LswCyclerReturner {\n    constructor(value) {\n      if(typeof value !== \"function\") {\n        throw new Error(\"Required argument «value» to be a function on «LswCyclerReturner.constructor»\");\n      }\n      this.value = value;\n    }\n  }\n\n  class LswCycler {\n\n    static Return = LswCyclerReturn;\n    static Returner = LswCyclerReturner;\n    static Set = LswCyclerSet;\n\n    static returner(value) {\n      return new this.Returner(value);\n    }\n\n    static return(value) {\n      return new this.Return(value);\n    }\n\n    static set(value) {\n      return new this.Set(value);\n    }\n\n    constructor($object, exposedProps = []) {\n      this.$object = $object;\n      if(exposedProps === \"*\") {\n        Object.assign(this, $object);\n      } else {\n        for(let index=0; index<exposedProps.length; index++) {\n          const exposedProp = exposedProps[index];\n          this[exposedProp] = $object[exposedProp];\n        }\n      }\n    }\n\n    static from(...args) {\n      return new this(...args);\n    }\n\n    async run(steps, parameters) {\n      let original = [];\n      let output = original;\n      Iterate_cycle:\n      for (let j = 0; j < steps.length; j++) {\n        let step = steps[j];\n        let fn = this.$object[step];\n        if (typeof fn !== \"function\") {\n          throw new Error(\"Required step «\" + step + \"» to be a function on round \" + j + \" on «LswCycler.run»\");\n        }\n        const result = await fn.call(this.$object, parameters);\n        Apply_intercycle_signals: {\n          if (result instanceof this.constructor.Set) {\n            output = await result.value;\n          } else if (result instanceof this.constructor.Return) {\n            return result.value;\n          } else if (result instanceof this.constructor.Returner) {\n            return result.value(output, original);\n          }\n        }\n        Append_result_if_not_changed_output: {\n          original.push(result);\n        }\n      }\n      return output;\n    }\n\n  }\n",
              "$code.label": "LswCycler class",
              "$output": "index.html"
            }
          ],
          "Lsw Database API » LswDatabase class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database/browsie.unbundled.js",
              "$location": {
                "start": {
                  "offset": 287,
                  "line": 15,
                  "column": 3
                },
                "end": {
                  "offset": 501,
                  "line": 25,
                  "column": 6
                }
              },
              "$section": "Lsw Database API » LswDatabase class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswDatabase",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database/browsie.unbundled.js",
              "$location": {
                "start": {
                  "offset": 502,
                  "line": 26,
                  "column": 1
                },
                "end": {
                  "offset": 587,
                  "line": 27,
                  "column": 1
                }
              },
              "section": "Lsw Database API » LswDatabase class",
              "$code": "  class BrowsieCheckersAPI {\n\n    static mustBeString(obj, method = \"Browsie.mustBeString\", id = \"?\") {\n      if (typeof obj !== \"string\") {\n        throw new Error(`Required «${id}» to be a string on «${method}»`);\n      }\n    }\n\n    static mustBeArray(obj, method = \"Browsie.mustBeArray\", id = \"?\") {\n      if (!Array.isArray(obj)) {\n        throw new Error(`Required «${id}» to be an array on «${method}»`);\n      }\n    }\n\n    static mustBeObject(obj, method = \"Browsie.mustBeObject\", id = \"?\") {\n      if (typeof obj !== \"object\") {\n        throw new Error(`Required «${id}» to be an object on «${method}»`);\n      }\n    }\n\n    static mustBeGreaterThan(obj, comparison = 0, method = \"Browsie.mustBeObject\", id = \"?\") {\n      if (obj <= comparison) {\n        throw new Error(`Required «${id}» to be greater than «${comparison}» on «${method}»`);\n      }\n    }\n  }\n\n  class BrowsieStaticAPI extends BrowsieCheckersAPI {\n\n    static openedConnections = [];\n\n    static _trace = true;\n\n    static trace(methodName, args = []) {\n      if (this._trace) {\n        console.log(\"[browsie][\" + methodName + \"]\", args.length + \" args: \" + Array.from(args).map(arg => typeof (arg)).join(\", \"));\n      }\n    }\n\n    static async listDatabases() {\n      this.trace(\"Browsie.listDatabases\", arguments);\n      try {\n        const databases = await indexedDB.databases();\n        console.log('Bases de datos disponibles:', databases);\n        return databases;\n      } catch (error) {\n        console.error('Error al obtener las bases de datos:', error);\n      }\n    }\n\n    static createDatabase(dbName, schemaDefinition = null, version = 1, versionUpgrades = {}) {\n      this.trace(\"Browsie.createDatabase\", arguments);\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName, version);\n        request.onsuccess = () => {\n          console.log(`[SUCCESS] Database \"${dbName}\" created/opened successfully.`);\n          request.result.close();\n          resolve(request.result);\n        };\n        request.onerror = (error) => {\n          console.error(`[ERROR] Failed to create/open database \"${dbName}\":`, error);\n          reject(error);\n        };\n        request.onupgradeneeded = async (event) => {\n          const db = event.target.result;\n          console.log(`[UPGRADE] Upgrading database \"${dbName}\" from version ${event.oldVersion} to ${version}.`);\n          // Si hay una definición de esquema inicial, crear los almacenes e índices\n          if (schemaDefinition && event.oldVersion === 0) {\n            console.log(\"[SCHEMA] Applying initial schema definition.\");\n            Object.keys(schemaDefinition).forEach((storeName) => {\n              if (!db.objectStoreNames.contains(storeName)) {\n                const objectStore = db.createObjectStore(storeName, {\n                  keyPath: \"id\",\n                  autoIncrement: true,\n                });\n                if (!Array.isArray(schemaDefinition[storeName])) {\n                  console.log(schemaDefinition);\n                  throw new Error(`Required property «schemaDefinition.${storeName}» to be an array on «LswDatabase.createDatabase»`);\n                }\n                schemaDefinition[storeName].forEach((index) => {\n                  const indexName = index.replace(/^\\!/, \"\");\n                  objectStore.createIndex(indexName, indexName, {\n                    unique: index.startsWith(\"!\")\n                  });\n                });\n              }\n            });\n          }\n          // Aplicar las transformaciones de esquema para cada versión\n          for (let v = event.oldVersion + 1; v <= version; v++) {\n            if (versionUpgrades[v]) {\n              console.log(`[VERSION ${v}] Applying upgrade function.`);\n              await versionUpgrades[v](db);\n            } else {\n              console.log(`[VERSION ${v}] No upgrade function defined.`);\n            }\n          }\n        };\n      });\n    }\n\n    // Obtener todos los datos de un store\n    static async getAllDataFromStore(dbName, storeName) {\n      this.trace(\"Browsie.getAllDataFromStore\", arguments);\n      return await new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName);\n\n        request.onsuccess = (event) => {\n          const db = event.target.result;\n          const transaction = db.transaction(storeName, 'readonly');\n          const store = transaction.objectStore(storeName);\n\n          const getAllRequest = store.getAll();\n          getAllRequest.onsuccess = () => resolve(getAllRequest.result);\n          getAllRequest.onerror = () => {\n            db.close();\n            reject(new Error('Error al obtener los datos del store'));\n          };\n        };\n\n        request.onerror = () => {\n          reject(new Error('Error al abrir la base de datos'));\n        };\n      });\n    }\n\n    // Insertar datos en un store\n    static async insertDataIntoStore(dbName, storeName, data) {\n      this.trace(\"Browsie.insertDataIntoStore\", arguments);\n      return await new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName);\n\n        request.onsuccess = (event) => {\n          const db = event.target.result;\n          const transaction = db.transaction(storeName, 'readwrite');\n          const store = transaction.objectStore(storeName);\n\n          data.forEach(item => store.add(item));\n\n          transaction.oncomplete = () => resolve();\n          transaction.onerror = () => {\n            db.close();\n            reject(new Error('Error al insertar los datos en el store'));\n          };\n        };\n\n        request.onerror = () => {\n          reject(new Error('Error al abrir la base de datos'));\n        };\n      });\n    }\n\n    // Eliminar una base de datos\n    static deleteDatabase(dbName) {\n      this.trace(\"Browsie.deleteDatabase\", arguments);\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.deleteDatabase(dbName);\n\n        request.onblocked = () => {\n          // db.close();\n          reject(new Error(\"Error al eliminar la base de datos porque está bloqueada\"));\n        };\n        request.onsuccess = () => resolve();\n        request.onerror = () => {\n          // db.close();\n          reject(new Error('Error al eliminar la base de datos'));\n        };\n      }).then(() => {\n        console.log(`[!] Base de datos «${dbName}» eliminada correctamente.`);\n      });\n    }\n\n    static async getSchema(dbName) {\n      this.trace(\"Browsie.getSchema\", arguments);\n      let db = undefined;\n      try {\n        // Abrir la base de datos en modo solo lectura\n        const request = indexedDB.open(dbName);\n\n        db = await new Promise((resolve, reject) => {\n          request.onsuccess = (event) => resolve(event.target.result);\n          request.onerror = () => {\n            reject(new Error('Error al abrir la base de datos'));\n          };\n        });\n\n        // Construir el esquema a partir de los almacenes\n        const schema = {};\n        const objectStoreNames = Array.from(db.objectStoreNames); // Lista de stores\n\n        objectStoreNames.forEach(storeName => {\n          const transaction = db.transaction(storeName, 'readonly');\n          const store = transaction.objectStore(storeName);\n\n          const storeInfo = {\n            keyPath: store.keyPath,\n            autoIncrement: store.autoIncrement,\n            indexes: []\n          };\n\n          // Recorrer los índices del store\n          const indexNames = Array.from(store.indexNames); // Lista de índices\n          indexNames.forEach(indexName => {\n            const index = store.index(indexName);\n            storeInfo.indexes.push({\n              name: index.name,\n              keyPath: index.keyPath,\n              unique: index.unique,\n              multiEntry: index.multiEntry\n            });\n          });\n\n          schema[storeName] = storeInfo;\n        });\n\n        return schema;\n      } catch (error) {\n        console.error('Error al obtener el esquema:', error);\n        throw error;\n      } finally {\n        if (db) {\n          db.close();\n        }\n      }\n    }\n\n    static async pickRow(databaseId, tableId, rowId) {\n      this.trace(\"Browsie.pickRow\", arguments);\n      $ensure(databaseId).type(\"string\");\n      $ensure(tableId).type(\"string\");\n      $ensure(rowId).type(\"number\");\n      let connection = undefined;\n      try {\n        connection = await this.open(databaseId);\n        const rows = await connection.selectMany(tableId, v => v.id === rowId);\n        if (rows.length === 1) {\n          return rows[0];\n        } else if (rows.length === 0) {\n          return undefined;\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        try {\n          await connection.close();\n        } catch (error) {\n          console.log(\"Could not close connection on picking row\");\n        }\n      }\n    }\n\n  }\n\n  class BrowsieTriggersAPI extends BrowsieStaticAPI {\n\n    static globMatch = TriggersClass.globMatch;\n\n    triggers = new TriggersClass();\n\n  }\n\n\n  class BrowsieCrudAPI extends BrowsieTriggersAPI {\n\n    static async open(...args) {\n      this.trace(\"Browsie.open\", arguments);\n      const db = new this(...args);\n      await db.open();\n      return db;\n    }\n\n    // Constructor que abre la base de datos\n    constructor(dbName, trace = false) {\n      super();\n      this.$dbName = dbName;\n      this.$db = null;\n      this.$innerSchema = null;\n      this._trace = trace;\n    }\n\n    getInnerSchema() {\n      this.constructor.trace(\"browsie.getInnerSchema\", arguments);\n      return this.$innerSchema;\n    }\n\n    setInnerSchema(innerSchema) {\n      this.constructor.trace(\"browsie.setInnerSchema\", arguments);\n      if (!(innerSchema instanceof LswSchema)) {\n        throw new Error(`Required parameter «innerSchema» to be an instance of LswSchema on «browsie.setInnerSchema»`);\n      }\n      this.$innerSchema = innerSchema;\n    }\n\n    // Abre la base de datos\n    open() {\n      this.constructor.trace(\"browsie.open\", arguments);\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.$dbName);\n\n        request.onsuccess = () => {\n          this.$db = request.result;\n          resolve(this.$db);\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.open» operation over database «${this.$dbName}»: `));\n      });\n    }\n\n    close(...args) {\n      this.constructor.trace(\"browsie.close\", arguments);\n      return this.$db.close(...args);\n    }\n\n    // Método para seleccionar 1 elemento de un store con un filtro\n    select(store, filter = {}) {\n      this.constructor.trace(\"browsie.select\", arguments);\n      this.triggers.emit(`crud.select.one.${store}`, { store, filter });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readonly');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.getAll();\n        request.onsuccess = () => {\n          const result = request.result.filter(item => {\n            return Object.keys(filter).every(key => item[key] === filter[key]);\n          });\n          resolve(result);\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.select» operation over store «${store}»: `));\n      });\n    }\n\n    // Método para insertar un solo item en un store\n    insert(store, item) {\n      this.constructor.trace(\"browsie.insert\", arguments);\n      this.triggers.emit(`crud.insert.one.${store}`, { store, item });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.add(item);\n\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.insert» operation over store «${store}»: `));\n      });\n    }\n\n    // Método para actualizar un item en un store\n    update(store, id, item) {\n      this.constructor.trace(\"browsie.update\", arguments);\n      this.triggers.emit(`crud.update.one.${store}`, { store, id, item });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.put({ ...item, id });\n\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.update» operation over store «${store}»: `));\n      });\n    }\n\n    // Método tipo upsert: que cambia solo los campos que le proporcionas (hace entre 1 y 2 queries)\n    async overwrite(store, idOrItem, item) {\n      this.constructor.trace(\"browsie.overwrite\", arguments);\n      this.triggers.emit(`crud.overwrite.one.${store}`, { store, idOrItem, item });\n      const isId = (typeof idOrItem === \"string\") || (typeof idOrItem === \"number\");\n      const isItem = typeof idOrItem === \"object\";\n      let previousItem = undefined;\n      if (isItem) {\n        previousItem = idOrItem;\n      } else if (isId) {\n        const matches = await this.select(store, it => it.id === idOrItem);\n        if (matches.length === 0) {\n          throw new Error(`Zero rows on overwrite operator. Cannot overwrite a row that does not exist on «browsie.overwrite»`);\n        } else if (matches.length > 1) {\n          throw new Error(`Multiple rows on overwrite operation. Cannot overwrite multiple rows. Ensure store «${store}» is using index «id» as unique value to complete this operation`);\n        }\n        previousItem = matches[0];\n      } else {\n        throw new Error(`Required parameter «idOrItem» to be a string or an object on «browsie.overwrite»`);\n      }\n      const newItem = Object.assign({}, previousItem, item);\n      return await this.update(store, newItem.id, newItem);\n    }\n\n    // Método para eliminar un item de un store por ID\n    delete(store, id) {\n      this.constructor.trace(\"browsie.delete\", arguments);\n      this._ensureIntegrity(store, id);\n      this.triggers.emit(`crud.delete.one.${store}`, { store, id });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.delete(id);\n        request.onsuccess = () => resolve();\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.delete» operation over store «${store}»: `));\n      });\n    }\n\n    _getSchemaEntityByStoreName(store) {\n      this.constructor.trace(\"browsie._ensureIntegrity\", arguments);\n      const innerSchema = this.getInnerSchema().$schema;\n      const tableIds = Object.keys(innerSchema.hasTables);\n      Iterating_tables:\n      for (let indexTables = 0; indexTables < tableIds.length; indexTables++) {\n        const tableId = tableIds[indexTables];\n        if (tableId === store) {\n          return innerSchema.hasTables[tableId];\n        }\n      }\n      return undefined;\n    }\n\n    _ensureIntegrity(store, id) {\n      this.constructor.trace(\"browsie._ensureIntegrity\", arguments);\n      const innerSchema = this.getInnerSchema().$schema;\n      const tableIds = Object.keys(innerSchema.hasTables);\n      const sourceEntity = innerSchema.hasTables[store];\n      const sourceEntityId = sourceEntity.hasEntityId;\n      const boundColumns = [];\n      Iterating_tables:\n      for (let indexTables = 0; indexTables < tableIds.length; indexTables++) {\n        const tableId = tableIds[indexTables];\n        const tableData = innerSchema.hasTables[tableId];\n        const columnIds = Object.keys(tableData.hasColumns);\n        Iterating_columns:\n        for (let indexColumns = 0; indexColumns < columnIds.length; indexColumns++) {\n          const columnId = columnIds[indexColumns];\n          const columnData = tableData.hasColumns[columnId];\n          When_it_has_references: {\n            if (!columnData.refersTo) {\n              break When_it_has_references;\n            }\n            const { entity: schemaEntityId, property: entityColumnId, constraint = true } = columnData.refersTo;\n            if (!constraint) {\n              break When_it_has_references;\n            }\n            const isSameEntity = schemaEntityId === sourceEntityId;\n            if (!isSameEntity) {\n              break When_it_has_references;\n            }\n            boundColumns.push({\n              source: [store, entityColumnId],\n              mustCheck: [tableId, columnId]\n            });\n          }\n        }\n      }\n      console.log(`BOUND COLUMNS to ${store}:`, boundColumns);\n    }\n\n    _expandError(errorObject, baseMessage = false) {\n      this.constructor.trace(\"browsie._expandError\", arguments);\n      let error = errorObject;\n      if (errorObject instanceof Error) {\n        error = errorObject;\n      } else if (errorObject.target && errorObject.target.error) {\n        error = errorObject.target.error;\n      } else {\n        error = new Error(errorObject);\n      }\n      if (baseMessage) {\n        const errorTemp = new Error(error.message ?? error);\n        Object.assign(errorTemp, error);\n        errorTemp.message = baseMessage + errorTemp.message;\n        error = errorTemp;\n      }\n      return error;\n    }\n\n    // Método para seleccionar elementos de un store con un filtro\n    select(store, filter) {\n      this.constructor.trace(\"browsie.select\", arguments);\n      this.triggers.emit(`crud.select.one.${store}`, { store, filter });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readonly');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.getAll();\n\n        request.onsuccess = () => {\n          const result = request.result.filter(item => {\n            try {\n              return filter(item);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «browsie.select»\");\n              return false;\n            }\n          });\n          resolve(result);\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.select» operation over store «${store}»: `));\n      });\n    }\n\n    selectMany(store, filterFn = i => true) {\n      this.constructor.trace(\"browsie.selectMany\", arguments);\n      this.triggers.emit(`crud.select.many.${store}`, { store, filterFn });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readonly');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria\n        const results = [];\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            let isAccepted = undefined;\n            try {\n              isAccepted = filterFn(cursor.value);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «browsie.selectMany»\");\n            }\n            if (isAccepted) { // Aplica la función de filtro\n              results.push(cursor.value);\n            }\n            cursor.continue(); // Avanza al siguiente registro\n          } else {\n            resolve(results); // Se terminó el recorrido\n          }\n        };\n        request.onerror = (error) =>\n          reject(this._expandError(error, `Error on «browsie.selectMany» operation over store «${store}»: `));\n      });\n    }\n\n    // Método para insertar varios items en un store\n    insertMany(store, items) {\n      this.constructor.trace(\"browsie.insertMany\", arguments);\n      this.triggers.emit(`crud.insert.many.${store}`, { store, items });\n      this.constructor.mustBeString(store, \"insertMany\", \"arguments[0]\");\n      this.constructor.mustBeArray(items, \"insertMany\", \"arguments[1]\");\n      return new Promise((resolve, reject) => {\n        if (items.length === 0) {\n          return resolve(false);\n        }\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        let insertedCount = 0;\n        items.forEach(item => {\n          const request = objectStore.add(item);\n          request.onsuccess = () => {\n            insertedCount++;\n            if (insertedCount === items.length) resolve();\n          };\n          request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.insertMany» operation over store «${store}» inserting «${items.length}» items: `));\n        });\n      });\n    }\n\n    // Método para actualizar varios items en un store\n    updateMany(store, filter, item) {\n      this.constructor.trace(\"browsie.updateMany\", arguments);\n      this.triggers.emit(`crud.update.many.${store}`, { store, filter, item });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.openCursor();\n        let updatedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (cursor) {\n            if (Object.keys(filter).every(key => cursor.value[key] === filter[key])) {\n              const updatedItem = { ...cursor.value, ...item };\n              const updateRequest = cursor.update(updatedItem);\n              updateRequest.onsuccess = () => {\n                updatedCount++;\n                if (updatedCount === cursor.value.length) resolve();\n              };\n            }\n            cursor.continue();\n          }\n        };\n\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.updateMany» operation over store «${store}»: `));\n      });\n    }\n\n    // Método a tipo upsertAll para llenar los valores pero dejar los que no\n    async overwriteMany(store, filter, item) {\n      this.constructor.trace(\"browsie.overwriteMany\", arguments);\n      this.triggers.emit(`crud.overwrite.many.${store}`, { store, filter, item });\n      const allMatches = await this.selectMany(store, filter);\n      const allResults = [];\n      for (let indexRow = 0; indexRow < allMatches.length; indexRow++) {\n        const row = allMatches[indexRow];\n        const result = await this.overwrite(store, row, item);\n        allResults.push(result);\n      }\n      return allResults;\n    }\n\n    // Método para eliminar varios items de un store según un filtro\n    deleteMany(store, filterCallback) {\n      this.constructor.trace(\"browsie.deleteMany\", arguments);\n      this.triggers.emit(`crud.delete.many.${store}`, { store, filterCallback });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.openCursor();\n        let deletedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (!cursor) {\n            return resolve();\n          }\n          const isAccepted = filterCallback(cursor.value);\n          if (isAccepted) {\n            const deleteRequest = cursor.delete();\n            deleteRequest.onsuccess = () => {\n              deletedCount++;\n              if (deletedCount === cursor.value.length) {\n                return resolve();\n              }\n            };\n            deleteRequest.onerror = (error) => reject(this._expandError(error, `Error on «browsie.deleteMany» operation over store «${store}» and id «${cursor.value.id}»: `));\n          }\n          cursor.continue();\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.deleteMany» operation over store «${store}»: `));\n      });\n    }\n  }\n\n  // @TOCONTINUEFROM\n  class BrowsieMigration {\n\n    static from(...args) {\n      return new this(...args);\n    }\n\n    static createTable(arg) {\n      return this.from({\n        operation: \"createTable\",\n        parameters: arg\n      });\n    }\n\n    static renameTable(arg) {\n      return this.from({\n        operation: \"renameTable\",\n        parameters: arg\n      });\n    }\n\n    static deleteTable(arg) {\n      return this.from({\n        operation: \"deleteTable\",\n        parameters: arg\n      });\n    }\n\n    static createColumn(arg) {\n      return this.from({\n        operation: \"createColumn\",\n        parameters: arg\n      });\n    }\n\n    static renameColumn(arg) {\n      return this.from({\n        operation: \"renameColumn\",\n        parameters: arg\n      });\n    }\n\n    static deleteColumn(arg) {\n      return this.from({\n        operation: \"deleteColumn\",\n        parameters: arg\n      });\n    }\n\n    constructor(options = {}) {\n      LswDatabase.trace(\"LswDatabaseMigration.constructor\");\n      const { operation, parameters } = options;\n      this.$validateOperation(operation);\n      this.$validateParameters(parameters);\n      this.operation = operation;\n      this.parameters = parameters;\n      this.config = {\n        temporaryDatabase: this.parameters.fromDatabase + \"_\" + this.$getRandomString(5),\n      };\n      this.migrated = false;\n    }\n\n    $getRandomString(len = 10) {\n      LswDatabase.trace(\"LswDatabaseMigration.$getRandomString\");\n      const alphabet = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\n      let out = \"\";\n      while (out.length < len) {\n        out += alphabet[Math.floor(Math.random() * alphabet.length)];\n      }\n      return out;\n    };\n\n    $validateOperation(operation) {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateOperation\");\n      if ([\"createTable\", \"renameTable\", \"deleteTable\", \"createColumn\", \"renameColumn\", \"deleteColumn\", \"cloneDatabase\", \"moveDatabase\"].indexOf(operation) === -1) {\n        throw new Error(\"Required «operation» to be a valid operation on «LswDatabaseMigration.$validateOperation»\");\n      }\n    }\n\n    $validateParameters(parameters) {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateParameters\");\n      if (typeof parameters !== \"object\") {\n        throw new Error(\"Required «parameters» to be an object on «LswDatabaseMigration.$validateParameters»\");\n      }\n    }\n\n    async $$transferBackTemporaryDatabase() {\n      await LswDatabase.deleteDatabase(this.parameters.fromDatabase);\n      await this.$replicateSchema({\n        fromDatabase: this.config.temporaryDatabase,\n        toDatabase: this.parameters.fromDatabase,\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.config.temporaryDatabase,\n        toDatabase: this.parameters.fromDatabase,\n      });\n      await LswDatabase.deleteDatabase(this.config.temporaryDatabase);\n    }\n\n    commit() {\n      LswDatabase.trace(\"LswDatabaseMigration.commit\");\n      return this[\"$$\" + this.operation].call(this).finally(() => {\n        this.migrated = true;\n      });\n    }\n\n    $validateCreateTableParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateCreateTableParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateCreateTableParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateCreateTableParameters»\");\n      }\n      if (typeof this.parameters.tableDefinition !== \"object\") {\n        throw new Error(\"Required «parameters.tableDefinition» to be an object on «LswDatabaseMigration.$validateCreateTableParameters»\");\n      }\n    }\n\n    async $$cloneDatabase() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$cloneDatabase\");\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n    }\n\n    async $$moveDatabase() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$moveDatabase\");\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n      await LswDatabase.deleteDatabase(this.parameters.fromDatabase);\n    }\n\n    async $$createTable() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$createTable\");\n      this.$validateCreateTableParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          schema[this.parameters.table] = this.parameters.tableDefinition;\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateDeleteTableParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateDeleteTableParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n    }\n\n    async $$deleteTable() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$deleteTable\");\n      this.$validateDeleteTableParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          delete schema[this.parameters.table];\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateRenameTableParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateRenameTableParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n      if (typeof this.parameters.tableSource !== \"string\") {\n        throw new Error(\"Required «parameters.tableSource» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n      if (typeof this.parameters.tableDestination !== \"string\") {\n        throw new Error(\"Required «parameters.tableDestination» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n    }\n\n    async $$renameTable() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$renameTable\");\n      this.$validateRenameTableParameters();\n      const currentSchema = await LswDatabase.getSchema(this.parameters.fromDatabase);\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          delete schema[this.parameters.tableSource];\n          const tableInput = this.$adaptSchemaTableAsSchemaDefinition(currentSchema[this.parameters.tableSource]);\n          schema[this.parameters.tableDestination] = tableInput;\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: tableId => {\n          return this.parameters.tableDestination;\n        },\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateCreateColumnParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateCreateColumnParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n      if (typeof this.parameters.column !== \"string\") {\n        throw new Error(\"Required «parameters.column» to be a string on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n      if (typeof this.parameters.columnDefinition !== \"object\") {\n        throw new Error(\"Required «parameters.columnDefinition» to be an object on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n    }\n\n    async $$createColumn() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$createColumn\");\n      this.$validateCreateColumnParameters();\n      const isUnique = !!this.parameters.columnDefinition.isUnique;\n      const columnSymbol = `${isUnique ? \"!\" : \"\"}${this.parameters.column}`;\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        table: this.parameters.table,\n        onAlterSchema: schema => {\n          schema[this.parameters.table].push(columnSymbol);\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateDeleteColumnParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateDeleteColumnParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateDeleteColumnParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateDeleteColumnParameters»\");\n      }\n      if (typeof this.parameters.column !== \"string\") {\n        throw new Error(\"Required «parameters.column» to be a string on «LswDatabaseMigration.$validateDeleteColumnParameters»\");\n      }\n    }\n\n    async $$deleteColumn() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$deleteColumn\");\n      this.$validateDeleteColumnParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          console.log(schema);\n          const columnPosition = schema[this.parameters.table].indexOf(this.parameters.column);\n          schema[this.parameters.table].splice(columnPosition, 1);\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        // !@TOCONFIGURE: $$deleteColumn needs a specific hook (or none).\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateRenameColumnParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateRenameColumnParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n      if (typeof this.parameters.columnSource !== \"string\") {\n        throw new Error(\"Required «parameters.columnSource» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n      if (typeof this.parameters.columnDestination !== \"string\") {\n        throw new Error(\"Required «parameters.columnDestination» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n    }\n\n    async $$renameColumn() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$renameColumn\");\n      this.$validateRenameColumnParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          console.log(schema);\n          const columnPosition = schema[this.parameters.table].indexOf(this.parameters.columnSource);\n          schema[this.parameters.table].splice(columnPosition, 1);\n          schema[this.parameters.table].push(this.parameters.columnDestination);\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: (columnId) => {\n          return columnId;\n        },\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $adaptSchemaAsSchemaDefinition(schemaDefinition) {\n      const output = {};\n      const tableIds = Object.keys(schemaDefinition);\n      for (let index = 0; index < tableIds.length; index++) {\n        const storeId = tableIds[index];\n        const tableDefinition = schemaDefinition[storeId];\n        const columns = tableDefinition.indexes;\n        if (!(storeId in output)) {\n          output[storeId] = [];\n        }\n        for (let indexColumn = 0; indexColumn < columns.length; indexColumn++) {\n          const column = columns[indexColumn];\n          const columnId = column.name;\n          const columnInput = this.$adaptSchemaColumnAsSchemaDefinition(column, columnId);\n          output[storeId].push(columnInput);\n        }\n      }\n      return output;\n    }\n\n    $adaptSchemaTableAsSchemaDefinition(tableDefinition) {\n      const output = [];\n      const columns = tableDefinition.indexes;\n      for (let indexColumn = 0; indexColumn < columns.length; indexColumn++) {\n        const column = columns[indexColumn];\n        const columnId = column.name;\n        const columnInput = this.$adaptSchemaColumnAsSchemaDefinition(column, columnId);\n        output.push(columnInput);\n      }\n      return output;\n    }\n\n    $adaptSchemaColumnAsSchemaDefinition(column, columnId) {\n      if (column.unique) {\n        return \"!\" + columnId;\n      } else {\n        return columnId;\n      }\n    }\n\n    async $replicateSchema(scenario) {\n      LswDatabase.trace(\"LswDatabaseMigration.$replicateSchema\");\n      const { fromDatabase, toDatabase, onAlterSchema } = scenario;\n      console.log(`⌛️ Replicating database from «${fromDatabase}» to «${toDatabase}» on «LswDatabaseMigration.$replicateSchema»`);\n      const schemaDefinition = await LswDatabase.getSchema(fromDatabase);\n      const schemaInput = this.$adaptSchemaAsSchemaDefinition(schemaDefinition);\n      let alteredSchema = schemaInput;\n      if (onAlterSchema) {\n        alteredSchema = onAlterSchema(schemaInput);\n        if (typeof alteredSchema === \"undefined\") {\n          throw new Error(\"Required «onAlterSchema» to return an object on «LswDatabaseMigration.$replicateSchema»\")\n        }\n      }\n      console.log(\"Replicated schema:\", alteredSchema);\n      await LswDatabase.createDatabase(toDatabase, alteredSchema);\n    }\n\n    async $populateDatabase(scenario) {\n      LswDatabase.trace(\"LswDatabaseMigration.$populateDatabase\");\n      const { fromDatabase, toDatabase, onMapTableId = false, onMapColumnId = false } = scenario;\n      console.log(`⌛️ Populating database from «${fromDatabase}» to «${toDatabase}» on «LswDatabaseMigration.$populateDatabase»`);\n      const schemaDefinition = await LswDatabase.getSchema(fromDatabase);\n      const tableIds = Object.keys(schemaDefinition);\n      let fromConnection = undefined;\n      let toConnection = undefined;\n      let indexTable = 0;\n      let indexColumn = 0;\n      let tableId = undefined;\n      let alteredTableId = undefined;\n      try {\n        fromConnection = new LswDatabase(fromDatabase);\n        toConnection = new LswDatabase(toDatabase);\n        await fromConnection.open();\n        await toConnection.open();\n        for (indexTable = 0; indexTable < tableIds.length; indexTable++) {\n          tableId = tableIds[indexTable];\n          console.log(\"table:\", tableId);\n          Transfering_tables: {\n            console.log(`⌛️ Transfering table «${tableId}» on «LswDatabaseMigration.$populateDatabase»`);\n            let allRows = await fromConnection.selectMany(tableId, v => true);\n            console.log(\"[*] Getting table id\");\n            alteredTableId = tableId;\n            if (onMapTableId) {\n              alteredTableId = onMapTableId(tableId);\n            }\n            console.log(\"[*] Getting column id\");\n            if (onMapColumnId) {\n              allRows = allRows.reduce((output, row) => {\n                const allKeys = Object.keys(row);\n                const alteredRow = {};\n                for (let indexKeys = 0; indexKeys < allKeys.length; indexKeys++) {\n                  console.log(\"column:\", indexKeys);\n                  const columnId = allKeys[indexKeys];\n                  const alteredColumnId = onMapColumnId(columnId, tableId, alteredTableId, {\n                    fromConnection,\n                    toConnection\n                  }) || columnId;\n                  alteredRow[alteredColumnId] = row[columnId];\n                }\n                output.push(alteredRow);\n                return output;\n              }, []);\n            }\n            console.log(\"[*] Got:\", alteredTableId, allRows);\n            await toConnection.insertMany(alteredTableId, allRows);\n            console.log(\"What??? 444\")\n          }\n        }\n      } catch (error) {\n        console.log(`💥 Error while populating database on table ${tableId || \"-\"} (alias «${alteredTableId}»):`, error);\n      } finally {\n        try {\n          await fromConnection.close();\n        } catch (error) {\n          console.log(error);\n        }\n        try {\n          await toConnection.close();\n        } catch (error) {\n          console.log(error);\n        }\n        console.log(`[*] Database «${toDatabase}» population finished successfully.`);\n      }\n    }\n\n  }\n\n  class LswDatabaseMigration extends BrowsieMigration {\n\n  }\n\n  LswDatabaseMigration.default = LswDatabaseMigration;\n  window.LswDatabaseMigration = LswDatabaseMigration;\n  window.BrowsieMigration = BrowsieMigration;\n\n  class BrowsieMigrable extends BrowsieCrudAPI {\n\n    static migration = LswDatabaseMigration;\n\n  }\n\n  window.Browsie = BrowsieMigrable;\n  Browsie.default = BrowsieMigrable;\n\n  /* Extended API */\n\n  class LswDatabase extends BrowsieMigrable {\n\n    class = this.constructor;\n\n  }\n\n  LswDatabase.default = LswDatabase;\n  window.LswDatabase = LswDatabase;\n",
              "$code.label": "LswDatabase class",
              "$output": "index.html"
            }
          ],
          "Lsw DatabaseVirtualizer API » LswDatabaseVirtualizer class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database-virtualizer/lsw-database-virtualizer.js",
              "$location": {
                "start": {
                  "offset": 310,
                  "line": 14,
                  "column": 1
                },
                "end": {
                  "offset": 428,
                  "line": 15,
                  "column": 1
                }
              },
              "section": "Lsw DatabaseVirtualizer API » LswDatabaseVirtualizer class",
              "$code": "  const LswDatabaseVirtualizer = class {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    static start(...args) {\n      const virtualization = new this(...args);\n      return virtualization;\n    }\n\n    $lifecycle = [\n      \"onStart\",\n      \"onStartValidation\",\n      \"onValidateConnection\",\n      \"onValidateSchema\",\n      \"onFinishValidation\",\n      \"onDeleteVirtualDatabase\",\n      \"onStartClonation\",\n      \"onCloneDatabase\",\n      \"onFinishClonation\",\n      \"onStartVirtualization\",\n      \"onVirtualizeSchema\",\n      \"onVirtualizeTables\",\n      \"onVirtualizeColumns\",\n      \"onFinishVirtualization\",\n      \"onStartFormalization\",\n      \"onFormalizeColumns\",\n      \"onFormalizeTables\",\n      \"onFormalizeSchema\",\n      \"onReport\",\n      \"onFinishFormalization\",\n      \"onFinish\",\n    ];\n\n    $defaultConfigurations = {\n      trace: true,\n    };\n\n    $trace(method, args) {\n      if(this.$configurations.trace) {\n        const methodArgs = Array.from(args);\n        console.log(`[trace][lsw-database-virtualizer] ${method}: (${methodArgs.length}) ${methodArgs.map(e => typeof e).join(\", \")}`);\n      }\n    }\n\n    constructor(configurations = {}) {\n      this.$configurations = Object.assign({}, this.$defaultConfigurations, configurations || {});\n      this.$trace(\"constructor\", arguments);\n      this.triggers = new TriggersClass();\n      this.physicalConnection = undefined;\n      this.virtualConnection = undefined;\n      this.schema = undefined;\n    }\n\n    configure(options = {}) {\n      this.$trace(\"configure\", arguments);\n      $ensure({ options }, 1).to.have.uniquelyKeys([\"physicalConnection\", \"virtualConnection\", \"schema\"]);\n      Object.assign(this, options);\n      return this;\n    }\n\n    setPhysicalConnection(physicalConnection) {\n      this.$trace(\"setPhysicalConnection\", arguments);\n      this.physicalConnection = physicalConnection;\n      return this;\n    }\n\n    setVirtualConnection(virtualConnection) {\n      this.$trace(\"setVirtualConnection\", arguments);\n      this.virtualConnection = virtualConnection;\n      return this;\n    }\n\n    setSchema(schema) {\n      this.$trace(\"setSchema\", arguments);\n      this.schema = schema;\n      return this;\n    }\n\n    start() {\n      this.$trace(\"start\", arguments);\n      return LswCycler.from(this, \"*\").run(this.$lifecycle);\n    }\n\n    async onStart() {\n      this.$trace(\"onStart\", arguments);\n      // *@TODO:\n    }\n\n    async onStartValidation() {\n      this.$trace(\"onStartValidation\", arguments);\n      // *@TODO:\n    }\n\n    async onValidateConnection() {\n      this.$trace(\"onValidateConnection\", arguments);\n      // *@TODO:\n    }\n\n    async onValidateSchema() {\n      this.$trace(\"onValidateSchema\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishValidation() {\n      this.$trace(\"onFinishValidation\", arguments);\n      // *@TODO:\n    }\n\n    async onDeleteVirtualDatabase() {\n      this.$trace(\"onDeleteVirtualDatabase\", arguments);\n      // *@TODO:\n    }\n\n    async onStartClonation() {\n      this.$trace(\"onStartClonation\", arguments);\n      // *@TODO:\n    }\n\n    async onCloneDatabase() {\n      this.$trace(\"onCloneDatabase\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishClonation() {\n      this.$trace(\"onFinishClonation\", arguments);\n      // *@TODO:\n    }\n\n    async onStartVirtualization() {\n      this.$trace(\"onStartVirtualization\", arguments);\n      // *@TODO:\n    }\n\n    async onVirtualizeSchema() {\n      this.$trace(\"onVirtualizeSchema\", arguments);\n      // *@TODO:\n    }\n\n    async onVirtualizeTables() {\n      this.$trace(\"onVirtualizeTables\", arguments);\n      // *@TODO:\n    }\n\n    async onVirtualizeColumns() {\n      this.$trace(\"onVirtualizeColumns\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishVirtualization() {\n      this.$trace(\"onFinishVirtualization\", arguments);\n      // *@TODO:\n    }\n\n    async onStartFormalization() {\n      this.$trace(\"onStartFormalization\", arguments);\n      // *@TODO:\n    }\n\n    async onFormalizeColumns() {\n      this.$trace(\"onFormalizeColumns\", arguments);\n      // *@TODO:\n    }\n\n    async onFormalizeTables() {\n      this.$trace(\"onFormalizeTables\", arguments);\n      // *@TODO:\n    }\n\n    async onFormalizeSchema() {\n      this.$trace(\"onFormalizeSchema\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishFormalization() {\n      this.$trace(\"onFinishFormalization\", arguments);\n      // *@TODO:\n    }\n\n    async onReport() {\n      this.$trace(\"onReport\", arguments);\n      // *@TODO:\n    }\n\n    async onFinish() {\n      this.$trace(\"onFinish\", arguments);\n      // *@TODO:\n    }\n\n  }\n",
              "$code.label": "LswDatabaseVirtualizer class",
              "$output": "index.html"
            }
          ],
          "Lsw Depender API » LswDepender class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-depender/lsw-depender.js",
              "$location": {
                "start": {
                  "offset": 288,
                  "line": 14,
                  "column": 3
                },
                "end": {
                  "offset": 502,
                  "line": 24,
                  "column": 6
                }
              },
              "$section": "Lsw Depender API » LswDepender class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswDepender",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-depender/lsw-depender.js",
              "$location": {
                "start": {
                  "offset": 503,
                  "line": 25,
                  "column": 1
                },
                "end": {
                  "offset": 588,
                  "line": 26,
                  "column": 1
                }
              },
              "section": "Lsw Depender API » LswDepender class",
              "$code": "  const Definition = class {\n    constructor({ id, dependencies = [] }) {\n      this.id = id;\n      this.dependencies = dependencies;\n    }\n  };\n\n  const LswDepender = class {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor(definitions = {}) {\n      this.$definitions = definitions;\n    }\n\n    hasDefined(name) {\n      if (name in this.$definitions) {\n        if (this.$definitions[name] instanceof Definition) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    define(...args) {\n      if (typeof args[0] === \"string\") {\n        return this.addDefinition(...args);\n      }\n      return this.addUniqueDefinitions(...args);\n    }\n\n    resolve(idsInput = this, defs = this.$definitions) {\n      const ids = idsInput === this ? Object.keys(this.$definitions) : idsInput;\n      let resolved = new Set();\n      let resultado = [];\n      const resolverNodo = function(id) {\n        console.log(\"resolviendo nodo:\", id, defs);\n        if (resolved.has(id)) return;\n        if (!defs[id]) return; // Si no está definido, lo ignoramos\n        for (let dep of defs[id].dependencies || []) {\n          resolverNodo(dep);\n        }\n        resolved.add(id);\n        resultado.push(id);\n      }\n      for (let id of [].concat(ids)) {\n        resolverNodo(id);\n      }\n      return resultado;\n    }\n\n    addDefinition(name, definition, shouldFailOnRedundancy = 1, shouldOverrideOnRedundancy = 1) {\n      Validation: {\n        if (this.hasDefined(name)) {\n          if (shouldFailOnRedundancy) {\n            throw new Error(`Dependency «${name}» is already defined and should not redund on «LswDepender.define»`);\n          } else if (!shouldOverrideOnRedundancy) {\n            return false; // !@BREAK: the fallback must not override it\n          } else if (shouldOverrideOnRedundancy) {\n            // !@OK: the fallback will override it\n          } else {\n            throw new Error(\"Cannot logically happen (1)\");\n          }\n        }\n      }\n      Define_it: {\n        if (typeof definition !== \"object\") {\n          throw new Error(`Required definition of «${name}» to be an object on «LswDepender.define»`);\n        } else if (typeof definition.id !== \"string\") {\n          definition.id = name;\n        } else if (Array.isArray(definition.dependencies)) {\n          throw new Error(`Required definition of «${name}» its property «dependencies» to be a array on «LswDepender.define»`);\n        } else {\n          for (let indexDependency = 0; indexDependency < definition.dependencies.length; indexDependency++) {\n            const dependencyRef = definition.dependencies[indexDependency];\n            if (typeof dependencyRef !== \"string\") {\n              throw new Error(`Required definition of «${name}» its property «dependencies» on its index «${indexDependency}» to be a string on «LswDepender.define»`);\n            }\n          }\n        }\n        this.$definitions[name] = new Definition(definition);\n      }\n    }\n\n    addUniqueDefinitions(moreDefinitions = {}) {\n      const definitionIds = Object.keys(moreDefinitions);\n      for (let indexId = 0; indexId < definitionIds.length; indexId++) {\n        const definitionId = definitionIds[indexId];\n        const definitionInstance = moreDefinitions[definitionId];\n        this.define(definitionId, definitionInstance, 1);\n      }\n    }\n\n    addMissingDefinitions(moreDefinitions = {}) {\n      const definitionIds = Object.keys(moreDefinitions);\n      for (let indexId = 0; indexId < definitionIds.length; indexId++) {\n        const definitionId = definitionIds[indexId];\n        const definitionInstance = moreDefinitions[definitionId];\n        this.define(definitionId, definitionInstance, 0, 0);\n      }\n    }\n\n    resetDefinitions(moreDefinitions = {}) {\n      const definitionIds = Object.keys(moreDefinitions);\n      for (let indexId = 0; indexId < definitionIds.length; indexId++) {\n        const definitionId = definitionIds[indexId];\n        const definitionInstance = moreDefinitions[definitionId];\n        this.define(definitionId, definitionInstance, 0, 1);\n      }\n    }\n\n    deleteDefinitions(definitionsInput = []) {\n      const definitions = Array.isArray(definitionsInput) ? definitionsInput : [definitionsInput];\n      for (let indexDefinition = 0; indexDefinition < definitions.length; indexDefinition++) {\n        const definitionId = definitions[indexDefinition];\n        delete this.$definitions[definitionId];\n      }\n    }\n\n  }\n\n  LswDepender.default = LswDepender;\n",
              "$code.label": "LswDepender class",
              "$output": "index.html"
            }
          ],
          "Lsw Dom API » LswDom class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-dom.js",
              "$location": {
                "start": {
                  "offset": 281,
                  "line": 15,
                  "column": 3
                },
                "end": {
                  "offset": 480,
                  "line": 25,
                  "column": 6
                }
              },
              "$section": "Lsw Dom API » LswDom class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswDom",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-dom.js",
              "$location": {
                "start": {
                  "offset": 481,
                  "line": 26,
                  "column": 1
                },
                "end": {
                  "offset": 551,
                  "line": 27,
                  "column": 1
                }
              },
              "section": "Lsw Dom API » LswDom class",
              "$code": "  const LswDom = class {\n\n    static collectLeaves(originalCollection, selectorSequence = []) {\n      $ensure(originalCollection).type(\"object\");\n      $ensure(selectorSequence).type(\"object\").to.be.array();\n      let collection = Array.isArray(originalCollection) ? originalCollection : [originalCollection];\n      const mapperFactory = selector => element => {\n        return [].concat(element.querySelectorAll(selector));\n      };\n      for(let indexSelector=0; indexSelector<selectorSequence.length; indexSelector++) {\n        const selector = selectorSequence[indexSelector];\n        const subnodes = collection.map(mapperFactory(selector)).flat();\n        collection = [].concat(subnodes);\n      }\n      return collection;\n    }\n\n    static getClosestParent(originalElement, selector) {\n      $ensure(originalElement).type(\"object\").to.be.instanceOf(HTMLElement);\n      $ensure(selector).type(\"string\");\n      let element = originalElement.parentElement;\n      while(element && (element !== document)) {\n        if(element.matches(selector)) {\n          return element;\n        }\n        element = element.parentElement;\n      }\n      return null;\n    }\n\n    static getClosestChildren(originalElement, selector) {\n      $ensure(originalElement).type(\"object\").to.be.instanceOf(HTMLElement);\n      $ensure(selector).type(\"string\");\n      return [...originalElement.querySelectorAll(selector)].filter(element => {\n        return this.getClosestParent(element, selector) === originalElement;\n      });\n    }\n\n  };\n",
              "$code.label": "LswDom class",
              "$output": "index.html"
            }
          ],
          "Lsw Vue2 API » LswVue2 class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-vue2.js",
              "$location": {
                "start": {
                  "offset": 280,
                  "line": 14,
                  "column": 3
                },
                "end": {
                  "offset": 482,
                  "line": 24,
                  "column": 6
                }
              },
              "$section": "Lsw Vue2 API » LswVue2 class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswVue2",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-vue2.js",
              "$location": {
                "start": {
                  "offset": 483,
                  "line": 25,
                  "column": 1
                },
                "end": {
                  "offset": 556,
                  "line": 26,
                  "column": 1
                }
              },
              "section": "Lsw Vue2 API » LswVue2 class",
              "$code": "  const LswVue2 = class {\n\n    static getClosestParent(component, filterCallback) {\n      $ensure(component).type(\"object\");\n      $ensure(filterCallback).type(\"function\");\n      let parentOf = component;\n      do {\n        parentOf = parentOf.$parent;\n        const isValid = filterCallback(parentOf);\n        if (isValid) {\n          return parentOf;\n        }\n      } while (typeof parentOf !== \"undefined\");\n      return undefined;\n    }\n\n    static extendComponent(baseComponent = {}) {\n      const extendedComponent = Object.assign({}, baseComponent);\n      extendedComponent.props = Object.assign({}, baseComponent.props || {});\n      extendedComponent.methods = Object.assign({}, baseComponent.methods || {});\n      extendedComponent.watch = Object.assign({}, baseComponent.watch || {});\n      extendedComponent.computed = Object.assign({}, baseComponent.computed || {});\n      return extendedComponent;\n    }\n\n  }\n",
              "$code.label": "LswVue2 class",
              "$output": "index.html"
            }
          ],
          "Lsw Ensurer API » LswEnsurer class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-ensurer/ensure.js",
              "$location": {
                "start": {
                  "offset": 286,
                  "line": 14,
                  "column": 3
                },
                "end": {
                  "offset": 497,
                  "line": 24,
                  "column": 6
                }
              },
              "$section": "Lsw Ensurer API » LswEnsurer class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswEnsurer",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-ensurer/ensure.js",
              "$location": {
                "start": {
                  "offset": 498,
                  "line": 25,
                  "column": 1
                },
                "end": {
                  "offset": 580,
                  "line": 26,
                  "column": 1
                }
              },
              "section": "Lsw Ensurer API » LswEnsurer class",
              "$code": "  class AssertionError extends Error {\n\n    constructor(...args) {\n      super(...args);\n      this.name = \"AssertionError\";\n    }\n\n  }\n\n  class Ensurement {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor(source, asLabeledObject = 0) {\n      Resolve_subject: {\n        if ((asLabeledObject === 1) && (typeof source === \"object\")) {\n          const sourceKeys = Object.keys(source);\n          if (sourceKeys.length !== 1) {\n            throw new Error(`The first parameter of $ensure or $check {when $2 is literally 1} must have 1 property (not ${sourceKeys.length}) on «Ensurement.constructor»`);\n          }\n          this.$subjectId = sourceKeys[0];\n          this.$subject = source[this.$subjectId];\n        } else if(typeof asLabeledObject === \"string\") {\n          this.$subjectId = asLabeledObject;\n          this.$subject = source;\n        } else {\n          this.$subjectId = \"@\";\n          this.$subject = source;\n        }\n      }\n      this.$operation = undefined;\n      this.$objectation = undefined;\n      this.asBoolean = false;\n    }\n    type(value) {\n      this.$operation = \"is of type\";\n      this.$objectation = value;\n      if(typeof value === \"string\") {\n        if (typeof this.$subject !== value) {\n          return this.$asFailed();\n        }\n      } else if(Array.isArray(value)) {\n        if(value.indexOf(typeof this.$subject) === -1) {\n          return this.$asFailed();\n        }\n      } else {\n        throw new Error(`Bad parameter on «$ensure(...).type(?)» (${typeof value} not admitted)`);\n      }\n      return this.$asResolved();\n    }\n    notType(value) {\n      this.$operation = \"is not of type\";\n      this.$objectation = value;\n      if (typeof this.$subject === value) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    is(value) {\n      this.$operation = \"is\";\n      this.$objectation = value;\n      if (this.$subject !== value) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    isnt(value) {\n      this.$operation = \"is not\";\n      this.$objectation = value;\n      if (this.$subject === value) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    can(value) {\n      this.$operation = \"can\";\n      this.$objectation = value;\n      if (!value(this.$subject)) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    cant(value) {\n      this.$operation = \"cant\";\n      this.$objectation = value;\n      if (value(this.$subject)) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    throws(value) {\n      this.$operation = \"throws\";\n      this.$objectation = value;\n      try {\n        objectation(this.$subject);\n        return this.$asFailed();\n      } catch (error) {\n        return this.$asResolved();\n      }\n    }\n    doesntThrow(value) {\n      this.$operation = \"doesntThrow\";\n      this.$objectation = value;\n      try {\n        value(this.$subject);\n        return this.$asFailed();\n      } catch (error) {\n        return this.$asResolved();\n      }\n    }\n    $asFailed(operation = this.$operation) {\n      if (this.asBoolean) {\n        return false;\n      }\n      throw new AssertionError(\"could not ensure «\" + this.$subjectId + \"» \" + operation + (this.$objectation ? \" «\" + this.$getObjectationAsString() + \"»\": \"\") + \"\");\n    }\n    $getObjectationAsString() {\n      return JSON.stringify(this.$objectation);\n    }\n    $asResolved() {\n      if (this.asBoolean) {\n        return true;\n      } else {\n        return this;\n      }\n    }\n  };\n\n  const BasicToBeInterface = class {\n    $isNegated = false;\n    set $operation(value) {\n      this.$ensurement.$operation = value;\n    }\n    get $operation() {\n      return this.$ensurement.$operation;\n    }\n    set $objectation(value) {\n      this.$ensurement.$objectation = value;\n    }\n    get $objectation() {\n      return this.$ensurement.$objectation;\n    }\n    constructor(ensurement) {\n      this.$ensurement = ensurement;\n      this.$subject = this.$ensurement.$subject;\n    }\n    $makeNegable(condition) {\n      return this.$isNegated === true ? !condition : condition;\n    }\n    $asFailed() {\n      return this.$ensurement.$asFailed();\n    }\n    $resolveNegableString(text) {\n      return text.replace(/\\{not\\?\\} */g, this.$isNegated ? \"not \" : \"\");\n    }\n  };\n\n  const ToBeInterface = class extends BasicToBeInterface {\n    string() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be string\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"string\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    number() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be number\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"number\") || Number.isNaN(this.$subject)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    object() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be object\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"object\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    null() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be null\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== null)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    undefined() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be undefined\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"undefined\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    boolean() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be boolean\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"boolean\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    instanceOf(clazz) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be instanceOf\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(!(this.$subject instanceof clazz))) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    array() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be array\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(!Array.isArray(this.$subject))) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    function() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be function\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof (this.$subject) !== \"function\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    empty() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be empty\");\n      this.$objectation = undefined;\n      const isEmpty = (() => {\n        const s = this.$subject;\n        if (Array.isArray(s)) {\n          return s.length === 0;\n        } else if (typeof s === \"object\") {\n          return s === null || Object.keys(s).length === 0;\n        } else if (typeof s === \"string\") {\n          return s === \"\";\n        } else if (typeof s === \"number\") {\n          return s === 0;\n        } else if (typeof s === \"boolean\") {\n          return s === false;\n        } else {\n          return true;\n        }\n      })();\n      if (this.$makeNegable(!isEmpty)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    equalTo(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be equal to\");\n      this.$objectation = value;\n      let isEqual = this.$subject === value;\n      if (this.$makeNegable(!isEqual)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    equalOrGreaterThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be equal or greater than\");\n      this.$objectation = value;\n      let isGreaterOrEqual = this.$subject >= value;\n      if (this.$makeNegable(!isGreaterOrEqual)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    greaterThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be greater than\");\n      this.$objectation = value;\n      let isGreater = this.$subject > value;\n      if (this.$makeNegable(!isGreater)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    greaterOrEqualTo(...args) {\n      return this.equalOrGreaterThan(...args);\n    }\n    equalOrLowerThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} equal or lower than\");\n      this.$objectation = value;\n      let isGreaterOrEqual = this.$subject <= value;\n      if (this.$makeNegable(!isGreaterOrEqual)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    lowerThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be lower than\");\n      this.$objectation = value;\n      let isGreater = this.$subject < value;\n      if (this.$makeNegable(!isGreater)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    lowerOrEqualTo(value) {\n      return this.equalOrLowerThan(...args);\n    }\n    oneOf(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be one of\");\n      this.$objectation = value;\n      if(!Array.isArray(value)) {\n        throw new Error(`Required on «$ensure(...).to.be.oneOf(!)» to provide an array on «ToBeInterface.oneOf»`);\n      }\n      let isOne = this.$objectation.indexOf(this.$subject) !== -1;\n      if (this.$makeNegable(!isOne)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n  };\n\n  const ToNotBeInterface = class extends ToBeInterface {\n    $isNegated = true;\n  };\n\n  const ToHaveInterface = class extends BasicToBeInterface {\n\n    text(prop) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have text\");\n      this.$objectation = prop;\n      const hasSubstring = this.$subject.indexOf(prop) !== -1;\n      if (this.$makeNegable(!hasSubstring)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    \n    key(prop) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have key\");\n      this.$objectation = prop;\n      const keys = Object.keys(this.$subject);\n      const hasKey = keys.indexOf(prop) !== -1;\n      if (this.$makeNegable(!hasKey)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    value(prop) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have value\");\n      this.$objectation = prop;\n      const values = Object.values(this.$subject);\n      const hasValue = values.indexOf(prop) !== -1;\n      if (this.$makeNegable(!hasValue)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    onlyPotentialKeys(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have only potential keys\");\n      this.$objectation = props;\n      const keys = Object.keys(this.$subject);\n      let hasOnly = true;\n      Iterating_props:\n      for (let index = 0; index < keys.length; index++) {\n        const key = keys[index];\n        if (props.indexOf(key) === -1) {\n          hasOnly = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasOnly)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    keys(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have keys\");\n      this.$objectation = props;\n      const keys = Object.keys(this.$subject);\n      let hasKeys = true;\n      Iterating_props:\n      for (let index = 0; index < props.length; index++) {\n        const prop = props[index];\n        if (keys.indexOf(prop) === -1) {\n          hasKeys = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasKeys)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    values(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have values\");\n      this.$objectation = props;\n      const values = Object.values(this.$subject);\n      let hasValues = true;\n      Iterating_props:\n      for (let index = 0; index < props.length; index++) {\n        const prop = props[index];\n        if (values.indexOf(prop) === -1) {\n          hasValues = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasValues)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    uniquelyKeys(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have uniquelyKeys\");\n      this.$objectation = props;\n      const keys = Object.keys(this.$subject);\n      let hasKeys = true;\n      Iterating_props:\n      for (let index = 0; index < keys.length; index++) {\n        const key = keys[index];\n        if (props.indexOf(key) === -1) {\n          hasKeys = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasKeys)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    uniquelyValues(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have uniquelyValues\");\n      this.$objectation = props;\n      const values = Object.values(this.$subject);\n      let hasValues = true;\n      Iterating_props:\n      for (let index = 0; index < values.length; index++) {\n        const value = values[index];\n        if (props.indexOf(value) === -1) {\n          hasValues = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasValues)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n  };\n\n  const ToNotHaveInterface = class extends ToHaveInterface {\n    $isNegated = true;\n  };\n\n  const EnsurementV1 = class extends Ensurement {\n\n    selfExtend(obj) {\n      return Object.assign(this, obj);\n    }\n\n    get $toNotBe() {\n      return new ToNotBeInterface(this);\n    }\n\n    get $toNotHave() {\n      return new ToNotHaveInterface(this);\n    }\n\n    get $toNot() {\n      return {\n        be: this.$toNotBe,\n        have: this.$toNotHave,\n      }\n    }\n\n    get $toBe() {\n      return new ToBeInterface(this);\n    }\n\n    get $toHave() {\n      return new ToHaveInterface(this);\n    }\n\n    get to() {\n      return {\n        be: this.$toBe,\n        have: this.$toHave,\n        not: this.$toNot,\n      };\n    }\n\n    its(id) {\n      return this.constructor.create({\n        [id]: this.$subject[id]\n      }, 1).selfExtend({\n        $parent: this,\n        asBoolean: this.asBoolean,\n      });\n    }\n\n    getSubject() {\n      return this.$subject;\n    }\n\n    safelyBack(levels = 1) {\n      for (let index = 0; index < levels; index++) {\n        try {\n          parent = this.$parent;\n        } catch (error) {\n          // @OK.\n        }\n      }\n    }\n\n    back(levels = 1) {\n      let parent = this;\n      for (let index = 0; index < levels; index++) {\n        try {\n          parent = this.$parent;\n        } catch (error) {\n          throw new Error(`Ensurement could not go «back» reaching parent on level «${index}» on «ensure(...).back»`);\n        }\n      }\n      return parent;\n    }\n\n    static $or(options) {\n      let correctOption = undefined;\n      const allIds = Object.keys(options);\n      const orError = new Error(`could not ensure «or» group with options: «${allIds.join(\"», «\")}»`);\n      for(let index=0; index<allIds.length; index++) {\n        const currentId = allIds[index];\n        const currentOptionCallback = options[currentId];\n        try {\n          currentOptionCallback();\n          return currentId;\n        } catch (error) {\n          orError.appendError(error);\n        }\n      }\n      throw orError.unified();\n    }\n\n    static ensure(...args) {\n      return this.create(...args);\n    }\n\n    static check(...args) {\n      return this.create(...args).selfExtend({\n        asBoolean: true\n      });\n    }\n\n    static assert(condition, errorMessage = \"Assertion error happened\") {\n      if (!condition) {\n        throw new AssertionError(errorMessage);\n      }\n      return true;\n    }\n\n    static fails(callback, errorMessage = \"Assertion error happened\") {\n      let passes = true;\n      try {\n        callback();\n        passes = false;\n      } catch (error) {\n        return true;\n      }\n      if (!passes) {\n        throw new AssertionError(errorMessage);\n      }\n    }\n\n    static AssertionError = AssertionError;\n\n  };\n\n  Export_to_globals: {\n    globalThis.$fails = EnsurementV1.fails.bind(EnsurementV1);\n    globalThis.$ensure = EnsurementV1.ensure.bind(EnsurementV1);\n    globalThis.$check = EnsurementV1.check.bind(EnsurementV1);\n    globalThis.$assert = EnsurementV1.assert.bind(EnsurementV1);\n    // globalThis.AssertionError = AssertionError;\n    globalThis.$ensure.$or = EnsurementV1.$or;\n  }\n  \n  return EnsurementV1;\n",
              "$code.label": "LswEnsurer class",
              "$output": "index.html"
            }
          ],
          "Lsw ErrorManager API » LswErrorManager class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-error-manager/lsw-error-manager.js",
              "$location": {
                "start": {
                  "offset": 2,
                  "line": 3,
                  "column": 1
                },
                "end": {
                  "offset": 208,
                  "line": 13,
                  "column": 4
                }
              },
              "$section": "Lsw ErrorManager API » LswErrorManager class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswErrorManager",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-error-manager/lsw-error-manager.js",
              "$location": {
                "start": {
                  "offset": 209,
                  "line": 14,
                  "column": 1
                },
                "end": {
                  "offset": 304,
                  "line": 15,
                  "column": 1
                }
              },
              "section": "Lsw ErrorManager API » LswErrorManager class",
              "$code": "\nglobalThis.ErrorSummary = class {\n  constructor(data) {\n    Object.assign(this, data);\n  }\n  toString() {\n    return JSON.stringify(this, null, 2);\n  }\n}\n\nglobalThis.Error = class AccumulableError extends Error {\n  constructor(...args) {\n    super(...args);\n    this.$accumulatedErrors = [];\n  }\n  toString() {\n    return JSON.stringify(this, null, 2);\n  }\n  toJSON() {\n    const data = {\n      name: this.name || \"Error\",\n      message: this.message || \"\",\n      stack: this.stack ? this.stack.split(\"\\n    at \") : \"\",\n      ...this,\n    };\n    if (this.$accumulatedErrors && this.$accumulatedErrors.length) {\n      data.$accumulatedErrors = this.$accumulatedErrors;\n    }\n    return data;\n  }\n  unified() {\n    this.message = this.message + \"\\n\" + this.$accumulatedErrors.map((e, i) => (i + 1) + ': ' + e.name + ': ' + e.message).join(\"\\n\");\n    this.$accumulatedErrors = [];\n    return this;\n  }\n  prependError(error) {\n    this.$accumulatedErrors.unshift(error);\n    return this;\n  }\n  appendError(error) {\n    this.$accumulatedErrors.push(error);\n    return this;\n  }\n  summarized() {\n    let uniqueTraces = [];\n    let commonTraces = [];\n    // Recopilar las trazas de la pila de errores acumulados\n    const allStacks = this.$accumulatedErrors.map(\n      (error) => (error.stack ? error.stack.split(\"\\n    at \") : [])\n    );\n    // Si no hay acumulados, no hay comunes ni únicos\n    if (allStacks.length === 0) {\n      return new ErrorSummary({\n        name: this.name,\n        message: this.message,\n        stack: this.stack ? this.stack.split(\"\\n    at \") : [],\n        uniqueTraces: uniqueTraces,\n        commonTraces: commonTraces,\n      });\n    }\n    // Identificar trazas comunes\n    const firstStack = allStacks[0];\n    for (let i = 0; i < firstStack.length; i++) {\n      const trace = firstStack[i];\n      let isCommon = true;\n      for (let j = 1; j < allStacks.length; j++) {\n        if (!allStacks[j].includes(trace)) {\n          isCommon = false;\n          break;\n        }\n      }\n      if (isCommon) {\n        commonTraces.push(trace);\n      }\n    }\n    // Identificar trazas únicas\n    for (let i = 0; i < allStacks.length; i++) {\n      const uniqueForStack = [];\n      for (let j = 0; j < allStacks[i].length; j++) {\n        const trace = allStacks[i][j];\n        if (!commonTraces.includes(trace)) {\n          uniqueForStack.push(trace);\n        }\n      }\n      uniqueTraces.push(uniqueForStack);\n    }\n    return new ErrorSummary({\n      ...this,\n      name: this.name,\n      message: this.message,\n      stack: this.stack ? this.stack.split(\"\\n    at \") : [],\n      uniqueTraces: uniqueTraces,\n      commonTraces: commonTraces,\n    });\n  }\n\n}\n\n",
              "$code.label": "LswErrorManager class",
              "$output": "index.html"
            }
          ],
          "UFS Manager API » UFS_manager class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-filesystem/ufs-v1.0.2.js",
              "$location": {
                "start": {
                  "offset": 326,
                  "line": 9,
                  "column": 1
                },
                "end": {
                  "offset": 408,
                  "line": 10,
                  "column": 1
                }
              },
              "section": "UFS Manager API » UFS_manager class",
              "$code": "(function (factory) {\n  const name = \"UFS_manager\";\n  const modulo = factory();\n  if (typeof window !== 'undefined') {\n    window[name] = modulo;\n  }\n  if (typeof module !== 'undefined') {\n    module.exports = modulo;\n  }\n  if (typeof global !== 'undefined') {\n    global[name] = modulo;\n  }\n  return modulo;\n})(function () {\n  const FilesystemError = class extends Error {\n    constructor(...args) {\n      super(...args);\n      this.name = \"FilesystemError\";\n    }\n  }\n  const UFS_manager_for_node = class {\n    constructor() {\n      // @OK\n    }\n    init() {\n      return this;\n    }\n    trace(method, args = []) {\n      console.log(\"[ufs][node-driver][\" + method + \"]\", Array.from(args).map(arg => typeof (arg) + \": \" + arg).join(\", \"));\n    }\n    resolve_path(...args) {\n      this.trace(\"resolve_path\", arguments);\n      return require(\"path\").resolve(...args);\n    }\n    get_current_directory() {\n      this.trace(\"get_current_directory\", arguments);\n      return process.cwd();\n    }\n    change_directory(node) {\n      this.trace(\"change_directory\", arguments);\n      return process.chdir(node);\n    }\n    rename(node, node2) {\n      this.trace(\"rename\", arguments);\n      return require(\"fs\").renameSync(node, node2);\n    }\n    read_directory(node) {\n      this.trace(\"read_directory\", arguments);\n      return require(\"fs\").readdirSync(node).reduce((out, item) => {\n        const subnode_fullpath = require(\"path\").resolve(node, item);\n        out[item] = require(\"fs\").lstatSync(subnode_fullpath).isFile() ? \"...\" : {};\n        return out;\n      }, {});\n    }\n    read_file(node) {\n      this.trace(\"read_file\", arguments);\n      return require(\"fs\").readFileSync(node).toString();\n    }\n    make_directory(node) {\n      this.trace(\"make_directory\", arguments);\n      return require(\"fs\").mkdirSync(node);\n    }\n    write_file(node, contents) {\n      this.trace(\"write_file\", arguments);\n      return require(\"fs\").writeFileSync(node, contents);\n    }\n    exists(node) {\n      this.trace(\"exists\", arguments);\n      return require(\"fs\").existsSync(node);\n    }\n    is_file(node) {\n      this.trace(\"is_file\", arguments);\n      return require(\"fs\").lstatSync(node).isFile();\n    }\n    is_directory(node) {\n      this.trace(\"is_directory\", arguments);\n      return require(\"fs\").lstatSync(node).isDirectory();\n    }\n    delete_file(node) {\n      this.trace(\"delete_file\", arguments);\n      return require(\"fs\").unlinkSync(node);\n    }\n    delete_directory(node) {\n      this.trace(\"delete_directory\", arguments);\n      return require(\"fs\").rmdirSync(node, { recursive: true });\n    }\n  }\n\n  const UFS_manager_for_localstorage = class extends UFS_manager_for_node {\n    constructor(storage_id = \"ufs_main_storage\") {\n      super();\n      this.storage_id = storage_id;\n      this.current_directory = this.environment === \"node\" ? process.cwd : \"/\";\n    }\n    trace(method, args = []) {\n      console.log(\"[ufs][ls-driver][\" + method + \"]\", Array.from(args).map(arg => typeof (arg) + \": \" + arg).join(\", \"));\n    }\n    get_persisted_data() {\n      this.trace(\"get_persisted_data\", arguments);\n      if (!(this.storage_id in localStorage)) {\n        localStorage[this.storage_id] = '{\"files\":{}}';\n      }\n      const data = JSON.parse(localStorage[this.storage_id]);\n      return data;\n    }\n    set_persisted_data(data) {\n      this.trace(\"set_persisted_data\", arguments);\n      localStorage[this.storage_id] = JSON.stringify(data);\n    }\n    remove_slash_end(txt) {\n      // this.trace(\"remove_slash_end\", arguments);\n      const txt2 = txt.replace(/\\/$/g, \"\");\n      if (txt2.length === 0) {\n        return \"/\";\n      }\n      return txt2;\n    }\n    remove_repeated_slahes(txt) {\n      // this.trace(\"remove_repeated_slahes\", arguments);\n      return txt.replace(/\\/(\\/)+/g, \"/\");\n    }\n    resolve_path(...args) {\n      this.trace(\"resolve_path\", arguments);\n      Validate_args: {\n        if (args.length === 0) {\n          throw new Error(\"Method «resolve_path» requires 1 or more parameters\");\n        }\n        for (let index_parameter = 0; index_parameter < args.length; index_parameter++) {\n          const arg = args[index_parameter];\n          if (typeof arg !== \"string\") {\n            throw new Error(\"Method «resolve_path» requires only strings as parameters (on index «\" + index_parameter + \"»)\");\n          }\n        }\n      }\n      let path_parts = [];\n      Format_path: {\n        const replace_last_slash_for_nothing = arg => this.remove_slash_end(arg);\n        path_parts = args.map(replace_last_slash_for_nothing);\n        if (!path_parts[0].startsWith(\"/\")) {\n          path_parts.unshift(this.current_directory.replace(/\\/$/g, \"\"));\n        }\n      }\n      let path_text = \"\";\n      Join_path: {\n        const replace_fist_slash_for_nothing = arg => arg.replace(/^\\//g, \"\");\n        for (let index_part = 0; index_part < path_parts.length; index_part++) {\n          const path_part = path_parts[index_part];\n          if (path_part.startsWith(\"/\")) {\n            path_text = path_part;\n          } else {\n            if (path_text !== \"/\") {\n              path_text += \"/\";\n            }\n            path_text += path_part.replace(replace_fist_slash_for_nothing);\n          }\n        }\n      }\n      Fix_slash_repetitions: {\n        path_text = this.remove_repeated_slahes(path_text);\n      }\n      Resolve_double_dots: {\n        const parts = path_text.split(\"/\");\n        const stack = [];\n        Iterating_parts:\n        for (const part of parts) {\n          if (part === \"\" || part === \".\") {\n            continue Iterating_parts;\n          } else if (part === \"..\") {\n            if (stack.length > 0) {\n              stack.pop();\n            }\n          } else {\n            stack.push(part);\n          }\n        }\n        path_text = \"/\" + stack.join(\"/\");\n      }\n      return path_text;\n    }\n    get_current_directory() {\n      this.trace(\"get_current_directory\", arguments);\n      return this.resolve_path(this.current_directory);\n    }\n    change_directory(node) {\n      this.trace(\"change_directory\", arguments);\n      const is_directory = this.exists(node);\n      if (!is_directory) {\n        throw new FilesystemError(\"Cannot «change_directory» because destination does not exist at: «\" + this.resolve_path(node) + \"»\");\n      }\n      this.current_directory = this.resolve_path(node);\n      return this.current_directory;\n    }\n    operate_on_node(node, callback, should_persist = true) {\n      this.trace(\"operate_on_node\", arguments);\n      const data = this.get_persisted_data();\n      const node_solved = this.resolve_path(node);\n      const node_parts = node_solved.split(\"/\").filter(p => p !== \"\");\n      const root = data.files;\n      const current_index = [\"data\"];\n      let pivot = root;\n      let output = undefined;\n      if (node_parts.length === 0) {\n        output = callback(data, \"files\", current_index);\n      } else {\n        for (let index_part = 0; index_part < node_parts.length; index_part++) {\n          const node_part = node_parts[index_part];\n          if (index_part === (node_parts.length - 1)) {\n            output = callback(pivot, node_part, current_index);\n          } else {\n            pivot = pivot[node_part];\n          }\n          current_index.push(node_part);\n        }\n      }\n      if (should_persist) {\n        this.set_persisted_data(data);\n      }\n      return output;\n    }\n    read_directory(node) {\n      this.trace(\"read_directory\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          throw new FilesystemError(\"Cannot «read_directory» because node does not exist at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"object\") {\n          throw new FilesystemError(\"Cannot «read_directory» because node is a file at: «\" + this.resolve_path(node) + \"»\");\n        }\n        return pivot[last_property];\n      });\n    }\n    read_file(node) {\n      this.trace(\"read_file\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          throw new FilesystemError(\"Cannot «read_file» because node does not exist at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"string\") {\n          throw new FilesystemError(\"Cannot «read_file» because node is a directory at: «\" + this.resolve_path(node) + \"»\");\n        }\n        return pivot[last_property];\n      });\n    }\n    make_directory(node) {\n      this.trace(\"make_directory\", arguments);\n      this.operate_on_node(node, (pivot, last_property, index) => {\n        if (last_property in pivot) {\n          throw new FilesystemError(\"Cannot «make_directory» because node already exists at: «\" + this.resolve_path(node) + \"»\");\n        }\n        pivot[last_property] = {};\n      });\n    }\n    write_file(node, contents) {\n      this.trace(\"write_file\", arguments);\n      this.operate_on_node(node, (pivot, last_property, index) => {\n        if (last_property in pivot) {\n          if (typeof pivot[last_property] !== \"string\") {\n            throw new FilesystemError(\"Cannot «write_file» because node is a directory at: «\" + this.resolve_path(node) + \"»\");\n          }\n        }\n        pivot[last_property] = contents;\n      });\n    }\n    exists(node) {\n      this.trace(\"exists\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          return false;\n        }\n        return true;\n      }, false);\n    }\n    is_file(node) {\n      this.trace(\"is_file\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          return false;\n        }\n        if (typeof pivot[last_property] !== \"string\") {\n          return false;\n        }\n        return true;\n      }, false);\n    }\n    is_directory(node) {\n      this.trace(\"is_directory\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          return false;\n        }\n        if (typeof pivot[last_property] !== \"object\") {\n          return false;\n        }\n        return true;\n      }, false);\n    }\n    delete_file(node) {\n      this.trace(\"delete_file\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (typeof pivot[last_property] === \"undefined\") {\n          throw new FilesystemError(\"Cannot «delete_file» because node does not exist at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"string\") {\n          throw new FilesystemError(\"Cannot «delete_file» because node is a directory at: «\" + this.resolve_path(node) + \"»\");\n        }\n        delete pivot[last_property];\n        return true;\n      }, true);\n    }\n    delete_directory(node) {\n      this.trace(\"delete_directory\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (typeof pivot[last_property] === \"undefined\") {\n          console.log(pivot);\n          console.log(last_property);\n          throw new FilesystemError(\"Cannot «delete_directory» because does not exists at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"object\") {\n          throw new FilesystemError(\"Cannot «delete_directory» because node is a file at: «\" + this.resolve_path(node) + \"»\");\n        }\n        delete pivot[last_property];\n        return true;\n      }, true);\n    }\n    rename(node, node2) {\n      this.trace(\"rename\", arguments);\n      const last_name = this.resolve_path(node2).split(\"/\").filter(p => p !== \"\").pop();\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (typeof pivot[last_property] === \"undefined\") {\n          throw new FilesystemError(\"Cannot «rename» because does not exists at: «\" + this.resolve_path(node) + \"»\");\n        }\n        pivot[last_name] = pivot[last_property];\n        pivot[last_property] = undefined;\n        delete pivot[last_property];\n        return true;\n      }, true);\n    }\n\n  }\n\n  const UFS_manager_for_idb = class extends UFS_manager_for_localstorage {\n\n    constructor(db_name = \"ufs_db\") {\n      super();\n      this.db_name = db_name;\n      this.db = null;\n      this.current_directory = \"/\";\n    }\n\n    trace(method, args = []) {\n      console.log(\"[ufs][idb-driver][\" + method + \"]\", Array.from(args).map(arg => typeof (arg) + \": \" + arg).join(\", \"));\n    }\n\n    init() {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.db_name, 1);\n        request.onupgradeneeded = (event) => {\n          let db = event.target.result;\n          if (!db.objectStoreNames.contains(\"ufs\")) {\n            let store = db.createObjectStore(\"ufs\", {\n              keyPath: \"id\",\n              autoIncrement: true,\n            });\n            store.createIndex(\"filepath\", \"filepath\", { unique: true });\n          }\n        };\n        request.onsuccess = (event) => {\n          this.db = event.target.result;\n          resolve();\n        };\n        request.onerror = (event) => reject(event.target.error);\n      });\n    }\n\n    _get_filename(somepath) {\n      return somepath.split(\"/\").filter(p => typeof (p) !== \"undefined\").pop();\n    }\n\n    isImmediateSubpathFrom(subpath, matchable) {\n      const matchablePos = matchable.length;\n      const coincidesParentPath = subpath.substr(0, matchablePos) === matchable;\n      if (!coincidesParentPath) return false;\n      const hasNoMoreSlashes = subpath.substr(matchablePos).indexOf(\"/\") === -1;\n      if (!hasNoMoreSlashes) return false;\n      return true;\n    }\n\n    read_directory(parentIdInput = \"/\") {\n      this.trace(\"read_directory\", arguments);\n      const parentId = this.resolve_path(parentIdInput);\n      return new Promise((resolve, reject) => {\n        The_previous_process: {\n          break The_previous_process;\n          const transaction = this.db.transaction(\"ufs\", \"readonly\");\n          const store = transaction.objectStore(\"ufs\");\n          const index = store.index(\"filepath\");\n          const request = index.getAll(parentId);\n          request.onsuccess = () => {\n            let result = {};\n            for (let item of request.result) {\n              result[item.name] = item.type === \"file\" ? \"...\" : {};\n            }\n            resolve(result);\n          };\n        }\n        const transaction = this.db.transaction(\"ufs\", 'readonly');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria\n        const results = [];\n        const matchableSubpath = (parentId === \"/\") ? parentId : (parentId + \"/\");\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            let isAccepted = false;\n            try {\n              isAccepted = cursor.value.filepath.startsWith(matchableSubpath);\n              isAccepted = isAccepted && this.isImmediateSubpathFrom(cursor.value.filepath, matchableSubpath);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «browsie.selectMany»\", error);\n            }\n            if (isAccepted) {\n              // Añade a la colección de salida\n              results.push(cursor.value);\n            }\n            cursor.continue(); // Avanza al siguiente registro\n          } else {\n            // Se formatean los resultados:\n            const formattedResults = {};\n            results.forEach(row => {\n              const rowName = this._get_filename(row.filepath);\n              formattedResults[rowName] = row.type === \"file\" ? \"...\" : {};\n            });\n            resolve(formattedResults);\n          }\n        };\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    read_file(nodeInput) {\n      this.trace(\"read_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => {\n          resolve(request.result ? request.result.content : null);\n        };\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    async write_file(nodeInput, contents) {\n      this.trace(\"write_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      const file = await this.$filepath(node);\n      return await new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readwrite\");\n        const store = transaction.objectStore(\"ufs\");\n        const filedata = { filepath: node, type: \"file\", content: contents };\n        if (file) {\n          filedata.id = file.id;\n        }\n        store.put(filedata);\n        transaction.oncomplete = () => resolve();\n        transaction.onerror = () => reject(transaction.error);\n      });\n    }\n\n    async make_directory(nodeInput) {\n      this.trace(\"make_directory\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return await new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readwrite\");\n        const store = transaction.objectStore(\"ufs\");\n        store.put({ filepath: node, type: \"directory\" });\n        transaction.oncomplete = () => resolve();\n        transaction.onerror = () => reject(transaction.error);\n      });\n    }\n\n    exists(nodeInput) {\n      this.trace(\"exists\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => resolve(!!request.result);\n        request.onerror = () => resolve(false);\n      });\n    }\n\n    is_file(nodeInput) {\n      this.trace(\"is_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => resolve(request.result ? request.result.type === \"file\" : false);\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    is_directory(nodeInput) {\n      this.trace(\"is_directory\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => resolve(request.result ? request.result.type === \"directory\" : false);\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    delete_file(nodeInput) {\n      this.trace(\"delete_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return this.$deleteMany(file => {\n        return (file.type === \"file\") && (file.filepath === node);\n      });\n    }\n\n    async delete_directory(nodeInput) {\n      this.trace(\"delete_directory\", arguments);\n      const node = this.resolve_path(nodeInput);\n      await this.$deleteMany(file => file.filepath.startsWith(node));\n      await this.$deleteMany(file => file.filepath === node);\n    }\n\n    $updateMany(filterCallback, expanderCallback) {\n      this.trace(\"$updateMany\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readwrite');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor();\n        let updatedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (cursor) {\n            const isAccepted = filterCallback(cursor.value, cursor);\n            if (isAccepted) {\n              const expanderItem = expanderCallback({ ...cursor.value }, cursor);\n              const updatedItem = { ...cursor.value, ...expanderItem };\n              const updateRequest = cursor.update(updatedItem);\n              updateRequest.onsuccess = () => {\n                updatedCount++;\n              };\n            }\n            cursor.continue();\n          } else {\n            return resolve(updatedCount);\n          }\n        };\n        request.onerror = () => reject(transaction.error);\n      });\n    }\n\n    $deleteMany(filterCallback) {\n      this.trace(\"$deleteMany\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readwrite');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor();\n        let deletedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (cursor) {\n            const isAccepted = filterCallback(cursor.value, cursor);\n            if (isAccepted) {\n              const deleteRequest = cursor.delete();\n              deleteRequest.onsuccess = () => {\n                deletedCount++;\n              };\n            }\n            cursor.continue();\n          } else {\n            return resolve(deletedCount);\n          }\n        };\n        request.onerror = () => reject(transaction.error);\n      });\n    }\n\n    rename(nodeInput, newName) {\n      this.trace(\"rename\", arguments);\n      const node = this.resolve_path(nodeInput);\n      const newNode = node.split(\"/\").slice(0, -1).concat(newName).join(\"/\") || \"/\";\n      const pathBegin = node.replace(/\\/$/g, \"\") + \"/\";\n      const newNodeBegin = newNode.replace(/\\/$/g, \"\") + \"/\";\n      console.log(\"Buscando nodos que empiecen por: «\" + pathBegin + \"»\");\n      const renameSubnodes = async () => {\n        const allSubnodes = await this.$selectMany(file => file.filepath.startsWith(pathBegin));\n        const allPromises = [];\n        for (let index = 0; index < allSubnodes.length; index++) {\n          const subnode = allSubnodes[index];\n          const newSubpath = subnode.filepath.replace(pathBegin, newNodeBegin);;\n          console.log(\"Reemplazando a:\", subnode.filepath, \"Por:\", newSubpath);\n          const subpromise = this.$update(subnode.id, { filepath: newSubpath });\n          allPromises.push(subpromise);\n        }\n        return await Promise.all(allPromises);\n      };\n      const renameNode = () => new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readwrite\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => {\n          if (!request.result) {\n            reject(new Error(\"Node not found\"));\n            return;\n          }\n          const data = request.result;\n          data.filepath = newNode;\n          store.put(data);\n          transaction.oncomplete = () => resolve();\n          transaction.onerror = () => reject(transaction.error);\n        };\n        request.onerror = () => reject(request.error);\n      });\n      return Promise.all([\n        renameNode().then(() => renameSubnodes()),\n      ]);\n    }\n\n    async $filepath(filepath) {\n      const selection = await this.$selectMany(file => file.filepath === filepath);\n      if (selection.length === 1) {\n        return selection[0];\n      } else if (selection.length > 1) {\n        return selection;\n      }\n      return null;\n    }\n\n    $selectMany(filterCallback) {\n      this.trace(\"$selectMany\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readonly');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria\n        const results = [];\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            let isAccepted = undefined;\n            try {\n              isAccepted = filterCallback(cursor.value);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «selectMany»\", error);\n            }\n            if (isAccepted) { // Aplica la función de filtro\n              results.push(cursor.value);\n            }\n            cursor.continue(); // Avanza al siguiente registro\n          } else {\n            resolve(results); // Se terminó el recorrido\n          }\n        };\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    $update(id, item) {\n      this.trace(\"$update\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readwrite');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request0 = objectStore.get(id);\n        request0.onsuccess = () => {\n          const originalState = request0.result;\n          if (!originalState) return reject(`No item found by id «${id}» on «$update»`);\n          const request = objectStore.put({ ...originalState, ...item, id });\n          request.onsuccess = () => resolve(request.result);\n          request.onerror = () => reject(request.error);\n        };\n        request0.onerror = () => reject(request0.error);\n      });\n    }\n\n  }\n\n  const api = {\n    node_driver: UFS_manager_for_node,\n    localstorage_driver: UFS_manager_for_localstorage,\n    idb_driver: UFS_manager_for_idb,\n    create(...args) {\n      const clazz = typeof global !== \"undefined\" ? UFS_manager_for_node : UFS_manager_for_localstorage;\n      return new clazz(...args);\n    },\n    driver(id) {\n      const driverId = id.toLowerCase() + \"_driver\";\n      if (!(driverId in api)) {\n        throw new Error(`Cannot find driver «${driverId}» on «UFS_manager.driver»`);\n      }\n      return {\n        create(...args) {\n          const clazz = api[driverId];\n          return new clazz(...args);\n        }\n      }\n    }\n  };\n\n  return api;\n",
              "$code.label": "UFS_manager class",
              "$output": "index.html"
            }
          ],
          "Lsw LswCycler API » LswCycler class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-lifecycle/lsw-lifecycle.js",
              "$location": {
                "start": {
                  "offset": 290,
                  "line": 14,
                  "column": 3
                },
                "end": {
                  "offset": 501,
                  "line": 24,
                  "column": 6
                }
              },
              "$section": "Lsw LswCycler API » LswCycler class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswCycler",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-lifecycle/lsw-lifecycle.js",
              "$location": {
                "start": {
                  "offset": 502,
                  "line": 25,
                  "column": 1
                },
                "end": {
                  "offset": 584,
                  "line": 26,
                  "column": 1
                }
              },
              "section": "Lsw LswCycler API » LswCycler class",
              "$code": "  const cycle = LswCycler.from({\n\n    steps: [\n      \"onStarted\",\n      \"onInitialize\",\n      \"onInitialized\",\n      \"onBoot\",\n      \"onBooted\",\n      \"onLoadModules\",\n      \"onModulesLoaded\",\n      \"onInstallModules\",\n      \"onModulesInstalled\",\n      \"onLoadSchema\",\n      \"onSchemaLoaded\",\n      \"onLoadDatabase\",\n      \"onDatabaseLoaded\",\n      \"onLoadApplication\",\n      \"onApplicationLoaded\",\n      \"onAllLoaded\",\n      \"onFinished\",\n    ],\n\n    hooks: TriggersClass.create(),\n\n    $trace: function(method, args) {\n      if(Vue.prototype.$trace) {\n        Vue.prototype.$trace(\"lsw-app-lifecycle.\" + method, args);\n      }\n    },\n\n    onStarted: function () {\n      this.$trace(\"onStarted\", []);\n      return this.hooks.emit(\"app:started\");\n    },\n\n    onInitialize: function () {\n      this.$trace(\"onInitialize\", []);\n      return this.hooks.emit(\"app:initialize\");\n    },\n\n    onInitialized: function () {\n      this.$trace(\"onInitialized\", []);\n      return this.hooks.emit(\"app:initialized\");\n    },\n\n    onBoot: function () {\n      this.$trace(\"onBoot\", []);\n      return this.hooks.emit(\"app:boot\");\n    },\n\n    onBooted: function () {\n      this.$trace(\"onBooted\", []);\n      return this.hooks.emit(\"app:booted\");\n    },\n\n    onLoadModules: function () {\n      this.$trace(\"onLoadModules\", []);\n      return this.hooks.emit(\"app:load_modules\");\n    },\n\n    onModulesLoaded: function () {\n      this.$trace(\"onModulesLoaded\", []);\n      return this.hooks.emit(\"app:modules_loaded\");\n    },\n    onInstallModules: function () {\n      this.$trace(\"onInstallModules\", []);\n      return this.hooks.emit(\"app:install_modules\");\n    },\n    onModulesInstalled: function () {\n      this.$trace(\"onModulesInstalled\", []);\n      return this.hooks.emit(\"app:modules_installed\");\n    },\n    onLoadSchema: async function () {\n      this.$trace(\"onLoadSchema\", []);\n      if (process.env.LSW_RESET_DATABASE) {\n        await LswDatabase.deleteDatabase(\"lsw_default_database\");\n      }\n      $lswSchema.loadSchemaByProxies(\"SchemaEntity\");\n      const databaseSchema = await $lswSchema.getDatabaseSchemaForLsw();\n      console.log(\"[*] Creating database from schema by proxies:\", Object.keys(databaseSchema).join(\", \"));\n      return await this.hooks.emit(\"app:load_schema\");\n    },\n    onSchemaLoaded: function () {\n      this.$trace(\"onSchemaLoaded\", []);\n      return this.hooks.emit(\"app:schema_loaded\");\n    },\n    onSeedDatabase: async function () {\n      this.$trace(\"onSeedDatabase\", []);\n      Fill_with_your_own_requirements: {\n        // @TOFILLIFNEEDED:\n      }\n      return await this.hooks.emit(\"app:seed_database\");\n    },\n    onDatabaseSeeded: async function () {\n      this.$trace(\"onDatabaseSeeded\", []);\n      Fill_with_your_own_requirements: {\n        // @TOFILLIFNEEDED:\n      }\n      return await this.hooks.emit(\"app:database_seeded\");\n    },\n    onLoadDatabase: async function () {\n      this.$trace(\"onLoadDatabase\", []);\n      Load_database_connection: {\n        Vue.prototype.$lsw.database = await LswDatabase.open(\"lsw_default_database\");\n        Vue.prototype.$lsw.database.setInnerSchema($lswSchema);\n      }\n      if(process.env.LSW_RESET_DATABASE) {\n        await this.onSeedDatabase();\n        await this.onDatabaseSeeded();\n      }\n      return await this.hooks.emit(\"app:load_database\");\n    },\n    onDatabaseLoaded: function () {\n      this.$trace(\"onDatabaseLoaded\", []);\n      return this.hooks.emit(\"app:database_loaded\");\n    },\n    onLoadApplication: function () {\n      this.$trace(\"onLoadApplication\", []);\n      return this.hooks.emit(\"app:load_application\");\n    },\n    onApplicationLoaded: function () {\n      this.$trace(\"onApplicationLoaded\", []);\n      return this.hooks.emit(\"app:application_loaded\");\n    },\n\n    onAllLoaded: function () {\n      this.$trace(\"onAllLoaded\", []);\n      return this.hooks.emit(\"app:all_loaded\");\n    },\n\n    onFinished: function () {\n      this.$trace(\"onFinished\", []);\n      return this.hooks.emit(\"app:finished\");\n    },\n\n    loadModule: function (moduleId) {\n      this.$trace(\"loadModule\", []);\n      return Vue.prototype.$lsw.importer.scriptAsync(`modules/${moduleId}/load.js`);\n    },\n\n    loadSubmodule: function (moduleId, subpath) {\n      this.$trace(\"loadSubmodule\", []);\n      return Vue.prototype.$lsw.importer.scriptAsync(`modules/${moduleId}/${subpath}`);\n    },\n\n    start: function () {\n      this.$trace(\"start\", []);\n      return this.run(this.steps);\n    },\n\n  }, \"*\");\n",
              "$code.label": "LswCycler class",
              "$output": "index.html"
            }
          ],
          "Superlogger API » Superlogger class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-logger/superlogger.unbundled.js",
              "$location": {
                "start": {
                  "offset": 377,
                  "line": 17,
                  "column": 3
                },
                "end": {
                  "offset": 590,
                  "line": 27,
                  "column": 6
                }
              },
              "$section": "Superlogger API » Superlogger class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "Superlogger",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-logger/superlogger.unbundled.js",
              "$location": {
                "start": {
                  "offset": 591,
                  "line": 28,
                  "column": 1
                },
                "end": {
                  "offset": 676,
                  "line": 29,
                  "column": 1
                }
              },
              "$section": "Superlogger API » Superlogger class",
              "$code": "  const Superlogger = class {\n\n    static create(id, options) {\n      return new this(id, options);\n    }\n\n    static levels = {\n      trace: 4,\n      debug: 3,\n      log: 2,\n      warn: 1,\n      error: 0,\n    };\n\n    static defaultOptions = {\n      active: true,\n      level: \"trace\"\n    };\n\n    static loggers = {};\n\n    static alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\n    static generateRandomString(len /* istanbul ignore next */  = 5) {\n      let out = \"\";\n      while(out.length < len) {\n        out += this.alphabet[Math.floor(Math.random() * this.alphabet.length - 1)];\n      }\n      return out;\n    }\n\n    constructor(idInput = false, options = {}) {\n      const id = idInput || this.constructor.generateRandomString(10);\n      if (typeof id !== \"string\") {\n        throw new Error(\"Required parameter «id» to be a string on «Superlogger.constructor»\");\n      }\n      if (id in this.constructor.loggers) {\n        throw new Error(\"Required parameter «id» to be a unique string on «Superlogger.constructor»\");\n      }\n      if (typeof options !== \"object\") {\n        throw new Error(\"Required parameter «options» to be an object on «Superlogger.constructor»\");\n      }\n      this.$id = id;\n      this.$options = Object.assign({}, this.constructor.defaultOptions, options);\n      this.$source = undefined;\n      this.$events = {};\n      this.$callbacks = {\n        before: undefined,\n        after: undefined,\n      };\n      this.resetEvents();\n      this.resetCallbacks();\n      this.constructor.loggers[id] = this;\n    }\n\n    activate() {\n      this.$options.active = true;\n    }\n\n    deactivate() {\n      this.$options.active = false;\n    }\n\n    setSource(source) {\n      this.source = source;\n    }\n\n    setLevel(level) {\n      if (!(level in this.constructor.levels)) {\n        throw new Error(\"Required parameter «level» to be a recognized level on «Superlogger.setLevel»\");\n      }\n      this.$options.level = this.constructor.levels[level];\n    }\n\n    setEvent(id, callback) {\n      this.$events[id] = callback;\n    }\n\n    resetEvents() {\n      this.$events = {\n        trace: undefined,\n        debug: undefined,\n        log: undefined,\n        warn: undefined,\n        error: undefined,\n      };\n    }\n\n    setBefore(callback) {\n      this.$callbacks.before = callback;\n    }\n\n    setAfter(callback) {\n      this.$callbacks.after = callback;\n    }\n\n    resetCallbacks() {\n      this.$callbacks = {\n        after: undefined,\n        before: undefined,\n      };\n    }\n\n    replacerFactory() {\n      const visited = new WeakMap();\n      return (key, value) => {\n        if (typeof value === \"function\") {\n          return \"[Function] \" + value.toString();\n        }\n        if (typeof value === \"object\" && value !== null) {\n          if (visited.has(value)) {\n            return \"[Circular]\";\n          }\n          visited.set(value, true);\n        } else /* istanbul ignore else */ {}\n        return value;\n      }\n    }\n\n    stringifyForDebugging(obj) {\n      return JSON.stringify(obj, this.replacerFactory(), 2);\n    }\n\n    $emit(event, args) {\n      if(!(event in this.$events)) {\n        return \"void::event not defined\";\n      }\n      const callback = this.$events[event];\n      if(typeof callback === \"undefined\") {\n        return \"void::callback not defined\";\n      }\n      return callback(this, args);\n    }\n\n    $log(levelId, elements, methodId = false) {\n      if(!(levelId in this.constructor.levels)) {\n        throw new Error(\"Required parameter «levelId» to be an identified level on «Superlogger.$log»\");\n      }\n      const level = this.constructor.levels[levelId];\n      if (!this.$options.active) {\n        return \"void::currently active=false state\";\n      }\n      if (this.$options.level < level) {\n        return \"void::level of tracing out of bounds\";\n      }\n      let message = `[${this.$id}][${levelId}]`;\n      if (methodId !== false) {\n        message += `[${methodId}]`;\n      }\n      for (let index = 0; index < elements.length; index++) {\n        const element = elements[index];\n        const stringification = typeof element === \"string\" ? element : this.stringifyForDebugging(element);\n        message += \" \" + stringification;\n      }\n      Event_triggering: {\n        if(typeof this.$callbacks.before !== \"undefined\") {\n          this.$callbacks.before(message, this, levelId, elements, methodId);\n        }\n        console.log(message);\n        if(typeof this.$callbacks.after !== \"undefined\") {\n          this.$callbacks.after(message, this, levelId, elements, methodId);\n        }\n        this.$emit(levelId, {elements, methodId});\n      }\n    }\n\n    trace(methodId, ...data) {\n      return this.$log(\"trace\", data, methodId);\n    }\n\n    debug(...data) {\n      return this.$log(\"debug\", data);\n    }\n\n    log(...data) {\n      return this.$log(\"log\", data);\n    }\n\n    warn(...data) {\n      return this.$log(\"warn\", data);\n    }\n\n    error(...data) {\n      return this.$log(\"error\", data);\n    }\n\n  };\n",
              "$code.label": "Superlogger class",
              "$output": "index.html"
            }
          ],
          "LswProxifier API » LswProxifier class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxifier/proxifier.unbundled.js",
              "$location": {
                "start": {
                  "offset": 290,
                  "line": 14,
                  "column": 3
                },
                "end": {
                  "offset": 506,
                  "line": 24,
                  "column": 6
                }
              },
              "$section": "LswProxifier API » LswProxifier class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswProxifier",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxifier/proxifier.unbundled.js",
              "$location": {
                "start": {
                  "offset": 507,
                  "line": 25,
                  "column": 1
                },
                "end": {
                  "offset": 595,
                  "line": 26,
                  "column": 1
                }
              },
              "$section": "LswProxifier API » LswProxifier class",
              "$code": "  class BaseClass {\n    initialize(...args) {\n      const promise = this.onInitialize(...args);\n      if (promise instanceof Promise) {\n        return promise.then(output => {\n          return this;\n        });\n      }\n      return this;\n    }\n    onInitialize() {\n      return this;\n    }\n  }\n\n  const AbstractProxy = class {\n    constructor(value) {\n      this.value = value;\n    }\n  }\n  class AbstractVirtualizer extends AbstractProxy {}\n  class AbstractSchemaEntity extends AbstractProxy {\n    static toObject() {\n      return {\n        entityId: this.getEntityId(),\n        name: this.getName(),\n        version: this.getVersion(),\n        properties: this.getProperties(),\n        externalProperties: this.getExternalProperties(),\n        methods: this.getMethods(),\n        virtualizerId: this.getVirtualizerId(),\n        formSettings: this.getFormSettings(),\n        extraAttributes: this.getExtraAttributes(),\n      };\n    }\n    static getEntityId() {\n      throw new Error(`Required method «getEntityId» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getEntityId»`);\n    }\n    static getName() {\n      throw new Error(`Required method «getName» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getName»`);\n    }\n    static getVersion() {\n      throw new Error(`Required method «getVersion» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getVersion»`);\n    }\n    static getProperties() {\n      throw new Error(`Required method «getProperties» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getProperties»`);\n    }\n    static getExternalProperties() {\n      return {};\n    }\n    static getMethods() {\n      throw new Error(`Required method «getMethods» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getMethods»`);\n    }\n    static getVirtualizerId() {\n      throw new Error(`Required method «getVirtualizerId» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getVirtualizerId»`);\n    }\n    static getFormSettings() {\n      throw new Error(`Required method «getFormSettings» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getFormSettings»`);\n    }\n    static getExtraAttributes() {\n      throw new Error(`Required method «getExtraAttributes» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getExtraAttributes»`);\n    }\n  }\n  class AbstractItem { }\n  class AbstractList {\n    constructor(value) {\n      this.value = Array.isArray(value) ? value : [];\n    }\n    forEach(callback) {\n      this.value.forEach(callback);\n      return this;\n    }\n    filter(callback) {\n      this.value = this.value.filter(callback);\n      return this;\n    }\n    map(callback) {\n      this.value = this.value.map(callback);\n      return this;\n    }\n    reduce(callback, initialValue = []) {\n      this.value = this.value.reduce(callback, initialValue);\n      return this;\n    }\n    modify(callback) {\n      this.value = callback(this.value);\n      return this;\n    }\n    concat(...lists) {\n      this.value = this.value.concat(...lists);\n      return this;\n    }\n    onlyProp(prop) {\n      this.value = this.value.map(it => it[prop]);\n      return this;\n    }\n    onlyProps(props) {\n      this.value = this.value.map(it => {\n        const out = {};\n        props.forEach(prop => {\n          out[prop] = it[prop];\n        });\n        return out;\n      });\n      return this;\n    }\n    removeProp(prop) {\n      return this.removeProps([prop]);\n    }\n    removeProps(props) {\n      this.value = this.value.map(it => {\n        const out = {};\n        const keys = Object.keys(it).filter(prop => {\n          return props.indexOf(prop) === -1;\n        });\n        keys.forEach(key => {\n          out[key] = it[key];\n        });\n        return out;\n      });\n      return this;\n    }\n    deduplicate() {\n      const out = [];\n      this.value.forEach(it => {\n        if (out.indexOf(it) === -1) {\n          out.push(it);\n        }\n      });\n      this.value = out;\n      return this;\n    }\n    sort(callback) {\n      this.value = this.value.sort(callback);\n      return this;\n    }\n  };\n\n  class LswProxifier {\n    static create(...args) {\n      return new this(...args);\n    }\n    AbstractProxy = AbstractProxy;\n    AbstractSchemaEntity = AbstractSchemaEntity;\n    AbstractVirtualizer = AbstractVirtualizer;\n    AbstractItem = AbstractItem;\n    AbstractList = AbstractList;\n    constructor(mainInjection = {}) {\n      this.$definitions = {};\n      this.$mainInjection = mainInjection;\n      this.$splitterChar = \"@\";\n    }\n    define(name, classesDef) {\n      if(!(name in this.$definitions)) {\n        this.$definitions[name] = {};\n      }\n      if(typeof classesDef !== \"object\") {\n        throw new Error(`Required parameter «classesDef» to be a class on «LswProxifier.define»`)\n      }\n      const classesIds = Object.keys(classesDef);\n      for(let index=0; index<classesIds.length; index++) {\n        const classId = classesIds[index];\n        const classDef = classesDef[classId];\n        if(typeof classDef !== \"function\") {\n          throw new Error(`Required proxy class «${classId}» to be a class on «LswProxifier.define»`)\n        }\n      }\n      Object.assign(this.$definitions[name], classesDef);\n    }\n    find(selector) {\n      const [name, aspectId = false] = selector.split(this.$splitterChar);\n      if(!(name in this.$definitions)) {\n        throw new Error(`Could not find proxy classes from name «${name}» on «LswProxifier.find»`);\n      }\n      if(!aspectId) {\n        return this.$definitions[name];\n      }\n      if(!(aspectId in this.$definitions[name])) {\n        throw new Error(`Could not find proxy aspect «${aspectId}» from class «${name}» on «LswProxifier.find»`);\n      }\n      return this.$definitions[name][aspectId];\n    }\n    getFactory() {\n      return this.proxify.bind(this);\n    }\n    proxify(obj) {\n      return {\n        as: (typeSelector = \"\", proxyExtraArguments = []) => {\n          if(typeof typeSelector !== \"string\") {\n            throw new Error(`Required parameter «typeSelector» to be a string on «proxify(@).as(@)»`);\n          }\n          const [definitionId, aspectId = \"Item\"] = typeSelector.split(this.$splitterChar);\n          if(!(definitionId in this.$definitions)) {\n            throw new Error(`Required parameter «definitionId» [«${definitionId}»] to exist in «proxifier.$definitions» but it does not on «proxify(@).as(@)`);\n          }\n          if(!(aspectId in this.$definitions[definitionId])) {\n            throw new Error(`Required parameter «aspectId» [«${aspectId}»] to exist in «proxifier.$definitions[${JSON.stringify(definitionId)}]» but it does not on «proxify(@).as(@)`);\n          }\n          const proxyClass = this.$definitions[definitionId][aspectId];\n          const proxyInstance = new proxyClass(obj, ...proxyExtraArguments);\n          if(typeof this.$mainInjection === \"function\") {\n            this.$mainInjection(proxyInstance, proxyClass);\n          } else if(typeof this.$mainInjection === \"object\") {\n            Object.assign(proxyInstance, this.$mainInjection);\n          }\n          return proxyInstance;\n        }\n      };\n    }\n  };\n\n  LswProxifier.default = LswProxifier;\n\n  globalThis.$proxifier = LswProxifier.create();\n",
              "$code.label": "LswProxifier class",
              "$output": "index.html"
            }
          ],
          "LswRandomizer API » LswRandomizer class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-randomizer/lsw-randomizer.js",
              "$location": {
                "start": {
                  "offset": 293,
                  "line": 15,
                  "column": 3
                },
                "end": {
                  "offset": 512,
                  "line": 25,
                  "column": 6
                }
              },
              "$section": "LswRandomizer API » LswRandomizer class",
              "type": "class",
              "extends": "Object",
              "vendor": "lsw",
              "namespace": "LswRandomizer",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-randomizer/lsw-randomizer.js",
              "$location": {
                "start": {
                  "offset": 513,
                  "line": 26,
                  "column": 1
                },
                "end": {
                  "offset": 604,
                  "line": 27,
                  "column": 1
                }
              },
              "$section": "LswRandomizer API » LswRandomizer class",
              "$code": "  const LswRandomizer = class {\n\n    static $defaultAlphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\n    static getRandomIntegerBetween(start = 0, end = 100) {\n      return Math.round(Math.random() * (end - start)) + start;\n    }\n\n    static getRandomString(len, alphabet = this.$defaultAlphabet) {\n      let out = \"\";\n      while (out.length < len) {\n        out += alphabet[Math.floor(Math.random() * alphabet.length)];\n      }\n      return out;\n    }\n\n    static getRandomItem(list) {\n      return list[Math.floor(Math.random() * list.length)];\n    }\n\n    static getRandomObject(totalProps = [0, 10], listOf = false) {\n      let randomProps = totalProps;\n      if (Array.isArray(totalProps)) {\n        randomProps = this.getRandomIntegerBetween(...totalProps);\n      }\n      const buildRandomObject = () => {\n        const randomObject = {};\n        while (Object.keys(randomObject).length < randomProps) {\n          const key = this.getRandomString(5);\n          const value = this.getRandomString(10);\n          randomObject[key] = value;\n        }\n        return randomObject;\n      };\n      if (listOf === false) {\n        return buildRandomObject();\n      }\n      const randomList = [];\n      for(let index=0; index<listOf; index++) {\n        const randomObject = buildRandomObject();\n        randomList.push(randomObject);\n      }\n      return randomList;\n    }\n\n  }\n\n  return LswRandomizer;\n",
              "$code.label": "LswRandomizer class",
              "$output": "index.html"
            }
          ],
          "LswReloader API » LswReloadable injection": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-reloader/reloadable.js",
              "$location": {
                "start": {
                  "offset": 0,
                  "line": 1,
                  "column": 1
                },
                "end": {
                  "offset": 95,
                  "line": 2,
                  "column": 1
                }
              },
              "$section": "LswReloader API » LswReloadable injection",
              "$code": "const serverUrl = 'http://127.0.0.1';\nconst serverPort = 3000;\n\nif (process?.env?.NODE_ENV === \"test\") {\n  const socket = io(`${serverUrl}:${serverPort}`);\n  socket.on('refrescar', () => {\n    console.log('Recibida la señal de refrescar desde el servidor');\n    location.reload();\n  });\n}\n",
              "$code.label": "LswReloadable injection",
              "$output": "index.html"
            }
          ],
          "ControlledFunction API » ControlledFunction classes": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-returner/controlled-function.js",
              "$location": {
                "start": {
                  "offset": 300,
                  "line": 14,
                  "column": 1
                },
                "end": {
                  "offset": 409,
                  "line": 15,
                  "column": 1
                }
              },
              "$section": "ControlledFunction API » ControlledFunction classes",
              "$code": "\n  const ReturnControl = class {\n    constructor(value) {\n      this.value = value;\n    }\n  };\n\n  const MutateControl = class {\n    constructor(mutator = {}) {\n      this.mutator = mutator;\n    }\n  };\n\n  const ReturnController = class {\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor() {\n      this.results = new Map();\n      this.functions = new Map();\n      this.middlewares = [];\n      this.properties = new Map();\n    }\n\n    prehook(middleware) {\n      this.middlewares.unshift(middleware);\n      return this;\n    }\n\n    hook(middleware) {\n      this.middlewares.push(middleware);\n      return this;\n    }\n\n    unhook(middleware) {\n      this.middlewares = this.middlewares.filter(m => m !== middleware);\n      return this;\n    }\n\n    prop(properties = {}) {\n      Object.assign(this.properties, properties);\n      return this;\n    }\n\n    hasProp(id) {\n      return this.properties.has(id);\n    }\n\n    getProp(id, defaultValue = undefined) {\n      if (!this.properties.has(id)) {\n        return defaultValue;\n      }\n      return this.properties.get(id);\n    }\n\n    setProp(id, value) {\n      this.properties.set(id, value);\n      return this;\n    }\n\n    load(functions) {\n      this.functions = new Map(Object.entries(functions));\n      return this;\n    }\n\n    solved(name) {\n      return this.results.get(name);\n    }\n\n    pipe(outputName, functionNames, parameters = []) {\n      for (let fnName of functionNames) {\n        const fnCallback = this.functions.get(fnName);\n        if (fnCallback) {\n          const result = fnCallback(...parameters);\n          if (this.processResult(result, outputName)) {\n            return this.solved(outputName);\n          }\n        }\n        for (const middleware of this.middlewares) {\n          const result = middleware(this);\n          if (this.processResult(result, outputName)) {\n            return this.solved(outputName);\n          }\n        }\n      }\n      return null;\n    }\n\n    processResult(result, outputName) {\n      if (result instanceof ReturnControl) {\n        this.results.set(outputName, result.value);\n        return true;\n      } else if (result instanceof MutateControl) {\n        const mutator = result.mutator;\n        if (typeof mutator === \"function\") {\n          const mutatorResult = mutator(this);\n          if (typeof mutatorResult === \"object\") {\n            Object.assign(this.properties, mutatorResult);\n          } else if (mutatorResult !== undefined) {\n            throw new Error(\n              `MutateControl's function mutator must return an object or undefined, found: ${typeof mutatorResult}`\n            );\n          }\n        } else if (typeof mutator === \"object\") {\n          Object.assign(this, mutator);\n        } else {\n          throw new Error(\n            `MutateControl's mutator must be a function or object, found: ${typeof mutator}`\n          );\n        }\n      }\n      return false;\n    }\n\n    reset() {\n      this.results.clear();\n      this.properties.clear();\n      return this;\n    }\n  };\n\n  const ControlledFunction = {\n    MutateControl,\n    ReturnControl,\n    ReturnController,\n  };\n\n  ControlledFunction.default = ControlledFunction;\n\n  return ControlledFunction;\n",
              "$code.label": "ControlledFunction global",
              "$output": "index.html"
            }
          ],
          "Lsw Schema API » LswSchema class": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-schema/lsw-schema.js",
              "$location": {
                "start": {
                  "offset": 627,
                  "line": 30,
                  "column": 3
                },
                "end": {
                  "offset": 807,
                  "line": 38,
                  "column": 6
                }
              },
              "$section": "Lsw Schema API » LswSchema class",
              "type": "Class",
              "vendor": "lsw",
              "namespace": "LswSchema",
              "source code": "La clase está definida así:\n",
              "$output": "index.html"
            },
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-schema/lsw-schema.js",
              "$location": {
                "start": {
                  "offset": 808,
                  "line": 39,
                  "column": 1
                },
                "end": {
                  "offset": 887,
                  "line": 40,
                  "column": 1
                }
              },
              "section": "Lsw Schema API » LswSchema class",
              "$code": "  const LswSchema = class {\n\n    $trace(methodId, argsList) {\n      if(this.$options && this.$options.trace) {\n        console.log(\"[trace][lsw-schema][\" + methodId + \"] \" + argsList.length);\n      }\n    }\n\n    static Signature = LswSchemaSignature;\n\n    static createSignature(creatorCallback, creatorParameters, creatorScope) {\n      return this.Signature.create(creatorCallback, creatorParameters, creatorScope);\n    }\n\n    onValidateSchema(schema) {\n      this.$trace(\"onValidateSchema\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onValidateTable(id, definition, schema) {\n      this.$trace(\"onValidateTable\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onValidateColumn(id, definition, tableId, schema) {\n      this.$trace(\"onValidateColumn\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onFusionateSchema(schema) {\n      this.$trace(\"onFusionateSchema\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onFusionateTable(table, tableId, schema) {\n      this.$trace(\"onFusionateTable\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onFusionateColumn(column, columnId, tableId, schema) {\n      this.$trace(\"onFusionateColumn\", arguments);\n      // @OVERRIDABLE\n    }\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor(options = {}) {\n      this.$cache = {\n        schemaForLsw: null\n      };\n      this.$schema = {\n        hasTables: {\n\n        }\n      };\n      this.$options = options;\n    }\n    \n    getDatabaseSchemaForLsw(refresh = false) {\n      this.$trace(\"getDatabaseSchemaForLsw\", arguments);\n      if(refresh) {\n        this.$cache.schemaForLsw = null;\n      }\n      if(this.$cache.schemaForLsw) {\n        return this.$cache.schemaForLsw;\n      }\n      const schemaForLsw = {};\n      for(let tableId in this.$schema.hasTables) {\n        const tableData = this.$schema.hasTables[tableId];\n        let tableSchema = [];\n        for(let columnId in tableData.hasColumns) {\n          const columnData = tableData.hasColumns[columnId];\n          const prefix = columnData.isUnique ? \"!\" : \"\";\n          tableSchema.push(prefix + columnId);\n        }\n        schemaForLsw[tableId] = tableSchema;\n      }\n      this.$cache.schemaForLsw = schemaForLsw;\n      return schemaForLsw;\n    }\n\n    loadSchemaByProxies(aspectId = \"SchemaEntity\") {\n      this.$trace(\"loadSchemaByProxies\", arguments);\n      const schema = this.getSchemaByProxies(aspectId);\n      return this.registerSchema(schema);\n    }\n\n    getSchemaByProxies(aspectId = \"SchemaEntity\") {\n      this.$trace(\"getSchemaByProxies\", arguments);\n      const allSchemaEntities = Object.values($proxifier.$definitions).filter(d => d[aspectId]).map(d => d[aspectId]);\n      const schemaTemp = new LswSchema();\n      for(let index=0; index<allSchemaEntities.length; index++) {\n        const SchemaEntityClass = allSchemaEntities[index];\n        const lswDatabaseSchema = this.adaptSchemaEntityToDatabaseSchema(SchemaEntityClass);\n        schemaTemp.registerSchema(lswDatabaseSchema);\n      }\n      return schemaTemp.$schema;\n    }\n\n    adaptSchemaEntityToDatabaseSchema(SchemaEntityClass) {\n      this.$trace(\"adaptSchemaEntityToDatabaseSchema\", arguments);\n      const schema = { hasTables: {} };\n      const data = SchemaEntityClass.toObject();\n      schema.hasTables[data.name] = {\n        ...data,\n        hasEntityId: SchemaEntityClass.getEntityId(),\n        hasColumns: data.properties,\n        hasExtraAttributes: data.extraAttributes,\n      };\n      return schema;\n    }\n\n    registerSchema(partialSchema = {}) {\n      this.$trace(\"registerSchema\", arguments);\n      if (typeof partialSchema !== \"object\") {\n        throw new Error(\"Required parameter «partialSchema» to be an object on «LswSchema.registerSchema»\");\n      }\n      this.$validateSchema(partialSchema);\n      this.$fusionateSchema(partialSchema);\n      return this;\n    }\n\n    $validateSchema(schema) {\n      this.$trace(\"$validateSchema\", arguments);\n      Native: {\n        this.$validateSchemaNative(schema);\n      }\n      Core_process: {\n        if (\"hasTables\" in schema) {\n          const tableIds = Object.keys(schema.hasTables);\n          Iterating_tables:\n          for (let indexTable = 0; indexTable < tableIds.length; indexTable++) {\n            const tableId = tableIds[indexTable];\n            const table = schema.hasTables[tableId];\n            this.$validateTableNative(table, tableId, schema);\n            if (!(\"hasColumns\" in table)) {\n              continue Iterating_tables;\n            }\n            const columnIds = Object.keys(table.hasColumns);\n            Iterating_columns:\n            for (let indexColumn = 0; indexColumn < columnIds.length; indexColumn++) {\n              const columnId = columnIds[indexColumn];\n              const column = table.hasColumns[columnId];\n              this.$validateColumnNative(column, columnId, tableId, schema);\n            }\n          }\n        }\n      }\n      User: {\n        this.onValidateSchema(schema);\n      }\n    }\n\n    $fusionateSchema(partialSchema) {\n      this.$trace(\"$fusionateSchema\", arguments);\n      const tableIds = Object.keys(partialSchema?.hasTables || {});\n      Debug_purposes: {\n        const columnIds = tableIds.map(tableId => Object.keys(partialSchema.hasTables[tableId].hasColumns || {}).map(columnId => [tableId, columnId].join(\".\")));\n        const tablesMessage = tableIds.length === 0 ? \"No tables to fusionate\" : \"Tables to fusionate:\\n - \" + tableIds.join(\"\\n - \");\n        const columnsMessage = columnIds.length === 0 ? \"No columns to fusionate\" : \"Columns to fusionate:\\n - \" + columnIds.join(\"\\n - \");\n        this.$trace(`[*] ${tablesMessage}`, []);\n        this.$trace(`[*] ${columnsMessage}`, []);\n      }\n      this.$fusionateSchemaNative(partialSchema);\n      Iterating_tables:\n      for (let indexTable = 0; indexTable < tableIds.length; indexTable++) {\n        const tableId = tableIds[indexTable];\n        const tableInfo = partialSchema.hasTables[tableId];\n        this.$fusionateTableNative(tableInfo, tableId, partialSchema);\n        const columnIds = Object.keys(tableInfo.columns || {});\n        Iterating_columns:\n        for (let indexColumn = 0; indexColumn < columnIds.length; indexColumn++) {\n          const columnId = columnIds[indexColumn];\n          const columnInfo = tableInfo.columns[columnId];\n          this.$fusionateColumnNative(columnInfo, columnId, tableId, partialSchema);\n        }\n      }\n    }\n\n    $validateSchemaNative(schema) {\n      this.$trace(\"$validateSchemaNative\", arguments);\n      Native: {\n        const ensureSchema = $ensure(schema).type(\"object\").to.have.key(\"hasTables\");\n        ensureSchema.its(\"hasTables\").type(\"object\");\n      }\n      User: {\n        this.onValidateSchema(schema);\n      }\n    }\n\n    $validateTableNative(definition, id, schema) {\n      this.$trace(\"$validateTableNative\", arguments);\n      Native: {\n        const ensureTable = $ensure(definition).type(\"object\").to.have.key(\"hasColumns\");\n        const ensureHasColumns = ensureTable.its(\"hasColumns\").type(\"object\");\n        const columnIds = Object.keys(ensureHasColumns.$subject);\n        for(let index=0; index<columnIds.length; index++) {\n          const columnId = columnIds[index];\n          const ensureColumn = ensureHasColumns.its(columnId).type(\"object\");\n          ensureColumn.its(\"isType\").type(\"string\");\n          ensureColumn.its(\"isUnique\").type([\"boolean\", \"undefined\"]);\n          ensureColumn.its(\"refersTo\").type([\"object\", \"undefined\", \"boolean\"]);\n          if(typeof ensureColumn.$subject.refersTo === \"object\") {\n            const ensureRefersTo = ensureColumn.its(\"refersTo\").type(\"object\");\n            ensureRefersTo.to.have.keys([\"entity\", \"property\"]);\n            ensureRefersTo.its(\"entity\").type(\"string\");\n            ensureRefersTo.its(\"property\").type(\"string\");\n          }\n          ensureColumn.its(\"isFormType\").type(\"string\");\n          ensureColumn.its(\"hasValidator\").type([\"string\", \"boolean\", \"function\", \"undefined\"]);\n          ensureColumn.its(\"hasFormatter\").type([\"string\", \"boolean\", \"function\", \"undefined\"]);\n          ensureColumn.its(\"hasLabel\").type([\"string\", \"boolean\", \"undefined\"]);\n          ensureColumn.its(\"hasDescription\").type([\"string\", \"boolean\", \"undefined\"]);\n          ensureColumn.its(\"hasPlaceholder\").type([\"string\", \"boolean\", \"undefined\"]);\n        }\n      }\n      User: {\n        this.onValidateTable(id, definition, schema);\n      }\n    }\n\n    $validateColumnNative(id, definition, tableId, schema) {\n      this.$trace(\"$validateColumnNative\", arguments);\n      Native: {\n        // !@OK: the validation is already made on the $validateTableNative\n      }\n      User: {\n        this.onValidateColumn(id, definition, tableId, schema);\n      }\n    }\n\n    $fusionateSchemaNative(partialSchema) {\n      this.$trace(\"$fusionateSchemaNative\", arguments);\n      Native_fusion: {\n        \n      }\n      User_fusion: {\n        this.onFusionateSchema(partialSchema);\n      }\n    }\n\n    $fusionateTableNative(tableInfo, tableId, partialSchema) {\n      this.$trace(\"$fusionateTableNative\", arguments);\n      Native_fusion: {\n        const isKnown = tableId in this.$schema.hasTables;\n        if(!isKnown) {\n          this.$schema.hasTables[tableId] = tableInfo;\n        } else {\n          throw new Error(`Schema cannot fusionate table «${tableId}» to schema for second time on «$fusionateTableNative»`);\n        }\n      }\n      User_fusion: {\n        this.onFusionateTable(tableInfo, tableId, partialSchema);\n      }\n    }\n\n    $fusionateColumnNative(columnInfo, columnId, tableId, partialSchema) {\n      this.$trace(\"$fusionateColumnNative\", arguments);\n      Native_fusion: {\n        const isKnown = columnId in this.$schema.hasTables[tableId].hasColumns;\n        if(!isKnown) {\n          this.$schema.hasTables[tableId].hasColumns[columnId] = columnInfo;\n        } else {\n          throw new Error(`Schema cannot fusionate column «${tableId}.${columnId}» to schema for second time on «$fusionateTableNative»`);\n        }\n      }\n      User_fusion: {\n        this.onFusionateColumn(columnInfo, columnId, tableId, partialSchema);\n      }\n    }\n\n  };\n  \n  // Last global injection for a unique main instance:\n  window.$lswSchema = LswSchema.create();\n",
              "$code.label": "LswSchema class",
              "$output": "index.html"
            }
          ],
          "Lsw Utils API » Lsw Utils global": [
            {
              "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-utils/lsw-utils.js",
              "$location": {
                "start": {
                  "offset": 280,
                  "line": 14,
                  "column": 1
                },
                "end": {
                  "offset": 352,
                  "line": 15,
                  "column": 1
                }
              },
              "section": "Lsw Utils API » Lsw Utils global",
              "$code": "  const LswUtils = {};\n\n  LswUtils.hello = () => console.log(\"Hello!\");\n\n  ///////////////////////////////////////////////////////\n  // API de Excel: usa SheetJS\n  Object.assign(LswUtils, {\n    readFileAsArrayBuffer(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = event => resolve(event.target.result);\n        reader.onerror = error => reject(error);\n        reader.readAsArrayBuffer(file);\n      });\n    },\n    readFileAsText(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = event => resolve(event.target.result);\n        reader.onerror = error => reject(error);\n        reader.readAsText(file);\n      });\n    },\n    readFileAsBinaryString(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = event => resolve(event.target.result);\n        reader.onerror = error => reject(error);\n        reader.readAsBinaryString(file);\n      });\n    },\n    selectFile() {\n      return new Promise(resolve => {\n        const inputHtml = document.createElement(\"input\");\n        inputHtml.setAttribute(\"type\", \"file\");\n        inputHtml.setAttribute(\"accept\", \".ods,.xlsx,.xls,.csv\");\n        inputHtml.style.display = \"none\";\n        document.body.appendChild(inputHtml);\n        inputHtml.addEventListener(\"change\", event => {\n          try {\n            const file = event.target.files[0];\n            if (file) {\n              return resolve(file);\n            } else {\n              return resolve(undefined);\n            }\n          } catch (error) {\n            console.log(\"This should not happen :(\", error);\n          } finally {\n            inputHtml.remove();\n          }\n        });\n        inputHtml.click();\n      });\n    },\n    sheetToArray(sheet) {\n      // Obtener el rango de celdas activo de la hoja\n      const range = sheet['!ref']; // Ejemplo: 'A1:C3'\n      // Extraer las coordenadas de la celda inicial y final del rango\n      const [startCell, endCell] = range.split(':');\n      const startCol = startCell.match(/[A-Z]+/)[0]; // Columna de la primera celda (por ejemplo, 'A')\n      const startRow = parseInt(startCell.match(/\\d+/)[0], 10); // Fila de la primera celda (por ejemplo, 1)\n      const endCol = endCell.match(/[A-Z]+/)[0]; // Columna de la última celda (por ejemplo, 'C')\n      const endRow = parseInt(endCell.match(/\\d+/)[0], 10); // Fila de la última celda (por ejemplo, 3)\n      const data = [];\n      // Iterar sobre las filas y columnas dentro del rango\n      for (let row = startRow; row <= endRow; row++) {\n        const rowData = [];\n        for (let col = startCol.charCodeAt(0); col <= endCol.charCodeAt(0); col++) {\n          const cellAddress = String.fromCharCode(col) + row;\n          const cell = sheet[cellAddress]; // Obtener la celda\n          rowData.push(cell ? cell.v : null); // Si la celda existe, tomar su valor. Si no, agregar `null`\n        }\n        data.push(rowData); // Agregar la fila al array de datos\n      }\n      return data;\n    }\n  });\n\n  ///////////////////////////////////////////////////////\n  // API de Conductometria: usa API de Excel (so: SheetJS)\n  Object.assign(LswUtils, {\n    isDatePassed(date, time, currentDate = new Date()) {\n      const [day, month, year] = date.split(\"/\").map(Number);\n      const [hour, minute, second] = time.split(\":\").map(Number);\n      const targetDate = new Date(year, month-1, day, hour, minute, second);\n      return currentDate > targetDate;\n    },\n    sheetToRegistros(sheet, asObjectIsOkay = false) {\n      const raw = this.sheetToArray(sheet);\n      const byDate = {};\n      let lastDate = undefined;\n      const currentDate = new Date();\n      Compact_by_date_using_last_date: {\n        for (let index = 0; index < raw.length; index++) {\n          const cells = raw[index];\n          const [time, content] = cells;\n          const isDate = time.match(/[0-9][0-9]\\/[0-9][0-9]\\/[0-9][0-9]/g);\n          if (isDate) {\n            if (!(time in byDate)) {\n              byDate[time] = {};\n            }\n            lastDate = time;\n          } else {\n            if (typeof content === \"string\") {\n              if (!(time in byDate[lastDate])) {\n                byDate[lastDate][time] = [];\n              }\n              Add_properties_to_hour: {\n              }\n              const items = content.split(\".\").filter(l => l !== \"\");\n              for (let indexItem = 0; indexItem < items.length; indexItem++) {\n                const item = items[indexItem];\n                const [name, details] = item.split(\":\").filter(l => l !== \"\");\n                let event = {};\n                Add_properties_to_event: {\n                  Object.assign(event, { name });\n                  Object.assign(event, details ? { details: details.trim() } : {});\n                }\n                byDate[lastDate][time].push(event);\n              }\n            }\n          }\n        }\n      }\n      if (asObjectIsOkay) {\n        return byDate;\n      }\n      const output = [];\n      Format_to_pure_array_to_avoid_confusions: {\n        const daysSorted = Object.keys(byDate).sort();\n        for (let index_day = 0; index_day < daysSorted.length; index_day++) {\n          const day_id = daysSorted[index_day];\n          const day_data = byDate[day_id];\n          const day_output = {\n            day: day_id,\n            hours: []\n          };\n          const hoursSorted = Object.keys(day_data).sort();\n          for (let index_hour = 0; index_hour < hoursSorted.length; index_hour++) {\n            const hour_id = hoursSorted[index_hour];\n            const hour_data = day_data[hour_id];\n            const hour_is_passed = this.isDatePassed(day_id, hour_id, currentDate);\n            const hour_is_current = hour_is_passed && (() => {\n              const [hours, minutes, seconds] = hour_id.split(\":\").map(Number);\n              const hour_next_id = [hours + 1, minutes, seconds].map(t => (\"\" + t).padStart(2, \"0\")).join(\":\");\n              console.log(hour_next_id);\n              return !this.isDatePassed(day_id, hour_next_id, currentDate);\n            })();\n            const hour_output = {\n              hour: hour_id,\n              events: [],\n              passed: hour_is_passed,\n              current: hour_is_current,\n            };\n            for (let index_item = 0; index_item < hour_data.length; index_item++) {\n              const item = hour_data[index_item];\n              hour_output.events.push(item);\n            }\n            day_output.hours.push(hour_output);\n          }\n          output.push(day_output);\n        }\n      }\n      return output;\n    },\n    async loadConductometriaByExcelFile() {\n      try {\n        const file = await this.selectFile();\n        const data = await this.readFileAsBinaryString(file);\n        const workbook = XLSX.read(data, { type: \"binary\", cellDates: false });\n        const sheet = workbook.Sheets[\"Tracking\"];\n        const registros = this.sheetToRegistros(sheet);\n        return { registros };\n      } catch (error) {\n        console.log(error);\n      }\n    },\n  });\n\n  // API de LSW:\n  LswUtils.toPlainObject = function(obj) {\n    const seen = new WeakSet();\n    return JSON.parse(JSON.stringify(obj, (key, value) => {\n      if (typeof value === \"object\" && value !== null) {\n        if (seen.has(value)) return undefined; // Ignora referencias circulares\n        seen.add(value);\n      }\n      return value;\n    }));\n  };\n\n\n  LswUtils.stringify = function(argInput, avoidedIndexes = []) {\n    const seen = new WeakSet();\n    return JSON.stringify(argInput, function (key, value) {\n      if(avoidedIndexes.indexOf(key) !== -1) {\n        return;\n      }\n      if (typeof value === \"object\") {\n        if(value.$el) {\n          return `[VueComponent:${value?.$options?.name}]`;\n        }\n        if (seen.has(value)) {\n          return \"[Circular]\";\n        }\n        if (value !== null) {\n          seen.add(value);\n        }\n      }\n      return value;\n    }, 2);\n  };\n\n  LswUtils.pluralizar = function(singular, plural, contexto, cantidad) {\n    return contexto.replace(\"%s\", cantidad === 1 ? singular : plural).replace(\"%i\", cantidad);\n  };\n\n  LswUtils.getRandomString = function(len = 10) {\n    const alphabet = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\n    let out = \"\";\n    while(out.length < len) {\n      out += alphabet[Math.floor(Math.random() * alphabet.length)];\n    }\n    return out;\n  };\n\n  LswUtils.hello = function() {\n    console.log(\"hello\");\n  };\n\n  LswUtils.waitForMilliseconds = function(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  };\n\n  LswUtils.splitStringOnce = function(text, splitter) {\n    if(typeof text !== \"string\") {\n      throw new Error(\"Required parameter «text» to be a string on «LswUtils.splitStringOnce»\");\n    }\n    if(typeof splitter !== \"string\") {\n      throw new Error(\"Required parameter «text» to be a string on «LswUtils.splitStringOnce»\");\n    }\n    const pos = text.indexOf(splitter);\n    if(pos === -1) return [undefined, text];\n    const parts = text.split(\"\");\n    return [[...parts].splice(0, pos).join(\"\"), [...parts].splice(pos+1).join(\"\")];\n  };\n\n  LswUtils.reverseString = function(text) {\n    return text.split(\"\").reverse().join(\"\");\n  };\n\n  LswUtils.capitalize = function(text) {\n    return text.substr(0,1).toUpperCase() + text.substr(1);\n  };\n\n  LswUtils.startThread = function(callback) {\n    setTimeout(callback, 0);\n  };\n",
              "$code.label": "LswUtils",
              "$output": "index.html"
            }
          ]
        }
      }
    }
  }
}