{
  "files": {
    "index.html": {
      "sections": {
        "Index of document": [],
        "Lsw Circuiter API » LswCircuiter class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-circuiter/async-circuit.js",
            "$location": {
              "start": {
                "offset": 290,
                "line": 14,
                "column": 3
              },
              "end": {
                "offset": 508,
                "line": 25,
                "column": 6
              }
            },
            "$section": "Lsw Circuiter API » LswCircuiter class\n",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswCircuiter",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-circuiter/async-circuit.js",
            "$location": {
              "start": {
                "offset": 509,
                "line": 26,
                "column": 1
              },
              "end": {
                "offset": 598,
                "line": 27,
                "column": 1
              }
            },
            "$section": "Lsw Circuiter API » LswCircuiter class",
            "$code": "  class AsyncCircuit {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor() {\n      this.middlewares = [];\n    }\n\n    hook(callback) {\n      this.middlewares.push(callback);\n      return this;\n    }\n\n    prehook(callback) {\n      this.middlewares.unshift(callback);\n      return this;\n    }\n\n    unhook(callback) {\n      const pos = this.middlewares.indexOf(callback);\n      if(pos !== -1) {\n        this.middlewares.splice(pos, 1);\n      }\n      return this;\n    }\n\n    // Función principal para parsear el árbol\n    parse(node) {\n      // Si el nodo es un array (ejecutar en paralelo)\n      if (Array.isArray(node)) {\n        const code = node.map(cb => this.parse(cb)).join(',');\n        return `Promise.all([${code}])`; // Convertimos todo en un Promise.all\n      }\n\n      // Si es un objeto con $type y $callbacks\n      if (node && typeof node === 'object') {\n        Inject_middlewares: {\n          for(let index__middleware=0; index__middleware<this.middlewares.length; index__middleware++) {\n            const middleware = this.middlewares[index__middleware];\n            const result = middleware(node);\n          }\n        }\n        const { $type, $callbacks } = node;\n        const callbacks = $callbacks.map(cb => (typeof cb === 'function' ? `(${cb.toString()})()` : this.parse(cb)));\n        // Dependiendo del tipo, generamos el código adecuado\n        switch ($type) {\n          case 'parallel':\n            return `Promise.all([\\n  ${callbacks.join(',')}\\n  ])`; // Ejecutar en paralelo\n          case 'serie':\n            return `(async () => {\\n  ${callbacks.map(cb => `await ${cb}`).join('; ')}\\n  })()`; // Ejecutar en serie\n          case 'race':\n            return `Promise.race([\\n  ${callbacks.join(',')}\\n  ])`; // Ejecutar en carrera\n          case 'sync':\n            return `(() => {\\n  ${callbacks.join(';\\n  ')};\\n  return Promise.resolve();\\n  })()`; // Ejecutar síncrono\n          default:\n            throw new Error(`Required property «$type» to be one known but found «${$type}» on «this.parse»`);\n        }\n      }\n\n      // Si el nodo es una función, la transformamos directamente\n      if (typeof node === 'function') {\n        return `(${node.toString()})()`; // Convertimos la función en una llamada inmediata\n      }\n\n      throw new Error(`Required argument «node» to be of known type but found «${typeof $type}» on «this.parse»`);\n    }\n\n    // Método que ejecuta el código generado por eval\n    async execute(node, externalScope = {}) {\n      const code = this.parse(node);\n      const AsyncFunction = (async function() {}).constructor;\n      const argKeys = Object.keys(externalScope).join(\", \");\n      const argValues = Object.values(externalScope);\n      const asyncFunction = new AsyncFunction(argKeys, code);\n      return await asyncFunction(...argValues); // Ejecutamos el código generado con eval\n    }\n  }\n",
            "$code.label": "LswCircuiter class",
            "$output": "index.html"
          }
        ],
        "Lsw ClassRegister API » LswClassRegister class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-class-register/lsw-class-register.js",
            "$location": {
              "start": {
                "offset": 300,
                "line": 14,
                "column": 3
              },
              "end": {
                "offset": 530,
                "line": 25,
                "column": 6
              }
            },
            "$section": "Lsw ClassRegister API » LswClassRegister class\n",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswClassRegister",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-class-register/lsw-class-register.js",
            "$location": {
              "start": {
                "offset": 531,
                "line": 26,
                "column": 1
              },
              "end": {
                "offset": 632,
                "line": 27,
                "column": 1
              }
            },
            "$section": "Lsw ClassRegister API » LswClassRegister class",
            "$code": "  class LswClassRegister {\n\n    constructor() {\n      this.$classes = {};\n    }\n\n    register(id, classDefinition, forceOverwrite = false) {\n      $ensure({id},1).type(\"string\");\n      $ensure({classDefinition},1).type(\"function\");\n      if(!forceOverwrite) {\n        $ensure({$classes:this.$classes},1).to.not.have.key(id);\n      }\n      this.$classes[id] = classDefinition;\n    }\n\n    unregister(id, silenceError = false) {\n      if(!silenceError) {\n        $ensure({$classes:this.$classes},1).to.have.key(id);\n      }\n      delete this.$classes[id];\n    }\n\n    instantiate(id, ...args) {\n      $ensure({id},1).type(\"string\");\n      $ensure({$classes:this.$classes},1).to.have.key(id);\n      const clazz = this.$classes[id];\n      const objeto = new clazz(...args);\n      return objeto;\n    }\n\n    async initialize(id, ...args) {\n      $ensure({id},1).type(\"string\");\n      $ensure({$classes:this.$classes},1).to.have.key(id);\n      const clazz = this.$classes[id];\n      const objeto = new clazz(...args);\n      if(typeof objeto.initialize === \"function\") {\n        await objeto.initialize();\n      }\n      return objeto;\n    }\n\n  }\n",
            "$code.label": "LswClassRegister class",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
            "$location": {
              "start": {
                "offset": 294,
                "line": 14,
                "column": 3
              },
              "end": {
                "offset": 524,
                "line": 25,
                "column": 6
              }
            },
            "$section": "Lsw ClassRegister API » LswClassRegister class\n",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswClassRegister",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
            "$location": {
              "start": {
                "offset": 525,
                "line": 26,
                "column": 1
              },
              "end": {
                "offset": 625,
                "line": 27,
                "column": 1
              }
            },
            "section": "Lsw ClassRegister API » LswClassRegister class",
            "$code": "  Promise_extensions: {\n    \n    globalThis.Promise.prototype.chain = function (nextPromise) {\n      return this.then(() => nextPromise);\n    };\n  }\n",
            "$code.label": "LswClassRegister class",
            "$output": "index.html"
          }
        ],
        "Lsw Commander API » LswCommander class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-commander/url-command.js",
            "$location": {
              "start": {
                "offset": 797,
                "line": 31,
                "column": 3
              },
              "end": {
                "offset": 1015,
                "line": 42,
                "column": 6
              }
            },
            "$section": "Lsw Commander API » LswCommander class\n",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswCommander",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-commander/url-command.js",
            "$location": {
              "start": {
                "offset": 1016,
                "line": 43,
                "column": 1
              },
              "end": {
                "offset": 1105,
                "line": 44,
                "column": 1
              }
            },
            "$section": "Lsw Commander API » LswCommander class",
            "$code": "  const LswCommander = class {\n\n    static from(...args) {\n      return new this(...args);\n    }\n\n    onRun(callback, args) {\n      try {\n        let output = undefined;\n        if (typeof this.$beforeRun === \"function\") {\n          this.$beforeRun(...args);\n        }\n        output = callback(...args);\n        if (typeof this.$afterRun === \"function\") {\n          this.$afterRun(...args);\n        }\n        return output;\n      } catch (error) {\n        if (typeof this.$onError === \"function\") {\n          const output = this.$onError(error);\n          if (typeof output !== \"undefined\") {\n            return output;\n          }\n        }\n        throw error;\n      }\n    }\n\n    constructor(handlers) {\n      this.$handlers = handlers;\n      this.$beforeRun = undefined;\n      this.$afterRun = undefined;\n      this.$onError = undefined;\n      this.command = (url, queryParamsExtender = {}) => {\n        if (!url) throw new Error(\"URL is required\");\n        if (typeof url !== \"string\") throw new Error(\"URL must be a string\");\n        if (typeof this.$handlers !== \"object\" || this.$handlers === null) {\n          throw new Error(\"Handlers must be a valid object\");\n        }\n        const [path, queryString] = url.split(\"?\");\n        const queryParams = queryString ? Object.fromEntries(new URLSearchParams(queryString).entries()) : {};\n        Object.assign(queryParams, queryParamsExtender);\n        const pathParts = path.split(\"/\").filter(Boolean);\n        let currentHandler = this.$handlers;\n        for (const part of pathParts) {\n          if (currentHandler[part] === undefined) {\n            throw new Error(`Handler for path \"${path}\" not found`);\n          }\n          currentHandler = currentHandler[part];\n        }\n        if (typeof currentHandler !== \"function\") {\n          throw new Error(`Handler at path \"${path}\" is not a function`);\n        }\n        const isSpreadable = isOnlyConsecutiveNumbers(queryParams);\n        if (isSpreadable && isSpreadable.length) {\n          return this.onRun(currentHandler, isSpreadable);\n        } else if (queryParams.argumentsOrder) {\n          const args = [];\n          const argKeys = queryParams.argumentsOrder.split(\",\").map(arg => arg.trim());\n          for (let index = 0; index < argKeys.length; index++) {\n            const argKey = argKeys[index];\n            const argValue = queryParams[argKey] || null;\n            args.push(argValue);\n          }\n          return this.onRun(currentHandler, args);\n        } else {\n          return this.onRun(currentHandler, [queryParams]);\n        }\n      };\n    }\n    get run() {\n      return this.command;\n    }\n    beforeRun(callback) {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"Required parameter «callback» to be a function on «beforeRun»\");\n      }\n      this.$beforeRun = callback;\n    }\n    afterRun(callback) {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"Required parameter «callback» to be a function on «afterRun»\");\n      }\n      this.$afterRun = callback;\n    }\n    onError(callback) {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"Required parameter «callback» to be a function on «onError»\");\n      }\n      this.$onError = callback;\n    }\n  };\n",
            "$code.label": "LswCommander class",
            "$output": "index.html"
          }
        ],
        "Lsw Compromiser API » LswCompromiser class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
            "$location": {
              "start": {
                "offset": 816,
                "line": 35,
                "column": 3
              },
              "end": {
                "offset": 1039,
                "line": 45,
                "column": 6
              }
            },
            "$section": "Lsw Compromiser API » LswCompromiser class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswCompromiser",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-compromiser/lsw-compromiser.js",
            "$location": {
              "start": {
                "offset": 1040,
                "line": 46,
                "column": 1
              },
              "end": {
                "offset": 1134,
                "line": 47,
                "column": 1
              }
            },
            "section": "Lsw Compromiser API » LswCompromiser class",
            "$code": "  class PromiseMap {\n\n    constructor(keys) {\n      this.promises = new Map();\n\n      keys.forEach(key => {\n        this.set(key);\n      });\n    }\n\n    static create(keys) {\n      return new this(keys);\n    }\n\n    has(key) {\n      return this.promises.has(key);\n    }\n\n    get(key) {\n      if (!this.has(key)) {\n        throw new Error(`Required argument «key» to be an existing key (not «${key}») on «PromiseMap.get»`);\n      }\n      return this.promises.get(key);\n    }\n\n    set(key) {\n      if (this.has(key)) {\n        throw new Error(`Required argument «key» to not be an existing key (not «${key}») on «PromiseMap.set»`);\n      }\n      let resolve, reject;\n      const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n      this.promises.set(key, { promise, resolve, reject });\n    }\n\n    unset(key) {\n      if (!this.has(key)) {\n        throw new Error(`Required argument «key» to be an existing key (not «${key}») on «PromiseMap.unset»`);\n      }\n      this.promises.delete(key);\n    }\n\n    on(key) {\n      if (!this.has(key)) {\n        throw new Error(`Required argument «key» to be an existing key (not «${key}») on «PromiseMap.on»`);\n      }\n      return this.promises.get(key).promise;\n    }\n\n    bind(key, key2) {\n      this.on(key).then(output => this.get(key2).resolve(output));\n    }\n\n    propagate(key) {\n      return {\n        to: (key2) => {\n          this.bind(key, key2);\n          return this.propagate(key2);\n        }\n      }\n    }\n\n  }\n",
            "$code.label": "LswCompromiser class",
            "$output": "index.html"
          }
        ],
        "Lsw Configurer API » LswConfigurer class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-configurer/lsw-configurer.js",
            "$location": {
              "start": {
                "offset": 294,
                "line": 14,
                "column": 3
              },
              "end": {
                "offset": 514,
                "line": 24,
                "column": 6
              }
            },
            "$section": "Lsw Configurer API » LswConfigurer class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswConfigurer",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-configurer/lsw-configurer.js",
            "$location": {
              "start": {
                "offset": 515,
                "line": 25,
                "column": 1
              },
              "end": {
                "offset": 606,
                "line": 26,
                "column": 1
              }
            },
            "section": "Lsw Configurer API » LswConfigurer class",
            "$code": "  const LswConfigurer = class {\n\n    constructor(parentConfigurer = null) {\n      this.$parent = parentConfigurer;\n      this.$state = {};\n    }\n\n    configure(stateOptions = {}) {\n      Object.assign(this.$state, stateOptions);\n    }\n\n    get(key, defaultValue = undefined) {\n      let target = this;\n      Iterating_parents:\n      while(!!target) {\n        if(key in target.$state) {\n          return target.$state[key];\n        }\n        target = target.$parent;\n      }\n      return defaultValue;\n    }\n\n  }\n",
            "$code.label": "LswConfigurer class",
            "$output": "index.html"
          }
        ],
        "Lsw Cycler API » LswCycler class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-cycler/lsw-cycler.js",
            "$location": {
              "start": {
                "offset": 312,
                "line": 17,
                "column": 3
              },
              "end": {
                "offset": 520,
                "line": 27,
                "column": 6
              }
            },
            "$section": "Lsw Cycler API » LswCycler class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswCycler",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-cycler/lsw-cycler.js",
            "$location": {
              "start": {
                "offset": 521,
                "line": 28,
                "column": 1
              },
              "end": {
                "offset": 600,
                "line": 29,
                "column": 1
              }
            },
            "section": "Lsw Cycler API » LswCycler class",
            "$code": "  class LswCyclerSet {\n    constructor(value) {\n      this.value = value;\n    }\n  }\n\n  class LswCyclerReturn {\n    constructor(value) {\n      this.value = value;\n    }\n  }\n\n  class LswCyclerReturner {\n    constructor(value) {\n      if(typeof value !== \"function\") {\n        throw new Error(\"Required argument «value» to be a function on «LswCyclerReturner.constructor»\");\n      }\n      this.value = value;\n    }\n  }\n\n  class LswCycler {\n\n    static Return = LswCyclerReturn;\n    static Returner = LswCyclerReturner;\n    static Set = LswCyclerSet;\n\n    static returner(value) {\n      return new this.Returner(value);\n    }\n\n    static return(value) {\n      return new this.Return(value);\n    }\n\n    static set(value) {\n      return new this.Set(value);\n    }\n\n    constructor($object, exposedProps = []) {\n      this.$object = $object;\n      if(exposedProps === \"*\") {\n        Object.assign(this, $object);\n      } else {\n        for(let index=0; index<exposedProps.length; index++) {\n          const exposedProp = exposedProps[index];\n          this[exposedProp] = $object[exposedProp];\n        }\n      }\n    }\n\n    static from(...args) {\n      return new this(...args);\n    }\n\n    async run(steps, parameters) {\n      let original = [];\n      let output = original;\n      Iterate_cycle:\n      for (let j = 0; j < steps.length; j++) {\n        let step = steps[j];\n        let fn = this.$object[step];\n        if (typeof fn !== \"function\") {\n          throw new Error(\"Required step «\" + step + \"» to be a function on round \" + j + \" on «LswCycler.run»\");\n        }\n        const result = await fn.call(this.$object, parameters);\n        Apply_intercycle_signals: {\n          if (result instanceof this.constructor.Set) {\n            output = await result.value;\n          } else if (result instanceof this.constructor.Return) {\n            return result.value;\n          } else if (result instanceof this.constructor.Returner) {\n            return result.value(output, original);\n          }\n        }\n        Append_result_if_not_changed_output: {\n          original.push(result);\n        }\n      }\n      return output;\n    }\n\n  }\n",
            "$code.label": "LswCycler class",
            "$output": "index.html"
          }
        ],
        "Lsw Database API » LswDatabase class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database/browsie.unbundled.js",
            "$location": {
              "start": {
                "offset": 287,
                "line": 15,
                "column": 3
              },
              "end": {
                "offset": 501,
                "line": 25,
                "column": 6
              }
            },
            "$section": "Lsw Database API » LswDatabase class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswDatabase",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database/browsie.unbundled.js",
            "$location": {
              "start": {
                "offset": 502,
                "line": 26,
                "column": 1
              },
              "end": {
                "offset": 587,
                "line": 27,
                "column": 1
              }
            },
            "section": "Lsw Database API » LswDatabase class",
            "$code": "  class BrowsieCheckersAPI {\n\n    static mustBeString(obj, method = \"Browsie.mustBeString\", id = \"?\") {\n      if (typeof obj !== \"string\") {\n        throw new Error(`Required «${id}» to be a string on «${method}»`);\n      }\n    }\n\n    static mustBeArray(obj, method = \"Browsie.mustBeArray\", id = \"?\") {\n      if (!Array.isArray(obj)) {\n        throw new Error(`Required «${id}» to be an array on «${method}»`);\n      }\n    }\n\n    static mustBeObject(obj, method = \"Browsie.mustBeObject\", id = \"?\") {\n      if (typeof obj !== \"object\") {\n        throw new Error(`Required «${id}» to be an object on «${method}»`);\n      }\n    }\n\n    static mustBeGreaterThan(obj, comparison = 0, method = \"Browsie.mustBeObject\", id = \"?\") {\n      if (obj <= comparison) {\n        throw new Error(`Required «${id}» to be greater than «${comparison}» on «${method}»`);\n      }\n    }\n  }\n\n  class BrowsieStaticAPI extends BrowsieCheckersAPI {\n\n    static openedConnections = [];\n\n    static _trace = true;\n\n    static trace(methodName, args = []) {\n      if (this._trace) {\n        console.log(\"[browsie][\" + methodName + \"]\", args.length + \" args: \" + Array.from(args).map(arg => typeof (arg)).join(\", \"));\n      }\n    }\n\n    static async listDatabases() {\n      this.trace(\"Browsie.listDatabases\", arguments);\n      try {\n        const databases = await indexedDB.databases();\n        console.log('Bases de datos disponibles:', databases);\n        return databases;\n      } catch (error) {\n        console.error('Error al obtener las bases de datos:', error);\n      }\n    }\n\n    static createDatabase(dbName, schemaDefinition = null, version = 1, versionUpgrades = {}) {\n      this.trace(\"Browsie.createDatabase\", arguments);\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName, version);\n        request.onsuccess = () => {\n          console.log(`[SUCCESS] Database \"${dbName}\" created/opened successfully.`);\n          request.result.close();\n          resolve(request.result);\n        };\n        request.onerror = (error) => {\n          console.error(`[ERROR] Failed to create/open database \"${dbName}\":`, error);\n          reject(error);\n        };\n        request.onupgradeneeded = async (event) => {\n          const db = event.target.result;\n          console.log(`[UPGRADE] Upgrading database \"${dbName}\" from version ${event.oldVersion} to ${version}.`);\n          // Si hay una definición de esquema inicial, crear los almacenes e índices\n          if (schemaDefinition && event.oldVersion === 0) {\n            console.log(\"[SCHEMA] Applying initial schema definition.\");\n            Object.keys(schemaDefinition).forEach((storeName) => {\n              if (!db.objectStoreNames.contains(storeName)) {\n                const objectStore = db.createObjectStore(storeName, {\n                  keyPath: \"id\",\n                  autoIncrement: true,\n                });\n                if (!Array.isArray(schemaDefinition[storeName])) {\n                  console.log(schemaDefinition);\n                  throw new Error(`Required property «schemaDefinition.${storeName}» to be an array on «LswDatabase.createDatabase»`);\n                }\n                schemaDefinition[storeName].forEach((index) => {\n                  const indexName = index.replace(/^\\!/, \"\");\n                  objectStore.createIndex(indexName, indexName, {\n                    unique: index.startsWith(\"!\")\n                  });\n                });\n              }\n            });\n          }\n          // Aplicar las transformaciones de esquema para cada versión\n          for (let v = event.oldVersion + 1; v <= version; v++) {\n            if (versionUpgrades[v]) {\n              console.log(`[VERSION ${v}] Applying upgrade function.`);\n              await versionUpgrades[v](db);\n            } else {\n              console.log(`[VERSION ${v}] No upgrade function defined.`);\n            }\n          }\n        };\n      });\n    }\n\n    // Obtener todos los datos de un store\n    static async getAllDataFromStore(dbName, storeName) {\n      this.trace(\"Browsie.getAllDataFromStore\", arguments);\n      return await new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName);\n\n        request.onsuccess = (event) => {\n          const db = event.target.result;\n          const transaction = db.transaction(storeName, 'readonly');\n          const store = transaction.objectStore(storeName);\n\n          const getAllRequest = store.getAll();\n          getAllRequest.onsuccess = () => resolve(getAllRequest.result);\n          getAllRequest.onerror = () => {\n            db.close();\n            reject(new Error('Error al obtener los datos del store'));\n          };\n        };\n\n        request.onerror = () => {\n          reject(new Error('Error al abrir la base de datos'));\n        };\n      });\n    }\n\n    // Insertar datos en un store\n    static async insertDataIntoStore(dbName, storeName, data) {\n      this.trace(\"Browsie.insertDataIntoStore\", arguments);\n      return await new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName);\n\n        request.onsuccess = (event) => {\n          const db = event.target.result;\n          const transaction = db.transaction(storeName, 'readwrite');\n          const store = transaction.objectStore(storeName);\n\n          data.forEach(item => store.add(item));\n\n          transaction.oncomplete = () => resolve();\n          transaction.onerror = () => {\n            db.close();\n            reject(new Error('Error al insertar los datos en el store'));\n          };\n        };\n\n        request.onerror = () => {\n          reject(new Error('Error al abrir la base de datos'));\n        };\n      });\n    }\n\n    // Eliminar una base de datos\n    static deleteDatabase(dbName) {\n      this.trace(\"Browsie.deleteDatabase\", arguments);\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.deleteDatabase(dbName);\n\n        request.onblocked = () => {\n          // db.close();\n          reject(new Error(\"Error al eliminar la base de datos porque está bloqueada\"));\n        };\n        request.onsuccess = () => resolve();\n        request.onerror = () => {\n          // db.close();\n          reject(new Error('Error al eliminar la base de datos'));\n        };\n      }).then(() => {\n        console.log(`[!] Base de datos «${dbName}» eliminada correctamente.`);\n      });\n    }\n\n    static async getSchema(dbName) {\n      this.trace(\"Browsie.getSchema\", arguments);\n      let db = undefined;\n      try {\n        // Abrir la base de datos en modo solo lectura\n        const request = indexedDB.open(dbName);\n\n        db = await new Promise((resolve, reject) => {\n          request.onsuccess = (event) => resolve(event.target.result);\n          request.onerror = () => {\n            reject(new Error('Error al abrir la base de datos'));\n          };\n        });\n\n        // Construir el esquema a partir de los almacenes\n        const schema = {};\n        const objectStoreNames = Array.from(db.objectStoreNames); // Lista de stores\n\n        objectStoreNames.forEach(storeName => {\n          const transaction = db.transaction(storeName, 'readonly');\n          const store = transaction.objectStore(storeName);\n\n          const storeInfo = {\n            keyPath: store.keyPath,\n            autoIncrement: store.autoIncrement,\n            indexes: []\n          };\n\n          // Recorrer los índices del store\n          const indexNames = Array.from(store.indexNames); // Lista de índices\n          indexNames.forEach(indexName => {\n            const index = store.index(indexName);\n            storeInfo.indexes.push({\n              name: index.name,\n              keyPath: index.keyPath,\n              unique: index.unique,\n              multiEntry: index.multiEntry\n            });\n          });\n\n          schema[storeName] = storeInfo;\n        });\n\n        return schema;\n      } catch (error) {\n        console.error('Error al obtener el esquema:', error);\n        throw error;\n      } finally {\n        if (db) {\n          db.close();\n        }\n      }\n    }\n\n    static async pickRow(databaseId, tableId, rowId) {\n      this.trace(\"Browsie.pickRow\", arguments);\n      $ensure(databaseId).type(\"string\");\n      $ensure(tableId).type(\"string\");\n      $ensure(rowId).type(\"number\");\n      let connection = undefined;\n      try {\n        connection = await this.open(databaseId);\n        const rows = await connection.selectMany(tableId, v => v.id === rowId);\n        if (rows.length === 1) {\n          return rows[0];\n        } else if (rows.length === 0) {\n          return undefined;\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        try {\n          await connection.close();\n        } catch (error) {\n          console.log(\"Could not close connection on picking row\");\n        }\n      }\n    }\n\n  }\n\n  class BrowsieTriggersAPI extends BrowsieStaticAPI {\n\n    static globMatch = TriggersClass.globMatch;\n\n    triggers = new TriggersClass();\n\n  }\n\n\n  class BrowsieCrudAPI extends BrowsieTriggersAPI {\n\n    static async open(...args) {\n      this.trace(\"Browsie.open\", arguments);\n      const db = new this(...args);\n      await db.open();\n      return db;\n    }\n\n    // Constructor que abre la base de datos\n    constructor(dbName, trace = false) {\n      super();\n      this.$dbName = dbName;\n      this.$db = null;\n      this.$innerSchema = null;\n      this._trace = trace;\n    }\n\n    getInnerSchema() {\n      this.constructor.trace(\"browsie.getInnerSchema\", arguments);\n      return this.$innerSchema;\n    }\n\n    setInnerSchema(innerSchema) {\n      this.constructor.trace(\"browsie.setInnerSchema\", arguments);\n      if (!(innerSchema instanceof LswSchema)) {\n        throw new Error(`Required parameter «innerSchema» to be an instance of LswSchema on «browsie.setInnerSchema»`);\n      }\n      this.$innerSchema = innerSchema;\n    }\n\n    // Abre la base de datos\n    open() {\n      this.constructor.trace(\"browsie.open\", arguments);\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.$dbName);\n\n        request.onsuccess = () => {\n          this.$db = request.result;\n          resolve(this.$db);\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.open» operation over database «${this.$dbName}»: `));\n      });\n    }\n\n    close(...args) {\n      this.constructor.trace(\"browsie.close\", arguments);\n      return this.$db.close(...args);\n    }\n\n    // Método para seleccionar 1 elemento de un store con un filtro\n    select(store, filter = {}) {\n      this.constructor.trace(\"browsie.select\", arguments);\n      this.triggers.emit(`crud.select.one.${store}`, { store, filter });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readonly');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.getAll();\n        request.onsuccess = () => {\n          const result = request.result.filter(item => {\n            return Object.keys(filter).every(key => item[key] === filter[key]);\n          });\n          resolve(result);\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.select» operation over store «${store}»: `));\n      });\n    }\n\n    // Método para insertar un solo item en un store\n    insert(store, item) {\n      this.constructor.trace(\"browsie.insert\", arguments);\n      this.triggers.emit(`crud.insert.one.${store}`, { store, item });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.add(item);\n\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.insert» operation over store «${store}»: `));\n      });\n    }\n\n    // Método para actualizar un item en un store\n    update(store, id, item) {\n      this.constructor.trace(\"browsie.update\", arguments);\n      this.triggers.emit(`crud.update.one.${store}`, { store, id, item });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.put({ ...item, id });\n\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.update» operation over store «${store}»: `));\n      });\n    }\n\n    // Método tipo upsert: que cambia solo los campos que le proporcionas (hace entre 1 y 2 queries)\n    async overwrite(store, idOrItem, item) {\n      this.constructor.trace(\"browsie.overwrite\", arguments);\n      this.triggers.emit(`crud.overwrite.one.${store}`, { store, idOrItem, item });\n      const isId = (typeof idOrItem === \"string\") || (typeof idOrItem === \"number\");\n      const isItem = typeof idOrItem === \"object\";\n      let previousItem = undefined;\n      if (isItem) {\n        previousItem = idOrItem;\n      } else if (isId) {\n        const matches = await this.select(store, it => it.id === idOrItem);\n        if (matches.length === 0) {\n          throw new Error(`Zero rows on overwrite operator. Cannot overwrite a row that does not exist on «browsie.overwrite»`);\n        } else if (matches.length > 1) {\n          throw new Error(`Multiple rows on overwrite operation. Cannot overwrite multiple rows. Ensure store «${store}» is using index «id» as unique value to complete this operation`);\n        }\n        previousItem = matches[0];\n      } else {\n        throw new Error(`Required parameter «idOrItem» to be a string or an object on «browsie.overwrite»`);\n      }\n      const newItem = Object.assign({}, previousItem, item);\n      return await this.update(store, newItem.id, newItem);\n    }\n\n    // Método para eliminar un item de un store por ID\n    delete(store, id) {\n      this.constructor.trace(\"browsie.delete\", arguments);\n      this._ensureIntegrity(store, id);\n      this.triggers.emit(`crud.delete.one.${store}`, { store, id });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.delete(id);\n        request.onsuccess = () => resolve();\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.delete» operation over store «${store}»: `));\n      });\n    }\n\n    _getSchemaEntityByStoreName(store) {\n      this.constructor.trace(\"browsie._ensureIntegrity\", arguments);\n      const innerSchema = this.getInnerSchema().$schema;\n      const tableIds = Object.keys(innerSchema.hasTables);\n      Iterating_tables:\n      for (let indexTables = 0; indexTables < tableIds.length; indexTables++) {\n        const tableId = tableIds[indexTables];\n        if (tableId === store) {\n          return innerSchema.hasTables[tableId];\n        }\n      }\n      return undefined;\n    }\n\n    _ensureIntegrity(store, id) {\n      this.constructor.trace(\"browsie._ensureIntegrity\", arguments);\n      const innerSchema = this.getInnerSchema().$schema;\n      const tableIds = Object.keys(innerSchema.hasTables);\n      const sourceEntity = innerSchema.hasTables[store];\n      const sourceEntityId = sourceEntity.hasEntityId;\n      const boundColumns = [];\n      Iterating_tables:\n      for (let indexTables = 0; indexTables < tableIds.length; indexTables++) {\n        const tableId = tableIds[indexTables];\n        const tableData = innerSchema.hasTables[tableId];\n        const columnIds = Object.keys(tableData.hasColumns);\n        Iterating_columns:\n        for (let indexColumns = 0; indexColumns < columnIds.length; indexColumns++) {\n          const columnId = columnIds[indexColumns];\n          const columnData = tableData.hasColumns[columnId];\n          When_it_has_references: {\n            if (!columnData.refersTo) {\n              break When_it_has_references;\n            }\n            const { entity: schemaEntityId, property: entityColumnId, constraint = true } = columnData.refersTo;\n            if (!constraint) {\n              break When_it_has_references;\n            }\n            const isSameEntity = schemaEntityId === sourceEntityId;\n            if (!isSameEntity) {\n              break When_it_has_references;\n            }\n            boundColumns.push({\n              source: [store, entityColumnId],\n              mustCheck: [tableId, columnId]\n            });\n          }\n        }\n      }\n      console.log(`BOUND COLUMNS to ${store}:`, boundColumns);\n    }\n\n    _expandError(errorObject, baseMessage = false) {\n      this.constructor.trace(\"browsie._expandError\", arguments);\n      let error = errorObject;\n      if (errorObject instanceof Error) {\n        error = errorObject;\n      } else if (errorObject.target && errorObject.target.error) {\n        error = errorObject.target.error;\n      } else {\n        error = new Error(errorObject);\n      }\n      if (baseMessage) {\n        const errorTemp = new Error(error.message ?? error);\n        Object.assign(errorTemp, error);\n        errorTemp.message = baseMessage + errorTemp.message;\n        error = errorTemp;\n      }\n      return error;\n    }\n\n    // Método para seleccionar elementos de un store con un filtro\n    select(store, filter) {\n      this.constructor.trace(\"browsie.select\", arguments);\n      this.triggers.emit(`crud.select.one.${store}`, { store, filter });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readonly');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.getAll();\n\n        request.onsuccess = () => {\n          const result = request.result.filter(item => {\n            try {\n              return filter(item);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «browsie.select»\");\n              return false;\n            }\n          });\n          resolve(result);\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.select» operation over store «${store}»: `));\n      });\n    }\n\n    selectMany(store, filterFn = i => true) {\n      this.constructor.trace(\"browsie.selectMany\", arguments);\n      this.triggers.emit(`crud.select.many.${store}`, { store, filterFn });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readonly');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria\n        const results = [];\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            let isAccepted = undefined;\n            try {\n              isAccepted = filterFn(cursor.value);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «browsie.selectMany»\");\n            }\n            if (isAccepted) { // Aplica la función de filtro\n              results.push(cursor.value);\n            }\n            cursor.continue(); // Avanza al siguiente registro\n          } else {\n            resolve(results); // Se terminó el recorrido\n          }\n        };\n        request.onerror = (error) =>\n          reject(this._expandError(error, `Error on «browsie.selectMany» operation over store «${store}»: `));\n      });\n    }\n\n    // Método para insertar varios items en un store\n    insertMany(store, items) {\n      this.constructor.trace(\"browsie.insertMany\", arguments);\n      this.triggers.emit(`crud.insert.many.${store}`, { store, items });\n      this.constructor.mustBeString(store, \"insertMany\", \"arguments[0]\");\n      this.constructor.mustBeArray(items, \"insertMany\", \"arguments[1]\");\n      return new Promise((resolve, reject) => {\n        if (items.length === 0) {\n          return resolve(false);\n        }\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        let insertedCount = 0;\n        items.forEach(item => {\n          const request = objectStore.add(item);\n          request.onsuccess = () => {\n            insertedCount++;\n            if (insertedCount === items.length) resolve();\n          };\n          request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.insertMany» operation over store «${store}» inserting «${items.length}» items: `));\n        });\n      });\n    }\n\n    // Método para actualizar varios items en un store\n    updateMany(store, filter, item) {\n      this.constructor.trace(\"browsie.updateMany\", arguments);\n      this.triggers.emit(`crud.update.many.${store}`, { store, filter, item });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.openCursor();\n        let updatedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (cursor) {\n            if (Object.keys(filter).every(key => cursor.value[key] === filter[key])) {\n              const updatedItem = { ...cursor.value, ...item };\n              const updateRequest = cursor.update(updatedItem);\n              updateRequest.onsuccess = () => {\n                updatedCount++;\n                if (updatedCount === cursor.value.length) resolve();\n              };\n            }\n            cursor.continue();\n          }\n        };\n\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.updateMany» operation over store «${store}»: `));\n      });\n    }\n\n    // Método a tipo upsertAll para llenar los valores pero dejar los que no\n    async overwriteMany(store, filter, item) {\n      this.constructor.trace(\"browsie.overwriteMany\", arguments);\n      this.triggers.emit(`crud.overwrite.many.${store}`, { store, filter, item });\n      const allMatches = await this.selectMany(store, filter);\n      const allResults = [];\n      for (let indexRow = 0; indexRow < allMatches.length; indexRow++) {\n        const row = allMatches[indexRow];\n        const result = await this.overwrite(store, row, item);\n        allResults.push(result);\n      }\n      return allResults;\n    }\n\n    // Método para eliminar varios items de un store según un filtro\n    deleteMany(store, filterCallback) {\n      this.constructor.trace(\"browsie.deleteMany\", arguments);\n      this.triggers.emit(`crud.delete.many.${store}`, { store, filterCallback });\n      return new Promise((resolve, reject) => {\n        const transaction = this.$db.transaction(store, 'readwrite');\n        const objectStore = transaction.objectStore(store);\n        const request = objectStore.openCursor();\n        let deletedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (!cursor) {\n            return resolve();\n          }\n          const isAccepted = filterCallback(cursor.value);\n          if (isAccepted) {\n            const deleteRequest = cursor.delete();\n            deleteRequest.onsuccess = () => {\n              deletedCount++;\n              if (deletedCount === cursor.value.length) {\n                return resolve();\n              }\n            };\n            deleteRequest.onerror = (error) => reject(this._expandError(error, `Error on «browsie.deleteMany» operation over store «${store}» and id «${cursor.value.id}»: `));\n          }\n          cursor.continue();\n        };\n        request.onerror = (error) => reject(this._expandError(error, `Error on «browsie.deleteMany» operation over store «${store}»: `));\n      });\n    }\n  }\n\n  // @TOCONTINUEFROM\n  class BrowsieMigration {\n\n    static from(...args) {\n      return new this(...args);\n    }\n\n    static createTable(arg) {\n      return this.from({\n        operation: \"createTable\",\n        parameters: arg\n      });\n    }\n\n    static renameTable(arg) {\n      return this.from({\n        operation: \"renameTable\",\n        parameters: arg\n      });\n    }\n\n    static deleteTable(arg) {\n      return this.from({\n        operation: \"deleteTable\",\n        parameters: arg\n      });\n    }\n\n    static createColumn(arg) {\n      return this.from({\n        operation: \"createColumn\",\n        parameters: arg\n      });\n    }\n\n    static renameColumn(arg) {\n      return this.from({\n        operation: \"renameColumn\",\n        parameters: arg\n      });\n    }\n\n    static deleteColumn(arg) {\n      return this.from({\n        operation: \"deleteColumn\",\n        parameters: arg\n      });\n    }\n\n    constructor(options = {}) {\n      LswDatabase.trace(\"LswDatabaseMigration.constructor\");\n      const { operation, parameters } = options;\n      this.$validateOperation(operation);\n      this.$validateParameters(parameters);\n      this.operation = operation;\n      this.parameters = parameters;\n      this.config = {\n        temporaryDatabase: this.parameters.fromDatabase + \"_\" + this.$getRandomString(5),\n      };\n      this.migrated = false;\n    }\n\n    $getRandomString(len = 10) {\n      LswDatabase.trace(\"LswDatabaseMigration.$getRandomString\");\n      const alphabet = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\n      let out = \"\";\n      while (out.length < len) {\n        out += alphabet[Math.floor(Math.random() * alphabet.length)];\n      }\n      return out;\n    };\n\n    $validateOperation(operation) {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateOperation\");\n      if ([\"createTable\", \"renameTable\", \"deleteTable\", \"createColumn\", \"renameColumn\", \"deleteColumn\", \"cloneDatabase\", \"moveDatabase\"].indexOf(operation) === -1) {\n        throw new Error(\"Required «operation» to be a valid operation on «LswDatabaseMigration.$validateOperation»\");\n      }\n    }\n\n    $validateParameters(parameters) {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateParameters\");\n      if (typeof parameters !== \"object\") {\n        throw new Error(\"Required «parameters» to be an object on «LswDatabaseMigration.$validateParameters»\");\n      }\n    }\n\n    async $$transferBackTemporaryDatabase() {\n      await LswDatabase.deleteDatabase(this.parameters.fromDatabase);\n      await this.$replicateSchema({\n        fromDatabase: this.config.temporaryDatabase,\n        toDatabase: this.parameters.fromDatabase,\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.config.temporaryDatabase,\n        toDatabase: this.parameters.fromDatabase,\n      });\n      await LswDatabase.deleteDatabase(this.config.temporaryDatabase);\n    }\n\n    commit() {\n      LswDatabase.trace(\"LswDatabaseMigration.commit\");\n      return this[\"$$\" + this.operation].call(this).finally(() => {\n        this.migrated = true;\n      });\n    }\n\n    $validateCreateTableParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateCreateTableParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateCreateTableParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateCreateTableParameters»\");\n      }\n      if (typeof this.parameters.tableDefinition !== \"object\") {\n        throw new Error(\"Required «parameters.tableDefinition» to be an object on «LswDatabaseMigration.$validateCreateTableParameters»\");\n      }\n    }\n\n    async $$cloneDatabase() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$cloneDatabase\");\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n    }\n\n    async $$moveDatabase() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$moveDatabase\");\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.parameters.toDatabase,\n      });\n      await LswDatabase.deleteDatabase(this.parameters.fromDatabase);\n    }\n\n    async $$createTable() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$createTable\");\n      this.$validateCreateTableParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          schema[this.parameters.table] = this.parameters.tableDefinition;\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateDeleteTableParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateDeleteTableParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n    }\n\n    async $$deleteTable() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$deleteTable\");\n      this.$validateDeleteTableParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          delete schema[this.parameters.table];\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateRenameTableParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateRenameTableParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n      if (typeof this.parameters.tableSource !== \"string\") {\n        throw new Error(\"Required «parameters.tableSource» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n      if (typeof this.parameters.tableDestination !== \"string\") {\n        throw new Error(\"Required «parameters.tableDestination» to be a string on «LswDatabaseMigration.$validateDeleteTableParameters»\");\n      }\n    }\n\n    async $$renameTable() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$renameTable\");\n      this.$validateRenameTableParameters();\n      const currentSchema = await LswDatabase.getSchema(this.parameters.fromDatabase);\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          delete schema[this.parameters.tableSource];\n          const tableInput = this.$adaptSchemaTableAsSchemaDefinition(currentSchema[this.parameters.tableSource]);\n          schema[this.parameters.tableDestination] = tableInput;\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: tableId => {\n          return this.parameters.tableDestination;\n        },\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateCreateColumnParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateCreateColumnParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n      if (typeof this.parameters.column !== \"string\") {\n        throw new Error(\"Required «parameters.column» to be a string on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n      if (typeof this.parameters.columnDefinition !== \"object\") {\n        throw new Error(\"Required «parameters.columnDefinition» to be an object on «LswDatabaseMigration.$validateCreateColumnParameters»\");\n      }\n    }\n\n    async $$createColumn() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$createColumn\");\n      this.$validateCreateColumnParameters();\n      const isUnique = !!this.parameters.columnDefinition.isUnique;\n      const columnSymbol = `${isUnique ? \"!\" : \"\"}${this.parameters.column}`;\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        table: this.parameters.table,\n        onAlterSchema: schema => {\n          schema[this.parameters.table].push(columnSymbol);\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateDeleteColumnParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateDeleteColumnParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateDeleteColumnParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateDeleteColumnParameters»\");\n      }\n      if (typeof this.parameters.column !== \"string\") {\n        throw new Error(\"Required «parameters.column» to be a string on «LswDatabaseMigration.$validateDeleteColumnParameters»\");\n      }\n    }\n\n    async $$deleteColumn() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$deleteColumn\");\n      this.$validateDeleteColumnParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          console.log(schema);\n          const columnPosition = schema[this.parameters.table].indexOf(this.parameters.column);\n          schema[this.parameters.table].splice(columnPosition, 1);\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        // !@TOCONFIGURE: $$deleteColumn needs a specific hook (or none).\n        onMapTableId: false,\n        onMapColumnId: false,\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $validateRenameColumnParameters() {\n      LswDatabase.trace(\"LswDatabaseMigration.$validateRenameColumnParameters\");\n      if (typeof this.parameters.fromDatabase !== \"string\") {\n        throw new Error(\"Required «parameters.fromDatabase» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n      if (typeof this.parameters.table !== \"string\") {\n        throw new Error(\"Required «parameters.table» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n      if (typeof this.parameters.columnSource !== \"string\") {\n        throw new Error(\"Required «parameters.columnSource» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n      if (typeof this.parameters.columnDestination !== \"string\") {\n        throw new Error(\"Required «parameters.columnDestination» to be a string on «LswDatabaseMigration.$validateRenameColumnParameters»\");\n      }\n    }\n\n    async $$renameColumn() {\n      LswDatabase.trace(\"LswDatabaseMigration.$$renameColumn\");\n      this.$validateRenameColumnParameters();\n      await this.$replicateSchema({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onAlterSchema: schema => {\n          console.log(schema);\n          const columnPosition = schema[this.parameters.table].indexOf(this.parameters.columnSource);\n          schema[this.parameters.table].splice(columnPosition, 1);\n          schema[this.parameters.table].push(this.parameters.columnDestination);\n          return schema;\n        },\n      });\n      await this.$populateDatabase({\n        fromDatabase: this.parameters.fromDatabase,\n        toDatabase: this.config.temporaryDatabase,\n        onMapTableId: false,\n        onMapColumnId: (columnId) => {\n          return columnId;\n        },\n      });\n      await this.$$transferBackTemporaryDatabase();\n    }\n\n    $adaptSchemaAsSchemaDefinition(schemaDefinition) {\n      const output = {};\n      const tableIds = Object.keys(schemaDefinition);\n      for (let index = 0; index < tableIds.length; index++) {\n        const storeId = tableIds[index];\n        const tableDefinition = schemaDefinition[storeId];\n        const columns = tableDefinition.indexes;\n        if (!(storeId in output)) {\n          output[storeId] = [];\n        }\n        for (let indexColumn = 0; indexColumn < columns.length; indexColumn++) {\n          const column = columns[indexColumn];\n          const columnId = column.name;\n          const columnInput = this.$adaptSchemaColumnAsSchemaDefinition(column, columnId);\n          output[storeId].push(columnInput);\n        }\n      }\n      return output;\n    }\n\n    $adaptSchemaTableAsSchemaDefinition(tableDefinition) {\n      const output = [];\n      const columns = tableDefinition.indexes;\n      for (let indexColumn = 0; indexColumn < columns.length; indexColumn++) {\n        const column = columns[indexColumn];\n        const columnId = column.name;\n        const columnInput = this.$adaptSchemaColumnAsSchemaDefinition(column, columnId);\n        output.push(columnInput);\n      }\n      return output;\n    }\n\n    $adaptSchemaColumnAsSchemaDefinition(column, columnId) {\n      if (column.unique) {\n        return \"!\" + columnId;\n      } else {\n        return columnId;\n      }\n    }\n\n    async $replicateSchema(scenario) {\n      LswDatabase.trace(\"LswDatabaseMigration.$replicateSchema\");\n      const { fromDatabase, toDatabase, onAlterSchema } = scenario;\n      console.log(`⌛️ Replicating database from «${fromDatabase}» to «${toDatabase}» on «LswDatabaseMigration.$replicateSchema»`);\n      const schemaDefinition = await LswDatabase.getSchema(fromDatabase);\n      const schemaInput = this.$adaptSchemaAsSchemaDefinition(schemaDefinition);\n      let alteredSchema = schemaInput;\n      if (onAlterSchema) {\n        alteredSchema = onAlterSchema(schemaInput);\n        if (typeof alteredSchema === \"undefined\") {\n          throw new Error(\"Required «onAlterSchema» to return an object on «LswDatabaseMigration.$replicateSchema»\")\n        }\n      }\n      console.log(\"Replicated schema:\", alteredSchema);\n      await LswDatabase.createDatabase(toDatabase, alteredSchema);\n    }\n\n    async $populateDatabase(scenario) {\n      LswDatabase.trace(\"LswDatabaseMigration.$populateDatabase\");\n      const { fromDatabase, toDatabase, onMapTableId = false, onMapColumnId = false } = scenario;\n      console.log(`⌛️ Populating database from «${fromDatabase}» to «${toDatabase}» on «LswDatabaseMigration.$populateDatabase»`);\n      const schemaDefinition = await LswDatabase.getSchema(fromDatabase);\n      const tableIds = Object.keys(schemaDefinition);\n      let fromConnection = undefined;\n      let toConnection = undefined;\n      let indexTable = 0;\n      let indexColumn = 0;\n      let tableId = undefined;\n      let alteredTableId = undefined;\n      try {\n        fromConnection = new LswDatabase(fromDatabase);\n        toConnection = new LswDatabase(toDatabase);\n        await fromConnection.open();\n        await toConnection.open();\n        for (indexTable = 0; indexTable < tableIds.length; indexTable++) {\n          tableId = tableIds[indexTable];\n          console.log(\"table:\", tableId);\n          Transfering_tables: {\n            console.log(`⌛️ Transfering table «${tableId}» on «LswDatabaseMigration.$populateDatabase»`);\n            let allRows = await fromConnection.selectMany(tableId, v => true);\n            console.log(\"[*] Getting table id\");\n            alteredTableId = tableId;\n            if (onMapTableId) {\n              alteredTableId = onMapTableId(tableId);\n            }\n            console.log(\"[*] Getting column id\");\n            if (onMapColumnId) {\n              allRows = allRows.reduce((output, row) => {\n                const allKeys = Object.keys(row);\n                const alteredRow = {};\n                for (let indexKeys = 0; indexKeys < allKeys.length; indexKeys++) {\n                  console.log(\"column:\", indexKeys);\n                  const columnId = allKeys[indexKeys];\n                  const alteredColumnId = onMapColumnId(columnId, tableId, alteredTableId, {\n                    fromConnection,\n                    toConnection\n                  }) || columnId;\n                  alteredRow[alteredColumnId] = row[columnId];\n                }\n                output.push(alteredRow);\n                return output;\n              }, []);\n            }\n            console.log(\"[*] Got:\", alteredTableId, allRows);\n            await toConnection.insertMany(alteredTableId, allRows);\n            console.log(\"What??? 444\")\n          }\n        }\n      } catch (error) {\n        console.log(`💥 Error while populating database on table ${tableId || \"-\"} (alias «${alteredTableId}»):`, error);\n      } finally {\n        try {\n          await fromConnection.close();\n        } catch (error) {\n          console.log(error);\n        }\n        try {\n          await toConnection.close();\n        } catch (error) {\n          console.log(error);\n        }\n        console.log(`[*] Database «${toDatabase}» population finished successfully.`);\n      }\n    }\n\n  }\n\n  class LswDatabaseMigration extends BrowsieMigration {\n\n  }\n\n  LswDatabaseMigration.default = LswDatabaseMigration;\n  window.LswDatabaseMigration = LswDatabaseMigration;\n  window.BrowsieMigration = BrowsieMigration;\n\n  class BrowsieMigrable extends BrowsieCrudAPI {\n\n    static migration = LswDatabaseMigration;\n\n  }\n\n  window.Browsie = BrowsieMigrable;\n  Browsie.default = BrowsieMigrable;\n\n  /* Extended API */\n\n  class LswDatabase extends BrowsieMigrable {\n\n    class = this.constructor;\n\n  }\n\n  LswDatabase.default = LswDatabase;\n  window.LswDatabase = LswDatabase;\n",
            "$code.label": "LswDatabase class",
            "$output": "index.html"
          }
        ],
        "Lsw DatabaseVirtualizer API » LswDatabaseVirtualizer class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-database-virtualizer/lsw-database-virtualizer.js",
            "$location": {
              "start": {
                "offset": 310,
                "line": 14,
                "column": 1
              },
              "end": {
                "offset": 428,
                "line": 15,
                "column": 1
              }
            },
            "section": "Lsw DatabaseVirtualizer API » LswDatabaseVirtualizer class",
            "$code": "  const LswDatabaseVirtualizer = class {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    static start(...args) {\n      const virtualization = new this(...args);\n      return virtualization;\n    }\n\n    $lifecycle = [\n      \"onStart\",\n      \"onStartValidation\",\n      \"onValidateConnection\",\n      \"onValidateSchema\",\n      \"onFinishValidation\",\n      \"onDeleteVirtualDatabase\",\n      \"onStartClonation\",\n      \"onCloneDatabase\",\n      \"onFinishClonation\",\n      \"onStartVirtualization\",\n      \"onVirtualizeSchema\",\n      \"onVirtualizeTables\",\n      \"onVirtualizeColumns\",\n      \"onFinishVirtualization\",\n      \"onStartFormalization\",\n      \"onFormalizeColumns\",\n      \"onFormalizeTables\",\n      \"onFormalizeSchema\",\n      \"onReport\",\n      \"onFinishFormalization\",\n      \"onFinish\",\n    ];\n\n    $defaultConfigurations = {\n      trace: true,\n    };\n\n    $trace(method, args) {\n      if(this.$configurations.trace) {\n        const methodArgs = Array.from(args);\n        console.log(`[trace][lsw-database-virtualizer] ${method}: (${methodArgs.length}) ${methodArgs.map(e => typeof e).join(\", \")}`);\n      }\n    }\n\n    constructor(configurations = {}) {\n      this.$configurations = Object.assign({}, this.$defaultConfigurations, configurations || {});\n      this.$trace(\"constructor\", arguments);\n      this.triggers = new TriggersClass();\n      this.physicalConnection = undefined;\n      this.virtualConnection = undefined;\n      this.schema = undefined;\n    }\n\n    configure(options = {}) {\n      this.$trace(\"configure\", arguments);\n      $ensure({ options }, 1).to.have.uniquelyKeys([\"physicalConnection\", \"virtualConnection\", \"schema\"]);\n      Object.assign(this, options);\n      return this;\n    }\n\n    setPhysicalConnection(physicalConnection) {\n      this.$trace(\"setPhysicalConnection\", arguments);\n      this.physicalConnection = physicalConnection;\n      return this;\n    }\n\n    setVirtualConnection(virtualConnection) {\n      this.$trace(\"setVirtualConnection\", arguments);\n      this.virtualConnection = virtualConnection;\n      return this;\n    }\n\n    setSchema(schema) {\n      this.$trace(\"setSchema\", arguments);\n      this.schema = schema;\n      return this;\n    }\n\n    start() {\n      this.$trace(\"start\", arguments);\n      return LswCycler.from(this, \"*\").run(this.$lifecycle);\n    }\n\n    async onStart() {\n      this.$trace(\"onStart\", arguments);\n      // *@TODO:\n    }\n\n    async onStartValidation() {\n      this.$trace(\"onStartValidation\", arguments);\n      // *@TODO:\n    }\n\n    async onValidateConnection() {\n      this.$trace(\"onValidateConnection\", arguments);\n      // *@TODO:\n    }\n\n    async onValidateSchema() {\n      this.$trace(\"onValidateSchema\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishValidation() {\n      this.$trace(\"onFinishValidation\", arguments);\n      // *@TODO:\n    }\n\n    async onDeleteVirtualDatabase() {\n      this.$trace(\"onDeleteVirtualDatabase\", arguments);\n      // *@TODO:\n    }\n\n    async onStartClonation() {\n      this.$trace(\"onStartClonation\", arguments);\n      // *@TODO:\n    }\n\n    async onCloneDatabase() {\n      this.$trace(\"onCloneDatabase\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishClonation() {\n      this.$trace(\"onFinishClonation\", arguments);\n      // *@TODO:\n    }\n\n    async onStartVirtualization() {\n      this.$trace(\"onStartVirtualization\", arguments);\n      // *@TODO:\n    }\n\n    async onVirtualizeSchema() {\n      this.$trace(\"onVirtualizeSchema\", arguments);\n      // *@TODO:\n    }\n\n    async onVirtualizeTables() {\n      this.$trace(\"onVirtualizeTables\", arguments);\n      // *@TODO:\n    }\n\n    async onVirtualizeColumns() {\n      this.$trace(\"onVirtualizeColumns\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishVirtualization() {\n      this.$trace(\"onFinishVirtualization\", arguments);\n      // *@TODO:\n    }\n\n    async onStartFormalization() {\n      this.$trace(\"onStartFormalization\", arguments);\n      // *@TODO:\n    }\n\n    async onFormalizeColumns() {\n      this.$trace(\"onFormalizeColumns\", arguments);\n      // *@TODO:\n    }\n\n    async onFormalizeTables() {\n      this.$trace(\"onFormalizeTables\", arguments);\n      // *@TODO:\n    }\n\n    async onFormalizeSchema() {\n      this.$trace(\"onFormalizeSchema\", arguments);\n      // *@TODO:\n    }\n\n    async onFinishFormalization() {\n      this.$trace(\"onFinishFormalization\", arguments);\n      // *@TODO:\n    }\n\n    async onReport() {\n      this.$trace(\"onReport\", arguments);\n      // *@TODO:\n    }\n\n    async onFinish() {\n      this.$trace(\"onFinish\", arguments);\n      // *@TODO:\n    }\n\n  }\n",
            "$code.label": "LswDatabaseVirtualizer class",
            "$output": "index.html"
          }
        ],
        "Lsw Depender API » LswDepender class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-depender/lsw-depender.js",
            "$location": {
              "start": {
                "offset": 288,
                "line": 14,
                "column": 3
              },
              "end": {
                "offset": 502,
                "line": 24,
                "column": 6
              }
            },
            "$section": "Lsw Depender API » LswDepender class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswDepender",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-depender/lsw-depender.js",
            "$location": {
              "start": {
                "offset": 503,
                "line": 25,
                "column": 1
              },
              "end": {
                "offset": 588,
                "line": 26,
                "column": 1
              }
            },
            "section": "Lsw Depender API » LswDepender class",
            "$code": "  const Definition = class {\n    constructor({ id, dependencies = [] }) {\n      this.id = id;\n      this.dependencies = dependencies;\n    }\n  };\n\n  const LswDepender = class {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor(definitions = {}) {\n      this.$definitions = definitions;\n    }\n\n    hasDefined(name) {\n      if (name in this.$definitions) {\n        if (this.$definitions[name] instanceof Definition) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    define(...args) {\n      if (typeof args[0] === \"string\") {\n        return this.addDefinition(...args);\n      }\n      return this.addUniqueDefinitions(...args);\n    }\n\n    resolve(idsInput = this, defs = this.$definitions) {\n      const ids = idsInput === this ? Object.keys(this.$definitions) : idsInput;\n      let resolved = new Set();\n      let resultado = [];\n      const resolverNodo = function(id) {\n        console.log(\"resolviendo nodo:\", id, defs);\n        if (resolved.has(id)) return;\n        if (!defs[id]) return; // Si no está definido, lo ignoramos\n        for (let dep of defs[id].dependencies || []) {\n          resolverNodo(dep);\n        }\n        resolved.add(id);\n        resultado.push(id);\n      }\n      for (let id of [].concat(ids)) {\n        resolverNodo(id);\n      }\n      return resultado;\n    }\n\n    addDefinition(name, definition, shouldFailOnRedundancy = 1, shouldOverrideOnRedundancy = 1) {\n      Validation: {\n        if (this.hasDefined(name)) {\n          if (shouldFailOnRedundancy) {\n            throw new Error(`Dependency «${name}» is already defined and should not redund on «LswDepender.define»`);\n          } else if (!shouldOverrideOnRedundancy) {\n            return false; // !@BREAK: the fallback must not override it\n          } else if (shouldOverrideOnRedundancy) {\n            // !@OK: the fallback will override it\n          } else {\n            throw new Error(\"Cannot logically happen (1)\");\n          }\n        }\n      }\n      Define_it: {\n        if (typeof definition !== \"object\") {\n          throw new Error(`Required definition of «${name}» to be an object on «LswDepender.define»`);\n        } else if (typeof definition.id !== \"string\") {\n          definition.id = name;\n        } else if (Array.isArray(definition.dependencies)) {\n          throw new Error(`Required definition of «${name}» its property «dependencies» to be a array on «LswDepender.define»`);\n        } else {\n          for (let indexDependency = 0; indexDependency < definition.dependencies.length; indexDependency++) {\n            const dependencyRef = definition.dependencies[indexDependency];\n            if (typeof dependencyRef !== \"string\") {\n              throw new Error(`Required definition of «${name}» its property «dependencies» on its index «${indexDependency}» to be a string on «LswDepender.define»`);\n            }\n          }\n        }\n        this.$definitions[name] = new Definition(definition);\n      }\n    }\n\n    addUniqueDefinitions(moreDefinitions = {}) {\n      const definitionIds = Object.keys(moreDefinitions);\n      for (let indexId = 0; indexId < definitionIds.length; indexId++) {\n        const definitionId = definitionIds[indexId];\n        const definitionInstance = moreDefinitions[definitionId];\n        this.define(definitionId, definitionInstance, 1);\n      }\n    }\n\n    addMissingDefinitions(moreDefinitions = {}) {\n      const definitionIds = Object.keys(moreDefinitions);\n      for (let indexId = 0; indexId < definitionIds.length; indexId++) {\n        const definitionId = definitionIds[indexId];\n        const definitionInstance = moreDefinitions[definitionId];\n        this.define(definitionId, definitionInstance, 0, 0);\n      }\n    }\n\n    resetDefinitions(moreDefinitions = {}) {\n      const definitionIds = Object.keys(moreDefinitions);\n      for (let indexId = 0; indexId < definitionIds.length; indexId++) {\n        const definitionId = definitionIds[indexId];\n        const definitionInstance = moreDefinitions[definitionId];\n        this.define(definitionId, definitionInstance, 0, 1);\n      }\n    }\n\n    deleteDefinitions(definitionsInput = []) {\n      const definitions = Array.isArray(definitionsInput) ? definitionsInput : [definitionsInput];\n      for (let indexDefinition = 0; indexDefinition < definitions.length; indexDefinition++) {\n        const definitionId = definitions[indexDefinition];\n        delete this.$definitions[definitionId];\n      }\n    }\n\n  }\n\n  LswDepender.default = LswDepender;\n",
            "$code.label": "LswDepender class",
            "$output": "index.html"
          }
        ],
        "Lsw Dom API » LswDom class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-dom.js",
            "$location": {
              "start": {
                "offset": 281,
                "line": 15,
                "column": 3
              },
              "end": {
                "offset": 480,
                "line": 25,
                "column": 6
              }
            },
            "$section": "Lsw Dom API » LswDom class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswDom",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-dom.js",
            "$location": {
              "start": {
                "offset": 481,
                "line": 26,
                "column": 1
              },
              "end": {
                "offset": 551,
                "line": 27,
                "column": 1
              }
            },
            "section": "Lsw Dom API » LswDom class",
            "$code": "  const LswDom = class {\n\n    static collectLeaves(originalCollection, selectorSequence = []) {\n      $ensure(originalCollection).type(\"object\");\n      $ensure(selectorSequence).type(\"object\").to.be.array();\n      let collection = Array.isArray(originalCollection) ? originalCollection : [originalCollection];\n      const mapperFactory = selector => element => {\n        return [].concat(element.querySelectorAll(selector));\n      };\n      for(let indexSelector=0; indexSelector<selectorSequence.length; indexSelector++) {\n        const selector = selectorSequence[indexSelector];\n        const subnodes = collection.map(mapperFactory(selector)).flat();\n        collection = [].concat(subnodes);\n      }\n      return collection;\n    }\n\n    static getClosestParent(originalElement, selector) {\n      $ensure(originalElement).type(\"object\").to.be.instanceOf(HTMLElement);\n      $ensure(selector).type(\"string\");\n      let element = originalElement.parentElement;\n      while(element && (element !== document)) {\n        if(element.matches(selector)) {\n          return element;\n        }\n        element = element.parentElement;\n      }\n      return null;\n    }\n\n    static getClosestChildren(originalElement, selector) {\n      $ensure(originalElement).type(\"object\").to.be.instanceOf(HTMLElement);\n      $ensure(selector).type(\"string\");\n      return [...originalElement.querySelectorAll(selector)].filter(element => {\n        return this.getClosestParent(element, selector) === originalElement;\n      });\n    }\n\n  };\n",
            "$code.label": "LswDom class",
            "$output": "index.html"
          }
        ],
        "Lsw Vue2 API » LswVue2 class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-vue2.js",
            "$location": {
              "start": {
                "offset": 280,
                "line": 14,
                "column": 3
              },
              "end": {
                "offset": 482,
                "line": 24,
                "column": 6
              }
            },
            "$section": "Lsw Vue2 API » LswVue2 class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswVue2",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-dom/lsw-vue2.js",
            "$location": {
              "start": {
                "offset": 483,
                "line": 25,
                "column": 1
              },
              "end": {
                "offset": 556,
                "line": 26,
                "column": 1
              }
            },
            "section": "Lsw Vue2 API » LswVue2 class",
            "$code": "  const LswVue2 = class {\n\n    static getClosestParent(component, filterCallback) {\n      $ensure(component).type(\"object\");\n      $ensure(filterCallback).type(\"function\");\n      let parentOf = component;\n      do {\n        parentOf = parentOf.$parent;\n        const isValid = filterCallback(parentOf);\n        if (isValid) {\n          return parentOf;\n        }\n      } while (typeof parentOf !== \"undefined\");\n      return undefined;\n    }\n\n    static extendComponent(baseComponent = {}) {\n      const extendedComponent = Object.assign({}, baseComponent);\n      extendedComponent.props = Object.assign({}, baseComponent.props || {});\n      extendedComponent.methods = Object.assign({}, baseComponent.methods || {});\n      extendedComponent.watch = Object.assign({}, baseComponent.watch || {});\n      extendedComponent.computed = Object.assign({}, baseComponent.computed || {});\n      return extendedComponent;\n    }\n\n  }\n",
            "$code.label": "LswVue2 class",
            "$output": "index.html"
          }
        ],
        "Lsw Ensurer API » LswEnsurer class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-ensurer/ensure.js",
            "$location": {
              "start": {
                "offset": 286,
                "line": 14,
                "column": 3
              },
              "end": {
                "offset": 497,
                "line": 24,
                "column": 6
              }
            },
            "$section": "Lsw Ensurer API » LswEnsurer class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswEnsurer",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-ensurer/ensure.js",
            "$location": {
              "start": {
                "offset": 498,
                "line": 25,
                "column": 1
              },
              "end": {
                "offset": 580,
                "line": 26,
                "column": 1
              }
            },
            "section": "Lsw Ensurer API » LswEnsurer class",
            "$code": "  class AssertionError extends Error {\n\n    constructor(...args) {\n      super(...args);\n      this.name = \"AssertionError\";\n    }\n\n  }\n\n  class Ensurement {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor(source, asLabeledObject = 0) {\n      Resolve_subject: {\n        if ((asLabeledObject === 1) && (typeof source === \"object\")) {\n          const sourceKeys = Object.keys(source);\n          if (sourceKeys.length !== 1) {\n            throw new Error(`The first parameter of $ensure or $check {when $2 is literally 1} must have 1 property (not ${sourceKeys.length}) on «Ensurement.constructor»`);\n          }\n          this.$subjectId = sourceKeys[0];\n          this.$subject = source[this.$subjectId];\n        } else if(typeof asLabeledObject === \"string\") {\n          this.$subjectId = asLabeledObject;\n          this.$subject = source;\n        } else {\n          this.$subjectId = \"@\";\n          this.$subject = source;\n        }\n      }\n      this.$operation = undefined;\n      this.$objectation = undefined;\n      this.asBoolean = false;\n    }\n    type(value) {\n      this.$operation = \"is of type\";\n      this.$objectation = value;\n      if(typeof value === \"string\") {\n        if (typeof this.$subject !== value) {\n          return this.$asFailed();\n        }\n      } else if(Array.isArray(value)) {\n        if(value.indexOf(typeof this.$subject) === -1) {\n          return this.$asFailed();\n        }\n      } else {\n        throw new Error(`Bad parameter on «$ensure(...).type(?)» (${typeof value} not admitted)`);\n      }\n      return this.$asResolved();\n    }\n    notType(value) {\n      this.$operation = \"is not of type\";\n      this.$objectation = value;\n      if (typeof this.$subject === value) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    is(value) {\n      this.$operation = \"is\";\n      this.$objectation = value;\n      if (this.$subject !== value) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    isnt(value) {\n      this.$operation = \"is not\";\n      this.$objectation = value;\n      if (this.$subject === value) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    can(value) {\n      this.$operation = \"can\";\n      this.$objectation = value;\n      if (!value(this.$subject)) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    cant(value) {\n      this.$operation = \"cant\";\n      this.$objectation = value;\n      if (value(this.$subject)) {\n        return this.$asFailed();\n      }\n      return this.$asResolved();\n    }\n    throws(value) {\n      this.$operation = \"throws\";\n      this.$objectation = value;\n      try {\n        objectation(this.$subject);\n        return this.$asFailed();\n      } catch (error) {\n        return this.$asResolved();\n      }\n    }\n    doesntThrow(value) {\n      this.$operation = \"doesntThrow\";\n      this.$objectation = value;\n      try {\n        value(this.$subject);\n        return this.$asFailed();\n      } catch (error) {\n        return this.$asResolved();\n      }\n    }\n    $asFailed(operation = this.$operation) {\n      if (this.asBoolean) {\n        return false;\n      }\n      throw new AssertionError(\"could not ensure «\" + this.$subjectId + \"» \" + operation + (this.$objectation ? \" «\" + this.$getObjectationAsString() + \"»\": \"\") + \"\");\n    }\n    $getObjectationAsString() {\n      return JSON.stringify(this.$objectation);\n    }\n    $asResolved() {\n      if (this.asBoolean) {\n        return true;\n      } else {\n        return this;\n      }\n    }\n  };\n\n  const BasicToBeInterface = class {\n    $isNegated = false;\n    set $operation(value) {\n      this.$ensurement.$operation = value;\n    }\n    get $operation() {\n      return this.$ensurement.$operation;\n    }\n    set $objectation(value) {\n      this.$ensurement.$objectation = value;\n    }\n    get $objectation() {\n      return this.$ensurement.$objectation;\n    }\n    constructor(ensurement) {\n      this.$ensurement = ensurement;\n      this.$subject = this.$ensurement.$subject;\n    }\n    $makeNegable(condition) {\n      return this.$isNegated === true ? !condition : condition;\n    }\n    $asFailed() {\n      return this.$ensurement.$asFailed();\n    }\n    $resolveNegableString(text) {\n      return text.replace(/\\{not\\?\\} */g, this.$isNegated ? \"not \" : \"\");\n    }\n  };\n\n  const ToBeInterface = class extends BasicToBeInterface {\n    string() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be string\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"string\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    number() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be number\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"number\") || Number.isNaN(this.$subject)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    object() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be object\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"object\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    null() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be null\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== null)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    undefined() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be undefined\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"undefined\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    boolean() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be boolean\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof this.$subject !== \"boolean\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    instanceOf(clazz) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be instanceOf\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(!(this.$subject instanceof clazz))) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    array() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be array\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(!Array.isArray(this.$subject))) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    function() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be function\");\n      this.$objectation = undefined;\n      if (this.$makeNegable(typeof (this.$subject) !== \"function\")) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    empty() {\n      this.$operation = this.$resolveNegableString(\"to {not?} be empty\");\n      this.$objectation = undefined;\n      const isEmpty = (() => {\n        const s = this.$subject;\n        if (Array.isArray(s)) {\n          return s.length === 0;\n        } else if (typeof s === \"object\") {\n          return s === null || Object.keys(s).length === 0;\n        } else if (typeof s === \"string\") {\n          return s === \"\";\n        } else if (typeof s === \"number\") {\n          return s === 0;\n        } else if (typeof s === \"boolean\") {\n          return s === false;\n        } else {\n          return true;\n        }\n      })();\n      if (this.$makeNegable(!isEmpty)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    equalTo(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be equal to\");\n      this.$objectation = value;\n      let isEqual = this.$subject === value;\n      if (this.$makeNegable(!isEqual)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    equalOrGreaterThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be equal or greater than\");\n      this.$objectation = value;\n      let isGreaterOrEqual = this.$subject >= value;\n      if (this.$makeNegable(!isGreaterOrEqual)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    greaterThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be greater than\");\n      this.$objectation = value;\n      let isGreater = this.$subject > value;\n      if (this.$makeNegable(!isGreater)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    greaterOrEqualTo(...args) {\n      return this.equalOrGreaterThan(...args);\n    }\n    equalOrLowerThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} equal or lower than\");\n      this.$objectation = value;\n      let isGreaterOrEqual = this.$subject <= value;\n      if (this.$makeNegable(!isGreaterOrEqual)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    lowerThan(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be lower than\");\n      this.$objectation = value;\n      let isGreater = this.$subject < value;\n      if (this.$makeNegable(!isGreater)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    lowerOrEqualTo(value) {\n      return this.equalOrLowerThan(...args);\n    }\n    oneOf(value) {\n      this.$operation = this.$resolveNegableString(\"to {not?} be one of\");\n      this.$objectation = value;\n      if(!Array.isArray(value)) {\n        throw new Error(`Required on «$ensure(...).to.be.oneOf(!)» to provide an array on «ToBeInterface.oneOf»`);\n      }\n      let isOne = this.$objectation.indexOf(this.$subject) !== -1;\n      if (this.$makeNegable(!isOne)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n  };\n\n  const ToNotBeInterface = class extends ToBeInterface {\n    $isNegated = true;\n  };\n\n  const ToHaveInterface = class extends BasicToBeInterface {\n\n    text(prop) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have text\");\n      this.$objectation = prop;\n      const hasSubstring = this.$subject.indexOf(prop) !== -1;\n      if (this.$makeNegable(!hasSubstring)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n    \n    key(prop) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have key\");\n      this.$objectation = prop;\n      const keys = Object.keys(this.$subject);\n      const hasKey = keys.indexOf(prop) !== -1;\n      if (this.$makeNegable(!hasKey)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    value(prop) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have value\");\n      this.$objectation = prop;\n      const values = Object.values(this.$subject);\n      const hasValue = values.indexOf(prop) !== -1;\n      if (this.$makeNegable(!hasValue)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    onlyPotentialKeys(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have only potential keys\");\n      this.$objectation = props;\n      const keys = Object.keys(this.$subject);\n      let hasOnly = true;\n      Iterating_props:\n      for (let index = 0; index < keys.length; index++) {\n        const key = keys[index];\n        if (props.indexOf(key) === -1) {\n          hasOnly = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasOnly)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    keys(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have keys\");\n      this.$objectation = props;\n      const keys = Object.keys(this.$subject);\n      let hasKeys = true;\n      Iterating_props:\n      for (let index = 0; index < props.length; index++) {\n        const prop = props[index];\n        if (keys.indexOf(prop) === -1) {\n          hasKeys = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasKeys)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    values(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have values\");\n      this.$objectation = props;\n      const values = Object.values(this.$subject);\n      let hasValues = true;\n      Iterating_props:\n      for (let index = 0; index < props.length; index++) {\n        const prop = props[index];\n        if (values.indexOf(prop) === -1) {\n          hasValues = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasValues)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    uniquelyKeys(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have uniquelyKeys\");\n      this.$objectation = props;\n      const keys = Object.keys(this.$subject);\n      let hasKeys = true;\n      Iterating_props:\n      for (let index = 0; index < keys.length; index++) {\n        const key = keys[index];\n        if (props.indexOf(key) === -1) {\n          hasKeys = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasKeys)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n    uniquelyValues(props) {\n      this.$operation = this.$resolveNegableString(\"to {not?} have uniquelyValues\");\n      this.$objectation = props;\n      const values = Object.values(this.$subject);\n      let hasValues = true;\n      Iterating_props:\n      for (let index = 0; index < values.length; index++) {\n        const value = values[index];\n        if (props.indexOf(value) === -1) {\n          hasValues = false;\n          break Iterating_props;\n        }\n      }\n      if (this.$makeNegable(!hasValues)) return this.$asFailed();\n      return this.$ensurement.$asResolved();\n    }\n\n  };\n\n  const ToNotHaveInterface = class extends ToHaveInterface {\n    $isNegated = true;\n  };\n\n  const EnsurementV1 = class extends Ensurement {\n\n    selfExtend(obj) {\n      return Object.assign(this, obj);\n    }\n\n    get $toNotBe() {\n      return new ToNotBeInterface(this);\n    }\n\n    get $toNotHave() {\n      return new ToNotHaveInterface(this);\n    }\n\n    get $toNot() {\n      return {\n        be: this.$toNotBe,\n        have: this.$toNotHave,\n      }\n    }\n\n    get $toBe() {\n      return new ToBeInterface(this);\n    }\n\n    get $toHave() {\n      return new ToHaveInterface(this);\n    }\n\n    get to() {\n      return {\n        be: this.$toBe,\n        have: this.$toHave,\n        not: this.$toNot,\n      };\n    }\n\n    its(id) {\n      return this.constructor.create({\n        [id]: this.$subject[id]\n      }, 1).selfExtend({\n        $parent: this,\n        asBoolean: this.asBoolean,\n      });\n    }\n\n    getSubject() {\n      return this.$subject;\n    }\n\n    safelyBack(levels = 1) {\n      for (let index = 0; index < levels; index++) {\n        try {\n          parent = this.$parent;\n        } catch (error) {\n          // @OK.\n        }\n      }\n    }\n\n    back(levels = 1) {\n      let parent = this;\n      for (let index = 0; index < levels; index++) {\n        try {\n          parent = this.$parent;\n        } catch (error) {\n          throw new Error(`Ensurement could not go «back» reaching parent on level «${index}» on «ensure(...).back»`);\n        }\n      }\n      return parent;\n    }\n\n    static $or(options) {\n      let correctOption = undefined;\n      const allIds = Object.keys(options);\n      const orError = new Error(`could not ensure «or» group with options: «${allIds.join(\"», «\")}»`);\n      for(let index=0; index<allIds.length; index++) {\n        const currentId = allIds[index];\n        const currentOptionCallback = options[currentId];\n        try {\n          currentOptionCallback();\n          return currentId;\n        } catch (error) {\n          orError.appendError(error);\n        }\n      }\n      throw orError.unified();\n    }\n\n    static ensure(...args) {\n      return this.create(...args);\n    }\n\n    static check(...args) {\n      return this.create(...args).selfExtend({\n        asBoolean: true\n      });\n    }\n\n    static assert(condition, errorMessage = \"Assertion error happened\") {\n      if (!condition) {\n        throw new AssertionError(errorMessage);\n      }\n      return true;\n    }\n\n    static fails(callback, errorMessage = \"Assertion error happened\") {\n      let passes = true;\n      try {\n        callback();\n        passes = false;\n      } catch (error) {\n        return true;\n      }\n      if (!passes) {\n        throw new AssertionError(errorMessage);\n      }\n    }\n\n    static AssertionError = AssertionError;\n\n  };\n\n  Export_to_globals: {\n    globalThis.$fails = EnsurementV1.fails.bind(EnsurementV1);\n    globalThis.$ensure = EnsurementV1.ensure.bind(EnsurementV1);\n    globalThis.$check = EnsurementV1.check.bind(EnsurementV1);\n    globalThis.$assert = EnsurementV1.assert.bind(EnsurementV1);\n    // globalThis.AssertionError = AssertionError;\n    globalThis.$ensure.$or = EnsurementV1.$or;\n  }\n  \n  return EnsurementV1;\n",
            "$code.label": "LswEnsurer class",
            "$output": "index.html"
          }
        ],
        "Lsw ErrorManager API » LswErrorManager class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-error-manager/lsw-error-manager.js",
            "$location": {
              "start": {
                "offset": 2,
                "line": 3,
                "column": 1
              },
              "end": {
                "offset": 208,
                "line": 13,
                "column": 4
              }
            },
            "$section": "Lsw ErrorManager API » LswErrorManager class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswErrorManager",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-error-manager/lsw-error-manager.js",
            "$location": {
              "start": {
                "offset": 209,
                "line": 14,
                "column": 1
              },
              "end": {
                "offset": 304,
                "line": 15,
                "column": 1
              }
            },
            "section": "Lsw ErrorManager API » LswErrorManager class",
            "$code": "\nglobalThis.ErrorSummary = class {\n  constructor(data) {\n    Object.assign(this, data);\n  }\n  toString() {\n    return JSON.stringify(this, null, 2);\n  }\n}\n\nglobalThis.Error = class AccumulableError extends Error {\n  constructor(...args) {\n    super(...args);\n    this.$accumulatedErrors = [];\n  }\n  toString() {\n    return JSON.stringify(this, null, 2);\n  }\n  toJSON() {\n    const data = {\n      name: this.name || \"Error\",\n      message: this.message || \"\",\n      stack: this.stack ? this.stack.split(\"\\n    at \") : \"\",\n      ...this,\n    };\n    if (this.$accumulatedErrors && this.$accumulatedErrors.length) {\n      data.$accumulatedErrors = this.$accumulatedErrors;\n    }\n    return data;\n  }\n  unified() {\n    this.message = this.message + \"\\n\" + this.$accumulatedErrors.map((e, i) => (i + 1) + ': ' + e.name + ': ' + e.message).join(\"\\n\");\n    this.$accumulatedErrors = [];\n    return this;\n  }\n  prependError(error) {\n    this.$accumulatedErrors.unshift(error);\n    return this;\n  }\n  appendError(error) {\n    this.$accumulatedErrors.push(error);\n    return this;\n  }\n  summarized() {\n    let uniqueTraces = [];\n    let commonTraces = [];\n    // Recopilar las trazas de la pila de errores acumulados\n    const allStacks = this.$accumulatedErrors.map(\n      (error) => (error.stack ? error.stack.split(\"\\n    at \") : [])\n    );\n    // Si no hay acumulados, no hay comunes ni únicos\n    if (allStacks.length === 0) {\n      return new ErrorSummary({\n        name: this.name,\n        message: this.message,\n        stack: this.stack ? this.stack.split(\"\\n    at \") : [],\n        uniqueTraces: uniqueTraces,\n        commonTraces: commonTraces,\n      });\n    }\n    // Identificar trazas comunes\n    const firstStack = allStacks[0];\n    for (let i = 0; i < firstStack.length; i++) {\n      const trace = firstStack[i];\n      let isCommon = true;\n      for (let j = 1; j < allStacks.length; j++) {\n        if (!allStacks[j].includes(trace)) {\n          isCommon = false;\n          break;\n        }\n      }\n      if (isCommon) {\n        commonTraces.push(trace);\n      }\n    }\n    // Identificar trazas únicas\n    for (let i = 0; i < allStacks.length; i++) {\n      const uniqueForStack = [];\n      for (let j = 0; j < allStacks[i].length; j++) {\n        const trace = allStacks[i][j];\n        if (!commonTraces.includes(trace)) {\n          uniqueForStack.push(trace);\n        }\n      }\n      uniqueTraces.push(uniqueForStack);\n    }\n    return new ErrorSummary({\n      ...this,\n      name: this.name,\n      message: this.message,\n      stack: this.stack ? this.stack.split(\"\\n    at \") : [],\n      uniqueTraces: uniqueTraces,\n      commonTraces: commonTraces,\n    });\n  }\n\n}\n\n",
            "$code.label": "LswErrorManager class",
            "$output": "index.html"
          }
        ],
        "UFS Manager API » UFS_manager class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-filesystem/ufs-v1.0.2.js",
            "$location": {
              "start": {
                "offset": 326,
                "line": 9,
                "column": 1
              },
              "end": {
                "offset": 408,
                "line": 10,
                "column": 1
              }
            },
            "section": "UFS Manager API » UFS_manager class",
            "$code": "(function (factory) {\n  const name = \"UFS_manager\";\n  const modulo = factory();\n  if (typeof window !== 'undefined') {\n    window[name] = modulo;\n  }\n  if (typeof module !== 'undefined') {\n    module.exports = modulo;\n  }\n  if (typeof global !== 'undefined') {\n    global[name] = modulo;\n  }\n  return modulo;\n})(function () {\n  const FilesystemError = class extends Error {\n    constructor(...args) {\n      super(...args);\n      this.name = \"FilesystemError\";\n    }\n  }\n  const UFS_manager_for_node = class {\n    constructor() {\n      // @OK\n    }\n    init() {\n      return this;\n    }\n    trace(method, args = []) {\n      console.log(\"[ufs][node-driver][\" + method + \"]\", Array.from(args).map(arg => typeof (arg) + \": \" + arg).join(\", \"));\n    }\n    resolve_path(...args) {\n      this.trace(\"resolve_path\", arguments);\n      return require(\"path\").resolve(...args);\n    }\n    get_current_directory() {\n      this.trace(\"get_current_directory\", arguments);\n      return process.cwd();\n    }\n    change_directory(node) {\n      this.trace(\"change_directory\", arguments);\n      return process.chdir(node);\n    }\n    rename(node, node2) {\n      this.trace(\"rename\", arguments);\n      return require(\"fs\").renameSync(node, node2);\n    }\n    read_directory(node) {\n      this.trace(\"read_directory\", arguments);\n      return require(\"fs\").readdirSync(node).reduce((out, item) => {\n        const subnode_fullpath = require(\"path\").resolve(node, item);\n        out[item] = require(\"fs\").lstatSync(subnode_fullpath).isFile() ? \"...\" : {};\n        return out;\n      }, {});\n    }\n    read_file(node) {\n      this.trace(\"read_file\", arguments);\n      return require(\"fs\").readFileSync(node).toString();\n    }\n    make_directory(node) {\n      this.trace(\"make_directory\", arguments);\n      return require(\"fs\").mkdirSync(node);\n    }\n    write_file(node, contents) {\n      this.trace(\"write_file\", arguments);\n      return require(\"fs\").writeFileSync(node, contents);\n    }\n    exists(node) {\n      this.trace(\"exists\", arguments);\n      return require(\"fs\").existsSync(node);\n    }\n    is_file(node) {\n      this.trace(\"is_file\", arguments);\n      return require(\"fs\").lstatSync(node).isFile();\n    }\n    is_directory(node) {\n      this.trace(\"is_directory\", arguments);\n      return require(\"fs\").lstatSync(node).isDirectory();\n    }\n    delete_file(node) {\n      this.trace(\"delete_file\", arguments);\n      return require(\"fs\").unlinkSync(node);\n    }\n    delete_directory(node) {\n      this.trace(\"delete_directory\", arguments);\n      return require(\"fs\").rmdirSync(node, { recursive: true });\n    }\n  }\n\n  const UFS_manager_for_localstorage = class extends UFS_manager_for_node {\n    constructor(storage_id = \"ufs_main_storage\") {\n      super();\n      this.storage_id = storage_id;\n      this.current_directory = this.environment === \"node\" ? process.cwd : \"/\";\n    }\n    trace(method, args = []) {\n      console.log(\"[ufs][ls-driver][\" + method + \"]\", Array.from(args).map(arg => typeof (arg) + \": \" + arg).join(\", \"));\n    }\n    get_persisted_data() {\n      this.trace(\"get_persisted_data\", arguments);\n      if (!(this.storage_id in localStorage)) {\n        localStorage[this.storage_id] = '{\"files\":{}}';\n      }\n      const data = JSON.parse(localStorage[this.storage_id]);\n      return data;\n    }\n    set_persisted_data(data) {\n      this.trace(\"set_persisted_data\", arguments);\n      localStorage[this.storage_id] = JSON.stringify(data);\n    }\n    remove_slash_end(txt) {\n      // this.trace(\"remove_slash_end\", arguments);\n      const txt2 = txt.replace(/\\/$/g, \"\");\n      if (txt2.length === 0) {\n        return \"/\";\n      }\n      return txt2;\n    }\n    remove_repeated_slahes(txt) {\n      // this.trace(\"remove_repeated_slahes\", arguments);\n      return txt.replace(/\\/(\\/)+/g, \"/\");\n    }\n    resolve_path(...args) {\n      this.trace(\"resolve_path\", arguments);\n      Validate_args: {\n        if (args.length === 0) {\n          throw new Error(\"Method «resolve_path» requires 1 or more parameters\");\n        }\n        for (let index_parameter = 0; index_parameter < args.length; index_parameter++) {\n          const arg = args[index_parameter];\n          if (typeof arg !== \"string\") {\n            throw new Error(\"Method «resolve_path» requires only strings as parameters (on index «\" + index_parameter + \"»)\");\n          }\n        }\n      }\n      let path_parts = [];\n      Format_path: {\n        const replace_last_slash_for_nothing = arg => this.remove_slash_end(arg);\n        path_parts = args.map(replace_last_slash_for_nothing);\n        if (!path_parts[0].startsWith(\"/\")) {\n          path_parts.unshift(this.current_directory.replace(/\\/$/g, \"\"));\n        }\n      }\n      let path_text = \"\";\n      Join_path: {\n        const replace_fist_slash_for_nothing = arg => arg.replace(/^\\//g, \"\");\n        for (let index_part = 0; index_part < path_parts.length; index_part++) {\n          const path_part = path_parts[index_part];\n          if (path_part.startsWith(\"/\")) {\n            path_text = path_part;\n          } else {\n            if (path_text !== \"/\") {\n              path_text += \"/\";\n            }\n            path_text += path_part.replace(replace_fist_slash_for_nothing);\n          }\n        }\n      }\n      Fix_slash_repetitions: {\n        path_text = this.remove_repeated_slahes(path_text);\n      }\n      Resolve_double_dots: {\n        const parts = path_text.split(\"/\");\n        const stack = [];\n        Iterating_parts:\n        for (const part of parts) {\n          if (part === \"\" || part === \".\") {\n            continue Iterating_parts;\n          } else if (part === \"..\") {\n            if (stack.length > 0) {\n              stack.pop();\n            }\n          } else {\n            stack.push(part);\n          }\n        }\n        path_text = \"/\" + stack.join(\"/\");\n      }\n      return path_text;\n    }\n    get_current_directory() {\n      this.trace(\"get_current_directory\", arguments);\n      return this.resolve_path(this.current_directory);\n    }\n    change_directory(node) {\n      this.trace(\"change_directory\", arguments);\n      const is_directory = this.exists(node);\n      if (!is_directory) {\n        throw new FilesystemError(\"Cannot «change_directory» because destination does not exist at: «\" + this.resolve_path(node) + \"»\");\n      }\n      this.current_directory = this.resolve_path(node);\n      return this.current_directory;\n    }\n    operate_on_node(node, callback, should_persist = true) {\n      this.trace(\"operate_on_node\", arguments);\n      const data = this.get_persisted_data();\n      const node_solved = this.resolve_path(node);\n      const node_parts = node_solved.split(\"/\").filter(p => p !== \"\");\n      const root = data.files;\n      const current_index = [\"data\"];\n      let pivot = root;\n      let output = undefined;\n      if (node_parts.length === 0) {\n        output = callback(data, \"files\", current_index);\n      } else {\n        for (let index_part = 0; index_part < node_parts.length; index_part++) {\n          const node_part = node_parts[index_part];\n          if (index_part === (node_parts.length - 1)) {\n            output = callback(pivot, node_part, current_index);\n          } else {\n            pivot = pivot[node_part];\n          }\n          current_index.push(node_part);\n        }\n      }\n      if (should_persist) {\n        this.set_persisted_data(data);\n      }\n      return output;\n    }\n    read_directory(node) {\n      this.trace(\"read_directory\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          throw new FilesystemError(\"Cannot «read_directory» because node does not exist at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"object\") {\n          throw new FilesystemError(\"Cannot «read_directory» because node is a file at: «\" + this.resolve_path(node) + \"»\");\n        }\n        return pivot[last_property];\n      });\n    }\n    read_file(node) {\n      this.trace(\"read_file\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          throw new FilesystemError(\"Cannot «read_file» because node does not exist at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"string\") {\n          throw new FilesystemError(\"Cannot «read_file» because node is a directory at: «\" + this.resolve_path(node) + \"»\");\n        }\n        return pivot[last_property];\n      });\n    }\n    make_directory(node) {\n      this.trace(\"make_directory\", arguments);\n      this.operate_on_node(node, (pivot, last_property, index) => {\n        if (last_property in pivot) {\n          throw new FilesystemError(\"Cannot «make_directory» because node already exists at: «\" + this.resolve_path(node) + \"»\");\n        }\n        pivot[last_property] = {};\n      });\n    }\n    write_file(node, contents) {\n      this.trace(\"write_file\", arguments);\n      this.operate_on_node(node, (pivot, last_property, index) => {\n        if (last_property in pivot) {\n          if (typeof pivot[last_property] !== \"string\") {\n            throw new FilesystemError(\"Cannot «write_file» because node is a directory at: «\" + this.resolve_path(node) + \"»\");\n          }\n        }\n        pivot[last_property] = contents;\n      });\n    }\n    exists(node) {\n      this.trace(\"exists\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          return false;\n        }\n        return true;\n      }, false);\n    }\n    is_file(node) {\n      this.trace(\"is_file\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          return false;\n        }\n        if (typeof pivot[last_property] !== \"string\") {\n          return false;\n        }\n        return true;\n      }, false);\n    }\n    is_directory(node) {\n      this.trace(\"is_directory\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (!(last_property in pivot)) {\n          return false;\n        }\n        if (typeof pivot[last_property] !== \"object\") {\n          return false;\n        }\n        return true;\n      }, false);\n    }\n    delete_file(node) {\n      this.trace(\"delete_file\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (typeof pivot[last_property] === \"undefined\") {\n          throw new FilesystemError(\"Cannot «delete_file» because node does not exist at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"string\") {\n          throw new FilesystemError(\"Cannot «delete_file» because node is a directory at: «\" + this.resolve_path(node) + \"»\");\n        }\n        delete pivot[last_property];\n        return true;\n      }, true);\n    }\n    delete_directory(node) {\n      this.trace(\"delete_directory\", arguments);\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (typeof pivot[last_property] === \"undefined\") {\n          console.log(pivot);\n          console.log(last_property);\n          throw new FilesystemError(\"Cannot «delete_directory» because does not exists at: «\" + this.resolve_path(node) + \"»\");\n        }\n        if (typeof pivot[last_property] !== \"object\") {\n          throw new FilesystemError(\"Cannot «delete_directory» because node is a file at: «\" + this.resolve_path(node) + \"»\");\n        }\n        delete pivot[last_property];\n        return true;\n      }, true);\n    }\n    rename(node, node2) {\n      this.trace(\"rename\", arguments);\n      const last_name = this.resolve_path(node2).split(\"/\").filter(p => p !== \"\").pop();\n      return this.operate_on_node(node, (pivot, last_property, index) => {\n        if (typeof pivot[last_property] === \"undefined\") {\n          throw new FilesystemError(\"Cannot «rename» because does not exists at: «\" + this.resolve_path(node) + \"»\");\n        }\n        pivot[last_name] = pivot[last_property];\n        pivot[last_property] = undefined;\n        delete pivot[last_property];\n        return true;\n      }, true);\n    }\n\n  }\n\n  const UFS_manager_for_idb = class extends UFS_manager_for_localstorage {\n\n    constructor(db_name = \"ufs_db\") {\n      super();\n      this.db_name = db_name;\n      this.db = null;\n      this.current_directory = \"/\";\n    }\n\n    trace(method, args = []) {\n      console.log(\"[ufs][idb-driver][\" + method + \"]\", Array.from(args).map(arg => typeof (arg) + \": \" + arg).join(\", \"));\n    }\n\n    init() {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.db_name, 1);\n        request.onupgradeneeded = (event) => {\n          let db = event.target.result;\n          if (!db.objectStoreNames.contains(\"ufs\")) {\n            let store = db.createObjectStore(\"ufs\", {\n              keyPath: \"id\",\n              autoIncrement: true,\n            });\n            store.createIndex(\"filepath\", \"filepath\", { unique: true });\n          }\n        };\n        request.onsuccess = (event) => {\n          this.db = event.target.result;\n          resolve();\n        };\n        request.onerror = (event) => reject(event.target.error);\n      });\n    }\n\n    _get_filename(somepath) {\n      return somepath.split(\"/\").filter(p => typeof (p) !== \"undefined\").pop();\n    }\n\n    isImmediateSubpathFrom(subpath, matchable) {\n      const matchablePos = matchable.length;\n      const coincidesParentPath = subpath.substr(0, matchablePos) === matchable;\n      if (!coincidesParentPath) return false;\n      const hasNoMoreSlashes = subpath.substr(matchablePos).indexOf(\"/\") === -1;\n      if (!hasNoMoreSlashes) return false;\n      return true;\n    }\n\n    read_directory(parentIdInput = \"/\") {\n      this.trace(\"read_directory\", arguments);\n      const parentId = this.resolve_path(parentIdInput);\n      return new Promise((resolve, reject) => {\n        The_previous_process: {\n          break The_previous_process;\n          const transaction = this.db.transaction(\"ufs\", \"readonly\");\n          const store = transaction.objectStore(\"ufs\");\n          const index = store.index(\"filepath\");\n          const request = index.getAll(parentId);\n          request.onsuccess = () => {\n            let result = {};\n            for (let item of request.result) {\n              result[item.name] = item.type === \"file\" ? \"...\" : {};\n            }\n            resolve(result);\n          };\n        }\n        const transaction = this.db.transaction(\"ufs\", 'readonly');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria\n        const results = [];\n        const matchableSubpath = (parentId === \"/\") ? parentId : (parentId + \"/\");\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            let isAccepted = false;\n            try {\n              isAccepted = cursor.value.filepath.startsWith(matchableSubpath);\n              isAccepted = isAccepted && this.isImmediateSubpathFrom(cursor.value.filepath, matchableSubpath);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «browsie.selectMany»\", error);\n            }\n            if (isAccepted) {\n              // Añade a la colección de salida\n              results.push(cursor.value);\n            }\n            cursor.continue(); // Avanza al siguiente registro\n          } else {\n            // Se formatean los resultados:\n            const formattedResults = {};\n            results.forEach(row => {\n              const rowName = this._get_filename(row.filepath);\n              formattedResults[rowName] = row.type === \"file\" ? \"...\" : {};\n            });\n            resolve(formattedResults);\n          }\n        };\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    read_file(nodeInput) {\n      this.trace(\"read_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => {\n          resolve(request.result ? request.result.content : null);\n        };\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    async write_file(nodeInput, contents) {\n      this.trace(\"write_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      const file = await this.$filepath(node);\n      return await new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readwrite\");\n        const store = transaction.objectStore(\"ufs\");\n        const filedata = { filepath: node, type: \"file\", content: contents };\n        if (file) {\n          filedata.id = file.id;\n        }\n        store.put(filedata);\n        transaction.oncomplete = () => resolve();\n        transaction.onerror = () => reject(transaction.error);\n      });\n    }\n\n    async make_directory(nodeInput) {\n      this.trace(\"make_directory\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return await new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readwrite\");\n        const store = transaction.objectStore(\"ufs\");\n        store.put({ filepath: node, type: \"directory\" });\n        transaction.oncomplete = () => resolve();\n        transaction.onerror = () => reject(transaction.error);\n      });\n    }\n\n    exists(nodeInput) {\n      this.trace(\"exists\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => resolve(!!request.result);\n        request.onerror = () => resolve(false);\n      });\n    }\n\n    is_file(nodeInput) {\n      this.trace(\"is_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => resolve(request.result ? request.result.type === \"file\" : false);\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    is_directory(nodeInput) {\n      this.trace(\"is_directory\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readonly\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => resolve(request.result ? request.result.type === \"directory\" : false);\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    delete_file(nodeInput) {\n      this.trace(\"delete_file\", arguments);\n      const node = this.resolve_path(nodeInput);\n      return this.$deleteMany(file => {\n        return (file.type === \"file\") && (file.filepath === node);\n      });\n    }\n\n    async delete_directory(nodeInput) {\n      this.trace(\"delete_directory\", arguments);\n      const node = this.resolve_path(nodeInput);\n      await this.$deleteMany(file => file.filepath.startsWith(node));\n      await this.$deleteMany(file => file.filepath === node);\n    }\n\n    $updateMany(filterCallback, expanderCallback) {\n      this.trace(\"$updateMany\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readwrite');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor();\n        let updatedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (cursor) {\n            const isAccepted = filterCallback(cursor.value, cursor);\n            if (isAccepted) {\n              const expanderItem = expanderCallback({ ...cursor.value }, cursor);\n              const updatedItem = { ...cursor.value, ...expanderItem };\n              const updateRequest = cursor.update(updatedItem);\n              updateRequest.onsuccess = () => {\n                updatedCount++;\n              };\n            }\n            cursor.continue();\n          } else {\n            return resolve(updatedCount);\n          }\n        };\n        request.onerror = () => reject(transaction.error);\n      });\n    }\n\n    $deleteMany(filterCallback) {\n      this.trace(\"$deleteMany\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readwrite');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor();\n        let deletedCount = 0;\n        request.onsuccess = () => {\n          const cursor = request.result;\n          if (cursor) {\n            const isAccepted = filterCallback(cursor.value, cursor);\n            if (isAccepted) {\n              const deleteRequest = cursor.delete();\n              deleteRequest.onsuccess = () => {\n                deletedCount++;\n              };\n            }\n            cursor.continue();\n          } else {\n            return resolve(deletedCount);\n          }\n        };\n        request.onerror = () => reject(transaction.error);\n      });\n    }\n\n    rename(nodeInput, newName) {\n      this.trace(\"rename\", arguments);\n      const node = this.resolve_path(nodeInput);\n      const newNode = node.split(\"/\").slice(0, -1).concat(newName).join(\"/\") || \"/\";\n      const pathBegin = node.replace(/\\/$/g, \"\") + \"/\";\n      const newNodeBegin = newNode.replace(/\\/$/g, \"\") + \"/\";\n      console.log(\"Buscando nodos que empiecen por: «\" + pathBegin + \"»\");\n      const renameSubnodes = async () => {\n        const allSubnodes = await this.$selectMany(file => file.filepath.startsWith(pathBegin));\n        const allPromises = [];\n        for (let index = 0; index < allSubnodes.length; index++) {\n          const subnode = allSubnodes[index];\n          const newSubpath = subnode.filepath.replace(pathBegin, newNodeBegin);;\n          console.log(\"Reemplazando a:\", subnode.filepath, \"Por:\", newSubpath);\n          const subpromise = this.$update(subnode.id, { filepath: newSubpath });\n          allPromises.push(subpromise);\n        }\n        return await Promise.all(allPromises);\n      };\n      const renameNode = () => new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", \"readwrite\");\n        const store = transaction.objectStore(\"ufs\");\n        const indexStore = store.index(\"filepath\");\n        const request = indexStore.get(node);\n        request.onsuccess = () => {\n          if (!request.result) {\n            reject(new Error(\"Node not found\"));\n            return;\n          }\n          const data = request.result;\n          data.filepath = newNode;\n          store.put(data);\n          transaction.oncomplete = () => resolve();\n          transaction.onerror = () => reject(transaction.error);\n        };\n        request.onerror = () => reject(request.error);\n      });\n      return Promise.all([\n        renameNode().then(() => renameSubnodes()),\n      ]);\n    }\n\n    async $filepath(filepath) {\n      const selection = await this.$selectMany(file => file.filepath === filepath);\n      if (selection.length === 1) {\n        return selection[0];\n      } else if (selection.length > 1) {\n        return selection;\n      }\n      return null;\n    }\n\n    $selectMany(filterCallback) {\n      this.trace(\"$selectMany\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readonly');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request = objectStore.openCursor(); // Usa cursor para recorrer la BD sin cargar todo en memoria\n        const results = [];\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            let isAccepted = undefined;\n            try {\n              isAccepted = filterCallback(cursor.value);\n            } catch (error) {\n              console.error(\"Error arised from filter callback on «selectMany»\", error);\n            }\n            if (isAccepted) { // Aplica la función de filtro\n              results.push(cursor.value);\n            }\n            cursor.continue(); // Avanza al siguiente registro\n          } else {\n            resolve(results); // Se terminó el recorrido\n          }\n        };\n        request.onerror = () => reject(request.error);\n      });\n    }\n\n    $update(id, item) {\n      this.trace(\"$update\", arguments);\n      return new Promise((resolve, reject) => {\n        const transaction = this.db.transaction(\"ufs\", 'readwrite');\n        const objectStore = transaction.objectStore(\"ufs\");\n        const request0 = objectStore.get(id);\n        request0.onsuccess = () => {\n          const originalState = request0.result;\n          if (!originalState) return reject(`No item found by id «${id}» on «$update»`);\n          const request = objectStore.put({ ...originalState, ...item, id });\n          request.onsuccess = () => resolve(request.result);\n          request.onerror = () => reject(request.error);\n        };\n        request0.onerror = () => reject(request0.error);\n      });\n    }\n\n  }\n\n  const api = {\n    node_driver: UFS_manager_for_node,\n    localstorage_driver: UFS_manager_for_localstorage,\n    idb_driver: UFS_manager_for_idb,\n    create(...args) {\n      const clazz = typeof global !== \"undefined\" ? UFS_manager_for_node : UFS_manager_for_localstorage;\n      return new clazz(...args);\n    },\n    driver(id) {\n      const driverId = id.toLowerCase() + \"_driver\";\n      if (!(driverId in api)) {\n        throw new Error(`Cannot find driver «${driverId}» on «UFS_manager.driver»`);\n      }\n      return {\n        create(...args) {\n          const clazz = api[driverId];\n          return new clazz(...args);\n        }\n      }\n    }\n  };\n\n  return api;\n",
            "$code.label": "UFS_manager class",
            "$output": "index.html"
          }
        ],
        "Lsw LswCycler API » LswCycler class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-lifecycle/lsw-lifecycle.js",
            "$location": {
              "start": {
                "offset": 290,
                "line": 14,
                "column": 3
              },
              "end": {
                "offset": 501,
                "line": 24,
                "column": 6
              }
            },
            "$section": "Lsw LswCycler API » LswCycler class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswCycler",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-lifecycle/lsw-lifecycle.js",
            "$location": {
              "start": {
                "offset": 502,
                "line": 25,
                "column": 1
              },
              "end": {
                "offset": 584,
                "line": 26,
                "column": 1
              }
            },
            "section": "Lsw LswCycler API » LswCycler class",
            "$code": "  const cycle = LswCycler.from({\n\n    steps: [\n      \"onStarted\",\n      \"onInitialize\",\n      \"onInitialized\",\n      \"onBoot\",\n      \"onBooted\",\n      \"onLoadModules\",\n      \"onModulesLoaded\",\n      \"onInstallModules\",\n      \"onModulesInstalled\",\n      \"onLoadSchema\",\n      \"onSchemaLoaded\",\n      \"onLoadDatabase\",\n      \"onDatabaseLoaded\",\n      \"onLoadApplication\",\n      \"onApplicationLoaded\",\n      \"onAllLoaded\",\n      \"onFinished\",\n    ],\n\n    hooks: TriggersClass.create(),\n\n    $trace: function(method, args) {\n      if(Vue.prototype.$trace) {\n        Vue.prototype.$trace(\"lsw-app-lifecycle.\" + method, args);\n      }\n    },\n\n    onStarted: function () {\n      this.$trace(\"onStarted\", []);\n      return this.hooks.emit(\"app:started\");\n    },\n\n    onInitialize: function () {\n      this.$trace(\"onInitialize\", []);\n      return this.hooks.emit(\"app:initialize\");\n    },\n\n    onInitialized: function () {\n      this.$trace(\"onInitialized\", []);\n      return this.hooks.emit(\"app:initialized\");\n    },\n\n    onBoot: function () {\n      this.$trace(\"onBoot\", []);\n      return this.hooks.emit(\"app:boot\");\n    },\n\n    onBooted: function () {\n      this.$trace(\"onBooted\", []);\n      return this.hooks.emit(\"app:booted\");\n    },\n\n    onLoadModules: function () {\n      this.$trace(\"onLoadModules\", []);\n      return this.hooks.emit(\"app:load_modules\");\n    },\n\n    onModulesLoaded: function () {\n      this.$trace(\"onModulesLoaded\", []);\n      return this.hooks.emit(\"app:modules_loaded\");\n    },\n    onInstallModules: function () {\n      this.$trace(\"onInstallModules\", []);\n      return this.hooks.emit(\"app:install_modules\");\n    },\n    onModulesInstalled: function () {\n      this.$trace(\"onModulesInstalled\", []);\n      return this.hooks.emit(\"app:modules_installed\");\n    },\n    onLoadSchema: async function () {\n      this.$trace(\"onLoadSchema\", []);\n      if (process.env.LSW_RESET_DATABASE) {\n        await LswDatabase.deleteDatabase(\"lsw_default_database\");\n      }\n      $lswSchema.loadSchemaByProxies(\"SchemaEntity\");\n      const databaseSchema = await $lswSchema.getDatabaseSchemaForLsw();\n      console.log(\"[*] Creating database from schema by proxies:\", Object.keys(databaseSchema).join(\", \"));\n      await LswDatabase.createDatabase(\"lsw_default_database\", databaseSchema);\n      return await this.hooks.emit(\"app:load_schema\");\n    },\n    onSchemaLoaded: function () {\n      this.$trace(\"onSchemaLoaded\", []);\n      return this.hooks.emit(\"app:schema_loaded\");\n    },\n    onSeedDatabase: async function () {\n      this.$trace(\"onSeedDatabase\", []);\n      Fill_with_your_own_requirements: {\n        // @TOFILLIFNEEDED:\n      }\n      return await this.hooks.emit(\"app:seed_database\");\n    },\n    onDatabaseSeeded: async function () {\n      this.$trace(\"onDatabaseSeeded\", []);\n      Fill_with_your_own_requirements: {\n        // @TOFILLIFNEEDED:\n      }\n      return await this.hooks.emit(\"app:database_seeded\");\n    },\n    onLoadDatabase: async function () {\n      this.$trace(\"onLoadDatabase\", []);\n      Load_database_connection: {\n        Vue.prototype.$lsw.database = await LswDatabase.open(\"lsw_default_database\");\n        Vue.prototype.$lsw.database.setInnerSchema($lswSchema);\n      }\n      if(process.env.LSW_RESET_DATABASE) {\n        await this.onSeedDatabase();\n        await this.onDatabaseSeeded();\n      }\n      return await this.hooks.emit(\"app:load_database\");\n    },\n    onDatabaseLoaded: function () {\n      this.$trace(\"onDatabaseLoaded\", []);\n      return this.hooks.emit(\"app:database_loaded\");\n    },\n    onLoadApplication: function () {\n      this.$trace(\"onLoadApplication\", []);\n      return this.hooks.emit(\"app:load_application\");\n    },\n    onApplicationLoaded: function () {\n      this.$trace(\"onApplicationLoaded\", []);\n      return this.hooks.emit(\"app:application_loaded\");\n    },\n\n    onAllLoaded: function () {\n      this.$trace(\"onAllLoaded\", []);\n      return this.hooks.emit(\"app:all_loaded\");\n    },\n\n    onFinished: function () {\n      this.$trace(\"onFinished\", []);\n      return this.hooks.emit(\"app:finished\");\n    },\n\n    loadModule: function (moduleId) {\n      this.$trace(\"loadModule\", []);\n      return Vue.prototype.$lsw.importer.scriptAsync(`modules/${moduleId}/load.js`);\n    },\n\n    loadSubmodule: function (moduleId, subpath) {\n      this.$trace(\"loadSubmodule\", []);\n      return Vue.prototype.$lsw.importer.scriptAsync(`modules/${moduleId}/${subpath}`);\n    },\n\n    start: function () {\n      this.$trace(\"start\", []);\n      return this.run(this.steps);\n    },\n\n  }, \"*\");\n",
            "$code.label": "LswCycler class",
            "$output": "index.html"
          }
        ],
        "LswLogger API » Superlogger API »  Superlogger class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-logger/superlogger.unbundled.js",
            "$location": {
              "start": {
                "offset": 377,
                "line": 17,
                "column": 3
              },
              "end": {
                "offset": 607,
                "line": 27,
                "column": 6
              }
            },
            "$section": "LswLogger API » Superlogger API »  Superlogger class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "Superlogger",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-logger/superlogger.unbundled.js",
            "$location": {
              "start": {
                "offset": 608,
                "line": 28,
                "column": 1
              },
              "end": {
                "offset": 710,
                "line": 29,
                "column": 1
              }
            },
            "$section": "LswLogger API » Superlogger API »  Superlogger class",
            "$code": "  const Superlogger = class {\n\n    static create(id, options) {\n      return new this(id, options);\n    }\n\n    static levels = {\n      trace: 4,\n      debug: 3,\n      log: 2,\n      warn: 1,\n      error: 0,\n    };\n\n    static defaultOptions = {\n      active: true,\n      level: \"trace\"\n    };\n\n    static loggers = {};\n\n    static alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\n    static generateRandomString(len /* istanbul ignore next */  = 5) {\n      let out = \"\";\n      while(out.length < len) {\n        out += this.alphabet[Math.floor(Math.random() * this.alphabet.length - 1)];\n      }\n      return out;\n    }\n\n    constructor(idInput = false, options = {}) {\n      const id = idInput || this.constructor.generateRandomString(10);\n      if (typeof id !== \"string\") {\n        throw new Error(\"Required parameter «id» to be a string on «Superlogger.constructor»\");\n      }\n      if (id in this.constructor.loggers) {\n        throw new Error(\"Required parameter «id» to be a unique string on «Superlogger.constructor»\");\n      }\n      if (typeof options !== \"object\") {\n        throw new Error(\"Required parameter «options» to be an object on «Superlogger.constructor»\");\n      }\n      this.$id = id;\n      this.$options = Object.assign({}, this.constructor.defaultOptions, options);\n      this.$source = undefined;\n      this.$events = {};\n      this.$callbacks = {\n        before: undefined,\n        after: undefined,\n      };\n      this.resetEvents();\n      this.resetCallbacks();\n      this.constructor.loggers[id] = this;\n    }\n\n    activate() {\n      this.$options.active = true;\n    }\n\n    deactivate() {\n      this.$options.active = false;\n    }\n\n    setSource(source) {\n      this.source = source;\n    }\n\n    setLevel(level) {\n      if (!(level in this.constructor.levels)) {\n        throw new Error(\"Required parameter «level» to be a recognized level on «Superlogger.setLevel»\");\n      }\n      this.$options.level = this.constructor.levels[level];\n    }\n\n    setEvent(id, callback) {\n      this.$events[id] = callback;\n    }\n\n    resetEvents() {\n      this.$events = {\n        trace: undefined,\n        debug: undefined,\n        log: undefined,\n        warn: undefined,\n        error: undefined,\n      };\n    }\n\n    setBefore(callback) {\n      this.$callbacks.before = callback;\n    }\n\n    setAfter(callback) {\n      this.$callbacks.after = callback;\n    }\n\n    resetCallbacks() {\n      this.$callbacks = {\n        after: undefined,\n        before: undefined,\n      };\n    }\n\n    replacerFactory() {\n      const visited = new WeakMap();\n      return (key, value) => {\n        if (typeof value === \"function\") {\n          return \"[Function] \" + value.toString();\n        }\n        if (typeof value === \"object\" && value !== null) {\n          if (visited.has(value)) {\n            return \"[Circular]\";\n          }\n          visited.set(value, true);\n        } else /* istanbul ignore else */ {}\n        return value;\n      }\n    }\n\n    stringifyForDebugging(obj) {\n      return JSON.stringify(obj, this.replacerFactory(), 2);\n    }\n\n    $emit(event, args) {\n      if(!(event in this.$events)) {\n        return \"void::event not defined\";\n      }\n      const callback = this.$events[event];\n      if(typeof callback === \"undefined\") {\n        return \"void::callback not defined\";\n      }\n      return callback(this, args);\n    }\n\n    $log(levelId, elements, methodId = false) {\n      if(!(levelId in this.constructor.levels)) {\n        throw new Error(\"Required parameter «levelId» to be an identified level on «Superlogger.$log»\");\n      }\n      const level = this.constructor.levels[levelId];\n      if (!this.$options.active) {\n        return \"void::currently active=false state\";\n      }\n      if (this.$options.level < level) {\n        return \"void::level of tracing out of bounds\";\n      }\n      let message = `[${this.$id}][${levelId}]`;\n      if (methodId !== false) {\n        message += `[${methodId}]`;\n      }\n      for (let index = 0; index < elements.length; index++) {\n        const element = elements[index];\n        const stringification = typeof element === \"string\" ? element : this.stringifyForDebugging(element);\n        message += \" \" + stringification;\n      }\n      Event_triggering: {\n        if(typeof this.$callbacks.before !== \"undefined\") {\n          this.$callbacks.before(message, this, levelId, elements, methodId);\n        }\n        console.log(message);\n        if(typeof this.$callbacks.after !== \"undefined\") {\n          this.$callbacks.after(message, this, levelId, elements, methodId);\n        }\n        this.$emit(levelId, {elements, methodId});\n      }\n    }\n\n    trace(methodId, ...data) {\n      return this.$log(\"trace\", data, methodId);\n    }\n\n    debug(...data) {\n      return this.$log(\"debug\", data);\n    }\n\n    log(...data) {\n      return this.$log(\"log\", data);\n    }\n\n    warn(...data) {\n      return this.$log(\"warn\", data);\n    }\n\n    error(...data) {\n      return this.$log(\"error\", data);\n    }\n\n  };\n",
            "$code.label": "Superlogger class",
            "$output": "index.html"
          }
        ],
        "LswProxifier API » LswProxifier class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxifier/proxifier.unbundled.js",
            "$location": {
              "start": {
                "offset": 290,
                "line": 14,
                "column": 3
              },
              "end": {
                "offset": 506,
                "line": 24,
                "column": 6
              }
            },
            "$section": "LswProxifier API » LswProxifier class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswProxifier",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-proxifier/proxifier.unbundled.js",
            "$location": {
              "start": {
                "offset": 507,
                "line": 25,
                "column": 1
              },
              "end": {
                "offset": 595,
                "line": 26,
                "column": 1
              }
            },
            "$section": "LswProxifier API » LswProxifier class",
            "$code": "  class BaseClass {\n    initialize(...args) {\n      const promise = this.onInitialize(...args);\n      if (promise instanceof Promise) {\n        return promise.then(output => {\n          return this;\n        });\n      }\n      return this;\n    }\n    onInitialize() {\n      return this;\n    }\n  }\n\n  const AbstractProxy = class {\n    constructor(value) {\n      this.value = value;\n    }\n  }\n  class AbstractVirtualizer extends AbstractProxy {}\n  class AbstractSchemaEntity extends AbstractProxy {\n    static toObject() {\n      return {\n        entityId: this.getEntityId(),\n        name: this.getName(),\n        version: this.getVersion(),\n        properties: this.getProperties(),\n        externalProperties: this.getExternalProperties(),\n        methods: this.getMethods(),\n        virtualizerId: this.getVirtualizerId(),\n        formSettings: this.getFormSettings(),\n        extraAttributes: this.getExtraAttributes(),\n      };\n    }\n    static getEntityId() {\n      throw new Error(`Required method «getEntityId» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getEntityId»`);\n    }\n    static getName() {\n      throw new Error(`Required method «getName» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getName»`);\n    }\n    static getVersion() {\n      throw new Error(`Required method «getVersion» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getVersion»`);\n    }\n    static getProperties() {\n      throw new Error(`Required method «getProperties» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getProperties»`);\n    }\n    static getExternalProperties() {\n      return {};\n    }\n    static getMethods() {\n      throw new Error(`Required method «getMethods» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getMethods»`);\n    }\n    static getVirtualizerId() {\n      throw new Error(`Required method «getVirtualizerId» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getVirtualizerId»`);\n    }\n    static getFormSettings() {\n      throw new Error(`Required method «getFormSettings» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getFormSettings»`);\n    }\n    static getExtraAttributes() {\n      throw new Error(`Required method «getExtraAttributes» to be overriden by «AbstractSchemaEntity» inherited class on «AbstractSchemaEntity.getExtraAttributes»`);\n    }\n  }\n  class AbstractItem { }\n  class AbstractList {\n    constructor(value) {\n      this.value = Array.isArray(value) ? value : [];\n    }\n    forEach(callback) {\n      this.value.forEach(callback);\n      return this;\n    }\n    filter(callback) {\n      this.value = this.value.filter(callback);\n      return this;\n    }\n    map(callback) {\n      this.value = this.value.map(callback);\n      return this;\n    }\n    reduce(callback, initialValue = []) {\n      this.value = this.value.reduce(callback, initialValue);\n      return this;\n    }\n    modify(callback) {\n      this.value = callback(this.value);\n      return this;\n    }\n    concat(...lists) {\n      this.value = this.value.concat(...lists);\n      return this;\n    }\n    onlyProp(prop) {\n      this.value = this.value.map(it => it[prop]);\n      return this;\n    }\n    onlyProps(props) {\n      this.value = this.value.map(it => {\n        const out = {};\n        props.forEach(prop => {\n          out[prop] = it[prop];\n        });\n        return out;\n      });\n      return this;\n    }\n    removeProp(prop) {\n      return this.removeProps([prop]);\n    }\n    removeProps(props) {\n      this.value = this.value.map(it => {\n        const out = {};\n        const keys = Object.keys(it).filter(prop => {\n          return props.indexOf(prop) === -1;\n        });\n        keys.forEach(key => {\n          out[key] = it[key];\n        });\n        return out;\n      });\n      return this;\n    }\n    deduplicate() {\n      const out = [];\n      this.value.forEach(it => {\n        if (out.indexOf(it) === -1) {\n          out.push(it);\n        }\n      });\n      this.value = out;\n      return this;\n    }\n    sort(callback) {\n      this.value = this.value.sort(callback);\n      return this;\n    }\n  };\n\n  class LswProxifier {\n    static create(...args) {\n      return new this(...args);\n    }\n    AbstractProxy = AbstractProxy;\n    AbstractSchemaEntity = AbstractSchemaEntity;\n    AbstractVirtualizer = AbstractVirtualizer;\n    AbstractItem = AbstractItem;\n    AbstractList = AbstractList;\n    constructor(mainInjection = {}) {\n      this.$definitions = {};\n      this.$mainInjection = mainInjection;\n      this.$splitterChar = \"@\";\n    }\n    define(name, classesDef) {\n      if(!(name in this.$definitions)) {\n        this.$definitions[name] = {};\n      }\n      if(typeof classesDef !== \"object\") {\n        throw new Error(`Required parameter «classesDef» to be a class on «LswProxifier.define»`)\n      }\n      const classesIds = Object.keys(classesDef);\n      for(let index=0; index<classesIds.length; index++) {\n        const classId = classesIds[index];\n        const classDef = classesDef[classId];\n        if(typeof classDef !== \"function\") {\n          throw new Error(`Required proxy class «${classId}» to be a class on «LswProxifier.define»`)\n        }\n      }\n      Object.assign(this.$definitions[name], classesDef);\n    }\n    find(selector) {\n      const [name, aspectId = false] = selector.split(this.$splitterChar);\n      if(!(name in this.$definitions)) {\n        throw new Error(`Could not find proxy classes from name «${name}» on «LswProxifier.find»`);\n      }\n      if(!aspectId) {\n        return this.$definitions[name];\n      }\n      if(!(aspectId in this.$definitions[name])) {\n        throw new Error(`Could not find proxy aspect «${aspectId}» from class «${name}» on «LswProxifier.find»`);\n      }\n      return this.$definitions[name][aspectId];\n    }\n    getFactory() {\n      return this.proxify.bind(this);\n    }\n    proxify(obj) {\n      return {\n        as: (typeSelector = \"\", proxyExtraArguments = []) => {\n          if(typeof typeSelector !== \"string\") {\n            throw new Error(`Required parameter «typeSelector» to be a string on «proxify(@).as(@)»`);\n          }\n          const [definitionId, aspectId = \"Item\"] = typeSelector.split(this.$splitterChar);\n          if(!(definitionId in this.$definitions)) {\n            throw new Error(`Required parameter «definitionId» [«${definitionId}»] to exist in «proxifier.$definitions» but it does not on «proxify(@).as(@)`);\n          }\n          if(!(aspectId in this.$definitions[definitionId])) {\n            throw new Error(`Required parameter «aspectId» [«${aspectId}»] to exist in «proxifier.$definitions[${JSON.stringify(definitionId)}]» but it does not on «proxify(@).as(@)`);\n          }\n          const proxyClass = this.$definitions[definitionId][aspectId];\n          const proxyInstance = new proxyClass(obj, ...proxyExtraArguments);\n          if(typeof this.$mainInjection === \"function\") {\n            this.$mainInjection(proxyInstance, proxyClass);\n          } else if(typeof this.$mainInjection === \"object\") {\n            Object.assign(proxyInstance, this.$mainInjection);\n          }\n          return proxyInstance;\n        }\n      };\n    }\n  };\n\n  LswProxifier.default = LswProxifier;\n\n  globalThis.$proxifier = LswProxifier.create();\n",
            "$code.label": "LswProxifier class",
            "$output": "index.html"
          }
        ],
        "LswRandomizer API » LswRandomizer class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-randomizer/lsw-randomizer.js",
            "$location": {
              "start": {
                "offset": 293,
                "line": 15,
                "column": 3
              },
              "end": {
                "offset": 512,
                "line": 25,
                "column": 6
              }
            },
            "$section": "LswRandomizer API » LswRandomizer class",
            "type": "class",
            "extends": "Object",
            "vendor": "lsw",
            "namespace": "LswRandomizer",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-randomizer/lsw-randomizer.js",
            "$location": {
              "start": {
                "offset": 513,
                "line": 26,
                "column": 1
              },
              "end": {
                "offset": 604,
                "line": 27,
                "column": 1
              }
            },
            "$section": "LswRandomizer API » LswRandomizer class",
            "$code": "  const LswRandomizer = class {\n\n    static $defaultAlphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\n    static getRandomIntegerBetween(start = 0, end = 100) {\n      return Math.round(Math.random() * (end - start)) + start;\n    }\n\n    static getRandomString(len, alphabet = this.$defaultAlphabet) {\n      let out = \"\";\n      while (out.length < len) {\n        out += alphabet[Math.floor(Math.random() * alphabet.length)];\n      }\n      return out;\n    }\n\n    static getRandomItem(list) {\n      return list[Math.floor(Math.random() * list.length)];\n    }\n\n    static getRandomObject(totalProps = [0, 10], listOf = false) {\n      let randomProps = totalProps;\n      if (Array.isArray(totalProps)) {\n        randomProps = this.getRandomIntegerBetween(...totalProps);\n      }\n      const buildRandomObject = () => {\n        const randomObject = {};\n        while (Object.keys(randomObject).length < randomProps) {\n          const key = this.getRandomString(5);\n          const value = this.getRandomString(10);\n          randomObject[key] = value;\n        }\n        return randomObject;\n      };\n      if (listOf === false) {\n        return buildRandomObject();\n      }\n      const randomList = [];\n      for(let index=0; index<listOf; index++) {\n        const randomObject = buildRandomObject();\n        randomList.push(randomObject);\n      }\n      return randomList;\n    }\n\n  }\n\n  return LswRandomizer;\n",
            "$code.label": "LswRandomizer class",
            "$output": "index.html"
          }
        ],
        "LswReloader API » LswReloadable injection": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-reloader/reloadable.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 95,
                "line": 2,
                "column": 1
              }
            },
            "$section": "LswReloader API » LswReloadable injection",
            "$code": "const serverUrl = 'http://127.0.0.1';\nconst serverPort = 3000;\n\nif (process?.env?.NODE_ENV === \"test\") {\n  const socket = io(`${serverUrl}:${serverPort}`);\n  socket.on('refrescar', () => {\n    console.log('Recibida la señal de refrescar desde el servidor');\n    location.reload();\n  });\n}\n",
            "$code.label": "LswReloadable injection",
            "$output": "index.html"
          }
        ],
        "LswControlledFunction API » ControlledFunction API » ControlledFunction classes": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-returner/controlled-function.js",
            "$location": {
              "start": {
                "offset": 300,
                "line": 14,
                "column": 1
              },
              "end": {
                "offset": 437,
                "line": 15,
                "column": 1
              }
            },
            "$section": "LswControlledFunction API » ControlledFunction API » ControlledFunction classes",
            "$code": "  const ReturnControl = class {\n    constructor(value) {\n      this.value = value;\n    }\n  };\n\n  const MutateControl = class {\n    constructor(mutator = {}) {\n      this.mutator = mutator;\n    }\n  };\n\n  const ReturnController = class {\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor() {\n      this.results = new Map();\n      this.functions = new Map();\n      this.middlewares = [];\n      this.properties = new Map();\n    }\n\n    prehook(middleware) {\n      this.middlewares.unshift(middleware);\n      return this;\n    }\n\n    hook(middleware) {\n      this.middlewares.push(middleware);\n      return this;\n    }\n\n    unhook(middleware) {\n      this.middlewares = this.middlewares.filter(m => m !== middleware);\n      return this;\n    }\n\n    prop(properties = {}) {\n      Object.assign(this.properties, properties);\n      return this;\n    }\n\n    hasProp(id) {\n      return this.properties.has(id);\n    }\n\n    getProp(id, defaultValue = undefined) {\n      if (!this.properties.has(id)) {\n        return defaultValue;\n      }\n      return this.properties.get(id);\n    }\n\n    setProp(id, value) {\n      this.properties.set(id, value);\n      return this;\n    }\n\n    load(functions) {\n      this.functions = new Map(Object.entries(functions));\n      return this;\n    }\n\n    solved(name) {\n      return this.results.get(name);\n    }\n\n    pipe(outputName, functionNames, parameters = []) {\n      for (let fnName of functionNames) {\n        const fnCallback = this.functions.get(fnName);\n        if (fnCallback) {\n          const result = fnCallback(...parameters);\n          if (this.processResult(result, outputName)) {\n            return this.solved(outputName);\n          }\n        }\n        for (const middleware of this.middlewares) {\n          const result = middleware(this);\n          if (this.processResult(result, outputName)) {\n            return this.solved(outputName);\n          }\n        }\n      }\n      return null;\n    }\n\n    processResult(result, outputName) {\n      if (result instanceof ReturnControl) {\n        this.results.set(outputName, result.value);\n        return true;\n      } else if (result instanceof MutateControl) {\n        const mutator = result.mutator;\n        if (typeof mutator === \"function\") {\n          const mutatorResult = mutator(this);\n          if (typeof mutatorResult === \"object\") {\n            Object.assign(this.properties, mutatorResult);\n          } else if (mutatorResult !== undefined) {\n            throw new Error(\n              `MutateControl's function mutator must return an object or undefined, found: ${typeof mutatorResult}`\n            );\n          }\n        } else if (typeof mutator === \"object\") {\n          Object.assign(this, mutator);\n        } else {\n          throw new Error(\n            `MutateControl's mutator must be a function or object, found: ${typeof mutator}`\n          );\n        }\n      }\n      return false;\n    }\n\n    reset() {\n      this.results.clear();\n      this.properties.clear();\n      return this;\n    }\n  };\n\n  const ControlledFunction = {\n    MutateControl,\n    ReturnControl,\n    ReturnController,\n  };\n\n  ControlledFunction.default = ControlledFunction;\n\n  return ControlledFunction;\n",
            "$code.label": "ControlledFunction global",
            "$output": "index.html"
          }
        ],
        "Lsw Schema API » LswSchema class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-schema/lsw-schema.js",
            "$location": {
              "start": {
                "offset": 627,
                "line": 30,
                "column": 3
              },
              "end": {
                "offset": 807,
                "line": 38,
                "column": 6
              }
            },
            "$section": "Lsw Schema API » LswSchema class",
            "type": "Class",
            "vendor": "lsw",
            "namespace": "LswSchema",
            "source code": "La clase está definida así:\n",
            "$output": "index.html"
          },
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-schema/lsw-schema.js",
            "$location": {
              "start": {
                "offset": 808,
                "line": 39,
                "column": 1
              },
              "end": {
                "offset": 887,
                "line": 40,
                "column": 1
              }
            },
            "section": "Lsw Schema API » LswSchema class",
            "$code": "  const LswSchema = class {\n\n    $trace(methodId, argsList) {\n      if(this.$options && this.$options.trace) {\n        console.log(\"[trace][lsw-schema][\" + methodId + \"] \" + argsList.length);\n      }\n    }\n\n    static Signature = LswSchemaSignature;\n\n    static createSignature(creatorCallback, creatorParameters, creatorScope) {\n      return this.Signature.create(creatorCallback, creatorParameters, creatorScope);\n    }\n\n    onValidateSchema(schema) {\n      this.$trace(\"onValidateSchema\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onValidateTable(id, definition, schema) {\n      this.$trace(\"onValidateTable\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onValidateColumn(id, definition, tableId, schema) {\n      this.$trace(\"onValidateColumn\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onFusionateSchema(schema) {\n      this.$trace(\"onFusionateSchema\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onFusionateTable(table, tableId, schema) {\n      this.$trace(\"onFusionateTable\", arguments);\n      // @OVERRIDABLE\n    }\n\n    onFusionateColumn(column, columnId, tableId, schema) {\n      this.$trace(\"onFusionateColumn\", arguments);\n      // @OVERRIDABLE\n    }\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor(options = {}) {\n      this.$cache = {\n        schemaForLsw: null\n      };\n      this.$schema = {\n        hasTables: {\n\n        }\n      };\n      this.$options = options;\n    }\n    \n    getDatabaseSchemaForLsw(refresh = false) {\n      this.$trace(\"getDatabaseSchemaForLsw\", arguments);\n      if(refresh) {\n        this.$cache.schemaForLsw = null;\n      }\n      if(this.$cache.schemaForLsw) {\n        return this.$cache.schemaForLsw;\n      }\n      const schemaForLsw = {};\n      for(let tableId in this.$schema.hasTables) {\n        const tableData = this.$schema.hasTables[tableId];\n        let tableSchema = [];\n        for(let columnId in tableData.hasColumns) {\n          const columnData = tableData.hasColumns[columnId];\n          const prefix = columnData.isUnique ? \"!\" : \"\";\n          tableSchema.push(prefix + columnId);\n        }\n        schemaForLsw[tableId] = tableSchema;\n      }\n      this.$cache.schemaForLsw = schemaForLsw;\n      return schemaForLsw;\n    }\n\n    loadSchemaByProxies(aspectId = \"SchemaEntity\") {\n      this.$trace(\"loadSchemaByProxies\", arguments);\n      const schema = this.getSchemaByProxies(aspectId);\n      return this.registerSchema(schema);\n    }\n\n    getSchemaByProxies(aspectId = \"SchemaEntity\") {\n      this.$trace(\"getSchemaByProxies\", arguments);\n      const allSchemaEntities = Object.values($proxifier.$definitions).filter(d => d[aspectId]).map(d => d[aspectId]);\n      const schemaTemp = new LswSchema();\n      for(let index=0; index<allSchemaEntities.length; index++) {\n        const SchemaEntityClass = allSchemaEntities[index];\n        const lswDatabaseSchema = this.adaptSchemaEntityToDatabaseSchema(SchemaEntityClass);\n        schemaTemp.registerSchema(lswDatabaseSchema);\n      }\n      return schemaTemp.$schema;\n    }\n\n    adaptSchemaEntityToDatabaseSchema(SchemaEntityClass) {\n      this.$trace(\"adaptSchemaEntityToDatabaseSchema\", arguments);\n      const schema = { hasTables: {} };\n      const data = SchemaEntityClass.toObject();\n      schema.hasTables[data.name] = {\n        ...data,\n        hasEntityId: SchemaEntityClass.getEntityId(),\n        hasColumns: data.properties,\n        hasExtraAttributes: data.extraAttributes,\n      };\n      return schema;\n    }\n\n    registerSchema(partialSchema = {}) {\n      this.$trace(\"registerSchema\", arguments);\n      if (typeof partialSchema !== \"object\") {\n        throw new Error(\"Required parameter «partialSchema» to be an object on «LswSchema.registerSchema»\");\n      }\n      this.$validateSchema(partialSchema);\n      this.$fusionateSchema(partialSchema);\n      return this;\n    }\n\n    $validateSchema(schema) {\n      this.$trace(\"$validateSchema\", arguments);\n      Native: {\n        this.$validateSchemaNative(schema);\n      }\n      Core_process: {\n        if (\"hasTables\" in schema) {\n          const tableIds = Object.keys(schema.hasTables);\n          Iterating_tables:\n          for (let indexTable = 0; indexTable < tableIds.length; indexTable++) {\n            const tableId = tableIds[indexTable];\n            const table = schema.hasTables[tableId];\n            this.$validateTableNative(table, tableId, schema);\n            if (!(\"hasColumns\" in table)) {\n              continue Iterating_tables;\n            }\n            const columnIds = Object.keys(table.hasColumns);\n            Iterating_columns:\n            for (let indexColumn = 0; indexColumn < columnIds.length; indexColumn++) {\n              const columnId = columnIds[indexColumn];\n              const column = table.hasColumns[columnId];\n              this.$validateColumnNative(column, columnId, tableId, schema);\n            }\n          }\n        }\n      }\n      User: {\n        this.onValidateSchema(schema);\n      }\n    }\n\n    $fusionateSchema(partialSchema) {\n      this.$trace(\"$fusionateSchema\", arguments);\n      const tableIds = Object.keys(partialSchema?.hasTables || {});\n      Debug_purposes: {\n        const columnIds = tableIds.map(tableId => Object.keys(partialSchema.hasTables[tableId].hasColumns || {}).map(columnId => [tableId, columnId].join(\".\")));\n        const tablesMessage = tableIds.length === 0 ? \"No tables to fusionate\" : \"Tables to fusionate:\\n - \" + tableIds.join(\"\\n - \");\n        const columnsMessage = columnIds.length === 0 ? \"No columns to fusionate\" : \"Columns to fusionate:\\n - \" + columnIds.join(\"\\n - \");\n        this.$trace(`[*] ${tablesMessage}`, []);\n        this.$trace(`[*] ${columnsMessage}`, []);\n      }\n      this.$fusionateSchemaNative(partialSchema);\n      Iterating_tables:\n      for (let indexTable = 0; indexTable < tableIds.length; indexTable++) {\n        const tableId = tableIds[indexTable];\n        const tableInfo = partialSchema.hasTables[tableId];\n        this.$fusionateTableNative(tableInfo, tableId, partialSchema);\n        const columnIds = Object.keys(tableInfo.columns || {});\n        Iterating_columns:\n        for (let indexColumn = 0; indexColumn < columnIds.length; indexColumn++) {\n          const columnId = columnIds[indexColumn];\n          const columnInfo = tableInfo.columns[columnId];\n          this.$fusionateColumnNative(columnInfo, columnId, tableId, partialSchema);\n        }\n      }\n    }\n\n    $validateSchemaNative(schema) {\n      this.$trace(\"$validateSchemaNative\", arguments);\n      Native: {\n        const ensureSchema = $ensure(schema).type(\"object\").to.have.key(\"hasTables\");\n        ensureSchema.its(\"hasTables\").type(\"object\");\n      }\n      User: {\n        this.onValidateSchema(schema);\n      }\n    }\n\n    $validateTableNative(definition, id, schema) {\n      this.$trace(\"$validateTableNative\", arguments);\n      Native: {\n        const ensureTable = $ensure(definition).type(\"object\").to.have.key(\"hasColumns\");\n        const ensureHasColumns = ensureTable.its(\"hasColumns\").type(\"object\");\n        const columnIds = Object.keys(ensureHasColumns.$subject);\n        for(let index=0; index<columnIds.length; index++) {\n          const columnId = columnIds[index];\n          const ensureColumn = ensureHasColumns.its(columnId).type(\"object\");\n          ensureColumn.its(\"isType\").type(\"string\");\n          ensureColumn.its(\"isUnique\").type([\"boolean\", \"undefined\"]);\n          ensureColumn.its(\"refersTo\").type([\"object\", \"undefined\", \"boolean\"]);\n          if(typeof ensureColumn.$subject.refersTo === \"object\") {\n            const ensureRefersTo = ensureColumn.its(\"refersTo\").type(\"object\");\n            ensureRefersTo.to.have.keys([\"entity\", \"property\"]);\n            ensureRefersTo.its(\"entity\").type(\"string\");\n            ensureRefersTo.its(\"property\").type(\"string\");\n          }\n          ensureColumn.its(\"isFormType\").type(\"string\");\n          ensureColumn.its(\"hasValidator\").type([\"string\", \"boolean\", \"function\", \"undefined\"]);\n          ensureColumn.its(\"hasFormatter\").type([\"string\", \"boolean\", \"function\", \"undefined\"]);\n          ensureColumn.its(\"hasLabel\").type([\"string\", \"boolean\", \"undefined\"]);\n          ensureColumn.its(\"hasDescription\").type([\"string\", \"boolean\", \"undefined\"]);\n          ensureColumn.its(\"hasPlaceholder\").type([\"string\", \"boolean\", \"undefined\"]);\n        }\n      }\n      User: {\n        this.onValidateTable(id, definition, schema);\n      }\n    }\n\n    $validateColumnNative(id, definition, tableId, schema) {\n      this.$trace(\"$validateColumnNative\", arguments);\n      Native: {\n        // !@OK: the validation is already made on the $validateTableNative\n      }\n      User: {\n        this.onValidateColumn(id, definition, tableId, schema);\n      }\n    }\n\n    $fusionateSchemaNative(partialSchema) {\n      this.$trace(\"$fusionateSchemaNative\", arguments);\n      Native_fusion: {\n        \n      }\n      User_fusion: {\n        this.onFusionateSchema(partialSchema);\n      }\n    }\n\n    $fusionateTableNative(tableInfo, tableId, partialSchema) {\n      this.$trace(\"$fusionateTableNative\", arguments);\n      Native_fusion: {\n        const isKnown = tableId in this.$schema.hasTables;\n        if(!isKnown) {\n          this.$schema.hasTables[tableId] = tableInfo;\n        } else {\n          throw new Error(`Schema cannot fusionate table «${tableId}» to schema for second time on «$fusionateTableNative»`);\n        }\n      }\n      User_fusion: {\n        this.onFusionateTable(tableInfo, tableId, partialSchema);\n      }\n    }\n\n    $fusionateColumnNative(columnInfo, columnId, tableId, partialSchema) {\n      this.$trace(\"$fusionateColumnNative\", arguments);\n      Native_fusion: {\n        const isKnown = columnId in this.$schema.hasTables[tableId].hasColumns;\n        if(!isKnown) {\n          this.$schema.hasTables[tableId].hasColumns[columnId] = columnInfo;\n        } else {\n          throw new Error(`Schema cannot fusionate column «${tableId}.${columnId}» to schema for second time on «$fusionateTableNative»`);\n        }\n      }\n      User_fusion: {\n        this.onFusionateColumn(columnInfo, columnId, tableId, partialSchema);\n      }\n    }\n\n  };\n  \n  // Last global injection for a unique main instance:\n  window.$lswSchema = LswSchema.create();\n",
            "$code.label": "LswSchema class",
            "$output": "index.html"
          }
        ],
        "LswTester API » Ensure API » Ensure classes and functions": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-tester/ensure.js",
            "$location": {
              "start": {
                "offset": 276,
                "line": 14,
                "column": 1
              },
              "end": {
                "offset": 376,
                "line": 15,
                "column": 1
              }
            },
            "$section": "LswTester API » Ensure API » Ensure classes and functions",
            "$code": "  const ensure = function (source) {\n    return new Ensurement(source);\n  };\n  class Ensurement {\n    constructor(source) {\n      if(typeof source !== \"object\") {\n        throw new Error(\"Ensurement only accepts 1 object\");\n      }\n      const sourceKeys = Object.keys(source);\n      if(sourceKeys.length !== 1) {\n        throw new Error(\"Ensurement only accepts 1 object with 1 property\");\n      }\n      const id = sourceKeys[0];\n      this.$subjectId = id;\n      this.$subject = source[id];\n      this.$operation = undefined;\n      this.$objectation = undefined;\n      this.$can = undefined;\n      this.$cant = undefined;\n      this.$is = undefined;\n      this.$isnt = undefined;\n      this.$throws = undefined;\n      this.$doesntThrow = undefined;\n    }\n    type(value) {\n      return this.$resolveOperation(\"type\", value);\n    }\n    notType(value) {\n      return this.$resolveOperation(\"notType\", value);\n    }\n    is(is) {\n      return this.$resolveOperation(\"is\", is);\n    }\n    isnt(isnt) {\n      return this.$resolveOperation(\"isnt\", isnt);\n    }\n    can(can) {\n      return this.$resolveOperation(\"can\", can);\n    }\n    cant(cant) {\n      return this.$resolveOperation(\"cant\", cant);\n    }\n    throws(throws) {\n      return this.$resolveOperation(\"throws\", throws);\n    }\n    doesntThrow(doesntThrow) {\n      return this.$resolveOperation(\"doesntThrow\", doesntThrow);\n    }\n    $throwError() {\n      throw new Error(\"could not ensure «\" + this.$subjectId + \" \" + this.$operation + \" \" + this.$objectation + \"»\");\n    }\n    $resolveOperation(op, objectation) {\n      this.$operation = op;\n      this.$objectation = objectation;\n      if (op === \"type\") {\n        if(typeof this.$subject !== objectation) {\n          this.$throwError();\n        }\n      } else if (op === \"notType\") {\n        if (typeof this.$subject === objectation) {\n          this.$throwError();\n        }\n      } else if (op === \"is\") {\n        if (this.$subject !== objectation) {\n          this.$throwError();\n        }\n      } else if (op === \"isnt\") {\n        if (this.$subject === objectation) {\n          this.$throwError();\n        }\n      } else if (op === \"can\") {\n        if (!objectation(this.$subject)) {\n          this.$throwError();\n        }\n      } else if (op === \"cant\") {\n        if (objectation(this.$subject)) {\n          this.$throwError();\n        }\n      } else if (op === \"throws\") {\n        try {\n          objectation(this.$subject);\n          this.$throwError();\n        } catch (error) { }\n      } else if (op === \"doesntThrow\") {\n        try {\n          objectation(this.$subject);\n        } catch (error) {\n          this.$throwError();\n        }\n      } else {\n        throw new Error(\"Ensure operation not admited: \" + op);\n      }\n      return this;\n    }\n  }\n  return ensure;\n",
            "$code.label": "Ensure API",
            "$output": "index.html"
          }
        ],
        "LswTester API » Tester API » Tester classes and functions": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-tester/universal-tester.js",
            "$location": {
              "start": {
                "offset": 406,
                "line": 16,
                "column": 1
              },
              "end": {
                "offset": 508,
                "line": 17,
                "column": 1
              }
            },
            "$section": "LswTester API » Tester API » Tester classes and functions",
            "$code": "    // exported to: UniversalTester & describe\n    const runQueue = async function (queue, errorHandler, it) {\n        Iterating_tests:\n        for (const test of queue) {\n            try {\n                await test();\n            } catch (err) {\n                await it.state.onError(err);\n                if (errorHandler) {\n                    try {\n                        await errorHandler(err);\n                    } catch (stopExecutionFailure) {\n                        console.error(\"Execution halted due to:\", stopExecutionFailure);\n                        break Iterating_tests; // Interrumpir la ejecución de la cola\n                    }\n                } else {\n                    console.error(err);\n                }\n            }\n        }\n    };\n    const print = function (message, color = false) {\n        if (typeof global !== \"undefined\") {\n            if (color === \"green\") {\n                console.log(`\\x1b[32m${message}\\x1b[0m`);\n            } else if (color === \"red\") {\n                console.log(`\\x1b[31m${message}\\x1b[0m`);\n            } else {\n                console.log(message);\n            }\n        } else {\n            console.log(message);\n        }\n    };\n\n    const describe = function (description, callback) {\n        const queue = [];\n        const state = {\n            finished: false,\n            onFailure: null,\n            onError: null,\n            tests: {},\n            onlyActivated: false\n        };\n        const getStateReport = function (last = 0, nonStringified = false) {\n            if (!last) {\n                let report = \"\";\n                report = JSON.stringify(state, null, 2);\n                return report;\n            } else {\n                let report = \"\";\n                state.passed = Object.keys(state.tests).filter(label => state.tests[label].state === \"passed\");\n                state.failed = Object.keys(state.tests).filter(label => state.tests[label].state === \"failed\");\n                if (nonStringified) {\n                    return state;\n                }\n                report = JSON.stringify(state, null, 2);\n                return report;\n            }\n        };\n        const updateDOM = function () {\n            Only_on_browsers:\n            if (typeof window !== \"undefined\") {\n                const matchedElements = Array.from(document.querySelectorAll(\"[data-test]\")).filter(el => el.getAttribute(\"data-test\") === description);\n                if (matchedElements.length === 0) {\n                    break Only_on_browsers;\n                }\n                const matchedElement = matchedElements[0];\n                matchedElement.textContent = getStateReport(1);\n            }\n        };\n        const updateUI = (is_on = \"pass\", force_on_nodejs = false, itModified = false, description = false) => {\n            try {\n                const is_starting_suite = is_on === \"begin\";\n                const is_starting = is_on === \"start\";\n                const is_passing = is_on === \"pass\";\n                const is_failing = is_on === \"fail\";\n                const is_finished = is_on === \"finish\";\n                const is_none = !is_starting_suite && !is_starting && !is_passing && !is_failing && !is_finished;\n                if(is_none) {\n                    throw new Error(\"Situation not managed error 1\");\n                }\n                if (is_finished) {\n                    state.finished = true;\n                }\n                On_both_browser_and_nodejs:\n                if (itModified) {\n                    const mark = itModified.state === \"passed\" ? \"✔\" : \"✘\";\n                    if (mark === \"✘\") {\n                        print(`  [${mark}] ${description} [${itModified.took_milliseconds}ms]`, \"red\");\n                    } else {\n                        print(`  [${mark}] ${description} [${itModified.took_milliseconds}ms]`, \"green\");\n                    }\n                } else if (is_finished) {\n                    const r = getStateReport(1, 1);\n                    if (r.failed.length) {\n                        print(`[✘] Failed ${r.failed.length} check(s) on:`, \"red\");\n                        r.failed.map((id, index) => {\n                            return {\n                                index: index + 1,\n                                test: id,\n                                error: r.tests[id].error\n                            }\n                        }).forEach(info => {\n                            const { error, index } = info;\n                            print(`  [✘] Fail ${index} on: «${info.test}» | ${error.name}: ${error.message}`, \"red\");\n                            console.log(error);\n                        });\n                        console.log();\n                    } else {\n                        print(`[✔] All tests were passed successfully`, \"green\");\n                    }\n                } else if (is_starting_suite) {\n                    print(`[!] Starting: ${description}`, \"green\");\n                }\n            } catch (error) {\n                console.error(error);\n            } finally {\n                updateDOM();\n            }\n        };\n        const startTest = (label) => {\n            state.tests[label] = { state: \"started\", started_at: new Date() };\n            return updateUI(\"start\");\n        };\n        const passTest = (label, output) => {\n            Object.assign(state.tests[label], { state: \"passed\", output, took_milliseconds: (new Date()) - state.tests[label].started_at });\n            return updateUI(\"pass\", 1, state.tests[label], label);\n        };\n        const failTest = async (label, error) => {\n            if(typeof(error) === \"object\" && (error instanceof describe.SilencedError)) {\n                // Llamamos al onError igualmente, pero no al onFailure:\n                await it.state.onError(error);\n                passTest(label, { name: error.name, message: error.message });\n                return false;\n            }\n            Object.assign(state.tests[label], { state: \"failed\", error, took_milliseconds: (new Date()) - state.tests[label].started_at });\n            updateUI(\"fail\", 1, state.tests[label], label);\n            return true;\n        };\n        const it = (label, callback, type = \"normal\") => {\n            queue.push(async () => {\n                if (type === \"never\") return; // Nunca ejecutar \"never\"\n                if (state.onlyActivated && type !== \"only\" && type !== \"always\") return; // Prioridad de only/always\n                let timeoutId;\n                const context = {\n                    queue,\n                    state,\n                    timeout(ms) {\n                        return new Promise((_, reject) => {\n                            timeoutId = setTimeout(() => reject(new Error(`Timeout: ${label}`)), ms);\n                        });\n                    }\n                };\n                try {\n                    startTest(label);\n                    const result = await callback.call(context);\n                    passTest(label, result);\n                } catch (err) {\n                    const trulyFailed = await failTest(label, err);\n                    if(trulyFailed === true) {\n                        throw err; // Re-lanzar el error para que runQueue lo capture\n                    }\n                } finally {\n                    clearTimeout(timeoutId); // Limpiar el timeout al finalizar\n                }\n            });\n            if (type === \"only\") state.onlyActivated = true;\n        };\n\n        it.always = (label, fn) => it(label, fn, \"always\");\n        it.never = (label, fn) => it(label, fn, \"never\");\n        it.normally = (label, fn) => it(label, fn, \"normal\");\n        it.only = (label, fn) => it(label, fn, \"only\");\n\n        it.onFailure = (callback) => {\n            state.onFailure = (error) => {\n                callback(error); // Configurar el manejador de fracaso de test\n                return error;\n            };\n        };\n\n        it.onError = (callback) => {\n            state.onError = (error) => {\n                callback(error); // Configurar el manejador de errores\n                return error;\n            };\n        };\n\n        it.describe = describe;\n        it.state = state;\n\n        const context = { it };\n\n        callback.call(context, context.it);\n        updateUI(\"begin\", 0, 0, description);\n\n        return runQueue(queue, state.onFailure, it).finally(() => {\n            updateUI(\"finish\");\n        });\n    };\n\n    describe.SilencedError = class extends Error {};\n\n    return { describe };\n",
            "$code.label": "Tester API",
            "$output": "index.html"
          }
        ],
        "LswTimer API » LswTimer classes and functions": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-timer/timeformat.api.js",
            "$location": {
              "start": {
                "offset": 280,
                "line": 14,
                "column": 1
              },
              "end": {
                "offset": 372,
                "line": 15,
                "column": 1
              }
            },
            "$section": "LswTimer API » LswTimer classes and functions",
            "$code": "    // exported to LswTimer\n  const Timeformat_utils = {};\n\n  Timeformat_utils.formatHour = function (horaInput, minutoInput) {\n    const hora = (\"\" + horaInput).padStart(2, '0');\n    const minuto = (\"\" + minutoInput).padStart(2, '0');\n    return `${hora}:${minuto}`;\n  };\n\n  Timeformat_utils.formatDatestringFromDate = function (dateObject, setUntilDay = false, setMeridian = false, setSeconds = false) {\n    if(typeof dateObject === \"undefined\") {\n      return undefined;\n    }\n    const anio = (\"\" + (dateObject.getFullYear() ?? 0)).padStart(4, '0');\n    const mes = (\"\" + ((dateObject.getMonth() ?? 0) + 1)).padStart(2, '0');\n    const dia = (\"\" + (dateObject.getDate() ?? 0)).padStart(2, '0');\n    if(setUntilDay) {\n      return `${anio}/${mes}/${dia}`;\n    }\n    const hora = (\"\" + (dateObject.getHours() ?? 0)).padStart(2, '0');\n    const minuto = (\"\" + (dateObject.getMinutes() ?? 0)).padStart(2, '0');\n    const segundo = setSeconds ? (\"\" + (dateObject.getSeconds() ?? 0)).padStart(2, '0') : false;\n    return `${anio}/${mes}/${dia} ${hora}:${minuto}${typeof segundo !== \"boolean\" ? (':' + segundo) : ''}${setMeridian ? hora >= 12 ? 'pm' : 'am' : ''}`;\n  };\n\n  Timeformat_utils.getDateFromMomentoText = function (momentoText, setMeridian = false) {\n    const momentoBrute = Timeformat_parser.parse(momentoText)[0];\n    console.log(momentoBrute);\n    const date = new Date();\n    console.log(1, date);\n    if(momentoBrute.anio) {\n      date.setFullYear(momentoBrute.anio);\n      if(momentoBrute.mes === 0) {\n        throw new Error(\"Cannot set «mes» to «0» in momento text on «LswTimer.utils.getDateFromMomentoText»\");\n      }\n      date.setMonth((momentoBrute.mes-1) || 0);\n      date.setDate(momentoBrute.dia || 0);\n    }\n    date.setHours(momentoBrute.hora || 0);\n    date.setMinutes(momentoBrute.minuto || 0);\n    date.setSeconds(momentoBrute.segundo || 0);\n    date.setMilliseconds(0);\n    console.log(\"Z\", date);\n    return date;\n  };\n  \n  Timeformat_utils.formatDatetimeFromMomento = function (momentoBrute, setMeridian = false) {\n    const momento = Timeformat_utils.toPlainObject(momentoBrute);\n    const anio = (\"\" + (momento.anio ?? 0)).padStart(4, '0');\n    const mes = (\"\" + (momento.mes ?? 0)).padStart(2, '0');\n    const dia = (\"\" + (momento.dia ?? 0)).padStart(2, '0');\n    const hora = (\"\" + (momento.hora ?? 0)).padStart(2, '0');\n    const minuto = (\"\" + (momento.minuto ?? 0)).padStart(2, '0');\n    return `${anio}/${mes}/${dia} ${hora}:${minuto}${setMeridian ? hora >= 12 ? 'pm' : 'am' : ''}`;\n  };\n\n  Timeformat_utils.formatHourFromMomento = function (momentoBrute, setMeridian = false) {\n    const momento = Timeformat_utils.toPlainObject(momentoBrute);\n    const hora = (\"\" + (momento.hora ?? 0)).padStart(2, '0');\n    const minuto = (\"\" + (momento.minuto ?? 0)).padStart(2, '0');\n    return `${hora}:${minuto}${setMeridian ? hora >= 12 ? 'pm' : 'am' : ''}`;\n  };\n\n  Timeformat_utils.formatHourFromMomentoCode = function (momentoCode, setMeridian = false) {\n    const momentoBruteList = Timeformat_parser.parse(momentoCode);\n    const momentoBrute = momentoBruteList[0];\n    const momento = Timeformat_utils.toPlainObject(momentoBrute);\n    const hora = (\"\" + (momento.hora ?? 0)).padStart(2, '0');\n    const minuto = (\"\" + (momento.minuto ?? 0)).padStart(2, '0');\n    return `${hora}:${minuto}${setMeridian ? hora >= 12 ? 'pm' : 'am' : ''}`;\n  };\n\n  Timeformat_utils.addDuracionToMomento = function (momentoBrute, duracion) {\n    const momentoFinal = {};\n    const duracionParsed = Timeformat_parser.parse(duracion)[0];\n    const props = [\"anio\", \"mes\", \"dia\", \"hora\", \"minuto\", \"segundo\"];\n    const propsInDuracion = [\"anios\", \"meses\", \"dias\", \"horas\", \"minutos\", \"segundos\"];\n    for (let index = 0; index < props.length; index++) {\n      const prop = props[index];\n      const propInDuracion = propsInDuracion[index];\n      const base = momentoBrute[prop] ?? 0;\n      const aggregated = duracionParsed[propInDuracion] ?? 0;\n      momentoFinal[prop] = base + aggregated;\n    }\n    return momentoFinal;\n  };\n\n  Timeformat_utils.toPlainObject = function (obj) {\n    const seen = new WeakSet();\n    return JSON.parse(JSON.stringify(obj, (key, value) => {\n      if (typeof value === \"object\" && value !== null) {\n        if (seen.has(value)) return undefined; // Ignora referencias circulares\n        seen.add(value);\n      }\n      return value;\n    }));\n  };\n\n  Timeformat_utils.isDurationOrThrow = function (text) {\n    const errorMessage = \"It must be a duration only, like 0y 0mon 0d 0h 0min 0s 0ms\";\n    try {\n      const ast = Timeformat_parser.parse(text);\n      const mainExpression = ast[0];\n      if (mainExpression.tipo !== \"Duracion\") {\n        throw new Error(`Expression of type «${mainExpression.tipo}» is not valid. ${errorMessage}`);\n      }\n    } catch (error) {\n      console.log(text);\n      throw new Error(errorMessage);\n    }\n    return true;\n  };\n\n  Timeformat_utils.isDatetimeOrThrow = function (text) {\n    const errorMessage = \"It must be a datetime only, like 2025/01/01 00:00\";\n    try {\n      const ast = Timeformat_parser.parse(text);\n      const mainExpression = ast[0];\n      if (mainExpression.tipo !== \"FechaHora\") {\n        throw new Error(errorMessage);\n      }\n    } catch (error) {\n      throw new Error(errorMessage);\n    }\n    return true;\n  };\n\n  Timeformat_utils.isDateOrThrow = function (text) {\n    const errorMessage = \"It must be a date only, like 2025/01/01\";\n    try {\n      const ast = Timeformat_parser.parse(text);\n      const mainExpression = ast[0];\n      if (mainExpression.tipo !== \"SoloFecha\") {\n        throw new Error(errorMessage);\n      }\n    } catch (error) {\n      throw new Error(errorMessage);\n    }\n    return true;\n  };\n\n  Timeformat_utils.isHourOrThrow = function (text) {\n    const errorMessage = \"It must be an hour only, like 00:00 or 23:00\";\n    try {\n      const ast = Timeformat_parser.parse(text);\n      const mainExpression = ast[0];\n      if (mainExpression.tipo === \"Hora\") {\n        throw new Error(errorMessage);\n      }\n    } catch (error) {\n      throw new Error(errorMessage);\n    }\n    return true;\n  };\n\n  Timeformat_utils.formatDateToSpanish = function(date) {\n    const anio = date.getFullYear();\n    const month = date.getMonth();\n    const day = date.getDate();\n    const weekday = date.getDay();\n    const diaSemana = (() => {\n      if(weekday === 0) return \"Domingo\";\n      if(weekday === 1) return \"Lunes\";\n      if(weekday === 2) return \"Martes\";\n      if(weekday === 3) return \"Miércoles\";\n      if(weekday === 4) return \"Jueves\";\n      if(weekday === 5) return \"Viernes\";\n      if(weekday === 6) return \"Sábado\";\n    })();\n    const mes = (() => {\n      if(month === 0) return \"Enero\";\n      if(month === 1) return \"Febrero\";\n      if(month === 2) return \"Marzo\";\n      if(month === 3) return \"Abril\";\n      if(month === 4) return \"Mayo\";\n      if(month === 5) return \"Junio\";\n      if(month === 6) return \"Julio\";\n      if(month === 7) return \"Agosto\";\n      if(month === 8) return \"Septiembre\";\n      if(month === 9) return \"Octubre\";\n      if(month === 10) return \"Noviembre\";\n      if(month === 11) return \"Diciembre\";\n    })();\n    return `${diaSemana}, ${day} de ${mes} del ${anio}`;\n  }\n\n  Timeformat_utils.formatMomentoObjectToMomentoString = function(momento) {\n    let out = \"\";\n    const { anio = false, mes = false, dia = false, hora = false, minuto = false, segundo = false, milisegundo = false } = momento;\n    if(anio !== false) {\n      out += (\"\" + anio).padStart(4, '0');\n      out += \"/\";\n    }\n    if(mes !== false) {\n      out += (\"\" + mes).padStart(2, '0');\n      out += \"/\";\n    }\n    if(dia !== false) {\n      out += (\"\" + dia).padStart(2, '0');\n      out += \" \";\n    }\n    if(hora !== false) {\n      out += (\"\" + hora).padStart(2, '0');\n      out += \":\";\n    }\n    if(minuto !== false) {\n      out += (\"\" + minuto).padStart(2, '0');\n      out += \":\";\n    }\n    if(segundo !== false) {\n      out += (\"\" + segundo).padStart(2, '0');\n      out += \".\";\n    }\n    if(milisegundo !== false) {\n      out += (\"\" + milisegundo).padStart(3, '0');\n    }\n    return out.trim();\n  }\n\n  return {\n    parser: Timeformat_parser,\n    utils: Timeformat_utils\n  };\n",
            "$code.label": "LswTimer API",
            "$output": "index.html"
          }
        ],
        "LswTriggers API » LswTriggers classes and functions": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-trigger/triggers-class.js",
            "$location": {
              "start": {
                "offset": 290,
                "line": 14,
                "column": 1
              },
              "end": {
                "offset": 389,
                "line": 15,
                "column": 1
              }
            },
            "$section": "LswTriggers API » LswTriggers classes and functions",
            "$code": "  // exported to TriggersClass\n  class TriggersClass {\n\n    static globMatch(patterns, list) {\n      const matches = new Set();\n\n      const regexes = patterns.map(pattern => {\n        let regexPattern = pattern\n          .replace(/[-/\\\\^$+?.()|[\\]{}]/g, \"\\\\$&\") // Escapa caracteres especiales\n          .replace(/\\\\\\*/g, \".*\")                 // '*' => cualquier cosa\n        return new RegExp(`^${regexPattern}$`);\n      });\n      for (const item of list) {\n        for (const regex of regexes) {\n          if (regex.test(item)) {\n            matches.add(item);\n            break;\n          }\n        }\n      }\n\n      return Array.from(matches);\n    }\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    all = {};\n\n    register(triggerNamePattern, triggerIdentifier, triggerCallback, triggerConfigurations = {}) {\n      const { priority = 0 } = triggerConfigurations; // Default priority is 0\n      if (!this.all[triggerNamePattern]) {\n        this.all[triggerNamePattern] = [];\n      }\n      this.all[triggerNamePattern].push({\n        id: triggerIdentifier,\n        callback: triggerCallback,\n        priority,\n      });\n    }\n\n    async emit(triggerName, parameters = {}) {\n      const matchedTriggers = [];\n      const allPatterns = Object.keys(this.all);\n\n      // Encuentra patrones que coincidan con el nombre del evento\n      const matchedPatterns = this.constructor.globMatch(allPatterns, [triggerName]);\n\n      // Agrega todos los eventos coincidentes a la lista de disparos\n      for (const pattern of matchedPatterns) {\n        matchedTriggers.push(...this.all[pattern]);\n      }\n\n      // Ordena por prioridad descendente\n      matchedTriggers.sort((a, b) => b.priority - a.priority);\n\n      // Ejecuta los callbacks en orden\n      const output = [];\n      for (const trigger of matchedTriggers) {\n        const result = await trigger.callback(parameters);\n        output.push(result);\n      }\n\n      return output;\n    }\n\n    unregister(triggerIdentifier) {\n      for (const pattern in this.all) {\n        this.all[pattern] = this.all[pattern].filter(\n          (trigger) => trigger.id !== triggerIdentifier\n        );\n        if (this.all[pattern].length === 0) {\n          delete this.all[pattern]; // Limpia patrones vacíos\n        }\n      }\n    }\n\n  }\n\n  TriggersClass.default = TriggersClass;\n\n  return TriggersClass;\n",
            "$code.label": "LswTriggers API",
            "$output": "index.html"
          }
        ],
        "LswTyper API » LswTyper class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-typer/lsw-typer.api.js",
            "$location": {
              "start": {
                "offset": 282,
                "line": 14,
                "column": 1
              },
              "end": {
                "offset": 356,
                "line": 15,
                "column": 1
              }
            },
            "$section": "LswTyper API » LswTyper class",
            "$code": "  class LswTyper {\n\n    static parse(jsontypedText) {\n      return LswTyperParser.parse(jsontypedText);\n    }\n\n    constructor(types = {}) {\n      this.$types = types;\n    }\n\n    define(typeId, typeCallback) {\n      this.$types[typeId] = typeCallback;\n    }\n\n    getTypeCallbackById(typeId) {\n      return this.$types[typeId] || null;\n    }\n\n    parse(jsontypedText) {\n      const ast = this.constructor.parse(jsontypedText);\n      const json = this.constructor.resolveTypes(ast, this.$types);\n      return JSON.parse(json);\n    }\n\n    static resolveTypes(input, reducers) {\n      return JSON.stringify(input, (key, value) => {\n        const isTyped = value && (typeof value === 'object') && (\"$value\" in value) && (\"$type\" in value);\n        // Filtramos los que no son type:\n        if (!isTyped) {\n          return value;\n        }\n        console.log(\"is typed:\", key, value);\n        const $types = Array.isArray(value.$type) ? value.$type : [value.$type];\n        Iterating_possible_types:\n        for(let index=0; index<$types.length; index++) {\n          const reducerId = $types[index];\n          // Filtramos los que cuyo $type no se encuentra entre los reducers:\n          if(!(reducerId in reducers)) {\n            console.log(\"Id not found:\", reducerId);\n            continue Iterating_possible_types;\n          }\n          console.log(\"Id reduceable:\", reducerId);\n          // Aplicamos el reducer pertinente...\n          const reducer = reducers[reducerId];\n          const result = reducer(value);\n          // Y si devuelven diferente de undefined...\n          console.log(\"Reduction:\", result);\n          if (typeof result !== \"undefined\") {\n            // Los retornamos.\n            return result;\n          }\n        }\n        // Y si no devolvemos lo normal.\n        return value;\n      }, 2);\n    }\n\n  }\n\n  globalThis.$lswTyper = new LswTyper();\n\n  return LswTyper;\n",
            "$code.label": "LswTyper API",
            "$output": "index.html"
          }
        ],
        "Lsw Utils API » Lsw Utils global": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-utils/lsw-utils.js",
            "$location": {
              "start": {
                "offset": 280,
                "line": 14,
                "column": 1
              },
              "end": {
                "offset": 352,
                "line": 15,
                "column": 1
              }
            },
            "section": "Lsw Utils API » Lsw Utils global",
            "$code": "  const LswUtils = {};\n\n  LswUtils.hello = () => console.log(\"Hello!\");\n\n  ///////////////////////////////////////////////////////\n  // API de Excel: usa SheetJS\n  Object.assign(LswUtils, {\n    readFileAsArrayBuffer(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = event => resolve(event.target.result);\n        reader.onerror = error => reject(error);\n        reader.readAsArrayBuffer(file);\n      });\n    },\n    readFileAsText(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = event => resolve(event.target.result);\n        reader.onerror = error => reject(error);\n        reader.readAsText(file);\n      });\n    },\n    readFileAsBinaryString(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = event => resolve(event.target.result);\n        reader.onerror = error => reject(error);\n        reader.readAsBinaryString(file);\n      });\n    },\n    selectFile() {\n      return new Promise(resolve => {\n        const inputHtml = document.createElement(\"input\");\n        inputHtml.setAttribute(\"type\", \"file\");\n        inputHtml.setAttribute(\"accept\", \".ods,.xlsx,.xls,.csv\");\n        inputHtml.style.display = \"none\";\n        document.body.appendChild(inputHtml);\n        inputHtml.addEventListener(\"change\", event => {\n          try {\n            const file = event.target.files[0];\n            if (file) {\n              return resolve(file);\n            } else {\n              return resolve(undefined);\n            }\n          } catch (error) {\n            console.log(\"This should not happen :(\", error);\n          } finally {\n            inputHtml.remove();\n          }\n        });\n        inputHtml.click();\n      });\n    },\n    sheetToArray(sheet) {\n      // Obtener el rango de celdas activo de la hoja\n      const range = sheet['!ref']; // Ejemplo: 'A1:C3'\n      // Extraer las coordenadas de la celda inicial y final del rango\n      const [startCell, endCell] = range.split(':');\n      const startCol = startCell.match(/[A-Z]+/)[0]; // Columna de la primera celda (por ejemplo, 'A')\n      const startRow = parseInt(startCell.match(/\\d+/)[0], 10); // Fila de la primera celda (por ejemplo, 1)\n      const endCol = endCell.match(/[A-Z]+/)[0]; // Columna de la última celda (por ejemplo, 'C')\n      const endRow = parseInt(endCell.match(/\\d+/)[0], 10); // Fila de la última celda (por ejemplo, 3)\n      const data = [];\n      // Iterar sobre las filas y columnas dentro del rango\n      for (let row = startRow; row <= endRow; row++) {\n        const rowData = [];\n        for (let col = startCol.charCodeAt(0); col <= endCol.charCodeAt(0); col++) {\n          const cellAddress = String.fromCharCode(col) + row;\n          const cell = sheet[cellAddress]; // Obtener la celda\n          rowData.push(cell ? cell.v : null); // Si la celda existe, tomar su valor. Si no, agregar `null`\n        }\n        data.push(rowData); // Agregar la fila al array de datos\n      }\n      return data;\n    }\n  });\n\n  ///////////////////////////////////////////////////////\n  // API de Conductometria: usa API de Excel (so: SheetJS)\n  Object.assign(LswUtils, {\n    isDatePassed(date, time, currentDate = new Date()) {\n      const [day, month, year] = date.split(\"/\").map(Number);\n      const [hour, minute, second] = time.split(\":\").map(Number);\n      const targetDate = new Date(year, month-1, day, hour, minute, second);\n      return currentDate > targetDate;\n    },\n    sheetToRegistros(sheet, asObjectIsOkay = false) {\n      const raw = this.sheetToArray(sheet);\n      const byDate = {};\n      let lastDate = undefined;\n      const currentDate = new Date();\n      Compact_by_date_using_last_date: {\n        for (let index = 0; index < raw.length; index++) {\n          const cells = raw[index];\n          const [time, content] = cells;\n          const isDate = time.match(/[0-9][0-9]\\/[0-9][0-9]\\/[0-9][0-9]/g);\n          if (isDate) {\n            if (!(time in byDate)) {\n              byDate[time] = {};\n            }\n            lastDate = time;\n          } else {\n            if (typeof content === \"string\") {\n              if (!(time in byDate[lastDate])) {\n                byDate[lastDate][time] = [];\n              }\n              Add_properties_to_hour: {\n              }\n              const items = content.split(\".\").filter(l => l !== \"\");\n              for (let indexItem = 0; indexItem < items.length; indexItem++) {\n                const item = items[indexItem];\n                const [name, details] = item.split(\":\").filter(l => l !== \"\");\n                let event = {};\n                Add_properties_to_event: {\n                  Object.assign(event, { name });\n                  Object.assign(event, details ? { details: details.trim() } : {});\n                }\n                byDate[lastDate][time].push(event);\n              }\n            }\n          }\n        }\n      }\n      if (asObjectIsOkay) {\n        return byDate;\n      }\n      const output = [];\n      Format_to_pure_array_to_avoid_confusions: {\n        const daysSorted = Object.keys(byDate).sort();\n        for (let index_day = 0; index_day < daysSorted.length; index_day++) {\n          const day_id = daysSorted[index_day];\n          const day_data = byDate[day_id];\n          const day_output = {\n            day: day_id,\n            hours: []\n          };\n          const hoursSorted = Object.keys(day_data).sort();\n          for (let index_hour = 0; index_hour < hoursSorted.length; index_hour++) {\n            const hour_id = hoursSorted[index_hour];\n            const hour_data = day_data[hour_id];\n            const hour_is_passed = this.isDatePassed(day_id, hour_id, currentDate);\n            const hour_is_current = hour_is_passed && (() => {\n              const [hours, minutes, seconds] = hour_id.split(\":\").map(Number);\n              const hour_next_id = [hours + 1, minutes, seconds].map(t => (\"\" + t).padStart(2, \"0\")).join(\":\");\n              console.log(hour_next_id);\n              return !this.isDatePassed(day_id, hour_next_id, currentDate);\n            })();\n            const hour_output = {\n              hour: hour_id,\n              events: [],\n              passed: hour_is_passed,\n              current: hour_is_current,\n            };\n            for (let index_item = 0; index_item < hour_data.length; index_item++) {\n              const item = hour_data[index_item];\n              hour_output.events.push(item);\n            }\n            day_output.hours.push(hour_output);\n          }\n          output.push(day_output);\n        }\n      }\n      return output;\n    },\n    async loadConductometriaByExcelFile() {\n      try {\n        const file = await this.selectFile();\n        const data = await this.readFileAsBinaryString(file);\n        const workbook = XLSX.read(data, { type: \"binary\", cellDates: false });\n        const sheet = workbook.Sheets[\"Tracking\"];\n        const registros = this.sheetToRegistros(sheet);\n        return { registros };\n      } catch (error) {\n        console.log(error);\n      }\n    },\n  });\n\n  // API de LSW:\n  LswUtils.toPlainObject = function(obj) {\n    const seen = new WeakSet();\n    return JSON.parse(JSON.stringify(obj, (key, value) => {\n      if (typeof value === \"object\" && value !== null) {\n        if (seen.has(value)) return undefined; // Ignora referencias circulares\n        seen.add(value);\n      }\n      return value;\n    }));\n  };\n\n\n  LswUtils.stringify = function(argInput, avoidedIndexes = []) {\n    const seen = new WeakSet();\n    return JSON.stringify(argInput, function (key, value) {\n      if(avoidedIndexes.indexOf(key) !== -1) {\n        return;\n      }\n      if (typeof value === \"object\") {\n        if(value.$el) {\n          return `[VueComponent:${value?.$options?.name}]`;\n        }\n        if (seen.has(value)) {\n          return \"[Circular]\";\n        }\n        if (value !== null) {\n          seen.add(value);\n        }\n      }\n      return value;\n    }, 2);\n  };\n\n  LswUtils.pluralizar = function(singular, plural, contexto, cantidad) {\n    return contexto.replace(\"%s\", cantidad === 1 ? singular : plural).replace(\"%i\", cantidad);\n  };\n\n  LswUtils.getRandomString = function(len = 10) {\n    const alphabet = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\n    let out = \"\";\n    while(out.length < len) {\n      out += alphabet[Math.floor(Math.random() * alphabet.length)];\n    }\n    return out;\n  };\n\n  LswUtils.hello = function() {\n    console.log(\"hello\");\n  };\n\n  LswUtils.waitForMilliseconds = function(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  };\n\n  LswUtils.splitStringOnce = function(text, splitter) {\n    if(typeof text !== \"string\") {\n      throw new Error(\"Required parameter «text» to be a string on «LswUtils.splitStringOnce»\");\n    }\n    if(typeof splitter !== \"string\") {\n      throw new Error(\"Required parameter «text» to be a string on «LswUtils.splitStringOnce»\");\n    }\n    const pos = text.indexOf(splitter);\n    if(pos === -1) return [undefined, text];\n    const parts = text.split(\"\");\n    return [[...parts].splice(0, pos).join(\"\"), [...parts].splice(pos+1).join(\"\")];\n  };\n\n  LswUtils.reverseString = function(text) {\n    return text.split(\"\").reverse().join(\"\");\n  };\n\n  LswUtils.capitalize = function(text) {\n    return text.substr(0,1).toUpperCase() + text.substr(1);\n  };\n\n  LswUtils.startThread = function(callback) {\n    setTimeout(callback, 0);\n  };\n",
            "$code.label": "LswUtils",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswCalendario API » LswCalendario component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-calendario/lsw-calendario.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 116,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswCalendario API » LswCalendario component",
            "$code": "Vue.component(\"LswCalendario\", {\n  template: $template,\n  props: {\n    modo: {\n      type: String,\n      default: () => \"datetime\" // can be: date, time, datetime\n    },\n    valorInicial: {\n      type: [String, Date],\n      default: () => new Date()\n    },\n    alCambiarValor: {\n      type: Function,\n      default: () => { }\n    },\n  },\n  data() {\n    try {\n      this.$trace(\"lsw-calendario.data\");\n      const hoy = new Date();\n      return {\n        es_carga_inicial: true,\n        valor_inicial_adaptado: this.adaptar_valor_inicial(this.valorInicial),\n        es_solo_fecha: this.modo === \"date\",\n        es_solo_hora: this.modo === \"time\",\n        es_fecha_y_hora: this.modo === \"datetime\",\n        fecha_seleccionada: undefined,\n        celdas_del_mes_actual: undefined,\n        marcadores_del_mes: {},\n        hoy: hoy,\n        dia_actual: hoy.getDate(),\n        mes_actual: hoy.getMonth(),\n        anio_actual: hoy.getFullYear(),\n        /*\n        hora_seleccionada: \"0\",\n        minuto_seleccionado: \"0\",\n        segundo_seleccionado: \"0\",\n        milisegundo_seleccionado: \"0\",\n        //*/\n      };\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  },\n  methods: {\n    getValue() {\n      this.$trace(\"lsw-calendario.methods.getValue\");\n      return this.fecha_seleccionada;\n    },\n    adaptar_valor_inicial(valor) {\n      this.$trace(\"lsw-calendario.methods.adaptar_valor_inicial\");\n      if (typeof valor === \"string\") {\n        try {\n          const resultado = LswTimer.utils.getDateFromMomentoText(valor);\n          console.log(\"FECHA ENTRADA:\", resultado);\n          return resultado;\n        } catch (error) {\n          console.error(\"Error parseando valor inicial de lsw-calendario:\", error);\n        }\n      }\n      return valor || new Date();\n    },\n    agregar_digito_de_hora(indice) {\n      this.$trace(\"lsw-calendario.methods.agregar_digito_de_hora\");\n      const value = this.obtener_digito_de_hora(indice);\n      const isInMaximum = ([3, 5].indexOf(indice) !== -1) ? value === 5 : ([1].indexOf(indice) !== -1) ? value === 2 : value === 9;\n      if (!isInMaximum) {\n        this.establecer_digito_de_hora(indice, value + 1);\n      }\n    },\n    quitar_digito_de_hora(indice) {\n      this.$trace(\"lsw-calendario.methods.quitar_digito_de_hora\");\n      const value = this.obtener_digito_de_hora(indice);\n      const isInMinimum = value === 0;\n      if (!isInMinimum) {\n        this.establecer_digito_de_hora(indice, value - 1);\n      }\n    },\n    obtener_digito_de_hora(indice, fecha = this.fecha_seleccionada) {\n      this.$trace(\"lsw-calendario.methods.obtener_digito_de_hora\");\n      if (indice === 1) {\n        return parseInt(this.espaciar_izquierda(fecha.getHours(), 2)[0]);\n      } else if (indice === 2) {\n        return parseInt(this.espaciar_izquierda(fecha.getHours(), 2)[1]);\n      } else if (indice === 3) {\n        return parseInt(this.espaciar_izquierda(fecha.getMinutes(), 2)[0]);\n      } else if (indice === 4) {\n        return parseInt(this.espaciar_izquierda(fecha.getMinutes(), 2)[1]);\n      } else if (indice === 5) {\n        return parseInt(this.espaciar_izquierda(fecha.getSeconds(), 2)[0]);\n      } else if (indice === 6) {\n        return parseInt(this.espaciar_izquierda(fecha.getSeconds(), 2)[1]);\n      } else {\n        throw new Error(\"No se reconoció el índice del dígito: \" + indice);\n      }\n    },\n    cambiar_posicion_en_texto(texto, posicion, valor) {\n      this.$trace(\"lsw-calendario.methods.cambiar_posicion_en_texto\");\n      const arr = (\"\" + texto).split(\"\");\n      arr[posicion] = valor;\n      return arr.join(\"\");\n    },\n    establecer_digito_de_hora(indice, valor) {\n      this.$trace(\"lsw-calendario.methods.establecer_digito_de_hora\");\n      console.log(indice, valor);\n      const fecha_clonada = new Date(this.fecha_seleccionada);\n      if (indice === 1) {\n        let horas = this.espaciar_izquierda(this.fecha_seleccionada.getHours(), 2);\n        horas = this.cambiar_posicion_en_texto(horas, 0, valor);\n        const horasInt = parseInt(horas);\n        if(horasInt > 23) return;\n        fecha_clonada.setHours(horasInt);\n      } else if (indice === 2) {\n        let horas = this.espaciar_izquierda(this.fecha_seleccionada.getHours(), 2);\n        horas = this.cambiar_posicion_en_texto(horas, 1, valor);\n        const horasInt = parseInt(horas);\n        if(horasInt > 23) return;\n        fecha_clonada.setHours(horasInt);\n      } else if (indice === 3) {\n        let minutos = this.espaciar_izquierda(this.fecha_seleccionada.getMinutes(), 2);\n        minutos = this.cambiar_posicion_en_texto(minutos, 0, valor);\n        const minutosInt = parseInt(minutos);\n        if(minutosInt > 59) return;\n        fecha_clonada.setMinutes(minutosInt);\n      } else if (indice === 4) {\n        let minutos = this.espaciar_izquierda(this.fecha_seleccionada.getMinutes(), 2);\n        minutos = this.cambiar_posicion_en_texto(minutos, 1, valor);\n        const minutosInt = parseInt(minutos);\n        if(minutosInt > 59) return;\n        fecha_clonada.setMinutes(minutosInt);\n      } else if (indice === 5) {\n        // @OK\n      } else if (indice === 6) {\n        // @OK\n      } else {\n        throw new Error(\"No se reconoció el índice del dígito: \" + indice);\n      }\n      console.log(fecha_clonada);\n      this.fecha_seleccionada = fecha_clonada;\n      this.actualizar_fecha_seleccionada(true);\n    },\n    ir_a_mes_anterior() {\n      this.$trace(\"lsw-calendario.methods.ir_a_mes_anterior\");\n      try {\n        const nueva_fecha = new Date(this.fecha_seleccionada);\n        this.fecha_seleccionada = new Date(nueva_fecha.getFullYear(), nueva_fecha.getMonth()-1, 1);\n      } catch (error) {\n        console.log(error);\n        throw error;\n      }\n\n    },\n    ir_a_mes_siguiente() {\n      this.$trace(\"lsw-calendario.methods.ir_a_mes_siguiente\");\n      try {\n        const nueva_fecha = new Date(this.fecha_seleccionada);\n        this.fecha_seleccionada = new Date(nueva_fecha.getFullYear(), nueva_fecha.getMonth()+1, 1);\n      } catch (error) {\n        console.log(error);\n        throw error;\n      }\n\n    },\n    seleccionar_dia(dia) {\n      this.$trace(\"lsw-calendario.methods.seleccionar_dia\");\n      try {\n        this.fecha_seleccionada = dia;\n        this.actualizar_fecha_seleccionada(true);\n      } catch (error) {\n        console.log(error);\n        throw error;\n      }\n\n    },\n    espaciar_izquierda(texto,\n      longitud,\n      relleno = \"0\") {\n      this.$trace(\"lsw-calendario.methods.espaciar_izquierda\");\n      try {\n        let salida = \"\" + texto;\n        while (salida.length < longitud) {\n          salida = relleno + salida;\n        }\n        return salida;\n      } catch (error) {\n        console.log(error);\n        throw error;\n      }\n\n    },\n    obtener_fecha_formateada(fecha) {\n      this.$trace(\"lsw-calendario.methods.obtener_fecha_formateada\");\n      try {\n        if (!(fecha instanceof Date)) {\n          console.log(fecha);\n          throw new Error(\"Required parameter «fecha» to be a Date on «LswCalendario.methods.obtener_fecha_formateada»\");\n        }\n        let formato = \"\";\n        formato += (() => {\n          try {\n            if (fecha.getDay() === 0) {\n              return \"Domingo\";\n            }\n            if (fecha.getDay() === 1) {\n              return \"Lunes\";\n            }\n            if (fecha.getDay() === 2) {\n              return \"Martes\";\n            }\n            if (fecha.getDay() === 3) {\n              return \"Miércoles\";\n            }\n            if (fecha.getDay() === 4) {\n              return \"Jueves\";\n            }\n            if (fecha.getDay() === 5) {\n              return \"Viernes\";\n            }\n            if (fecha.getDay() === 6) {\n              return \"Sábado\";\n            }\n          } catch (error) {\n            console.log(error);\n            throw error;\n          }\n        })();\n        formato += \", \";\n        formato += fecha.getDate();\n        formato += \" de \";\n        formato += (() => {\n          try {\n            if (fecha.getMonth() === 0) {\n              return \"Enero\";\n            }\n            if (fecha.getMonth() === 1) {\n              return \"Febrero\";\n            }\n            if (fecha.getMonth() === 2) {\n              return \"Marzo\";\n            }\n            if (fecha.getMonth() === 3) {\n              return \"Abril\";\n            }\n            if (fecha.getMonth() === 4) {\n              return \"Mayo\";\n            }\n            if (fecha.getMonth() === 5) {\n              return \"Junio\";\n            }\n            if (fecha.getMonth() === 6) {\n              return \"Julio\";\n            }\n            if (fecha.getMonth() === 7) {\n              return \"Agosto\";\n            }\n            if (fecha.getMonth() === 8) {\n              return \"Septiembre\";\n            }\n            if (fecha.getMonth() === 9) {\n              return \"Octubre\";\n            }\n            if (fecha.getMonth() === 10) {\n              return \"Noviembre\";\n            }\n            if (fecha.getMonth() === 11) {\n              return \"Diciembre\";\n            }\n          } catch (error) {\n            console.log(error);\n            throw error;\n          }\n        })();\n        formato += \" de \";\n        formato += fecha.getFullYear();\n        return formato;\n      } catch (error) {\n        console.log(error);\n        throw error;\n      }\n\n    },\n    actualizar_calendario(nuevo_valor = this.fecha_seleccionada) {\n      this.$trace(\"lsw-calendario.methods.actualizar_calendario\");\n      try {\n        const dias = [];\n        const dia_1_del_mes = new Date(nuevo_valor);\n        dia_1_del_mes.setDate(1);\n        dia_1_del_mes.setHours(0);\n        dia_1_del_mes.setMinutes(0);\n        dia_1_del_mes.setSeconds(0);\n        dia_1_del_mes.setMilliseconds(0);\n        const dias_antes_de_entrar_en_el_mes = (() => {\n          try {\n            const dia_de_semana = dia_1_del_mes.getDay();\n            if (dia_de_semana === 0) {\n              return 6;\n            }\n            if (dia_de_semana === 1) {\n              return 0;\n            }\n            if (dia_de_semana === 2) {\n              return 1;\n            }\n            if (dia_de_semana === 3) {\n              return 2;\n            }\n            if (dia_de_semana === 4) {\n              return 3;\n            }\n            if (dia_de_semana === 5) {\n              return 4;\n            }\n            if (dia_de_semana === 6) {\n              return 5;\n            }\n          } catch (error) {\n            console.log(error);\n            throw error;\n          }\n        })();\n        const celdas_vacias_anteriores = new Array(dias_antes_de_entrar_en_el_mes);\n        let dia_final_del_mes = undefined;\n        Logica_anterior: {\n          dia_final_del_mes = new Date(nuevo_valor);\n          dia_final_del_mes.setMonth(dia_final_del_mes.getMonth() + 1);\n          dia_final_del_mes.setDate(1);\n          dia_final_del_mes.setDate(dia_final_del_mes.getDate() - 1);\n        }\n        Logica_chatgpt: {\n          dia_final_del_mes = new Date(nuevo_valor.getFullYear(), nuevo_valor.getMonth() + 1, 0);\n        }\n        const numero_final_de_mes = dia_final_del_mes.getDate();\n        let fila_actual = celdas_vacias_anteriores;\n        for (let index = 1; index <= numero_final_de_mes; index++) {\n          const nueva_fecha = new Date(dia_1_del_mes);\n          nueva_fecha.setDate(index);\n          fila_actual.push(nueva_fecha);\n          if (nueva_fecha.getDay() === 0) {\n            dias.push(fila_actual);\n            fila_actual = [];\n          }\n        }\n        if (fila_actual.length) {\n          dias.push(fila_actual);\n        }\n        this.celdas_del_mes_actual = dias;\n        this.propagar_cambio();\n      } catch (error) {\n        console.log(error);\n        throw error;\n      }\n    },\n    actualizar_fecha_seleccionada(con_propagacion = true, fecha_seleccionada = this.fecha_seleccionada) {\n      this.$trace(\"lsw-calendario.methods.actualizar_fecha_seleccionada\");\n      if (con_propagacion) {\n        const clon_fecha = new Date(fecha_seleccionada);\n        this.fecha_seleccionada = clon_fecha;\n      }\n    },\n    propagar_cambio() {\n      this.$trace(\"lsw-calendario.methods.propagar_cambio\");\n      if (typeof this.alCambiarValor === \"function\") {\n        this.alCambiarValor(this.fecha_seleccionada, this);\n      }\n    },\n    obtener_expresion_de_hora(fecha = this.fecha_seleccionada) {\n      let hours = fecha.getHours();\n      let minutes = fecha.getMinutes();\n      let seconds = fecha.getSeconds();\n      hours = this.espaciar_izquierda(hours, 2, \"0\");\n      minutes = this.espaciar_izquierda(minutes, 2, \"0\");\n      seconds = this.espaciar_izquierda(seconds, 2, \"0\");\n      return `${hours}:${minutes}:${seconds}`;\n    },\n    establecer_marcadores_del_mes(marcadores_del_mes) {\n      this.marcadores_del_mes = marcadores_del_mes;\n    }\n  },\n  watch: {\n    fecha_seleccionada(nuevo_valor) {\n      this.$trace(\"lsw-calendario.watch.fecha_seleccionada\");\n      this.actualizar_calendario(nuevo_valor);\n    },\n  },\n  mounted() {\n    this.$trace(\"lsw-calendario.mounted\");\n    try {\n      this.fecha_seleccionada = this.valor_inicial_adaptado;\n      this.es_carga_inicial = false;\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n});\n",
            "$code.label": "LswCalendario API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswConsoleHooker API » LswConsoleHooker API": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-console-hooker/console-hooker-api.js",
            "$location": {
              "start": {
                "offset": 290,
                "line": 14,
                "column": 1
              },
              "end": {
                "offset": 411,
                "line": 15,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswConsoleHooker API » LswConsoleHooker API",
            "$code": "  class ConsoleHooker {\n    constructor(outputElementId) {\n      this.originalConsole = { ...console }; // Guardar los métodos originales\n      this.outputElementId = outputElementId;\n      this.hookConsole();\n      this.messageCounter = 0;\n    }\n\n    hookConsole() {\n      Object.keys(console).forEach(method => {\n        if (typeof console[method] === 'function') {\n          console[method] = (...args) => {\n            this.writeToHtml(method, args);\n            this.originalConsole[method](...args); // Llamar al método original\n          };\n        }\n      });\n    }\n\n    formatError(error) {\n      let errorMessage = \"\";\n      errorMessage += \"Error: \" + error.name + \": \" + error.message;\n      if (error.location) {\n        errorMessage += JSON.stringify({\n          found: error.found,\n          expected: error.expected,\n          location: error.location\n        }, null, 2);\n      }\n      return errorMessage;\n    }\n\n    consoleReducer() {\n      return (arg) => {\n        if (typeof arg === 'object') {\n          if (arg instanceof Error) {\n            return this.formatError(arg);\n          } else {\n            const seen = new WeakSet();\n            return JSON.stringify(arg, function (key, value) {\n              if (typeof value === \"object\") {\n                if (seen.has(value)) {\n                  return \"[Circular]\";\n                }\n                if (value !== null) {\n                  seen.add(value);\n                }\n              }\n              return value;\n            }, 2);\n          }\n        } else {\n          return arg;\n        }\n      };\n    }\n\n    writeToHtml(method, args) {\n      // Do not log from this method or it becomes recursive:\n      const message = document.createElement('div');\n      message.className = `console-${method}`;\n      message.textContent = `[${this.messageCounter++}] ${args.map(this.consoleReducer()).join(' ')}`;\n      const outputElement = document.getElementById(this.outputElementId);\n      if (!outputElement) {\n        // console.log(\"no console hooker output element found\");\n        return;\n      }\n      const subnodes = outputElement.children;\n      const subnodesLength = outputElement.children.length;\n      const hasMoreThan100 = outputElement.children.length > 100;\n      if (hasMoreThan100) {\n        for (let index = subnodes.length - 1; index > 50; index--) {\n          const subnode = subnodes[index];\n          subnode.remove();\n        }\n      }\n      const parent = outputElement;\n      parent.insertBefore(message, parent.firstChild);\n    }\n\n    restoreConsole() {\n      Object.keys(this.originalConsole).forEach(method => {\n        console[method] = this.originalConsole[method];\n      });\n    }\n  }\n\n  ConsoleHooker.default = ConsoleHooker;\n\n  return ConsoleHooker;\n",
            "$code.label": "LswConsoleHooker API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswConsoleHooker API » LswConsoleHooker component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-console-hooker/console-hooker.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 125,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswConsoleHooker API » LswConsoleHooker component",
            "$code": "Vue.component(\"LswConsoleHooker\", {\n  template: $template,\n  props: {},\n  data() {\n    return {\n      is_shown: true,\n      instance: undefined\n    }\n  },\n  methods: {\n    show() {\n      this.is_shown = true;\n    },\n    hide() {\n      this.is_shown = false;\n    }\n  },\n  mounted() {\n    this.instance = new ConsoleHooker(\"lsw-console-hooker-output\");\n    if(process.env.NODE_ENV !== \"production\") {\n    }\n    this.instance.restoreConsole();\n    this.hide();\n    this.$vue.prototype.$consoleHooker = this;\n    this.$window.LswConsoleHooker = this;\n  },\n  unmounted() {\n\n  }\n});\n",
            "$code.label": "LswConsoleHooker API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswDialogs API » LswDialogs classes and functions": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-dialogs/lsw-dialogs.js",
            "$location": {
              "start": {
                "offset": 16,
                "line": 3,
                "column": 1
              },
              "end": {
                "offset": 137,
                "line": 4,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswDialogs API » LswDialogs classes and functions",
            "$code": "  const defaultDialogFactory = () => {\n    return {\n      props: {},\n      data() {\n        return {};\n      },\n      methods: {},\n      mounted() { },\n    };\n  };\n\n  class Dialog {\n    static fromIdToComponentName(id) {\n      return \"lsw-dialog-\" + id;\n    }\n    constructor(info = {}) {\n      Object.assign(this, info);\n      Validations: {\n        if (typeof this.id !== \"string\") {\n          throw new Error(`Required parameter «dialog.id» to be a string on «Dialog.constructor»`);\n        }\n        if (typeof this.name !== \"string\") {\n          throw new Error(`Required parameter «dialog.name» to be a string on «Dialog.constructor»`);\n        }\n        if (typeof this.priority !== \"number\") {\n          throw new Error(`Required parameter «dialog.priority» to be a number on «Dialog.constructor»`);\n        }\n        if (typeof this.component !== \"object\") {\n          throw new Error(`Required parameter «dialog.component» to be an object on «Dialog.constructor»`);\n        }\n        if (typeof this.promiser !== \"object\") {\n          throw new Error(`Required parameter «dialog.promiser» to be an object on «Dialog.constructor»`);\n        }\n        if (!(this.promiser.promise instanceof Promise)) {\n          throw new Error(`Required parameter «dialog.promiser.promise» to be an instance of Promise on «Dialog.constructor»`);\n        }\n        if (typeof this.promiser.resolve !== \"function\") {\n          throw new Error(`Required parameter «dialog.promiser.resolve» to be an function on «Dialog.constructor»`);\n        }\n        if (typeof this.promiser.reject !== \"function\") {\n          throw new Error(`Required parameter «dialog.promiser.reject» to be an function on «Dialog.constructor»`);\n        }\n        if (typeof this.acceptButton !== \"object\") {\n          this.acceptButton = false;\n        }\n        if (typeof this.cancelButton !== \"object\") {\n          this.cancelButton = false;\n        }\n      }\n    }\n  }\n\n  const closeSubdialogsHook = function (id, lswDialogs) {\n    const ids = Object.keys(lswDialogs.opened);\n    for (let index_dialog = 0; index_dialog < ids.length; index_dialog++) {\n      const idOpened = ids[index_dialog];\n      const idParent = lswDialogs.opened[idOpened].parentId;\n      if (idParent === id) {\n        lswDialogs.close(idOpened);\n      }\n    }\n  };\n\n  Vue.component(\"LswDialogs\", {\n    name: \"LswDialogs\",\n    template: $template,\n    props: {\n      asWindows: {\n        type: Boolean,\n        default: () => false\n      }\n    },\n    data() {\n      this.$trace(\"lsw-dialogs.data\", []);\n      return {\n        enabledWindowsSystem: this.asWindows,\n        opened: {},\n        openedLength: 0,\n        notMinimizedLength: 0,\n        hookOnOpen: undefined,\n        hookOnClose: closeSubdialogsHook,\n      };\n    },\n    watch: {\n      opened(newValue) {\n        this.$trace(\"lsw-dialogs.watch.opened\", [\"too long object\"]);\n        this.openedLength = (typeof newValue !== \"object\") ? 0 : Object.keys(newValue).length;\n        this._refreshMinimizedLength(newValue);\n      }\n    },\n    methods: {\n      open(parametricObject = {}) {\n        this.$trace(\"lsw-dialogs.methods.open\", arguments);\n        if (typeof parametricObject !== \"object\") {\n          throw new Error(`Required argument «parametricObject» to be an object on «LswDialogs.methods.open»`);\n        }\n        const {\n          template,\n          title = \"\",\n          id = \"default\",\n          priority = 500,\n          factory = defaultDialogFactory,\n          parentId = undefined,\n          created_at = new Date()\n        } = parametricObject;\n        const componentInfo = {};\n        if (typeof id !== \"string\") {\n          throw new Error(`Required parameter «id» to be a string on «LswDialogs.methods.open»`);\n        }\n        if (id in this.opened) {\n          return this.maximize(id);\n          // throw new Error(`Cannot open dialog «${id}» because it is already opened on «LswDialogs.methods.open»`);\n        }\n        if (typeof template !== \"string\") {\n          throw new Error(`Required parameter «template» to be a string on «LswDialogs.methods.open»`);\n        }\n        if (typeof factory === \"object\") {\n          // @OK\n        } else if (typeof factory !== \"function\") {\n          throw new Error(`Required parameter «factory» to be an object or a function on «LswDialogs.methods.open»`);\n        }\n        if (typeof priority !== \"number\") {\n          throw new Error(`Required parameter «priority» to be a number on «LswDialogs.methods.open»`);\n        }\n        const dialogComponentInput = typeof factory === \"function\" ? factory() : factory;\n        const dialogComponentData = (() => {\n          if (typeof dialogComponentInput.data === \"undefined\") {\n            return function () { return {}; };\n          } else if (typeof dialogComponentInput.data === \"object\") {\n            return function () { return dialogComponentInput.data };\n          } else if (typeof dialogComponentInput.data === \"function\") {\n            return dialogComponentInput.data;\n          } else {\n            console.log(dialogComponentInput.data);\n            throw new Error(\"Required parameter «data» returned by «factory» to be an object, a function or empty on «LswDialogs.methods.open»\");\n          }\n        })();\n        const scopifyMethods = function (obj, scope) {\n          return Object.keys(obj).reduce((out, k) => {\n            const v = obj[k];\n            if (typeof v !== \"function\") {\n              out[k] = v;\n            } else {\n              out[k] = v.bind(scope);\n            }\n            return out;\n          }, {});\n        };\n        // 1) Este es para el Vue.component:\n        const componentId = Dialog.fromIdToComponentName(id);\n        const dialogComponent = Object.assign({}, dialogComponentInput, {\n          name: componentId,\n          template,\n          data(component, ...args) {\n            this.$trace(`lsw-dialogs.[${componentId}].data`, [\"too long object\"]);\n            const preData = dialogComponentData.call(this);\n            if (typeof preData.value === \"undefined\") {\n              preData.value = \"\";\n            };\n            // console.log(\"El data del nuevo componente dialog:\", preData);\n            dialogComponentInput.watch = scopifyMethods(dialogComponentInput.watch || {}, component);\n            dialogComponentInput.computed = scopifyMethods(dialogComponentInput.computed || {}, component);\n            dialogComponentInput.methods = scopifyMethods(dialogComponentInput.methods || {}, component);\n            return preData;\n          },\n          watch: (dialogComponentInput.watch || {}),\n          computed: (dialogComponentInput.computed || {}),\n          methods: {\n            getValue() {\n              this.$trace(`lsw-dialogs.[${componentId}].methods.getValue`, []);\n              return JSON.parse(JSON.stringify(this.value));\n            },\n            accept(solution = undefined, ...args) {\n              this.$trace(`lsw-dialogs.[${componentId}].methods.accept`, [solution, ...args]);\n              if (solution instanceof Event) {\n                return this.$dialogs.resolve(id, this.getValue()).close(id);\n              }\n              return this.$dialogs.resolve(id, typeof solution !== \"undefined\" ? solution : this.getValue()).close(id);\n            },\n            cancel(...args) {\n              this.$trace(\"lsw-dialogs.[${componentId}].methods.cancel\", args);\n              return this.$dialogs.resolve(id, -1).close(id);\n            },\n            abort(error = undefined, ...args) {\n              this.$trace(`lsw-dialogs.[${componentId}].methods.abort`, [error, ...args]);\n              if (solution instanceof Event) {\n                return this.$dialogs.reject(id, new Error(\"Aborted dialog error\")).close(id);\n              }\n              return this.$dialogs.reject(id, error).close(id);\n            },\n            close(...args) {\n              this.$trace(`lsw-dialogs.[${componentId}].methods.close`, args);\n              return this.$dialogs.resolve(id, -2).close(id);\n            },\n            ...(dialogComponentInput.methods || {})\n          }\n        });\n        Define_component: {\n          Vue.component(dialogComponent.name, dialogComponent);\n        }\n        // 1) Este es para el this.$dialogs:\n        const dialogDefinition = Object.assign({}, {\n          ...parametricObject,\n          id,\n          title,\n          name: dialogComponent.name,\n          component: dialogComponent,\n          priority,\n          minimized: false,\n          parentId,\n          created_at,\n          promiser: Promise.withResolvers(),\n        });\n        const dialogInstance = new Dialog(dialogDefinition);\n        // console.log(\"Definición final del dialogo\", dialogInstance);\n        Define_dialog: {\n          this.opened = Object.assign({}, this.opened, {\n            [id]: dialogInstance\n          });\n        }\n        if (typeof this.hookOnOpen === \"function\") {\n          this.hookOnOpen(this.opened[id], id, this);\n        }\n        return this.opened[id].promiser.promise;\n      },\n      resolve(id, solution, ...args) {\n        this.$trace(\"lsw-dialogs.methods.resolve\", [id, solution, ...args]);\n        if (typeof id !== \"string\") {\n          throw new Error(\"Required parameter «id» (argument:1) to be a string on «LswDialogs.resolve»\");\n        }\n        if (!(id in this.opened)) {\n          throw new Error(`Cannot resolve dialog «${id}» because it is not opened on «LswDialogs.resolve»`);\n        }\n        this.opened[id].promiser.resolve(solution);\n        return {\n          close: () => this.close(id)\n        };\n      },\n      reject(id, error, ...args) {\n        this.$trace(\"lsw-dialogs.methods.reject\", [id, error, ...args]);\n        if (typeof id !== \"string\") {\n          throw new Error(\"Required parameter «id» (argument:1) to be a string on «LswDialogs.reject»\");\n        }\n        if (!(id in this.opened)) {\n          throw new Error(`Cannot reject dialog «${id}» because it is not opened on «LswDialogs.reject»`);\n        }\n        this.opened[id].promiser.reject(error);\n        return {\n          close: () => this.close(id)\n        };\n      },\n      close(id, ...args) {\n        this.$trace(\"lsw-dialogs.methods.close\", [id, ...args]);\n        if (typeof id !== \"string\") {\n          throw new Error(\"Required parameter «id» (argument:1) to be a string on «LswDialogs.close»\");\n        }\n        if (!(id in this.opened)) {\n          throw new Error(`Cannot close dialog «${id}» because it is not opened on «LswDialogs.close»`);\n        }\n        let promiseOfDialog = undefined;\n        Undefine_component: {\n          const dialogName = Dialog.fromIdToComponentName(id);\n          delete Vue.options.components[dialogName];\n        }\n        Undefine_dialog: {\n          Solve_promise_if_not_already: {\n            if (this.opened[id].promiser.promise.state === \"pending\") {\n              this.opened[id].promiser.resolve(-3);\n            }\n          }\n          promiseOfDialog = this.opened[id].promiser.promise;\n          delete this.opened[id];\n          this.opened = Object.assign({}, this.opened);\n        }\n        if (typeof this.hookOnClose === \"function\") {\n          this.hookOnClose(id, this);\n        }\n        return promiseOfDialog;\n        // this.$forceUpdate(true);\n      },\n      minimize(id, ...args) {\n        this.$trace(\"lsw-dialogs.methods.minimize\", [id, ...args]);\n        if (typeof id !== \"string\") {\n          throw new Error(\"Required parameter «id» (argument:1) to be a string on «LswDialogs.minimize»\");\n        }\n        if (!(id in this.opened)) {\n          throw new Error(`Cannot minimize dialog «${id}» because it is not opened on «LswDialogs.minimize»`);\n        }\n        this.opened[id].minimized = true;\n        this._refreshMinimizedLength(this.opened);\n      },\n      maximize(id, ...args) {\n        this.$trace(\"lsw-dialogs.methods.maximize\", [id, ...args]);\n        if (typeof id !== \"string\") {\n          throw new Error(\"Required parameter «id» (argument:1) to be a string on «LswDialogs.maximize»\");\n        }\n        if (!(id in this.opened)) {\n          throw new Error(`Cannot minimize dialog «${id}» because it is not opened on «LswDialogs.maximize»`);\n        }\n        Iterating_dialogs:\n        for (let dialogId in this.opened) {\n          if (id === dialogId) {\n            continue Iterating_dialogs;\n          }\n          const dialogData = this.opened[dialogId];\n          const currentPriority = parseInt(dialogData.priority);\n          this.opened[dialogId].priority = currentPriority - 1;\n\n        }\n        this.opened[id].priority = 500;\n        this.opened[id].minimized = false;\n        this._refreshMinimizedLength();\n      },\n      _refreshMinimizedLength(newValue = this.opened, ...args) {\n        this.$trace(\"lsw-dialogs.methods._refreshMinimizedLength\", [\"too long object\", ...args]);\n        this.notMinimizedLength = Object.keys(newValue).reduce((out, k) => {\n          const v = newValue[k];\n          if (v.minimized === false) {\n            out++;\n          }\n          return out;\n        }, 0);\n        this.$forceUpdate(true);\n      },\n      goHome(...args) {\n        this.$trace(\"lsw-dialogs.methods.goHome\", [...args]);\n        this.$window.LswWindows.show();\n      },\n      onOpen(callback, ...args) {\n        this.$trace(\"lsw-dialogs.methods.onOpen\", [callback, ...args]);\n        this.hookOnOpen = callback;\n      },\n      onClose(callback, ...args) {\n        this.$trace(\"lsw-dialogs.methods.onClose\", [callback, ...args]);\n        this.hookOnClose = callback;\n      }\n    },\n    mounted(...args) {\n      this.$trace(\"lsw-dialogs.mounted\", [...args]);\n      Vue.prototype.$dialogs = this;\n      if (Vue.prototype.$lsw) {\n        Vue.prototype.$lsw.dialogs = this;\n      }\n      window.LswDialogs = this;\n      console.log(\"[*] LswDialogs mounted.\");\n    }\n  });\n",
            "$code.label": "LswDialogs API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw SchemaBasedForm API » LswNotes component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-notes/lsw-notes.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 112,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw SchemaBasedForm API » LswNotes component",
            "$code": "Vue.component(\"LswNotes\", {\n  template: $template,\n  props: {\n    \n  },\n  data() {\n    this.$trace(\"lsw-notes.data\");\n    return {\n      isLoaded: false,\n      allNotes: false,\n      currentError: this.error,\n    };\n  },\n  methods: {\n    setError(error = undefined) {\n      this.$trace(\"lsw-notes.methods.setError\");\n      this.currentError = error;\n    },\n    async loadNotes() {\n      this.$trace(\"lsw-notes.methods.loadNotes\");\n      // *@TODO: seleccionar e importar notes.\n      this.isLoaded = false;\n      const notes = await this.$lsw.database.selectMany(\"Nota\");\n      const notesSorted = notes.sort((n1, n2) => {\n        const d1 = LswTimer.utils.getDateFromMomentoText(n1.tiene_fecha);\n        const d2 = LswTimer.utils.getDateFromMomentoText(n2.tiene_fecha);\n        if(d1 >= d2) return -1;\n        return 1;\n      });\n      this.allNotes = notesSorted;\n      this.isLoaded = true;\n    },\n    async openAddNoteDialog() {\n      this.$trace(\"lsw-notes.methods.openAddNoteDialog\");\n      const response = await this.$lsw.dialogs.open({\n        title: \"Nueva nota\",\n        template: `<div class=\"pad_1 position_absolute top_0 right_0 left_0 bottom_0 flex_column\">\n          <div class=\"flex_1\">\n            <input class=\"width_100\" type=\"text\" v-model=\"value.tiene_fecha\" placeholder=\"Fecha de la nota\" ref=\"fecha\" />\n          </div>\n          <div class=\"flex_1 flex_row centered\" style=\"padding-top: 1px;\">\n            <div class=\"flex_1\">Estado: </div>\n            <select class=\"flex_100\" v-model=\"value.tiene_estado\">\n              <option value=\"creada\">Creada</option>\n              <option value=\"procesada\">Procesada</option>\n              <option value=\"dudosa\">Dudosa</option>\n              <option value=\"desestimada\">Desestimada</option>\n            </select>\n          </div>\n          <div class=\"flex_1\" style=\"padding-top: 2px;\">\n            <input class=\"width_100\" type=\"text\" v-model=\"value.tiene_categorias\" placeholder=\"categoría 1; categoria 2; categoria 3\" />\n          </div>\n          <div class=\"flex_100\" style=\"padding-top: 1px;\">\n            <textarea v-focus v-model=\"value.tiene_contenido\" spellcheck=\"false\" style=\"height: 100%;\" placeholder=\"Contenido de la nota. Acepta **markdown**, recuerda.\" ref=\"contenido\" />\n          </div>\n          <div class=\"flex_1\" style=\"padding-top: 2px;\">\n            <input class=\"width_100\" type=\"text\" v-model=\"value.tiene_titulo\" placeholder=\"Título de la nota\" ref=\"titulo\" />\n          </div>\n          <div class=\"flex_row pad_top_1\">\n            <div class=\"flex_100\"></div>\n            <div class=\"flex_1 flex_row\">\n              <div class=\"pad_right_1\">\n                <button class=\"mini\" v-on:click=\"validate\">➕ Añadir</button>\n              </div>\n              <div>\n                <button class=\"mini\" v-on:click=\"cancel\">❌ Cancelar</button>\n              </div>\n            </div>\n          </div>\n        </div>`,\n        factory: {\n          methods: {\n            validate() {\n              const isValidFecha = LswTimer.parser.parse(this.value.tiene_fecha);\n              const isValidContenido = this.value.tiene_contenido.trim() !== \"\";\n              const isValidTitulo = this.value.tiene_titulo.trim() !== \"\";\n              if(!isValidTitulo) {\n                window.alert(\"Necesita un título la nota.\");\n                return this.$refs.titulo.focus();\n              }\n              if(!isValidContenido) {\n                window.alert(\"Necesita un contenido la nota.\");\n                return this.$refs.contenido.focus();\n              }\n              if(!isValidFecha) {\n                window.alert(\"Necesita una fecha válida la nota.\");\n                return this.$refs.fecha.focus();\n              }\n              return this.accept();\n            }\n          },\n          data: {\n            value: {\n              tiene_fecha: LswTimer.utils.formatDatestringFromDate(new Date(), false, false, true),\n              tiene_titulo: \"\",\n              tiene_categorias: \"\",\n              tiene_contenido: \"\",\n              tiene_estado: \"creada\", // \"procesada\"\n            }\n          }\n        }\n      });\n      if(typeof response !== \"object\") return;\n      await this.$lsw.database.insert(\"Nota\", response);\n      await this.loadNotes();\n    }\n  },\n  watch: {},\n  async mounted() {\n    try {\n      this.$trace(\"lsw-notes.mounted\");\n      await this.loadNotes();\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswNotes API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw SchemaBasedForm API » LswSchemaBasedForm component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-schema-based-form/lsw-schema-based-form.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 132,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw SchemaBasedForm API » LswSchemaBasedForm component",
            "$code": "Vue.component(\"LswSchemaBasedForm\", {\n  template: $template,\n  props: {\n    model: {\n      type: Object,\n      required: true,\n    },\n    onSubmit: {\n      type: Function,\n      default: () => this.$noop,\n    },\n    onValidate: {\n      type: Function,\n      default: () => this.$noop,\n    },\n    onDeleteRow: {\n      type: Function,\n      default: () => this.$noop,\n    },\n    overridenValues: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  data() {\n    this.$trace(\"lsw-schema-based-form.data\");\n    this.validateModel(this.model);\n    const isOperation = (this.model.row && this.model.row.id) || (this.model.rowId && (this.model.rowId !== -1)) ? \"update\" : \"insert\";\n    return {\n      own: this,\n      validFormtypes: [\n        \"text\",\n        \"long-text\",\n        \"options\",\n        \"boolean\",\n        \"date\",\n        \"duration\",\n        \"ref-object\",\n        \"ref-list\",\n        \"ref-relation\",\n        \"source-code\",\n      ],\n      section: 'campos propios', // 'campos reflejos'\n      isShowingFormInfo: false,\n      isLoaded: false,\n      tableDefinition: false,\n      columnDefinitions: false,\n      value: this.model.row ?? false,\n      editableFields: [],\n      minimizedFields: [],\n      isOperation,\n      isUpdateOperation: isOperation === \"update\",\n      isInsertOperation: isOperation === \"insert\",\n    };\n  },\n  methods: {\n    selectSection(section) {\n      this.section = section;\n    },\n    toggleMinimizedField(field) {\n      this.$trace(\"lsw-schema-based-form.methods.toggleMinimizedField\");\n      const fieldPos = this.minimizedFields.indexOf(field);\n      if (fieldPos === -1) {\n        this.minimizedFields.push(field);\n      } else {\n        this.minimizedFields.splice(fieldPos, 1);\n      }\n      this.$forceUpdate(true);\n    },\n    hideMinimizedField(field) {\n      this.$trace(\"lsw-schema-based-form.methods.hideMinimizedField\");\n      const fieldPos = this.minimizedFields.indexOf(field);\n      if (fieldPos === -1) {\n        this.minimizedFields.push(field);\n      }\n      this.$forceUpdate(true);\n    },\n    showMinimizedField(field) {\n      this.$trace(\"lsw-schema-based-form.methods.showMinimizedField\");\n      const fieldPos = this.minimizedFields.indexOf(field);\n      if (fieldPos !== -1) {\n        this.minimizedFields.splice(fieldPos, 1);\n      }\n      this.$forceUpdate(true);\n    },\n    toggleEditableField(field) {\n      this.$trace(\"lsw-schema-based-form.methods.toggleEditableField\");\n      const fieldPos = this.editableFields.indexOf(field);\n      if (fieldPos === -1) {\n        this.editableFields.push(field);\n      } else {\n        this.editableFields.splice(fieldPos, 1);\n      }\n    },\n    saveField(field, value) {\n      this.$trace(\"lsw-schema-based-form.methods.saveField\");\n      console.log(\"Should save field:\", field, value);\n      // *@TODO: use $lsw.database.overwrite to send the field only\n\n    },\n    validateModel(model) {\n      this.$trace(\"lsw-schema-based-form.methods.validateModel\");\n      try {\n        const ensureModel = $ensure({ model }, 1);\n        const checkModel = $check(model);\n        Basic_type_and_signature: {\n          ensureModel.type(\"object\");\n          ensureModel.to.have.uniquelyKeys([\"connection\", \"databaseId\", \"tableId\", \"rowId\", \"row\", \"databaseExplorer\"]);\n          ensureModel.to.have.keys([\"databaseId\", \"tableId\"]);\n          const correctOption = $ensure.$or({\n            \"has connection and rowId\": () => ensureModel.to.have.key(\"rowId\"),\n            \"has row\": () => ensureModel.to.have.key(\"row\"),\n          });\n          if (!checkModel.to.have.key(\"rowId\")) {\n            ensureModel.to.have.key(\"row\");\n          }\n        }\n        Component_types_and_signatures: {\n          if (checkModel.to.have.key(\"connection\")) {\n            ensureModel.its(\"connection\").type(\"object\");\n          }\n          if (checkModel.to.have.key(\"databaseId\")) {\n            ensureModel.its(\"databaseId\").type(\"string\");\n          }\n          if (checkModel.to.have.key(\"tableId\")) {\n            ensureModel.its(\"tableId\").type(\"string\");\n          }\n          if (checkModel.to.have.key(\"rowId\")) {\n            ensureModel.its(\"rowId\").type(\"number\");\n          }\n          if (checkModel.to.have.key(\"row\")) {\n            $ensure.$or({\n              \"row is object\": () => ensureModel.its(\"row\").type(\"object\"),\n              \"row is false\": () => ensureModel.its(\"row\").type(\"boolean\").is(false),\n            });\n          }\n          if(checkModel.to.have.key(\"databaseExplorer\")) {\n            ensureModel.its(\"databaseExplorer\").type(\"object\");\n          }\n        }\n      } catch (error) {\n        console.error(\"Failed validating «model» property on «lsw-schema-based-form.validateModel»\");\n        console.error(error);\n      }\n    },\n    async loadValue() {\n      this.$trace(\"lsw-schema-based-form.methods.loadValue\");\n      if (this.model.rowId) {\n        const originalValues = await LswDatabase.pickRow(this.model.databaseId, this.model.tableId, this.model.rowId);\n        this.value = Object.assign({}, originalValues, this.overridenValues);\n      }\n    },\n    onlyKnownTypes(formtype) {\n      if(this.validFormtypes.indexOf(formtype) !== -1) {\n        return formtype;\n      }\n      return \"long-text\";\n    },\n    async loadSchema() {\n      this.$trace(\"lsw-schema-based-form.methods.loadSchema\");\n      const columnIds = Object.keys($lswSchema.$schema.hasTables[this.model.tableId].hasColumns);\n      for(let columnId of columnIds) {\n        const columnData = $lswSchema.$schema.hasTables[this.model.tableId].hasColumns[columnId];\n        Object.assign(columnData, {\n          belongsToDatabase: this.model.databaseId,\n          belongsToTable: this.model.tableId,\n          hasFormtypeSettings: {\n            id: 'lsw-' + this.onlyKnownTypes(columnData.isFormType) + '-control',\n            name: columnId,\n            input: {\n              props: {\n                placeholder: columnData.hasPlaceholder,\n              },\n              events: {\n                \n              }\n            },\n          }\n        })\n      }\n      this.tableDefinition = $lswSchema.$schema.hasTables[this.model.tableId];\n      this.columnDefinitions = this.tableDefinition.hasColumns;\n    },\n    toggleFormInfo() {\n      this.$trace(\"lsw-schema-based-form.methods.toggleFormInfo\");\n      this.isShowingFormInfo = !this.isShowingFormInfo;\n    },\n    closeEditables() {\n      this.$trace(\"lsw-schema-based-form.methods.closeEditables\");\n      const uneditables = this.$el.querySelectorAll(\".lsw_form_control .lsw_control_label .button_to_uneditable\");\n      for(let index=0; index<uneditables.length; index++) {\n        const uneditable = uneditables[index];\n        uneditable.click();\n      }\n    },\n    openEditables() {\n      this.$trace(\"lsw-schema-based-form.methods.openEditables\");\n      const editables = this.$el.querySelectorAll(\".lsw_form_control .lsw_control_label .button_to_editable\");\n      for(let index=0; index<editables.length; index++) {\n        const editable = editables[index];\n        editable.click();\n      }\n    },\n    validateForm() {\n      this.$trace(\"lsw-schema-based-form.methods.validateForm\");\n      return this.$refs.schemaForm0.$xform.validate();\n    },\n    async submitForm(v) {\n      this.$trace(\"lsw-schema-based-form.methods.submitForm\");\n      return await this.$refs.schemaForm0.$xform.submit();\n    },\n    async deleteRow() {\n      this.$trace(\"lsw-schema-based-form.methods.submitForm\");\n      const confirmed = await Vue.prototype.$dialogs.open({\n        title: \"Eliminar registro\",\n        template: `\n          <div>\n            <div class=\"pad_2\">¿Seguro que quieres eliminar el registro?</div>\n            <hr class=\"margin_0\" />\n            <div class=\"pad_2 text_align_right\">\n              <button class=\"danger_button\" v-on:click=\"() => accept(true)\">Eliminar</button>\n              <button class=\"\" v-on:click=\"() => accept(false)\">Cancelar</button>\n            </div>\n          </div>\n        `,\n      });\n      if(!confirmed) return false;\n      await this.$lsw.database.delete(this.model.tableId, this.model.rowId || this.model.row.id);\n      if(this.onDeleteRow) {\n        this.onDeleteRow(this.model.rowId, this.model.tableId, true);\n      }\n      if(this.model.databaseExplorer) {\n        this.model.databaseExplorer.selectPage(\"LswPageRows\", {\n          database: this.model.databaseId,\n          table: this.model.tableId,\n        });\n      }\n    }\n  },\n  watch: {\n    \n  },\n  async mounted() {\n    try {\n      this.$trace(\"lsw-schema-based-form.mounted\");\n      await this.loadSchema();\n      await this.loadValue();\n      this.isLoaded = true;\n      this.$nextTick(() => {\n        window.sf0 = this.$refs.schemaForm0;\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswSchemaBasedForm API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Toasts API » LswToasts component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-toasts/lsw-toasts.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 105,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Toasts API » LswToasts component",
            "$code": "Vue.component(\"LswToasts\", {\n  template: $template,\n  props: {},\n  data() {\n    return {\n      sent: {}\n    };\n  },\n  methods: {\n    getRandomString(len = 10) {\n      const alphabet = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\n      let out = \"\";\n      while(out.length < len) {\n        out += alphabet[Math.floor(Math.random() * alphabet.length)];\n      }\n      return out;\n    },\n    send(toastsInput = {}) {\n      const toastData = Object.assign({\n        id: this.getRandomString(),\n        title: \"\",\n        text: \"\",\n        timeout: 3000,\n        orientation: \"bottom\",\n        background: \"rgba(255,255,255,0.5)\",\n        foreground: \"#000\",\n        started_at: new Date()\n      }, toastsInput);\n      if(typeof toastData.timeout !== \"number\") {\n        throw new Error(\"Required parameter «timeout» to be a number or empty on «LswToasts.methods.send»\");\n      }\n      if(isNaN(toastData.timeout)) {\n        throw new Error(\"Required parameter «timeout» to be a (non-NaN) number or empty on «LswToasts.methods.send»\");\n      }\n      if([\"top\", \"bottom\", \"center\"].indexOf(toastData.orientation) === -1) {\n        throw new Error(\"Required parameter «orientation» to be a string (top, center, bottom) or empty on «LswToasts.methods.send»\");\n      }\n      if(toastData.id in this.sent) {\n        throw new Error(\"Required parameter «id» to not be repeated on «LswToasts.methods.send»\");\n      }\n      this.sent = Object.assign({}, this.sent, {\n        [toastData.id]: toastData\n      });\n      setTimeout(() => {\n        this.close(toastData.id);\n      }, toastData.timeout);\n    },\n    close(id) {\n      delete this.sent[id];\n      this.$forceUpdate(true);\n    }\n  },\n  watch: {},\n  mounted() {\n    this.$toasts = this;\n    this.$window.LswToasts = this;\n    if(this.$lsw) {\n      this.$lsw.toasts = this;\n    }\n  }\n});\n",
            "$code.label": "LswToasts API",
            "$output": "index.html"
          }
        ],
        "Lsw Directives » v-call directive": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/directives/v-call/v-call.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 74,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Lsw Directives » v-call directive",
            "$code": "Vue.directive(\"call\", {\n  inserted: function(el) {\n    \n  }\n});\n",
            "$code.label": "v-call API",
            "$output": "index.html"
          }
        ],
        "Lsw Directives » v-descriptor directive": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/directives/v-descriptor/v-descriptor.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 86,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Lsw Directives » v-descriptor directive",
            "$code": "(() => {\n\n  const getDescriptorKeys = function (el, binding) {\n    if (binding.expression.startsWith(\"'\") || binding.expression.startsWith('\"')) {\n      return (binding.value || el.getAttribute(\"descriptor\")).split(\" \");\n    }\n    return (binding.expression || el.getAttribute(\"descriptor\")).split(\" \");\n  };\n\n  Vue.directive(\"descriptor\", {\n    bind(el, binding) {\n      const resolveClasses = key => {\n        let resolved = window.stylingDescriptor[key];\n        if (!resolved) return key;\n        if (typeof resolved === \"string\") {\n          resolved = resolved.split(\" \");\n        }\n        return resolved.map(subKey => resolveClasses(subKey)).flat();\n      };\n      const descriptorKeys = getDescriptorKeys(el, binding);\n      const descriptorClasses = descriptorKeys.map(key => resolveClasses(key)).flat();\n      descriptorClasses.forEach(cls => {\n        if (cls.indexOf(\".\") === -1) {\n          el.classList.add(cls);\n        }\n      });\n    }\n  });\n\n  const styleTag = document.createElement(\"style\");\n  styleTag.textContent = `\n  .title_of_form {\n    border: 1px solid #113;\n    box-shadow: 0 0 4px black;\n    border-radius: 0pt;\n    color: black;\n    width: 100%;\n    padding: 8px;\n    font-size: 12px;\n    background-color: #AAF;\n  }\n  .block_of_form {\n    padding: 4px;\n    padding-left: 0px;\n    padding-right: 0px;\n    padding-bottom: 0px;\n    padding-top: 0px;\n  }\n  .bordered_1 {\n    border: 1px solid #999;\n    border-radius: 2pt;\n  }\n  .with_separator_on_bottom_1 {\n    border-bottom: 1px solid #999;\n  }\n  .lateral_button {\n    height: 100%;\n  }\n  .lateral_button_cell {\n    padding-top: 4px;\n    padding-bottom: 4px;\n    padding-right: 4px;\n  }\n  .padded_1 {\n    padding: 4px;\n  }\n  .vertically_padded_1 {\n    padding-top: 4px;\n    padding-bottom: 4px;\n  }\n  .horizontally_padded_1 {\n    padding-left: 4px;\n    padding-right: 4px;\n  }\n  .left_padded_1 {\n    padding-left: 4px;\n  }\n  .right_padded_1 {\n    padding-right: 4px;\n  }\n  .top_padded_1 {\n    padding-top: 4px;\n  }\n  .bottom_padded_1 {\n    padding-bottom: 4px;\n  }\n  .calendar_main_panel {\n    padding-left: 0px;\n    padding-right: 0px;\n    padding-top: 0px;\n    padding-bottom: 4px;\n  }\n  .calendar_buttons_panel_1 {\n    padding-bottom: 0px;\n    padding-top: 0px;\n  }\n`;\n\n  window.addEventListener(\"load\", function() {\n    console.log(document);\n    document.body.appendChild(styleTag);\n  });\n\n  window.stylingDescriptor = {\n    \"agenda.calendar.buttons_panel_1\": \"calendar_main_panel calendar_buttons_panel_1\",\n    \"agenda.task_form.title\": \"title_of_form\",\n    \"agenda.task_form.block\": \"block_of_form\",\n    \"agenda.task_form.block_of_add_button\": \"block_of_form vertically_padded_1\",\n    \"agenda.task_form.block_of_aggregated_field\": \"bordered_1\",\n    \"agenda.task_form.section\": \"with_separator_on_bottom_1\",\n    \"agenda.task_form.aggregations.block\": \"block_of_form\",\n    \"agenda.task_form.aggregations.lateral_button\": \"lateral_button\",\n    \"agenda.task_form.aggregations.lateral_button_cell\": \"lateral_button_cell\",\n    \"lsw_table.no_data_provided_message\": \"pad_top_2 pad_bottom_2\"\n  }\n\n})();\n",
            "$code.label": "v-descriptor API",
            "$output": "index.html"
          }
        ],
        "Lsw Directives » v-focus directive": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/directives/v-focus/v-focus.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 76,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Lsw Directives » v-focus directive",
            "$code": "Vue.directive(\"focus\", {\n  inserted: function(el) {\n    el.focus();\n  }\n});\n",
            "$code.label": "v-focus API",
            "$output": "index.html"
          }
        ],
        "Lsw Directives » v-xform directive": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/directives/v-xform/v-xform.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 77,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Lsw Directives » v-xform directive",
            "$code": "(function (factory) {\n  const mod = factory();\n  if (typeof window !== 'undefined') {\n    window['LswXForm'] = mod;\n  }\n  if (typeof global !== 'undefined') {\n    global['LswXForm'] = mod;\n  }\n  if (typeof module !== 'undefined') {\n    module.exports = mod;\n  }\n})(function () {\n\n  let isTracing = true;\n  let $COUNTADOR1 = 0;\n\n  const trace = function (method, args = []) {\n    if (isTracing) {\n      console.log(\"[trace][lsw-xform][\" + method + \"]\", args.length);\n    }\n  };\n\n  const XformCommonInterface = class {\n    formInterface = \"Common\";\n    static create(...args) {\n      return new this(...args);\n    }\n    constructor(inheritedArgument, subtype) {\n      const { el, binding, scope } = inheritedArgument;\n      trace(\"XformCommonInterface.constructor:\" + this.formInterface);\n      this.$el = el;\n      this.$binding = binding;\n      this.$component = scope;\n      this.$type = subtype;\n      this.$name = this.$binding.value?.name || false;\n      this.$onValidateInterfaceArguments();\n      this.$injectAttributesToElement();\n    }\n    $injectAttributesToElement() {\n      trace(\"XformCommonInterface.$injectAttributesToElement:\" + this.formInterface);\n      this.$el.setAttribute(\"data-xform-node\", this);\n    }\n    $onValidateInterfaceArguments() {\n      trace(\"XformCommonInterface.$onValidateInterfaceArguments:\" + this.formInterface);\n      const ensureEl = $ensure(this.$el).type(\"object\").to.be.instanceOf(HTMLElement);\n      const ensureBinding = $ensure(this.$binding).type(\"object\");\n      const ensureValue = ensureBinding.its(\"value\").type(\"object\");\n      const checkValue = $check(ensureValue.$subject);\n      $ensure(this.$type).type(\"string\").to.be.oneOf([\"form\", \"control\", \"input\", \"error\"]);\n      ensureValue.to.have.keys([\"name\"]).its(\"name\").type(\"string\").back();\n      if (checkValue.to.have.key(\"onSetError\")) {\n        ensureValue.its(\"onSetError\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onClearError\")) {\n        ensureValue.its(\"onClearError\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onGetValue\")) {\n        ensureValue.its(\"onGetValue\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onGetChildren\")) {\n        ensureValue.its(\"onGetChildren\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onValidate\")) {\n        ensureValue.its(\"onValidate\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onSubmit\")) {\n        ensureValue.its(\"onSubmit\").type(\"function\");\n      }\n    }\n    validate() {\n      trace(\"XformCommonInterface.validate:\" + this.formInterface);\n      const value = this.getValue();\n      const result = this.$hookWith(\"onValidate\", [value, this]);\n      this.$propagateSuccess();\n      return true;\n    }\n    $getParent(onlyTypes = false) {\n      trace(\"XformCommonInterface.$getParent:\" + this.formInterface);\n      if (typeof onlyTypes === \"string\") {\n        onlyTypes = [onlyTypes];\n      }\n      const found = LswDom.getClosestParent(this.$el, \"[data-xform-node]\");\n      if (!Array.isArray(onlyTypes)) {\n        return found;\n      } else if (!found?.length) {\n        return found;\n      }\n      return found.filter(el => onlyTypes.indexOf(el.$xform.$type) !== -1);\n    }\n    $getChildren(onlyTypesInput = false) {\n      trace(\"XformCommonInterface.$getChildren:\" + this.formInterface);\n      let onlyTypes = onlyTypesInput;\n      if (typeof onlyTypesInput === \"string\") {\n        onlyTypes = [onlyTypesInput];\n      }\n      const found = LswDom.getClosestChildren(this.$el, \"[data-xform-node]\");\n      if (!Array.isArray(onlyTypes)) {\n        return found;\n      } else if (!found?.length) {\n        return found;\n      }\n      const foundChildren = found.filter(el => onlyTypes.indexOf(el.$xform.$type) !== -1);\n      return foundChildren;\n    }\n    getValue() {\n      trace(\"XformCommonInterface.getValue:\" + this.formInterface);\n      const result = this.$hookWith(\"onGetValue\");\n      if (typeof result !== \"undefined\") {\n        return result;\n      }\n      return this.$getChildren([\"form\", \"control\", \"input\"]).reduce((output, el) => {\n        const hasName = el.$xform.$binding.value.name;\n        if (hasName === \"*\") {\n          output = el.$xform.getValue();\n        } else if (!hasName) {\n          // @OK...\n        } else {\n          output[hasName] = el.$xform.getValue();\n        }\n        return output;\n      }, {});\n    }\n    $hookWith(hookId, parameters = []) {\n      trace(\"XformCommonInterface.$hookWith:\" + this.formInterface);\n      if (!(hookId in this.$binding.value)) {\n        console.log(`[-] No hooks found for ${hookId}`);\n        return undefined;\n      }\n      const hookFunction = this.$binding.value[hookId];\n      if (typeof hookFunction === \"undefined\") {\n        console.log(`[-] Hook with bad type found for ${hookId}`);\n        return undefined;\n      } else if (typeof hookFunction !== \"function\") {\n        throw new Error(`Expected parameter «${hookId}» to be a function on «$hookWith»`);\n      }\n      console.log(`[*] Executing hook for ${hookId}`);\n      console.log(hookFunction.toString(), parameters);\n      return hookFunction(...parameters);\n    }\n    $setError(error) {\n      trace(\"XformCommonInterface.$setError:\" + this.formInterface);\n      this.$error = error;\n      this.$hookWith(\"onSetError\", [error, this]);\n      return this;\n    }\n    $clearError() {\n      trace(\"XformCommonInterface.$clearError:\" + this.formInterface);\n      this.$error = false;\n      this.$hookWith(\"onClearError\", [this]);\n      return this;\n    }\n    $propagateError(error, rethrowIt = 1, propagateDown = 1, propagateUp = 1) {\n      trace(\"XformCommonInterface.$propagateError:\" + this.formInterface);\n      try {\n        if (this.$binding.value.debug) {\n          console.error(`[DEBUG] Error propagated to «v-form.${this.$type}»:`, error);\n        }\n        const contador = ++$COUNTADOR1;\n        Propagate_down: {\n          if(!propagateDown) {\n            break Propagate_down;\n          }\n          console.log(\"propagate down now \" + contador + \" \" + this.formInterface);\n          const propagableChildren = this.$getChildren([\"error\"]);\n          console.log(propagableChildren);\n          if (propagableChildren && propagableChildren.length) {\n            for (let index = 0; index < propagableChildren.length; index++) {\n              const child = propagableChildren[index];\n              child.$xform.$setError(error);\n            }\n          }\n          console.log(\"ok down now \" + contador + \" \" + this.formInterface);\n        }\n        Propagate_up: {\n          if(!propagateUp) {\n            break Propagate_up;\n          }\n          console.log(\"propagate up now \" + contador + \" \" + this.formInterface);\n          const propagableParent = this.$getParent([\"form\", \"control\"]);\n          console.log(propagableParent);\n          if (propagableParent) {\n            try {\n              propagableParent.$xform.$propagateError(error, 1);\n            } catch (error) {\n              console.log(error);\n            }\n          }\n          console.log(\"ok up now \" + contador + \" \" + this.formInterface);\n        }\n      } catch (error) {\n        console.log(error);\n      } finally {\n        this.$setError(error);\n        if (rethrowIt === 1) {\n          throw error;\n        }\n      }\n    }\n    $propagateSuccess() {\n      trace(\"XformCommonInterface.$propagateSuccess:\" + this.formInterface);\n      // this.$getParent([\"form\", \"control\"]).$propagateSuccess(error);\n      const contador = ++$COUNTADOR1;\n      Propagate_down: {\n        console.log(\"propagate SUCCESS down now (to errors)\" + contador + \" \" + this.formInterface);\n        const propagableChildren = this.$getChildren([\"error\"]);\n        console.log(propagableChildren);\n        for (let index = 0; index < propagableChildren.length; index++) {\n          const child = propagableChildren[index];\n          child.$xform.$clearError();\n        }\n        console.log(\"ok down now (to errors)\" + contador + \" \" + this.formInterface);\n      }\n      this.$clearError();\n    }\n  };\n\n  const XformForm = class extends XformCommonInterface {\n    formInterface = \"Form\";\n    $onValidateInterfaceArguments() {\n      trace(\"XformForm.$onValidateInterfaceArguments\");\n      const ensureEl = $ensure(this.$el);\n      const ensureBinding = $ensure(this.$binding);\n      const ensureValue = ensureBinding.its(\"value\").type(\"object\");\n      const checkValue = $check(ensureValue.$subject);\n    }\n    submit() {\n      trace(\"XformForm.submit\");\n      const resultado = this.validate();\n      if(resultado !== true) throw new Error(\"Could not validate form\");\n      const value = this.getValue();\n      const result = this.$hookWith(\"onSubmit\", [value], this);\n      if (typeof result !== \"undefined\") {\n        return result;\n      }\n    }\n    validate() {\n      trace(\"XformForm.validate\");\n      try {\n        const allChildren = this.$getChildren([\"form\", \"control\"]);\n        let allErrors = 0;\n        for (let indexChild = 0; indexChild < allChildren.length; indexChild++) {\n          const child = allChildren[indexChild];\n          console.log(\"Validating [from form] now child to validate:\", child);\n          try {\n            const result = child.$xform.validate();\n            if(!result) {\n              allErrors++;\n            }\n          } catch (error) {\n            allErrors++;\n          }\n        }\n        if(allErrors > 0) {\n          throw new Error(`Form has «${allErrors}» validation errors. Fix them to continue.`);\n        }\n        const resultado = super.validate();\n        if(resultado !== true) {\n          throw new Error(\"Could not validate form natively (calling super.validate) on «XformForm.validate»\");\n        }\n        this.$propagateSuccess();\n        return true;\n      } catch (error) {\n        this.$propagateError(error, 0, 1, 0);\n        throw error;\n      }\n    }\n  };\n\n  const XformControl = class extends XformCommonInterface {\n    formInterface = \"Control\";\n    $onValidateInterfaceArguments() {\n      trace(\"XformControl.$onValidateInterfaceArguments\");\n      const ensureEl = $ensure(this.$el);\n      const ensureBinding = $ensure(this.$binding);\n      const ensureValue = ensureBinding.its(\"value\").type(\"object\");\n      const checkValue = $check(ensureValue.$subject);\n      ensureValue.to.have.keys([\"name\"]).its(\"name\").type(\"string\").back();\n      if (checkValue.to.have.key(\"onSetError\")) {\n        ensureValue.its(\"onSetError\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onClearError\")) {\n        ensureValue.its(\"onClearError\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onGetValue\")) {\n        ensureValue.its(\"onGetValue\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onGetChildren\")) {\n        ensureValue.its(\"onGetChildren\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onValidate\")) {\n        ensureValue.its(\"onValidate\").type(\"function\");\n      }\n    }\n    $validateChildren() {\n      trace(\"XformControl.$validateChildren\");\n      const allChildren = this.$getChildren([\"form\", \"control\", \"input\"]);\n      for (let indexChild = 0; indexChild < allChildren.length; indexChild++) {\n        const child = allChildren[indexChild];\n        console.log(\"Validating [from control] now child to validate:\", child);\n        child.$xform.validate();\n      }\n      this.$propagateSuccess();\n    }\n    validate(deeply = false) {\n      trace(\"XformControl.validate\");\n      try {\n        const value = this.getValue();\n        this.$hookWith(\"onValidate\", [value, this]);\n        this.$propagateSuccess();\n        return true;\n      } catch (error) {\n        this.$propagateError(error, 0, 1, 0);\n      }\n    }\n  };\n\n  const XformInput = class extends XformCommonInterface {\n    formInterface = \"Input\";\n    validate() {\n      trace(\"XformInput.validate\");\n      const value = this.getValue();\n      this.$hookWith(\"onValidate\", [value, this]);\n      return true;\n    }\n    $onValidateInterfaceArguments() {\n      trace(\"XformInput.$onValidateInterfaceArguments\");\n      const ensureEl = $ensure(this.$el);\n      const ensureBinding = $ensure(this.$binding);\n      const ensureValue = ensureBinding.its(\"value\").type(\"object\");\n      const checkValue = $check(ensureValue.$subject);\n      ensureValue.to.have.keys([\"name\"]).its(\"name\").type(\"string\").back();\n      if (checkValue.to.have.key(\"onSetError\")) {\n        ensureValue.its(\"onSetError\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onClearError\")) {\n        ensureValue.its(\"onClearError\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onGetValue\")) {\n        ensureValue.its(\"onGetValue\").type(\"function\");\n      }\n    }\n    getValue() {\n      trace(\"XformInput.getValue\");\n      if ([\"INPUT\", \"TEXTAREA\", \"SELECT\"].indexOf(this.$el.tagName) !== -1) {\n        const ownValue = this.$el.value;\n        return ownValue;\n      } else {\n        return super.getValue();\n      }\n    }\n    $propagateSuccess() {\n      const control = this.$getParent([\"control\"]);\n      control.$xform.$propagateSuccess();\n    }\n  };\n\n  const XformError = class extends XformCommonInterface {\n    formInterface = \"Error\";\n    $onValidateInterfaceArguments() {\n      trace(\"XformError.$onValidateInterfaceArguments\");\n      const ensureEl = $ensure(this.$el);\n      const ensureBinding = $ensure(this.$binding);\n      const ensureValue = ensureBinding.its(\"value\").type(\"object\");\n      const checkValue = $check(ensureValue.$subject);\n      if (checkValue.to.have.key(\"onSetError\")) {\n        ensureValue.its(\"onSetError\").type(\"function\");\n      }\n      if (checkValue.to.have.key(\"onClearError\")) {\n        ensureValue.its(\"onClearError\").type(\"function\");\n      }\n    }\n    validate() {\n      // @EMPTY.\n    }\n    $getChildren() {\n      trace(\"XformError.$getChildren\");\n      throw new Error(`Error can not contain children on «XformError.$getChildren»`);\n    }\n    getValue() {\n      trace(\"XformError.getValue\");\n      throw new Error(`Error can not contain a value on «XformError.getValue»`);\n    }\n    $setError(error) {\n      trace(\"XformError.$setError\");\n      this.$error = error;\n      this.$el.classList.add(\"error_is_affecting_field\");\n      try {\n        const summarizedError = error.summarized();\n        summarizedError.stack2 = summarizedError.stack.map(tr => {\n          return tr.split(\"\\n\").map((msg, errorIndex) => {\n            const [callbackName, rest1] = LswUtils.splitStringOnce(msg, \"@\");\n            if (!rest1) {\n              return [1, callbackName, rest1];\n            }\n            const rest2 = LswUtils.reverseString(rest1);\n            const [columnReversed, rest3] = LswUtils.splitStringOnce(rest2, \":\");\n            if (!rest3) {\n              return [3, rest3, columnReversed, callbackName];\n              return msg;\n            }\n            const [lineReversed, errorSource] = LswUtils.splitStringOnce(rest3, \":\");\n            if (!errorSource) {\n              return [5, errorSource, lineReversed, rest3, columnReversed, callbackName];\n              return msg;\n            }\n            const line = LswUtils.reverseString(lineReversed);\n            const column = LswUtils.reverseString(columnReversed);\n            return `${errorIndex + 1}. ${LswUtils.reverseString(errorSource)}:${line}:${column}::${callbackName}`;\n          }).join(\"\\n\")\n        });\n        this.$getErrorMessageElement().textContent = `${error.name}: ${error.message}.\\n${summarizedError.stack2}`;\n      } catch (error2) {\n        this.$getErrorMessageElement().textContent = `${error.name}: ${error.message} [${error.stack}]`;\n      }\n      try {\n        this.$hookWith(\"onSetError\", [error, this]);\n      } catch (error) {\n        console.log(error);\n      }\n      return this;\n    }\n    $getErrorMessageElement() {\n      return (this.$el.querySelector(\".errorMessage\") || this.$el);\n    }\n    $clearError() {\n      trace(\"XformError.$clearError\");\n      this.$error = undefined;\n      this.$el.classList.remove(\"error_is_affecting_field\");\n      this.$getErrorMessageElement().textContent = ``;\n      this.$hookWith(\"onClearError\", [this]);\n      return this;\n    }\n  };\n\n  const xformClasses = {\n    form: XformForm,\n    control: XformControl,\n    input: XformInput,\n    error: XformError,\n  };\n\n  Vue.directive(\"xform\", {\n    bind(el, binding) {\n      trace(\"xform-directive.bind\");\n      // console.log(binding);\n      const modifierType = Object.keys(binding.modifiers)[0];\n      if (!(modifierType in xformClasses)) {\n        throw new Error(\"Required directive «v-form» to be injected with a known modifier on «xform.bind»\");\n      }\n      const xformClass = xformClasses[modifierType];\n      const xformInstance = xformClass.create({ el, binding, scope: this }, modifierType);\n      el.$xform = xformInstance;\n    },\n    unbind(el) {\n      trace(\"xform-directive.unbind\");\n      delete el.$xform.$binding;\n      delete el.$xform.$el;\n      delete el.$xform;\n    }\n  });\n\n  const XFormPublicAPI = {\n    validateSettings(settings) {\n      trace(\"XFormPublicAPI.validateSettings\");\n      const checkSettings = $check(settings);\n      const ensureSettings = $ensure(settings).type(\"object\").to.have.key(\"name\");\n      ensureSettings.its(\"name\").type(\"string\").back();\n      if (checkSettings.to.have.key(\"input\")) {\n        const ensureInput = ensureSettings.its(\"input\").type(\"object\");\n        ensureInput.to.have.uniquelyKeys([\"props\", \"events\"]);\n        ensureInput.its(\"props\").type(\"object\");\n        ensureInput.its(\"events\").type(\"object\");\n      }\n    }\n  }\n\n  return XFormPublicAPI;\n\n});\n",
            "$code.label": "LswXForm API",
            "$output": "index.html"
          }
        ],
        "Módulo org.allnulled.lsw-conductometria » Vue.js (v2) Components » LswAutomensajesViewer API » LswAutomensajesViewer component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/modules/org.allnulled.lsw-conductometria/components/lsw-automensajes-viewer/lsw-automensajes-viewer.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 182,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Módulo org.allnulled.lsw-conductometria » Vue.js (v2) Components » LswAutomensajesViewer API » LswAutomensajesViewer component",
            "$code": "Vue.component(\"LswAutomensajesViewer\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-automensajes-viewer.data\");\n    return {\n      allAutomensajes: [],\n    };\n  },\n  methods: {\n    async loadAutomensajes() {\n      this.$trace(\"LswAutomensajesViewer.methods.loadAutomensajes\", arguments);\n      this.allAutomensajes = [];\n    }\n  },\n  watch: {},\n  async mounted() {\n    try {\n      this.$trace(\"lsw-automensajes-viewer.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  },\n  unmount() {\n    this.$trace(\"lsw-automensajes-viewer.unmount\");\n  }\n});\n",
            "$code.label": "LswAutomensajesViewer API",
            "$output": "index.html"
          }
        ],
        "Módulo org.allnulled.lsw-conductometria » Vue.js (v2) Components » LswCurrentAccionViewer API » LswCurrentAccionViewer component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/modules/org.allnulled.lsw-conductometria/components/lsw-current-accion-viewer/lsw-current-accion-viewer.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 185,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Módulo org.allnulled.lsw-conductometria » Vue.js (v2) Components » LswCurrentAccionViewer API » LswCurrentAccionViewer component",
            "$code": "Vue.component(\"LswCurrentAccionViewer\", {\n  template: $template,\n  props: {\n    \n  },\n  data() {\n    this.$trace(\"lsw-current-accion-viewer.data\");\n    return {\n      currentDate: new Date(),\n      selectedSection: 'none', // 'antes', 'despues'\n      accionesAntes: false,\n      accionesDespues: false,\n    };\n  },\n  methods: {\n    selectSection(section) {\n      this.$trace(\"lsw-current-accion-viewer.selectSection\");\n      if(this.selectedSection === section) {\n        this.selectedSection = \"none\";\n      } else {\n        this.selectedSection = section;\n      }\n      if([\"antes\", \"despues\"].indexOf(section) !== -1) {\n        this.loadAcciones();\n      } else {\n        this.$forceUpdate(true);\n      }\n    },\n    async loadAcciones() {\n      this.$trace(\"lsw-current-accion-viewer.loadAcciones\");\n      const output = await this.$lsw.database.selectMany(\"Accion\");\n      const estaHora = (() => {\n        const d = new Date();\n        d.setHours(0);\n        return d;\n      })();\n      const accionesAntes = [];\n      const accionesDespues = [];\n      output.forEach(accion => {\n        console.log(accion.tiene_inicio);\n        try {\n          const dateAccion = LswTimer.utils.getDateFromMomentoText(accion.tiene_inicio);\n          console.log(dateAccion);\n          if(dateAccion >= estaHora) {\n            accionesDespues.push(accion);\n          } else {\n            accionesAntes.push(accion);\n          }\n        } catch (error) {\n          console.log(error);\n        }\n      });\n      this.accionesAntes = accionesAntes;\n      this.accionesDespues = accionesDespues;\n      this.$forceUpdate(true);\n    },\n    async alternarEstado(accion) {\n      this.$trace(\"lsw-current-accion-viewer.methods.alternarEstado\");\n      const nextEstado = accion.tiene_estado === \"pendiente\" ? \"completada\" : \n        accion.tiene_estado === \"completada\" ? \"fallida\" : \"pendiente\";\n      await this.$lsw.database.update(\"Accion\", accion.id, {\n        ...accion,\n        tiene_estado: nextEstado\n      });\n      await this.loadAcciones();\n    },\n    startTimer() {\n      this.timerId = setTimeout(() => {\n        this.currentDate = new Date();\n        this.startTimer();\n      }, 1000);\n    },\n    stopTimer() {\n      clearTimeout(this.timerId);\n    }\n  },\n  watch: {},\n  async mounted() {\n    try {\n      this.$trace(\"lsw-current-accion-viewer.mounted\");\n      await this.loadAcciones();\n      this.startTimer();\n    } catch(error) {\n      console.log(error);\n    }\n  },\n  unmount() {\n    this.stopTimer();\n  }\n});\n",
            "$code.label": "LswCurrentAccionViewer API",
            "$output": "index.html"
          }
        ],
        "Módulo org.allnulled.lsw-conductometria » Vue.js (v2) Components » LswProtolangEditor API » LswProtolangEditor component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/modules/org.allnulled.lsw-conductometria/components/lsw-protolang-editor/lsw-protolang-editor.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 173,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Módulo org.allnulled.lsw-conductometria » Vue.js (v2) Components » LswProtolangEditor API » LswProtolangEditor component",
            "$code": "Vue.component(\"LswProtolangEditor\", {\n  template: $template,\n  props: {\n    initialContents: {\n      type: String,\n      default: () => \"\"\n    }\n  },\n  data() {\n    this.$trace(\"lsw-protolang-editor.data\");\n    return {\n      error: false,\n      result: false,\n      contents: this.initialContents,\n      placeholder: `rel correr\n  > cardio * 1\n  > musculación * 0.3\n  >> propagador de correr * []`\n    };\n  },\n  methods: {\n    setError(error) {\n      this.$trace(\"lsw-protolang-editor.methods.setError\");\n      this.error = error;\n    },\n    setResult(result) {\n      this.$trace(\"lsw-protolang-editor.methods.setResult\");\n      this.result = result;\n    },\n    async validateCode() {\n      this.$trace(\"lsw-protolang-editor.methods.validateCode\");\n      try {\n        const value = this.contents;\n        const js = await Protolang.codify(value);\n        console.log(js);\n        this.setError(false);\n        this.setResult(js);\n      } catch (error) {\n        this.setError(error);\n      }\n    },\n    async evaluateCode() {\n      this.$trace(\"lsw-protolang-editor.methods.evaluateCode\");\n      try {\n        const value = this.contents;\n        const js = await Protolang.codify(value);\n        console.log(js);\n        this.setError(false);\n      } catch (error) {\n        this.setError(error);\n      }\n    },\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-protolang-editor.mounted\");\n      this.$window.protolangEditor = this;\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswProtolangEditor API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgenda API » LswAgenda component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/lsw-agenda/lsw-agenda.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 120,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgenda API » LswAgenda component",
            "$code": "Vue.component(\"LswAgenda\", {\n  name: \"LswAgenda\",\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda.data\");\n    return {\n      counter: 0,\n      isLoading: false,\n      hasPsicodelia: true,\n      selectedContext: \"agenda\",\n      selectedSubmenu1: 'none',\n      selectedDate: undefined,\n      selectedDateTasks: undefined,\n      selectedDateTasksFormattedPerHour: undefined,\n      selectedForm: undefined,\n      hiddenDateHours: [],\n    };\n  },\n  methods: {\n    showAllHours() {\n      this.$trace(\"lsw-agenda.methods.showAllHours\");\n      this.hiddenDateHours = [];\n    },\n    hideAllHours() {\n      this.$trace(\"lsw-agenda.methods.hideAllHours\");\n      this.hiddenDateHours = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\"];\n    },\n    selectContext(id, parameters = {}) {\n      this.$trace(\"lsw-agenda.methods.selectContext\");\n      this.selectedSubmenu1 = \"none\";\n      this.selectedContextParameters = parameters;\n      this.selectedContext = id;\n    },\n    selectSubmenu1(id) {\n      this.$trace(\"lsw-agenda.methods.selectSubmenu1\");\n      this.selectedSubmenu1 = id;\n    },\n    togglePsicodelia() {\n      this.$trace(\"lsw-agenda.methods.togglePsicodelia\");\n      this.hasPsicodelia = !this.hasPsicodelia;\n    },\n    toggleHour(hourInt) {\n      this.$trace(\"lsw-agenda.methods.toggleHour\");\n      const pos = this.hiddenDateHours.indexOf(hourInt);\n      if (pos === -1) {\n        this.hiddenDateHours.push(hourInt);\n      } else {\n        this.hiddenDateHours.splice(pos, 1);\n      }\n    },\n    async loadDateTasks(newDate, calendario) {\n      this.$trace(\"lsw-agenda.methods.loadDateTasks\");\n      this.isLoading = true;\n      console.log(\"Loading date tasks of: \" + newDate);\n      try {\n        this.selectedDate = newDate;\n        const selectedDate = this.selectedDate;\n        const selectedDateTasks = await this.$lsw.database.selectMany(\"Accion\", valueBrute => {\n          try {\n            const valueList = Timeformat_parser.parse(valueBrute.tiene_inicio);\n            const value = valueList[0];\n            const isSameYear = value.anio === selectedDate.getFullYear();\n            const isSameMonth = value.mes === (selectedDate.getMonth() + 1);\n            const isSameDay = value.dia === selectedDate.getDate();\n            const isAccepted = isSameYear && isSameMonth && isSameDay;\n            return isAccepted;\n          } catch (error) {\n            return true;\n          }\n        });\n        this.selectedDateTasks = selectedDateTasks;\n        this.propagateDateTasks();\n      } catch (error) {\n        console.log(\"Error loading date taskes:\", error);\n      } finally {\n        setTimeout(() => {this.isLoading = false}, 100);\n      }\n      if(calendario) {\n        const selectedDate = this.selectedDate;\n        const tasksOfMonth = await this.$lsw.database.selectMany(\"Accion\", valueBrute => {\n          const valueList = Timeformat_parser.parse(valueBrute.tiene_inicio);\n          const value = valueList[0];\n          const isSameYear = value.anio === selectedDate.getFullYear();\n          const isSameMonth = value.mes === (selectedDate.getMonth() + 1);\n          const isAccepted = isSameYear && isSameMonth;\n          return isAccepted;\n        });\n        const tasksOfMonthByDay = tasksOfMonth.reduce((out, item) => {\n          const valueList = Timeformat_parser.parse(item.tiene_inicio);\n          const value = valueList[0];\n          const day = value.dia;\n          if(!(day in out)) {\n            out[day] = [];\n          }\n          out[day].push(item);\n          return out;\n        }, {});\n        calendario.establecer_marcadores_del_mes(tasksOfMonthByDay);\n      }\n    },\n    groupTasksByHour(tareas = this.selectedDateTasks) {\n      this.$trace(\"lsw-agenda.methods.groupTasksByHour\");\n      const mapaHoras = {};\n      Agrupacion_inicial:\n      for (let i = 0; i < tareas.length; i++) {\n        const tarea = tareas[i];\n        const { tiene_inicio } = tarea;\n        const [inicioObject] = Timeformat_parser.parse(tiene_inicio);\n        const { hora, minuto } = inicioObject;\n        if(typeof hora !== \"number\") {\n          continue Agrupacion_inicial;\n        }\n        if (!(hora in mapaHoras)) {\n          mapaHoras[hora] = [];\n        }\n        mapaHoras[hora].push(tarea);\n      }\n      //return mapaHoras;\n      const segunHoras = [];\n      Formateo_final:\n      for(let hora in mapaHoras) {\n        const lista = mapaHoras[hora];\n        segunHoras.push({\n          hora,\n          tareas: lista,\n        });\n      }\n      return segunHoras;\n    },\n    propagateDateTasks() {\n      this.$trace(\"lsw-agenda.methods.propagateDateTasks\");\n      this.selectedDateTasksFormattedPerHour = this.groupTasksByHour();\n    },\n    async openInsertTaskDialog() {\n      this.$trace(\"lsw-agenda.methods.openInsertTaskDialog\");\n      // *@TODO: \n    },\n    async openUpdateTaskDialog(tarea) {\n      this.$trace(\"lsw-agenda.methods.openUpdateTaskDialog\");\n      // *@TODO: \n      this.selectHour(tarea.id);\n    },\n    async openDeleteTaskDialog(tarea, e) {\n      this.$trace(\"lsw-agenda.methods.openDeleteTaskDialog\");\n      const confirmed = await Vue.prototype.$dialogs.open({\n        title: \"Eliminar registro\",\n        template: `\n          <div>\n            <div class=\"pad_2\">¿Seguro que quieres eliminar el registro?</div>\n            <hr class=\"margin_0\" />\n            <div class=\"pad_2 text_align_right\">\n              <button class=\"danger_button\" v-on:click=\"() => accept(true)\">Eliminar</button>\n              <button class=\"\" v-on:click=\"() => accept(false)\">Cancelar</button>\n            </div>\n          </div>\n        `,\n      });\n      console.log(confirmed);\n      if(!confirmed) return false;\n      await this.$lsw.database.delete(\"Accion\", tarea.id);\n      this.selectedForm = undefined;\n      this.refreshTasks();\n    },\n    selectHour(hora) {\n      this.$trace(\"lsw-agenda.methods.selectHour\");\n      if(this.selectedForm === hora) {\n        this.selectedForm = undefined;\n      } else {\n        this.selectedForm = hora;\n      }\n    },\n    async refreshTasks() {\n      this.$trace(\"lsw-agenda.methods.refreshTasks\");\n      this.loadDateTasks(new Date(this.selectedDate));\n    },\n    async onUpdateTask(v, tarea) {\n      this.$trace(\"lsw-agenda.methods.onUpdateTask\");\n      await this.$lsw.database.update('Accion', tarea.id, v);\n      this.selectedForm = tarea.id;\n      this.refreshTasks();\n    },\n    async onInsertTask(v, tarea) {\n      this.$trace(\"lsw-agenda.methods.onInsertTask\");\n      const id = await this.$lsw.database.insert('Accion', v);\n      this.selectedForm = id;\n      this.refreshTasks();\n    },\n    async advanceTaskState(tarea) {\n      this.$trace(\"lsw-agenda.methods.onInsertTask\");\n      const siguienteEstado = (() => {\n        switch(tarea.tiene_estado) {\n          case \"pendiente\": return \"completada\";\n          case \"completada\": return \"fallida\";\n          case \"fallida\": return \"pendiente\";\n          default: return \"pendiente\";\n        }\n      })();\n      await this.$lsw.database.overwrite('Accion', tarea.id, {\n        tiene_estado: siguienteEstado\n      });\n      this.refreshTasks();\n    }\n  },\n  watch: {\n  },\n  async mounted() {\n    try {\n      this.$trace(\"lsw-agenda.mounted\");\n      const selectedDate = this.$refs.calendario.getValue();\n      this.loadDateTasks(selectedDate);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgenda API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswDataExplorer API » LswDataExplorer API": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-explorer/lsw-data-explorer/lsw-data-explorer.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 116,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswDataExplorer API » LswDataExplorer API",
            "$code": "Vue.component('LswDataExplorer', {\n  template: $template,\n  props: {\n    value: {\n      required: true\n    },\n    pageSize: {\n      type: Number,\n      default: 10\n    },\n    level: {\n      type: Number,\n      default: 0\n    },\n    pointer: {\n      type: Array,\n      default: () => []\n    }\n  },\n  data() {\n    return {\n      hasLoadedInnerValue: true,\n      isLoadingInnerValue: false,\n      originalValue: this.value,\n      innerValue: this.value,\n      textFilter: \"\",\n      isShowingTopPanel: false,\n      isShowingRelatedDocuments: false,\n      documentTitle: \"\",\n      documentContent: \"\",\n      expanded: {},\n      relatedDocuments: [{\n        title: \"Document 1\",\n        text: \"console.log('hi!');\",\n      }],\n      propagateFastFilterTimeoutId: undefined,\n      propagateFastFilterTimeoutMs: 1500\n    };\n  },\n  methods: {\n    getRandomId() {\n      return this.$lsw.toasts.getRandomString();\n    },\n    toggleTopPanel() {\n      this.isShowingTopPanel = !this.isShowingTopPanel;\n    },\n    toggleExpand(key) {\n      this.$set(this.expanded, key, !this.expanded[key]);\n    },\n    toggleRelatedDocuments() {\n      this.isShowingRelatedDocuments = !this.isShowingRelatedDocuments;\n    },\n    openDocument(docIndex) {\n      // *@TODO:\n      const doc = this.relatedDocuments[docIndex];\n      this.documentTitle = doc.title;\n      this.documentContent = doc.text;\n      this.isShowingRelatedDocuments = false;\n    },\n    saveRelatedDocument() {\n\n    },\n    async applyFastFilter(textFilter = this.textFilter) {\n      // *@TODO:\n      try {\n        this.hasLoadedInnerValue = false;\n        this.$forceUpdate(true);\n        if(textFilter.trim() === \"\") {\n          this.innerValue = this.originalValue;\n          return;\n        }\n        const textFilterFunction = new Function(\"it,key,i\", \"try {\\n  return \" + textFilter + \";\\n} catch(e) {\\n  return false;\\n}\");\n        console.log(\"User-built filter function:\");\n        console.log(textFilterFunction.toString());\n        if(typeof this.originalValue !== \"object\") {\n          this.innerValue = this.originalValue;\n          return;\n        } else if(Array.isArray(this.originalValue)) {\n          this.innerValue = [].concat(this.originalValue).filter(textFilterFunction);\n        } else {\n          Object.keys(this.originalValue).reduce((out, key, i) => {\n            const value = this.originalValue[key];\n            const passesFilter = textFilterFunction(value, key, i);\n            if(passesFilter) {\n              out[key] = value;\n            }\n            return out;\n          }, {});\n          this.innerValue = out;\n        }\n      } catch (error) {\n        console.log(error);\n      } finally {\n        this.isLoadingInnerValue = false;\n        this.hasLoadedInnerValue = true;\n        this.$forceUpdate(true);\n      }\n    },\n    propagateFastFilter(textFilter = this.textFilter) {\n      this.isLoadingInnerValue = true;\n      clearTimeout(this.propagateFastFilterTimeoutId);\n      this.propagateFastFilterTimeoutId = setTimeout(() => {\n        this.applyFastFilter(textFilter);\n      }, this.propagateFastFilterTimeoutMs);\n    }\n  },\n  watch: {\n    textFilter(newValue) {\n      this.propagateFastFilter(newValue);\n    }\n  }\n});\n",
            "$code.label": "LswDataExplorer API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswDataImplorer API » LswDataImplorer API": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-data-explorer/lsw-data-implorer/lsw-data-implorer.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 116,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswDataImplorer API » LswDataImplorer API",
            "$code": "Vue.component('LswDataImplorer', {\n  template: $template,\n  props: {\n    value: {\n      required: true\n    },\n    pageSize: {\n      type: Number,\n      default: () => 10\n    },\n    level: {\n      type: Number,\n      default: () => 0\n    },\n    pointer: {\n      type: Array,\n      default: () => []\n    }\n  },\n  data() {\n    return {\n      expanded: {},\n      isRoot: this.pointer.length === 0,\n      currentPageSize: this.pageSize,\n      currentPage: 1,\n      page: {},\n      entries: [],\n      paginatedEntries: [],\n      isPaginated: false,\n    };\n  },\n  methods: {\n    loadEntries() {\n      if (typeof this.value !== 'object' || this.value === null) {\n        return [{ key: 'value', value: this.value }];\n      }\n      this.entries = Object.entries(this.value).map(([key, value]) => ({ key, value }));\n    },\n    toggleExpand(key) {\n      this.$set(this.expanded, key, !this.expanded[key]);\n    },\n    goToPage(page) {\n      this.currentPage = page;\n      this.loadPaginatedEntries();\n    },\n    goToPreviousPage() {\n      if(this.currentPage <= 1) {\n        return;\n      }\n      this.currentPage--;\n      this.loadPaginatedEntries();\n    },\n    goToNextPage() {\n      if(this.currentPage >= Math.ceil(this.entries.length / this.pageSize)) {\n        return;\n      }\n      this.currentPage++;\n      this.loadPaginatedEntries();\n    },\n    goToLastPage() {\n      this.currentPage = Math.ceil(this.entries.length / this.pageSize);\n      this.loadPaginatedEntries();\n    },\n    paginateArray(array, pageSize = this.currentPageSize, currentPage = this.currentPage) {\n      const start = (currentPage - 1) * pageSize;\n      const end = start + pageSize;\n      return array.slice(start, end);\n    },\n    loadPaginatedEntries(entries = this.entries) {\n      this.paginatedEntries = this.paginateArray(entries);\n      this.isPaginated = this.paginatedEntries.length !== this.entries.length;\n    },\n  },\n  watch: {\n    entries(newValue) {\n      if(this.pageSize <= 0) {\n        return newValue;\n      }\n      this.loadPaginatedEntries(newValue);\n    }\n  },\n  mounted() {\n    this.loadEntries();\n  }\n});\n",
            "$code.label": "LswDataImplorer API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswDatabaseBreadcrumb API » LswDatabaseBreadcrumb API": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/database-breadcrumb/database-breadcrumb.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 134,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswDatabaseBreadcrumb API » LswDatabaseBreadcrumb API",
            "$code": "Vue.component(\"LswDatabaseBreadcrumb\", {\n  template: $template,\n  props: {\n    databaseExplorer: {\n      type: Object,\n      required: true\n    },\n    breadcrumb: {\n      type: Array,\n      required: true\n    }\n  },\n  data() {\n    return {\n      \n    }\n  },\n  methods: {\n    selectPage(page, args = {}) {\n      return this.databaseExplorer.selectPage(page, args);\n    }\n  },\n  async mounted() {\n    \n  },\n  unmounted() {\n\n  }\n});\n",
            "$code.label": "LswDatabaseBreadcrumb API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswDatabaseExplorer API » LswDatabaseExplorer API": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/database-explorer/database-explorer.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 128,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswDatabaseExplorer API » LswDatabaseExplorer API",
            "$code": "Vue.component(\"LswDatabaseExplorer\", {\n  template: $template,\n  props: {\n    showBreadcrumb: {\n      type: Boolean,\n      default: () => true\n    },\n    initialPage: {\n      type: String,\n      default: () => \"lsw-page-tables\"\n    },\n    initialArgs: {\n      type: Object,\n      default: () => ({ database: \"lsw_default_database\" })\n    }\n  },\n  data() {\n    this.$trace(\"lsw-database-explorer.data\", []);\n    return {\n      isLoading: false,\n      selectedPage: this.initialPage,\n      selectedArgs: this.initialArgs,\n    }\n  },\n  methods: {\n    selectPage(page, args = {}) {\n      try {\n        this.$trace(\"lsw-database-explorer.methods.selectPage\", arguments);\n        $ensure({page}, 1).type(\"string\");\n        $ensure({args}, 1).type(\"object\");\n        this.isLoading = true;\n        this.$nextTick(() => {\n          this.selectedArgs = args;\n          this.selectedPage = page;\n          this.isLoading = false;\n        });\n      } catch (error) {\n        console.log(error);\n        throw error;\n      }\n    }\n  },\n  async mounted() {\n    this.$trace(\"lsw-database-explorer.methods.mounted\", arguments);\n  },\n  unmounted() {\n    this.$trace(\"lsw-database-explorer.methods.unmounted\", arguments);\n  }\n});\n",
            "$code.label": "LswDatabaseExplorer API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswPageDatabases API » LswPageDatabases API": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-databases/page-databases.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 119,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswPageDatabases API » LswPageDatabases API",
            "$code": "Vue.component(\"LswPageDatabases\", {\n  template: $template,\n  props: {\n    databaseExplorer: {\n      type: Object,\n      required: true\n    },\n    args: {\n      type: Object,\n      required: true\n    },\n  },\n  data() {\n    return {\n      databases: [],\n      databasesForTable: false,\n      breadcrumb: [{\n        page: \"LswPageDatabases\",\n        name: \"Databases\",\n        args: {},\n        current: true\n      }],\n    }\n  },\n  methods: {\n    openDatabase(name) {\n      this.databaseExplorer.selectPage(\"LswPageTables\", { database: name });\n    }\n  },\n  watch: {\n    databases(value) {\n      AdaptingForTable: {\n        const databasesForTable = [];\n        if (typeof value !== \"object\") {\n          break AdaptingForTable;\n        }\n        const databaseIds = Object.keys(value);\n        for(let indexDatabase=0; indexDatabase<databaseIds.length; indexDatabase++) {\n          const databaseId = databaseIds[indexDatabase];\n          const databaseObject = value[databaseId];\n        }\n        this.databasesForTable = databasesForTable;\n      }\n    }\n  },\n  async mounted() {\n    this.databases = await LswDatabaseAdapter.listDatabases();\n    Filter_by_entity_schema_matched_db_names: {\n      $lswSchema\n    }\n  },\n  unmounted() {\n\n  }\n});\n",
            "$code.label": "LswPageDatabases API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswPageRow API » LswPageRow API": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-row/page-row.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 101,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswPageRow API » LswPageRow API",
            "$code": "Vue.component(\"LswPageRow\", {\n  template: $template,\n  props: {\n    databaseExplorer: {\n      type: Object,\n      required: true\n    },\n    args: {\n      type: Object,\n      required: true\n    },\n  },\n  data() {\n    this.$trace(\"lsw-page-row.data\", arguments);\n    $ensure(this.args.database).type(\"string\");\n    $ensure(this.args.table).type(\"string\");\n    $ensure(this.args.rowId).type(\"number\");\n    return {\n      isLoaded: false,\n      breadcrumb: [{\n        page: \"LswPageTables\",\n        name: this.args.database,\n        args: {\n          database: this.args.database\n        }\n      }, {\n        page: \"LswPageRows\",\n        name: this.args.table,\n        args: {\n          database: this.args.database,\n          table: this.args.table\n        },\n      }, {\n        page: \"LswPageRow\",\n        name: (this.args.rowId === -1) ? '#new' : (\"#\" + this.args.rowId),\n        args: {\n          database: this.args.database,\n          table: this.args.table,\n          rowId: this.args.rowId\n        },\n        current: true\n      }],\n      database: this.args.database,\n      table: this.args.table,\n      rowId: this.args.rowId,\n      connection: undefined,\n      row: false,\n    }\n  },\n  methods: {\n    goBack() {\n      this.$trace(\"lsw-page-row.methods.goBack\", arguments);\n      return this.databaseExplorer.selectPage(\"LswPageRows\", {\n        database: this.database,\n        table: this.table\n      });\n    },\n    async loadRow() {\n      this.$trace(\"lsw-page-row.methods.loadRow\", arguments);\n      try {\n        if(this.rowId === -1) {\n          return false;\n        }\n        this.connection = this.connection ?? new LswDatabaseAdapter(this.database);\n        await this.connection.open();\n        const matches = await this.connection.select(this.table, it => it.id === this.rowId);\n        this.row = matches[0];\n      } catch (error) {\n        console.log(\"Error loading row:\", error);\n        throw error;\n      } finally {\n        this.row = false;\n      }\n    },\n    async upsertRow(v) {\n      this.$trace(\"lsw-page-row.methods.upsertRow\", arguments);\n      const existsRow = this.rowId || ((typeof (this.row) === \"object\") && (typeof (this.row.id) === \"number\") && (this.row.id !== -1));\n      let id = this.rowId || this.row.id;\n      const operation = (existsRow && (id !== -1)) ? \"update\" : \"insert\";\n      if (operation === \"insert\") {\n        id = await this.$lsw.database.insert(this.table, v);\n      } else {\n        await this.$lsw.database.update(this.table, id, v);\n      }\n      lsw.toasts.send({\n        title: `Nueva ${operation === 'insert' ? 'inserción' : 'actualización'}`,\n        text: `El registro #${id} de «${this.table}» fue ${operation === 'insert' ? 'insertado' : 'actualizado'} correctamente.`\n      });\n      if(operation === \"insert\") {\n        this.databaseExplorer.selectPage(\"LswPageRow\", {\n          database: this.database,\n          table: this.table,\n          rowId: id\n        });\n      } else {\n        // @OK.\n      }\n    }\n  },\n  async mounted() {\n    this.$trace(\"lsw-page-row.mounted\", arguments);\n    try {\n      await this.loadRow();\n    } catch (error) {\n      console.log(\"Error loading row:\", error);\n      throw error;\n    } finally {\n      this.isLoaded = true;\n    }\n  },\n  unmounted() {\n    this.$trace(\"lsw-page-row.unmounted\", arguments);\n    this.connection.close();\n  }\n});\n",
            "$code.label": "LswPageRow API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswPageRows API » LswPageRows API": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-rows/page-rows.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 104,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswPageRows API » LswPageRows API",
            "$code": "Vue.component(\"LswPageRows\", {\n  template: $template,\n  props: {\n    databaseExplorer: {\n      type: Object,\n      required: true\n    },\n    args: {\n      type: Object,\n      required: true\n    },\n  },\n  data() {\n    this.$trace(\"lsw-page-rows.data\", []);\n    $ensure(this.args).type(\"object\");\n    $ensure(this.args.database).type(\"string\");\n    $ensure(this.args.table).type(\"string\");\n    return {\n      breadcrumb: [{\n        page: \"LswPageTables\",\n        name: this.args.database,\n        args: {\n          database: this.args.database\n        }\n      }, {\n        page: \"LswPageRows\",\n        name: this.args.table,\n        args: {\n          database: this.args.database,\n          table: this.args.table\n        },\n        current: true\n      }],\n      database: this.args.database,\n      table: this.args.table,\n      rows: undefined,\n      connection: undefined,\n    }\n  },\n  methods: {\n    goBack() {\n      this.$trace(\"lsw-page-rows.methods.goBack\", arguments);\n      return this.databaseExplorer.selectPage(\"LswPageTables\", {\n        database: this.database,\n      });\n    },\n    async loadRows() {\n      this.$trace(\"lsw-page-rows.methods.loadRows\", arguments);\n      this.connection = this.connection ?? new LswDatabaseAdapter(this.database);\n      await this.connection.open();\n      const selection = await this.connection.select(this.table, it => true);\n      this.rows = selection;\n      return selection;\n    },\n    openRow(rowId) {\n      this.$trace(\"lsw-page-rows.methods.openRow\", arguments);\n      return this.databaseExplorer.selectPage(\"LswPageRow\", {\n        database: this.database,\n        table: this.table,\n        rowId: rowId\n      });\n    }\n  },\n  mounted() {\n    this.$trace(\"lsw-page-rows.mounted\", arguments);\n    this.loadRows();\n  },\n  unmounted() {\n    this.$trace(\"lsw-page-rows.unmounted\", arguments);\n    this.connection.close();\n  }\n});\n",
            "$code.label": "LswPageRows API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswPageSchema API » LswPageSchema API": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-schema/page-schema.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 110,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswPageSchema API » LswPageSchema API",
            "$code": "Vue.component(\"LswPageSchema\", {\n  template: $template,\n  props: {},\n  data() {\n    return {\n      \n    }\n  },\n  methods: {\n    \n  },\n  mounted() {\n    \n  },\n  unmounted() {\n\n  }\n});\n",
            "$code.label": "LswPageSchema API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswPageTables API » LswPageTables API": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-database-ui/page-tables/page-tables.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 110,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswPageTables API » LswPageTables API",
            "$code": "Vue.component(\"LswPageTables\", {\n  template: $template,\n  props: {\n    databaseExplorer: {\n      type: Object,\n      required: true\n    },\n    args: {\n      type: Object,\n      required: true\n    },\n  },\n  data() {\n    const ensureArgs = $ensure(this.args).type(\"object\");\n    ensureArgs.to.have.key(\"database\").its(\"database\").type(\"string\");\n    return {\n      breadcrumb: [{\n        page: \"LswPageTables\",\n        name: this.args.database,\n        args: {\n          database: this.args.database\n        },\n        current: true\n      }],\n      database: this.args.database,\n      tables: false,\n      tablesAsList: false,\n    }\n  },\n  methods: {\n    async loadDatabase() {\n      const db = await LswDatabaseAdapter.getSchema(this.database);\n      this.tables = db;\n      console.log(`[*] Tables of database ${this.args.database}:`, db);\n    },\n    openTable(table) {\n      $ensure({ table }, 1).type(\"string\");\n      return this.databaseExplorer.selectPage(\"LswPageRows\", {\n        database: this.database,\n        table: table\n      });\n    }\n  },\n  watch: {\n    tables(value) {\n      const tablesAsList = [];\n      const tableIds = Object.keys(value);\n      for(let index=0; index<tableIds.length; index++) {\n        const tableId = tableIds[index];\n        const tableData = value[tableId];\n        tablesAsList.push({\n          name: tableId,\n          ...tableData,\n          indexes: tableData.indexes ? tableData.indexes.map(ind => ind.name) : []\n        });\n      }\n      this.tablesAsList = tablesAsList;\n    }\n  },\n  mounted() {\n    this.loadDatabase();\n  },\n  unmounted() {\n\n  }\n});\n",
            "$code.label": "LswPageTables API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Filesystem Explorer API » LswFilesystemButtonsPanel component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-buttons-panel/lsw-filesystem-buttons-panel.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 150,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Filesystem Explorer API » LswFilesystemButtonsPanel component",
            "$code": "Vue.component(\"LswFilesystemButtonsPanel\", {\n  name: \"LswFilesystemButtonsPanel\",\n  template: $template,\n  props: {\n    explorer: {\n      type: Object,\n      required: true\n    },\n    orientation: {\n      type: String,\n      default: () => \"row\" // could be \"column\" too\n    }\n  },\n  data() {\n    return {\n      buttons: []\n    };\n  },\n  watch: {\n\n  },\n  methods: {\n    setButtons(...buttons) {\n      this.$trace(\"lsw-filesystem-buttons-panel.methods.prependButtons\");\n      this.buttons = buttons;\n    },\n    prependButtons(...buttons) {\n      this.$trace(\"lsw-filesystem-buttons-panel.methods.prependButtons\");\n      this.buttons = buttons.concat(this.buttons);\n    },\n    appendButtons(...buttons) {\n      this.$trace(\"lsw-filesystem-buttons-panel.methods.appendButtons\");\n      this.buttons = this.buttons.concat(buttons);\n    },\n  },\n  mounted() {\n\n  }\n});\n",
            "$code.label": "LswFilesystemButtonsPanel API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Filesystem Explorer API » LswFilesystemEditor component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-editor/lsw-filesystem-editor.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 138,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Filesystem Explorer API » LswFilesystemEditor component",
            "$code": "Vue.component(\"LswFilesystemEditor\", {\n  name: \"LswFilesystemEditor\",\n  template: $template,\n  props: {\n    explorer: {\n      type: Object,\n      required: true\n    },\n    filecontents: {\n      type: String,\n      required: true\n    }\n  },\n  data() {\n    return {\n      contents: this.filecontents\n    };\n  },\n  watch: {\n\n  },\n  methods: {\n    getContents() {\n      return this.contents;\n    },\n    setContents(contents) {\n      this.contents = contents;\n    }\n  },\n  mounted() {\n\n  }\n});\n",
            "$code.label": "LswFilesystemEditor API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Filesystem Explorer API » LswFilesystemExplorer component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-explorer/lsw-filesystem-explorer.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 142,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Filesystem Explorer API » LswFilesystemExplorer component",
            "$code": "Vue.component(\"LswFilesystemExplorer\", {\n  name: \"LswFilesystemExplorer\",\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-filesystem-explorer.data\");\n    return {\n      is_ready: false,\n      current_node: undefined,\n      current_node_parts: undefined,\n      current_node_basename: undefined,\n      current_node_basedir: undefined,\n      current_node_contents: undefined,\n      current_node_subnodes: [],\n      current_node_is_file: false,\n      current_node_is_directory: false,\n      STANDARIZED_REFRESH_DELAY: 100\n    };\n  },\n  methods: {\n    open(...args) {\n      this.$trace(\"lsw-filesystem-explorer.methods.open\");\n      return this.open_node(...args);\n    },\n    goUp() {\n      this.$trace(\"lsw-filesystem-explorer.methods.goUp\");\n      const parts = this.current_node.split(\"/\");\n      parts.pop();\n      const dest = this.normalize_path(\"/\" + parts.join(\"/\"));\n      return this.open(dest);\n    },\n    async refresh() {\n      this.$trace(\"lsw-filesystem-explorer.methods.refresh\");\n      this.is_ready = false;\n      try {\n        await this.open(this.current_node);\n      } catch (error) {\n        throw error;\n      } finally {\n        this.$nextTick(() => {\n          this.is_ready = true;\n          this.$forceUpdate(true);\n        });\n      }\n    },\n    normalize_path(subpath) {\n      this.$trace(\"lsw-filesystem-explorer.methods.normalize_path\");\n      return this.$lsw.fs.resolve_path(this.current_node, subpath);\n    },\n    async open_node(subpath = this.current_node) {\n      this.$trace(\"lsw-filesystem-explorer.methods.open_node\");\n      try {\n        if ([\"\", \"/\"].indexOf(subpath) !== -1) {\n          return await this._openDirectory(\"/\");\n        }\n        const temporaryPath = this.normalize_path(subpath);\n        const is_directory = await this.$lsw.fs.is_directory(temporaryPath);\n        if (is_directory) {\n          return await this._openDirectory(temporaryPath);\n        }\n        const is_file = await this.$lsw.fs.is_file(temporaryPath);\n        if (is_file) {\n          return await this._openFile(temporaryPath);\n        }\n        throw new Error(`Cannot open path because it does not exist: ${temporaryPath} on «LswFilesystemExplorer.methods.open_node»`);\n      } catch (error) {\n        console.log(error);\n        throw error;\n      }\n    },\n    async processToCreateFile() {\n      this.$trace(\"lsw-filesystem-explorer.methods.processToCreateFile\");\n      const filename = await this.$lsw.dialogs.open({\n        title: \"Crear fichero\",\n        template: `<div>\n          <div class=\"pad_1\">\n            <div>Estás en la carpeta:</div>\n            <div class=\"pad_2\">{{ current_directory }}</div>\n            <div>Di el nombre del nuevo fichero:</div>\n            <div class=\"pad_top_1\">\n              <input class=\"width_100\" type=\"text\" placeholder=\"myfile.txt\" v-model=\"filename\" v-focus v-on:keyup.enter=\"() => accept(filename)\" />\n            </div>\n          </div>\n          <hr />\n          <div class=\"flex_row centered pad_1\">\n            <div class=\"flex_100\"></div>\n            <div class=\"flex_1 pad_right_1\">\n              <button class=\"nowrap danger_button\" v-on:click=\"() => accept(filename)\">Crear fichero</button>\n            </div>\n            <div class=\"flex_1\">\n              <button class=\"nowrap \" v-on:click=\"() => accept(false)\">Cancelar</button>\n            </div>\n          </div>\n        </div>`,\n        factory: {\n          data() {\n            return {\n              current_directory: this.$lsw.fs.get_current_directory(),\n              filename: \"\",\n            };\n          },\n        },\n      });\n      if(!filename) return;\n      const filepath = this.$lsw.fs.resolve_path(this.$lsw.fs.get_current_directory(), filename);\n      await this.$lsw.fs.write_file(filepath, \"\");\n      this.refresh();\n    },\n    async processToCreateDirectory() {\n      this.$trace(\"lsw-filesystem-explorer.methods.processToCreateDirectory\");\n      const filename = await this.$lsw.dialogs.open({\n        title: \"Crear directorio\",\n        template: `<div>\n          <div class=\"pad_1\">\n            <div>Estás en la carpeta:</div>\n            <div class=\"pad_2\">{{ current_directory }}</div>\n            <div>Di el nombre del nuevo directorio:</div>\n            <div class=\"pad_top_1\">\n              <input class=\"width_100\" type=\"text\" placeholder=\"myfolder\" v-model=\"filename\" v-focus v-on:keyup.enter=\"() => accept(filename)\" />\n            </div>\n          </div>\n          <hr />\n          <div class=\"flex_row centered pad_1\">\n            <div class=\"flex_100\"></div>\n            <div class=\"flex_1 pad_right_1\">\n              <button class=\"nowrap danger_button\" v-on:click=\"() => accept(filename)\">Sí, seguro</button>\n            </div>\n            <div class=\"flex_1\">\n              <button class=\"nowrap \" v-on:click=\"() => accept(false)\">Cancelar</button>\n            </div>\n          </div>\n        </div>`,\n        factory: {\n          data() {\n            return {\n              current_directory: this.$lsw.fs.get_current_directory(),\n              filename: \"\",\n            };\n          },\n        },\n      });\n      if(!filename) return;\n      const filepath = this.$lsw.fs.resolve_path(this.$lsw.fs.get_current_directory(), filename);\n      await this.$lsw.fs.make_directory(filepath);\n      this.refresh();\n    },\n    async processToDeleteDirectory() {\n      this.$trace(\"lsw-filesystem-explorer.methods.processToDeleteDirectory\");\n      const confirmation = await this.$lsw.dialogs.open({\n        title: \"Eliminar directorio\",\n        template: `<div>\n          <div class=\"pad_1\">\n            <div>¿Seguro que quieres eliminar el directorio?</div>\n            <div class=\"pad_2\">{{ current_directory }}</div>\n          </div>\n          <hr />\n          <div class=\"flex_row centered pad_1\">\n            <div class=\"flex_100\"></div>\n            <div class=\"flex_1 pad_right_1\">\n              <button class=\"nowrap danger_button\" v-on:click=\"() => accept(true)\">Sí, seguro</button>\n            </div>\n            <div class=\"flex_1\">\n              <button class=\"nowrap \" v-on:click=\"() => accept(false)\">Cancelar</button>\n            </div>\n          </div>\n        </div>`,\n        factory: {\n          data: {\n            current_directory: this.$lsw.fs.get_current_directory(),\n          }\n        }\n      });\n      if(!confirmation) return;\n      await this.$lsw.fs.delete_directory(this.$lsw.fs.get_current_directory());\n      this.refresh();\n    },\n    async processToDeleteFile() {\n      this.$trace(\"lsw-filesystem-explorer.methods.processToDeleteFile\");\n      const confirmation = await this.$lsw.dialogs.open({\n        title: \"Eliminar fichero\",\n        template: `<div>\n          <div class=\"pad_1\">\n            <div>¿Seguro que quieres eliminar el fichero?</div>\n            <div class=\"pad_2\">{{ current_file }}</div>\n          </div>\n          <hr />\n          <div class=\"flex_row centered pad_1\">\n            <div class=\"flex_100\"></div>\n            <div class=\"flex_1 pad_right_1\">\n              <button class=\"nowrap danger_button\" v-on:click=\"() => accept(true)\">Sí, seguro</button>\n            </div>\n            <div class=\"flex_1\">\n              <button class=\"nowrap \" v-on:click=\"() => accept(false)\">Cancelar</button>\n            </div>\n          </div>\n        </div>`,\n        factory: {\n          data: {\n            current_file: this.current_node,\n          }\n        }\n      });\n      if(!confirmation) return;\n      await this.$lsw.fs.delete_file(this.current_node);\n      const upperDir = (() => {\n        const parts = this.current_node.split(\"/\");\n        parts.pop();\n        return parts.join(\"/\");\n      })();\n      this.refresh();\n    },\n    async processToRenameFile() {\n      this.$trace(\"lsw-filesystem-explorer.methods.processToRenameFile\");\n      const elementType = this.current_node_is_file ? \"fichero\" : \"directorio\";\n      const newName = await this.$lsw.dialogs.open({\n        title: \"Renombrar \" + elementType,\n        template: `<div>\n          <div class=\"pad_1\">\n            <div>Refiriéndose al {{ elementType }}:</div>\n            <div class=\"pad_2\">{{ filename }}</div>\n          </div>\n          <div class=\"pad_1\">\n            <div>Di el nuevo nombre del {{ elementType }}:</div>\n            <div class=\"pad_top_1\">\n              <input v-focus class=\"width_100\" type=\"text\" placeholder=\"Nuevo nombre aquí\" v-model=\"new_filename\" v-on:keyup.enter=\"() => accept(new_filename)\" />\n            </div>\n          </div>\n          <hr />\n          <div class=\"flex_row centered\">\n            <div class=\"flex_100\"></div>\n            <div class=\"flex_1 pad_right_1\">\n              <button class=\"nowrap danger_button\" v-on:click=\"() => accept(new_filename)\">Sí, seguro</button>\n            </div>\n            <div class=\"flex_1\">\n              <button class=\"nowrap \" v-on:click=\"() => accept(false)\">Cancelar</button>\n            </div>\n          </div>\n        </div>`,\n        factory: {\n          data: {\n            elementType,\n            filename: this.current_node,\n            new_filename: this.current_node.split(\"/\").pop(),\n          }\n        }\n      });\n      if(newName === false) return;\n      if(newName.trim() === \"\") return;\n      const allParts = this.current_node.split(\"/\");\n      allParts.pop();\n      const dirPath = \"/\" + allParts.join(\"/\");\n      const newFullpath = this.$lsw.fs.resolve_path(dirPath, newName);\n      await this.$lsw.fs.rename(this.current_node, newName.replace(/^\\/+/g, \"\"));\n      await this.open(newFullpath);\n    },\n    async processToExecuteFile() {\n      this.$trace(\"lsw-filesystem-explorer.methods.processToExecuteFile\");\n      const editorContents = this.$refs.editor.getContents();\n      const AsyncFunction = (async function() {}).constructor;\n      const asyncFunction = new AsyncFunction(editorContents);\n      try {\n        await asyncFunction.call(this);\n      } catch (error) {\n        this.$lsw.toasts.send({\n          title: \"Error arised when executing file\",\n          text: `File ${this.current_node} produced following error: ${error.name}: ${error.message}`\n        });\n      }\n    },\n    async processToLoadFile() {\n      this.$trace(\"lsw-filesystem-explorer.methods.processToLoadFile\");\n      this.is_ready = false;\n      const contents = await this.$lsw.fs.read_file(this.current_node);\n      this.current_node_contents = contents;\n      this.$nextTick(() => {\n        this.is_ready = true;\n      });\n    },\n    async processToSaveFile() {\n      this.$trace(\"lsw-filesystem-explorer.methods.processToSaveFile\");\n      if(this.$refs.editor) {\n        const editorContents = this.$refs.editor.getContents();\n        console.log(this.current_node, editorContents);\n        await this.$lsw.fs.write_file(this.current_node, editorContents);\n      }\n    },\n    _setButtonsForFile() {\n      this.$trace(\"lsw-filesystem-explorer.methods._setButtonsForFile\");\n      this.is_ready = false;\n      this.current_node_is_file = true;\n      this.current_node_is_directory = false;\n      const allButtonsOnFile = [\n        {\n          text: \"➜\",\n          classes: \"reversed\",\n          click: () => this.goUp(),\n        }, {\n          text: \"💾\",\n          click: () => this.processToSaveFile(),\n        }, {\n          text: \"↔️\",\n          click: () => this.processToRenameFile(),\n        }, {\n          text: \"🔄\",\n          click: () => this.processToLoadFile(),\n        }, {\n          text: \"📄 ❌\",\n          classes: \"danger_button\",\n          click: () => this.processToDeleteFile(),\n        }\n      ];\n      if(this.current_node.endsWith(\".js\")) {\n        allButtonsOnFile.push({\n          text: \"⚡️\",\n          classes: \"danger_button\",\n          click: () => this.processToExecuteFile(),\n        });\n      }\n      this.$refs.panelTop.setButtons(...allButtonsOnFile);\n      this.$nextTick(() => {\n        this.is_ready = true;\n      });\n    },\n    _setButtonsForDirectory() {\n      this.$trace(\"lsw-filesystem-explorer.methods._setButtonsForDirectory\");\n      this.is_ready = false;\n      this.current_node_is_directory = true;\n      this.current_node_is_file = false;\n      this.$refs.panelTop.setButtons({\n        text: \"📄+\",\n        click: () => this.processToCreateFile(),\n      }, {\n        text: \"📁+\",\n        click: () => this.processToCreateDirectory(),\n      }, {\n        text: \"📁 ❌\",\n        classes: \"danger_button\",\n        click: () => this.processToDeleteDirectory()\n      });\n      this.$nextTick(() => {\n        this.is_ready = true;\n      });\n    },\n    async _openFile(subpath) {\n      this.$trace(\"lsw-filesystem-explorer.methods._openFile\");\n      this.current_node = subpath;\n      const contents = await this.$lsw.fs.read_file(this.current_node);\n      this.current_node_contents = contents;\n      this._setButtonsForFile();\n    },\n    async _openDirectory(subpath) {\n      this.$trace(\"lsw-filesystem-explorer.methods._openDirectory\");\n      this.current_node = subpath;\n      const subnodes = await this.$lsw.fs.read_directory(this.current_node);\n      const sortedSubnodes = {\n        files: [],\n        folders: []\n      };\n      Object.keys(subnodes).forEach(id => {\n        const subnode = subnodes[id];\n        const subnodeType = typeof subnode === \"string\" ? \"files\" : \"folders\";\n        sortedSubnodes[subnodeType].push(id);\n      });\n      const formattedSubnodes = {};\n      sortedSubnodes.folders.sort().forEach(folder => {\n        formattedSubnodes[folder] = {};\n      });\n      sortedSubnodes.files.sort().forEach(file => {\n        formattedSubnodes[file] = \"...\";\n      });\n      console.log(subnodes, formattedSubnodes);\n      this.$lsw.fs.change_directory(subpath);\n      this.current_node_subnodes = formattedSubnodes;\n      this._setButtonsForDirectory();\n    },\n    __update_node_parts(newValue = this.current_node) {\n      this.$trace(\"lsw-filesystem-explorer.methods.__update_node_parts\");\n      this.current_node_parts = newValue.split(\"/\").filter(p => p !== \"\");\n    },\n    __update_current_node_basename(current_node_parts = this.current_node_parts) {\n      this.$trace(\"lsw-filesystem-explorer.methods.__update_current_node_basename\");\n      if (current_node_parts.length) {\n        this.current_node_basename = current_node_parts[current_node_parts.length - 1];\n      } else {\n        this.current_node_basename = \"/\";\n      }\n    },\n    __update_current_node_basedir(current_node_parts = this.current_node_parts) {\n      this.$trace(\"lsw-filesystem-explorer.methods.__update_current_node_basedir\");\n      if (current_node_parts.length > 1) {\n        this.current_node_basedir = \"/\" + [].concat(current_node_parts).splice(0, current_node_parts.length - 1).join(\"/\") + \"/\";\n      } else {\n        this.current_node_basedir = \"/\";\n      }\n    },\n    _updateNodeSubdata(newValue = this.current_node) {\n      this.$trace(\"lsw-filesystem-explorer.methods._updateNodeSubdata\");\n      this.__update_node_parts(newValue);\n      this.__update_current_node_basename();\n      this.__update_current_node_basedir();\n    },\n    setPanelButtons(panelOptions = {}) {\n      this.$trace(\"lsw-filesystem-explorer.methods.setPanelButtons\");\n      Validation: {\n        if (typeof panelOptions !== \"object\") {\n          throw new Error(\"Required argument «panelOptions» to be an object on «LswFilesystemExplorer.methods.setPanelButtons»\");\n        }\n        const keys = Object.keys(panelOptions);\n        if (keys.length === 0) {\n          throw new Error(\"Required argument «panelOptions» to be have 1 or more keys on «LswFilesystemExplorer.methods.setPanelButtons»\");\n        }\n        const valid_keys = [\"top\", \"bottom\", \"left\", \"right\"];\n        for (let index = 0; index < keys.length; index++) {\n          const key = keys[index];\n          if(valid_keys.indexOf(key) === -1) {\n            throw new Error(`Required argument «panelOptions[${key}]» to be a valid key out of «${valid_keys.join(\",\")}», not «${key}» on «LswFilesystemExplorer.methods.setPanelButtons»`);\n          }\n          const value = panelOptions[key];\n          if(typeof value !== \"object\") {\n            throw new Error(`Required argument «panelOptions[${key}]» to be an object or array, not ${typeof value}» on «LswFilesystemExplorer.methods.setPanelButtons»`);\n          }\n        }\n      }\n    }\n  },\n  watch: {\n    current_node(newValue) {\n      this.$trace(\"lsw-filesystem-explorer.watch.current_node\");\n      this._updateNodeSubdata(newValue);\n    }\n  },\n  async mounted() {\n    try {\n      this.$trace(\"lsw-filesystem-explorer.mounted\");\n      this.$lsw.fs = new LswFilesystem();\n      this.$lsw.fsExplorer = this;\n      await this.$lsw.fs.init();\n      await this.open(\"/\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswFilesystemExplorer API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Filesystem Explorer API » LswFilesystemTreeviewer component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-filesystem-explorer/lsw-filesystem-treeviewer/lsw-filesystem-treeviewer.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 146,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Filesystem Explorer API » LswFilesystemTreeviewer component",
            "$code": "Vue.component(\"LswFilesystemTreeviewer\", {\n  name: \"LswFilesystemTreeviewer\",\n  template: $template,\n  props: {\n    explorer: {\n      type: Object,\n      required: true\n    }\n  },\n  data() {\n    this.$trace(\"lsw-filesystem-treeviewer.data\");\n    return {};\n  },\n  watch: {},\n  methods: {\n    goUp() {\n      this.$trace(\"lsw-filesystem-treeviewer.methods.goUp\");\n      return this.explorer.goUp();\n    },\n    openSubnode(subnodeIndex) {\n      this.$trace(\"lsw-filesystem-treeviewer.methods.openSubnode\");\n      return this.explorer.open(subnodeIndex);\n    },\n    async deleteNode(subnodeIndex) {\n      this.$trace(\"lsw-filesystem-treeviewer.methods.deleteNode\");\n      const fullpath = this.$lsw.fs.resolve_path(subnodeIndex);\n      const isDirectory = await this.$lsw.fs.is_directory(fullpath);\n      const elementType = isDirectory ? 'directorio' : 'fichero';\n      const confirmation = await this.$lsw.dialogs.open({\n        title: `Proceder a eliminar ${elementType}`,\n        template: `\n          <div class=\"pad_1\">\n            <div>Seguro que quieres eliminar el {{ elementType }} «{{ fullpath }}»?</div>\n            <hr />\n            <div class=\"flex_row centered\">\n              <div class=\"flex_100\"></div>\n              <div class=\"flex_1 pad_right_1\">\n                <button class=\"danger_button nowrap\" v-on:click=\"() => accept(true)\">Sí, eliminar</button>\n              </div>\n              <div class=\"flex_1\">\n                <button class=\"\" v-on:click=\"() => accept(false)\">Salir</button>\n              </div>\n            </div>\n          </div>\n        `,\n        factory: {\n          data: {\n            elementType,\n            fullpath,\n          }\n        }\n      });\n      if (!confirmation) return;\n      try {\n        if (isDirectory) {\n          await this.$lsw.fs.delete_directory(fullpath);\n        } else {\n          await this.$lsw.fs.delete_file(fullpath);\n        }\n        await this.explorer.refresh();\n      } catch (error) {\n        await this.$lsw.dialogs.open({\n          title: `El fichero no se pudo eliminar`,\n          template: `\n            <div class=\"pad_1\">\n              <div>El fichero «{{ fullpath }}» no se pudo eliminar debido al siguiente error:</div>\n              <hr />\n              <div v-if=\"error\">{{ error.name }}: {{ error.message }}</div>\n            </div>\n          `,\n          factory: {\n            data: {\n              error,\n              fullpath,\n            }\n          }\n        });\n      }\n    },\n    async renameNode(subnodeIndex) {\n      this.$trace(\"lsw-filesystem-treeviewer.methods.renameNode\");\n      const fullpath = this.$lsw.fs.resolve_path(subnodeIndex);\n      const isDirectory = await this.$lsw.fs.is_directory(fullpath);\n      const elementType = isDirectory ? 'directorio' : 'fichero';\n      const newName = await this.$lsw.dialogs.open({\n        title: \"Renombrar \" + elementType,\n        template: `<div>\n          <div class=\"pad_1\">\n            <div>Refiriéndose al {{ elementType }}:</div>\n            <div class=\"pad_2\">{{ filename }}</div>\n            <div>Di el nuevo nombre del {{ elementType }}:</div>\n            <input v-focus class=\"width_100\" type=\"text\" v-model=\"newFilename\" v-on:keyup.enter=\"() => accept(newFilename)\" />\n          </div>\n          <hr />\n          <div class=\"flex_row centered pad_1\">\n            <div class=\"flex_100\"></div>\n            <div class=\"flex_1 pad_right_1\">\n              <button class=\"\" v-on:click=\"() => accept(newFilename)\">Renombrar</button>\n            </div>\n            <div class=\"flex_1\">\n              <button class=\"\" v-on:click=\"() => accept(false)\">Cancelar</button>\n            </div>\n          </div>\n        </div>`,\n        factory: {\n          data: {\n            elementType,\n            fullpath,\n            filename: subnodeIndex,\n            newFilename: subnodeIndex,\n          }\n        }\n      });\n      if (typeof newName !== \"string\") return;\n      if (newName.trim() === \"\") return;\n      await this.$lsw.fs.rename(subnodeIndex, newName.replace(/^\\/+/g, \"\"));\n      this.explorer.refresh();\n    }\n  },\n  mounted() {\n    this.$trace(\"lsw-filesystem-treeviewer.mounted\");\n    this.explorer.setPanelButtons({\n      top: [],\n      left: [],\n      right: [],\n      bottom: [],\n    })\n  },\n  unmounted() {\n    this.$trace(\"lsw-filesystem-treeviewer.unmounted\");\n  }\n});\n",
            "$code.label": "LswFilesystemTreeviewer API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswFormtypesUtils component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/api/api.js",
            "$location": {
              "start": {
                "offset": 288,
                "line": 14,
                "column": 1
              },
              "end": {
                "offset": 414,
                "line": 15,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswFormtypesUtils component",
            "$code": "  class LswFormtypesUtils {\n\n    static class = this;\n\n    static async submitControl() {\n      if (this.settings.parentSchemaForm) {\n        await this.validate();\n      }\n\n    }\n\n    static validateControl() {\n      return this.$refs.controller.$xform.validate();\n    }\n\n    static validateSettings() {\n      LswXForm.validateSettings(this.settings);\n      const ensureSettings = $ensure(this.settings);\n      const checkSettings = $check(this.settings);\n      ensureSettings.to.have.onlyPotentialKeys([\n        \"name\",\n        \"input\",\n        \"entity\",\n        \"database\",\n        \"table\",\n        \"column\",\n        \"initialValue\",\n        \"label\",\n        \"parentSchemaForm\",\n        \"extraAttributes\",\n        \"formtypeParameters\",\n        \"formtypeSettings\"\n      ]);\n      if (checkSettings.to.have.key(\"initialValue\")) {\n        const ensureInitialValue = ensureSettings.its(\"initialValue\").type(\"string\");\n      }\n      if (checkSettings.to.have.key(\"label\")) {\n        const ensureHasLabel = ensureSettings.its(\"label\").type([\"string\", \"undefined\", \"boolean\"]);\n      }\n    }\n\n  }\n\n  class LswFormtypes {\n\n    static class = this;\n\n    constructor() {\n      this.$formtypes = new Map();\n    }\n\n    static utils = LswFormtypesUtils;\n\n  }\n\n  window.commonFormtypes = new LswFormtypes();\n\n  return LswFormtypes;\n",
            "$code.label": "LswFormtypesUtils API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Table API » LswTable component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-table/lsw-table/lsw-table.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 102,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Table API » LswTable component",
            "$code": "Vue.component(\"LswTable\", {\n  template: $template,\n  props: {\n    initialInput: {\n      type: Array,\n      default: () => []\n    },\n    initialSettings: {\n      type: Object,\n      default: () => ({})\n    },\n    rowButtons: {\n      type: Array,\n      default: () => []\n    },\n    tableButtons: {\n      type: Array,\n      default: () => []\n    },\n    selectable: {\n      type: String,\n      default: () => \"none\"\n    },\n    onChooseRow: {\n      type: Function,\n      default: () => {}\n    },\n    choosableId: {\n      type: String,\n      default: () => \"id\"\n    },\n    initialChoosenValue: {\n      type: [],\n      default: () => []\n    }\n  },\n  data() {\n    this.$trace(\"lsw-table.data\");\n    const input = [].concat(this.initialInput);\n    return {\n      input,\n      title: this.initialSettings?.title || \"\",\n      isShowingMenu: this.initialSettings?.isShowingMenu || false,\n      isShowingSubpanel: this.initialSettings?.isShowingSubpanel || \"Extensor\",\n      selectedRows: [],\n      choosenRows: this.initialChoosenValue || [],\n      extender: this.initialSettings?.extender || \"\",\n      filter: this.initialSettings?.filter || \"\",\n      sorter: this.initialSettings?.sorter || \"\",\n      itemsPerPage: this.initialSettings?.itemsPerPage || 10,\n      currentPage: this.initialSettings?.currentPage || 0,\n      columnsAsList: this.initialSettings?.columnsAsList || [],\n      columnsOrder: this.initialSettings?.columnsOrder || [],\n      output: [],\n      paginatedOutput: [],\n      headers: [],\n      attachedHeaders: this._adaptRowButtonsToHeaders(this.rowButtons),\n      attachedColumns: this._adaptRowButtonsToColumns(this.rowButtons),\n      attachedTopButtons: this._adaptRowButtonsToColumns(this.tableButtons),\n      placeholderForExtensor: \"data.map(function(it, i) {\\n  return /* you start here */ || {};\\n});\",\n      placeholderForOrdenador: \"data.sort(function(a, b) {\\n  return /* you start here */;\\n});\",\n      placeholderForFiltro: \"data.filter(function(it, i) {\\n  return /* you start here */;\\n});\",\n    };\n  },\n  methods: {\n    goToFirstPage() {\n      this.$trace(\"lsw-table.methods.goToFirstPage\");\n      this.currentPage = 0;\n    },\n    decreasePage() {\n      this.$trace(\"lsw-table.methods.decreasePage\");\n      if (this.currentPage > 0) {\n        this.currentPage--;\n      }\n    },\n    increasePage() {\n      this.$trace(\"lsw-table.methods.increasePage\");\n      const lastPage = Math.floor(this.output.length / this.itemsPerPage);\n      if (this.currentPage < lastPage) {\n        this.currentPage++;\n      }\n    },\n    goToLastPage() {\n      this.$trace(\"lsw-table.methods.goToLastPage\");\n      const lastPage = Math.floor(this.output.length / this.itemsPerPage);\n      if (this.currentPage !== lastPage) {\n        this.currentPage = lastPage;\n      }\n    },\n    toggleChoosenRow(rowId) {\n      this.$trace(\"lsw-table.methods.toggleChoosenRow\");\n      if(this.selectable === 'many') {\n        const pos = this.choosenRows.indexOf(rowId);\n        if (pos === -1) {\n          this.choosenRows.push(rowId);\n        } else {\n          this.choosenRows.splice(pos, 1);\n        }\n      } else if(this.selectable === 'one') {\n        const isSame = this.choosenRows === rowId;\n        if(isSame) {\n          this.choosenRows = undefined;\n        } else {\n          this.choosenRows = rowId;\n        }\n      }\n    },\n    toggleRow(rowIndex) {\n      this.$trace(\"lsw-table.methods.toggleRow\");\n      const pos = this.selectedRows.indexOf(rowIndex);\n      if (pos === -1) {\n        this.selectedRows.push(rowIndex);\n      } else {\n        this.selectedRows.splice(pos, 1);\n      }\n    },\n    toggleMenu() {\n      this.$trace(\"lsw-table.methods.toggleMenu\");\n      this.isShowingMenu = !this.isShowingMenu;\n    },\n    digestOutput() {\n      this.$trace(\"lsw-table.methods.digestOutput\");\n      const input = this.input;\n      let temp = [];\n      const extenderExpression = this.extender.trim() || \"{}\";\n      const extenderFunction = new Function(\"it\", \"i\", `return ${extenderExpression}`);\n      const filterExpression = this.filter.trim() || \"true\";\n      const filterFunction = new Function(\"it\", \"i\", `return ${filterExpression}`);\n      const sorterExpression = this.sorter.trim() || \"0\";\n      const sorterFunction = new Function(\"a\", \"b\", `return ${sorterExpression}`);\n      let tempHeaders = new Set();\n      for (let index = 0; index < input.length; index++) {\n        const row = input[index];\n        let extendedRow = undefined;\n        Apply_extender: {\n          try {\n            const extenderProduct = extenderFunction(row, index) || {};\n            extendedRow = Object.assign({}, row, extenderProduct);\n          } catch (error) {\n            extendedRow = Object.assign({}, row);\n          }\n        }\n        Apply_filter: {\n          try {\n            const filterProduct = filterFunction(extendedRow, index);\n            if (filterProduct === true) {\n              temp.push(extendedRow);\n            }\n          } catch (error) {\n            // @OK.\n          }\n        }\n        Extract_headers: {\n          try {\n            Object.keys(extendedRow).forEach(key => {\n              tempHeaders.add(key);\n            });\n          } catch (error) {\n            // @OK.\n          }\n        }\n      }\n      Apply_sorter: {\n        try {\n          temp = temp.sort(sorterFunction);\n        } catch (error) {\n          // @OK.\n        }\n        Also_to_headers: {\n          if(Array.isArray(this.columnsOrder) && this.columnsOrder.length) {\n            tempHeaders = [...tempHeaders].sort((h1, h2) => {\n              const pos1 = this.columnsOrder.indexOf(h1);\n              const pos2 = this.columnsOrder.indexOf(h2);\n              if(pos1 === -1 && pos2 === -1) {\n                return -1;\n              } else if(pos1 === -1) {\n                return 1;\n              } else if(pos2 === -1) {\n                return -1;\n              } else if(pos1 > pos2) {\n                return 1;\n              }\n              return -1;\n            });\n          }\n        }\n      }\n      this.headers = tempHeaders;\n      this.output = temp;\n      this.digestPagination();\n    },\n    digestPagination() {\n      this.$trace(\"lsw-table.methods.digestPagination\");\n      const page = this.currentPage;\n      const items = this.itemsPerPage;\n      const firstPosition = items * (page);\n      this.selectedRows = [];\n      this.paginatedOutput = [].concat(this.output).splice(firstPosition, items);\n    },\n    saveCurrentTransformer() {\n      this.$trace(\"lsw-table.methods.saveCurrentTransformer\");\n    },\n    _adaptRowButtonsToHeaders(rowButtons) {\n      const attachedHeaders = [];\n      for(let index=0; index<rowButtons.length; index++) {\n        const attachedButton = rowButtons[index];\n        attachedHeaders.push({\n          text: attachedButton.header || \"\"\n        });\n      }\n      return attachedHeaders;\n    },\n    _adaptRowButtonsToColumns(rowButtons) {\n      const attachedColumns = [];\n      for(let index=0; index<rowButtons.length; index++) {\n        const attachedButton = rowButtons[index];\n        attachedColumns.push({\n          text: attachedButton.text || \"\",\n          event: attachedButton.event || this.$noop,\n        });\n      }\n      return attachedColumns;\n    }\n  },\n  watch: {\n    itemsPerPage(value) {\n      this.$trace(\"lsw-table.watch.itemsPerPage\");\n      this.digestPagination();\n    },\n    currentPage(value) {\n      this.$trace(\"lsw-table.watch.currentPage\");\n      this.digestPagination();\n    },\n    choosenRows(v) {\n      this.$trace(\"lsw-table.watch.value\");\n      this.onChooseRow(v, this);\n    }\n  },\n  computed: {\n    hasFiltersApplying() {\n      this.$trace(\"lsw-table.computed.hasFiltersApplying\");\n      if (this.extender.length) {\n        return true;\n      }\n      if (this.filter.length) {\n        return true;\n      }\n      if (this.sorter.length) {\n        return true;\n      };\n      return false;\n    }\n  },\n  mounted() {\n    this.$trace(\"lsw-table.mounted\");\n    this.digestOutput();\n  }\n});\n",
            "$code.label": "LswTable API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Wiki API » LswWiki component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-wiki/lsw-wiki/lsw-wiki.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 99,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Wiki API » LswWiki component",
            "$code": "Vue.component(\"LswWiki\", {\n  name: \"LswWiki\",\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-wiki.data\");\n    return {\n      search_text_1: \"\",\n    };\n  },\n  methods: {\n    search() {\n      this.$trace(\"lsw-wiki.methods.search\");\n      console.log(\"Search\");\n    }\n  },\n  watch: {\n    \n  },\n  async mounted() {\n    try {\n      this.$trace(\"lsw-wiki.mounted\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswWiki API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Windows API » LswWindowsMainTab component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-main-tab/lsw-windows-main-tab.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 122,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Windows API » LswWindowsMainTab component",
            "$code": "// Change this component at your convenience:\nVue.component(\"LswWindowsMainTab\", {\n  template: $template,\n  props: {\n    viewer: {\n      type: Object,\n      required: true\n    }\n  },\n  data() {\n    return {\n      \n    };\n  },\n  methods: {\n    getRandomString(len = 10) {\n      const alphabet = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\n      let out = \"\";\n      while(out.length < len) {\n        out += alphabet[Math.floor(Math.random() * alphabet.length)];\n      }\n      return out;\n    },\n    openRest() {\n      this.viewer.hide();\n      this.$dialogs.open({\n        id: \"database-explorer-\" + this.getRandomString(5),\n        title: \"Database explorer\",\n        template: `<lsw-database-explorer />`,\n      });\n    },\n    openFilesystem() {\n      this.viewer.hide();\n      this.$dialogs.open({\n        id: \"filesystem-explorer-\" + this.getRandomString(5),\n        title: \"Filesystem explorer\",\n        template: `<lsw-filesystem-explorer />`,\n      });\n    },\n    openWiki() {\n      this.viewer.hide();\n      this.$dialogs.open({\n        id: \"wiki-explorer-\" + this.getRandomString(5),\n        title: \"Wiki explorer\",\n        template: `<lsw-wiki />`,\n      });\n    },\n    openAgenda() {\n      this.viewer.hide();\n      this.$dialogs.open({\n        id: \"agenda-viewer-\" + this.getRandomString(5),\n        title: \"Agenda viewer\",\n        template: `<lsw-agenda />`,\n      });\n    },\n  },\n  mounted() {\n    \n  }\n});\n",
            "$code.label": "LswWindowsMainTab API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Windows API » LswWindowsPivotButton component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-pivot-button/lsw-windows-pivot-button.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 130,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Windows API » LswWindowsPivotButton component",
            "$code": "// Change this component at your convenience:\nVue.component(\"LswWindowsPivotButton\", {\n  template: $template,\n  props: {\n    viewer: {\n      type: Object,\n      required: true\n    }\n  },\n  data() {\n    return {\n      \n    };\n  },\n  methods: {\n    onClick(event) {\n      this.viewer.toggleState();\n    }\n  },\n  mounted() {\n    \n  }\n});\n",
            "$code.label": "LswWindowsPivotButton API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Windows API » LswWindowsViewer classes and functions": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-windows/lsw-windows-viewer/lsw-windows-viewer.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 132,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Windows API » LswWindowsViewer classes and functions",
            "$code": "// Change this component at your convenience:\nVue.component(\"LswWindowsViewer\", {\n  template: $template,\n  props: {},\n  data() {\n    return {\n      isShowing: false\n    };\n  },\n  methods: {\n    hide() {\n      this.isShowing = false;\n    },\n    show() {\n      this.isShowing = true;\n    },\n    toggleState() {\n      this.isShowing = !this.isShowing;\n      this.$forceUpdate(true);\n    },\n    selectDialog(id) {\n      this.hide();\n      this.$refs.dialogs.maximize(id);\n    }\n  },\n  mounted() {\n    this.$window.LswWindows = this;\n    this.$lsw.windows = this;\n  }\n});\n",
            "$code.label": "LswWindowsViewer API",
            "$output": "index.html"
          }
        ],
        "LswStore API » LswStore class": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/apis/lsw-store/src/lib/002.store.js",
            "$location": {
              "start": {
                "offset": 280,
                "line": 14,
                "column": 1
              },
              "end": {
                "offset": 356,
                "line": 15,
                "column": 1
              }
            },
            "$section": "LswStore API » LswStore class",
            "$code": "  const Store = class {\n\n    static create(...args) {\n      return new this(...args);\n    }\n\n    constructor(initialState = {}, path_to_store = \"original_store.json\") {\n      this.$store = initialState;\n      this.$storePath = path_to_store;\n      this.events = {};\n    }\n\n    _triggerParentEvents(event, path, value) {\n      const originalPath = path.join(\".\");\n      if (this.events[originalPath]) {\n        this.events[originalPath].forEach((callback) => {\n          return callback(event, path, value);\n        });\n      }\n      while (path.length > 0) {\n        path.pop();\n        const parentPath = path.join(\".\");\n        if (this.events[parentPath]) {\n          this.events[parentPath].forEach((callback) => {\n            const value = this.get(path);\n            return callback(event, path, value);\n          });\n        }\n      }\n    }\n\n    get(path = []) {\n      return path.reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : undefined), this.$store);\n    }\n\n    set(path, value) {\n      if (!Array.isArray(path) || path.length === 0) {\n        throw new Error(\"La ruta debe ser un array de strings no vacío.\");\n      }\n      const lastKey = path.pop();\n      const target = path.reduce((acc, key) => {\n        if (!acc[key]) acc[key] = {};\n        return acc[key];\n      }, this.$store);\n      target[lastKey] = value;\n      path.push(lastKey);\n      this._triggerParentEvents(\"set\", path, value);\n    }\n\n    watch(path, callback) {\n      const key = path.join(\".\");\n      if (!this.events[key]) {\n        this.events[key] = [];\n      }\n      this.events[key].push(callback);\n    }\n\n    unwatch(path, callback) {\n      const key = path.join(\".\");\n      if (this.events[key]) {\n        this.events[key] = this.events[key].filter((cb) => {\n          return cb !== callback;\n        });\n        if (this.events[key].length === 0) {\n          delete this.events[key];\n        }\n      }\n    }\n\n    delete(path) {\n      if (!Array.isArray(path) || path.length === 0) {\n        throw new Error(\"La ruta debe ser un array de strings no vacío.\");\n      }\n      const lastKey = path.pop();\n      const target = this.get(path);\n      if (target && target.hasOwnProperty(lastKey)) {\n        delete target[lastKey];\n        this._triggerParentEvents(\"delete\", path);\n      }\n    }\n\n    push(path, value) {\n      const array = this.get(path);\n      if (Array.isArray(array)) {\n        array.push(value);\n        this._triggerParentEvents(\"push\", path, array);\n      }\n    }\n\n    pop(path) {\n      const array = this.get(path);\n      if (Array.isArray(array)) {\n        const value = array.pop();\n        this._triggerParentEvents(\"pop\", path, array);\n        return value;\n      }\n    }\n\n    unshift(path, value) {\n      const array = this.get(path);\n      if (Array.isArray(array)) {\n        array.unshift(value);\n        this._triggerParentEvents(\"unshift\", path, array);\n      }\n    }\n\n    shift(path) {\n      const array = this.get(path);\n      if (Array.isArray(array)) {\n        const value = array.shift();\n        this._triggerParentEvents(\"shift\", path, array);\n        return value;\n      }\n    }\n\n    add(path, key, value) {\n      const object = this.get(path);\n      if (object && typeof object === 'object' && !Array.isArray(object)) {\n        object[key] = value;\n        this._triggerParentEvents(\"add\", path, object);\n      }\n    }\n\n    remove(path, key) {\n      const object = this.get(path);\n      if (object && typeof object === 'object' && !Array.isArray(object)) {\n        delete object[key];\n        this._triggerParentEvents(\"remove\", path, object);\n      }\n    }\n\n    splice(path, start, deleteCount, ...items) {\n      const array = this.get(path);\n      if (Array.isArray(array)) {\n        const result = array.splice(start, deleteCount, ...items);\n        this._triggerParentEvents(\"splice\", path, array);\n        return result;\n      }\n    }\n\n    extend(path, newProps) {\n      const object = this.get(path);\n      if (object && typeof object === 'object' && !Array.isArray(object)) {\n        Object.assign(object, newProps);\n        this._triggerParentEvents(\"extend\", path, object);\n      }\n    }\n\n    multiextend(...extensions) {\n      for (let index = 0; index < extensions.length; index++) {\n        const {\n          selector,\n          value: targetValue,\n          mode,\n          modifier\n        } = extensions[index];\n        this.modify(selector, currentValue => {\n          let lastValue = currentValue;\n          Set_value: {\n            if (mode === \"assign\") {\n              lastValue = Object.assign(currentValue, targetValue);\n            } else if (mode === \"default\") {\n              lastValue = Object.assign({}, targetValue, currentValue);\n            } else if (mode === \"set\") {\n              lastValue = targetValue;\n            } else if (mode === \"concat\") {\n              lastValue = currentValue.concat(targetValue);\n            }\n          }\n          Run_modifier: {\n            if (modifier) {\n              const result = modifier(lastValue);\n              if (typeof result !== \"undefined\") {\n                return result;\n              }\n            }\n            return lastValue;\n          }\n        });\n      }\n    }\n\n    modify(path, modifier) {\n      const currentValue = this.get(path);\n      const newValue = modifier(currentValue);\n      const isNotSame = newValue !== currentValue;\n      const isNotUndefined = typeof newValue !== \"undefined\";\n      if (isNotUndefined && isNotSame) {\n        this.set(path, newValue);\n      }\n    }\n\n    hydrate(file) {\n      const ufs = UFS_manager.create(this.$storePath);\n      this.$store = JSON.parse(ufs.read_file(file));\n    }\n\n    dehydrate(file) {\n      const ufs = UFS_manager.create(this.$storePath);\n      ufs.write_file(file, JSON.stringify(this.$store));\n    }\n\n  };\n\n  Store.default = Store;\n\n  return Store;\n",
            "$code.label": "LswStore class",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaAccionAdd API » LswAgendaAccionAdd component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-accion-add/lsw-agenda-accion-add.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 147,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaAccionAdd API » LswAgendaAccionAdd component",
            "$code": "Vue.component(\"LswAgendaAccionAdd\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-accion-add.data\");\n    return {\n      // \n    };\n  },\n  methods: {\n    async insertAccion(v) {\n      this.$trace(\"lsw-agenda-accion-add.methods.insertAccion\");\n      await this.$lsw.database.insert(\"Accion\", v);\n      // *@TODO: should redirect\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-accion-add.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaAccionAdd API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaAccionSearch API » LswAgendaAccionSearch component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-accion-search/lsw-agenda-accion-search.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 156,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaAccionSearch API » LswAgendaAccionSearch component",
            "$code": "Vue.component(\"LswAgendaAccionSearch\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-accion-search.data\");\n    return {\n      isLoaded: false,\n    };\n  },\n  methods: {\n    async loadRows() {\n      this.$trace(\"lsw-agenda-accion-search.methods.loadRows\");\n      this.rows = await this.$lsw.database.selectMany(\"Accion\", it => true);\n      this.isLoaded = true;\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-accion-search.mounted\");\n      this.loadRows();\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaAccionSearch API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaBreadcrumb API » LswAgendaBreadcrumb component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-breadcrumb/lsw-agenda-breadcrumb.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 150,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaBreadcrumb API » LswAgendaBreadcrumb component",
            "$code": "Vue.component(\"LswAgendaBreadcrumb\", {\n  name: \"LswAgendaBreadcrumb\",\n  template: $template,\n  props: {\n    agenda: {\n      type: Object,\n      default: () => null\n    },\n    pathItems: {\n      type: Array,\n      required: true\n    }\n  },\n  data() {\n    this.$trace(\"lsw-agenda-breadcrumb.data\");\n    return {\n      \n    };\n  },\n  methods: {\n    goToSection(section) {\n      this.$trace(\"lsw-agenda-breadcrumb.methods.goToSection\");\n      if(this.agenda) {\n        this.agenda.selectContext(section);\n      }\n    }\n  },\n  watch: {\n\n  },\n  async mounted() {\n    try {\n      this.$trace(\"lsw-agenda-breadcrumb.mounted\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaBreadcrumb API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaConceptoAdd API » LswAgendaConceptoAdd component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-concepto-add/lsw-agenda-concepto-add.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 153,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaConceptoAdd API » LswAgendaConceptoAdd component",
            "$code": "Vue.component(\"LswAgendaConceptoAdd\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-concepto-add.data\");\n    return {\n      // \n    };\n  },\n  methods: {\n    async insertConcepto(v) {\n      this.$trace(\"lsw-agenda-concepto-add.methods.insertConcepto\");\n      await this.$lsw.database.insert(\"Concepto\", v);\n      // *@TODO: should redirect\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-concepto-add.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaConceptoAdd API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaConceptoSearch API » LswAgendaConceptoSearch component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-concepto-search/lsw-agenda-concepto-search.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 162,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaConceptoSearch API » LswAgendaConceptoSearch component",
            "$code": "Vue.component(\"LswAgendaConceptoSearch\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-concepto-search.data\");\n    return {\n      isLoaded: false,\n    };\n  },\n  methods: {\n    async loadRows() {\n      this.$trace(\"lsw-agenda-concepto-search.methods.loadRows\");\n      this.rows = await this.$lsw.database.selectMany(\"Concepto\", it => true);\n      this.isLoaded = true;\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-concepto-search.mounted\");\n      this.loadRows();\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaConceptoSearch API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaEventoSearch API » LswAgendaEventoSearch component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-evento-search/lsw-agenda-evento-search.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 156,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaEventoSearch API » LswAgendaEventoSearch component",
            "$code": "Vue.component(\"LswAgendaEventoSearch\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-evento-search.data\");\n    return {};\n  },\n  methods: {},\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-evento-search.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaEventoSearch API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaForm API » LswAgendaForm component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-form/lsw-agenda-form.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 132,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaForm API » LswAgendaForm component",
            "$code": "Vue.component(\"LswAgendaForm\", {\n  template: $template,\n  props: {\n    formMetadata: {\n      type: Object,\n      required: true,\n    }\n  },\n  data() {\n    this.$trace(\"lsw-agenda-form.data\");\n    this.validateFormMetadata(this.formMetadata);\n    return {\n      expandedExplanations: [],\n      formScope: {},\n      formState: {}\n    };\n  },\n  methods: {\n    validateFormMetadata(v) {\n      const isObject = typeof v === \"object\";\n      const hasFormAsObject = typeof v.form === \"object\";\n      const hasFieldsAsArray = Array.isArray(v.fields);\n      if(!isObject) {\n        throw new Error(\"Required parameter «formMetadata» to be an object on «LswAgendaForm.methods.validateFormMetadata»\");\n      }\n      if(!hasFormAsObject) {\n        throw new Error(\"Required parameter «formMetadata.form» to be an object on «LswAgendaForm.methods.validateFormMetadata»\");\n      }\n      if(!hasFieldsAsArray) {\n        throw new Error(\"Required parameter «formMetadata.fields» to be an array on «LswAgendaForm.methods.validateFormMetadata»\");\n      }\n    },\n    toggleExplanation(id) {\n      const pos = this.expandedExplanations.indexOf(id);\n      if(pos === -1) {\n        this.expandedExplanations.push(id);\n      } else {\n        this.expandedExplanations.splice(pos, 1);\n      }\n    },\n    loadFields() {\n      this.$window.F = this.$refs.agenda_form;\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-form.mounted\");\n      this.loadFields();\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaForm API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaImpresionAdd API » LswAgendaImpresionAdd component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-impresion-add/lsw-agenda-impresion-add.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 156,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaImpresionAdd API » LswAgendaImpresionAdd component",
            "$code": "Vue.component(\"LswAgendaImpresionAdd\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-impresion-add.data\");\n    return {};\n  },\n  methods: {},\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-impresion-add.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaImpresionAdd API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaImpresionSearch API » LswAgendaImpresionSearch component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-impresion-search/lsw-agenda-impresion-search.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 165,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaImpresionSearch API » LswAgendaImpresionSearch component",
            "$code": "Vue.component(\"LswAgendaImpresionSearch\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-impresion-search.data\");\n    return {};\n  },\n  methods: {},\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-impresion-search.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaImpresionSearch API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaInfraccionSearch API » LswAgendaInfraccionSearch component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-infraccion-search/lsw-agenda-infraccion-search.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 168,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaInfraccionSearch API » LswAgendaInfraccionSearch component",
            "$code": "Vue.component(\"LswAgendaInfraccionSearch\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-infraccion-search.data\");\n    return {};\n  },\n  methods: {},\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-infraccion-search.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaInfraccionSearch API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaLimitadorAdd API » LswAgendaLimitadorAdd component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-add/lsw-agenda-limitador-add.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 156,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaLimitadorAdd API » LswAgendaLimitadorAdd component",
            "$code": "Vue.component(\"LswAgendaLimitadorAdd\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-limitador-add.data\");\n    return {\n      // \n    };\n  },\n  methods: {\n    async insertLimitador(v) {\n      this.$trace(\"lsw-agenda-limitador-add.methods.insertLimitador\");\n      await this.$lsw.database.insert(\"Limitador\", v);\n      // *@TODO: should redirect\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-limitador-add.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaLimitadorAdd API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaLimitadorSearch API » LswAgendaLimitadorSearch component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-search/lsw-agenda-limitador-search.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 165,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaLimitadorSearch API » LswAgendaLimitadorSearch component",
            "$code": "Vue.component(\"LswAgendaLimitadorSearch\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-limitador-search.data\");\n    return {\n      isLoaded: false,\n    };\n  },\n  methods: {\n    async loadRows() {\n      this.$trace(\"lsw-agenda-limitador-search.methods.loadRows\");\n      this.rows = await this.$lsw.database.selectMany(\"Limitador\", it => true);\n      this.isLoaded = true;\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-limitador-search.mounted\");\n      this.loadRows();\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaLimitadorSearch API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaLimitadorViewer API » LswAgendaLimitadorViewer component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-limitador-viewer/lsw-agenda-limitador-viewer.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 165,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaLimitadorViewer API » LswAgendaLimitadorViewer component",
            "$code": "Vue.component(\"LswAgendaLimitadorViewer\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-limitador-viewer.data\");\n    return {\n      isLoaded: false,\n      limitadores: undefined,\n      infracciones: [],\n    };\n  },\n  methods: {\n    fixAsyncCode(asyncCode) {\n      if(asyncCode.trim().startsWith(\"async \")) {\n        return `return await (${asyncCode}).call(this)`\n      }\n      return asyncCode;\n    },\n    async executeLimitadores() {\n      const lims = this.limitadores;\n      for(let index=0; index<lims.length; index++) {\n        const limitador = lims[index];\n        const asyncCode = limitador.tiene_funcion;\n        const AsyncFunc = (async function() {}).constructor;\n        const fixedAsyncCode = this.fixAsyncCode(asyncCode);\n        const asyncFunc = new AsyncFunc(fixedAsyncCode);\n        console.log(asyncFunc);\n        try {\n          await asyncFunc.call(this);\n        } catch (error) {\n          this.infracciones.push(error);\n        }\n      }\n    },\n    async loadLimitadores() {\n      this.$trace(\"lsw-agenda-limitador-viewer.methods.loadLimitadores\");\n      const limitadores = await this.$lsw.database.selectMany(\"Limitador\");\n      this.limitadores = limitadores;\n      await this.executeLimitadores();\n    }\n  },\n  watch: {},\n  async mounted() {\n    try {\n      this.$trace(\"lsw-agenda-limitador-viewer.mounted\");\n      await this.loadLimitadores();\n      this.isLoaded = true;\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaLimitadorViewer API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaPostimpresionSearch API » LswAgendaPostimpresionSearch component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-postimpresion-search/lsw-agenda-postimpresion-search.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 177,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaPostimpresionSearch API » LswAgendaPostimpresionSearch component",
            "$code": "Vue.component(\"LswAgendaPostimpresionSearch\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-postimpresion-search.data\");\n    return {};\n  },\n  methods: {},\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-postimpresion-search.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaPostimpresionSearch API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaPropagacionSearch API » LswAgendaPropagacionSearch component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-propagacion-search/lsw-agenda-propagacion-search.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 171,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaPropagacionSearch API » LswAgendaPropagacionSearch component",
            "$code": "Vue.component(\"LswAgendaPropagacionSearch\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-propagacion-search.data\");\n    return {};\n  },\n  methods: {},\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-propagacion-search.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaPropagacionSearch API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » LswAgenda API » LswAgendaPropagadorSearch API » LswAgendaPropagadorSearch component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-agenda/components/lsw-agenda-propagador-search/lsw-agenda-propagador-search.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 168,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » LswAgenda API » LswAgendaPropagadorSearch API » LswAgendaPropagadorSearch component",
            "$code": "Vue.component(\"LswAgendaPropagadorSearch\", {\n  template: $template,\n  props: {},\n  data() {\n    this.$trace(\"lsw-agenda-propagador-search.data\");\n    return {};\n  },\n  methods: {},\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-agenda-propagador-search.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswAgendaPropagadorSearch API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswFormBuilder component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-form-builder/lsw-form-builder.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 118,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswFormBuilder component",
            "$code": "Vue.component(\"LswFormBuilder\", {\n  template: $template,\n  props: {\n    validate: {\n      type: Object,\n      default: () => ({})\n    },\n    submit: {\n      type: Object,\n      default: () => ({})\n    },\n    fields: {\n      type: Array,\n      required: true,\n    }\n  },\n  data() {\n    this.$trace(\"lsw-form-builder.data\");\n    this.formatFields();\n    return {\n      formMetadata: false,\n    };\n  },\n  methods: {\n    setError(error) {\n      this.$trace(\"lsw-form-builder.setError\");\n      this.error = error;\n    },\n    formatFields(value = this.fields) {\n      this.$trace(\"lsw-form-builder.formatFields\");\n      try {\n        const $outterScope = {};\n        if (value.length === 0) {\n          throw new Error(\"Required property «prop.fields» to be an array on «LswFormBuilder.props.fields.validator»\");\n        }\n        const fields = [];\n        const form = {\n          scope: $outterScope,\n          id: \"form.default\"\n        };\n        const metadata = { fields, form, scope: $outterScope };\n        form.vForm = {\n          selfScope: $outterScope,\n          selfId: form.id,\n          onValidate: typeof this.validate.onClick === 'function' ? this.validate.onClick : this.$noop,\n          onSubmit: typeof this.submit.onClick === 'function' ? this.submit.onClick : this.$noop,\n        }\n        for (let index = 0; index < value.length; index++) {\n          const row = value[index];\n          if (typeof row !== \"object\") {\n            throw new Error(`Required all rows on «prop.fields» to be an object but row «${index}» does not on «LswFormBuilder.props.fields.validator»`)\n          }\n          if (!(\"type\" in row)) {\n            throw new Error(`Required all rows on «prop.fields» to have property «type» but row «${index}» does not on «LswFormBuilder.props.fields.validator»`)\n          }\n          if (typeof row.type !== \"string\") {\n            throw new Error(`Required all rows on «prop.fields» to have property «type» as a string but row «${index}» does not on «LswFormBuilder.props.fields.validator»`)\n          }\n          if (!(\"name\" in row)) {\n            throw new Error(`Required all rows on «prop.fields» to have property «name» but row «${index}» does not on «LswFormBuilder.props.fields.validator»`)\n          }\n          if (typeof row.name !== \"string\") {\n            throw new Error(`Required all rows on «prop.fields» to have property «name» as a string but row «${index}» does not on «LswFormBuilder.props.fields.validator»`)\n          }\n          const $innerScope = {};\n          row.vForm = {\n            parentScope: $outterScope,\n            parentId: metadata.form.id,\n            selfScope: $innerScope,\n            selfId: row.name,\n            name: row.name,\n          };\n          if (row.type === \"point\") {\n            row.dimensions = [];\n            row.vFormForPoint = {\n              parentScope: $innerScope,\n              parentId: row.name,\n              selfScope: $innerScope,\n              selfId: \"point.control\",\n              name: null,\n            };\n            row.dimensions = [{\n              label: \"Axis 1:\",\n              vForm: {\n                parentScope: $innerScope,\n                parentId: \"point.control\",\n                name: \"axis_1\"\n              }\n            }, {\n              label: \"Axis 2:\",\n              vForm: {\n                parentScope: $innerScope,\n                parentId: \"point.control\",\n                name: \"axis_2\"\n              }\n            }];\n            if (row.dimensions.length < 2) {\n              throw new Error(`Required property «row.dimensions» to have more than 1 item on row «${index}» on «adaptRowToVForm»`);\n            }\n            for (let indexDimension = 0; indexDimension < row.dimensions.length; indexDimension++) {\n\n            }\n          }\n          fields.push(row);\n        }\n        this.formMetadata = Object.freeze(metadata);\n      } catch (error) {\n        console.log(error);\n        this.setError(error);\n      }\n    },\n    adaptRowToVForm(row, metadata, indexRow) {\n      this.$trace(\"lsw-form-builder.adaptRowToVForm\");\n\n    }\n  },\n  watch: {},\n  mount() {\n    try {\n      this.$trace(\"lsw-form-builder.mount\");\n    } catch (error) {\n      console.log(error);\n    }\n  },\n  mounted() {\n    try {\n      this.$trace(\"lsw-form-builder.mounted\");\n      this.formatFields();\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswFormBuilder API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswControlError component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/partials/lsw-control-error/lsw-control-error.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 120,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswControlError component",
            "$code": "Vue.component(\"LswControlError\", {\n  template: $template,\n  props: {\n    \n  },\n  data() {\n    this.$trace(\"lsw-control-error-control.data\");\n    return {\n      \n    };\n  },\n  methods: {\n    removeError() {\n      this.$trace(\"lsw-control-error-control.methods.removeError\");\n      this.$refs.errorBox.$xform.$clearError();\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-control-error-control.mounted\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswControlError API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswControlLabel component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/partials/lsw-control-label/lsw-control-label.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 120,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswControlLabel component",
            "$code": "Vue.component(\"LswControlLabel\", {\n  template: $template,\n  props: {\n    parentFormtype: {\n      type: Object,\n      required: false,\n    },\n    settings: {\n      type: Object,\n      default: () => ({})\n    },\n  },\n  data() {\n    this.$trace(\"lsw-control-label-control.data\");\n    this.validateSettings();\n    return {\n      uuid: LswRandomizer.getRandomString(5),\n      isShowingDescription: false,\n      name: this.settings?.name,\n      label: (typeof (this.settings?.label) !== \"undefined\") ? this.settings.label : this.settings?.column?.hasLabel,\n      description: this.settings?.column?.hasDescription\n    };\n  },\n  methods: {\n    toggleDescription() {\n      this.isShowingDescription = !this.isShowingDescription;\n    },\n    validateSettings() {\n      this.$trace(\"lsw-control-label-control.methods.validateSettings\");\n      LswXForm.validateSettings(this.settings);\n      const ensureSettings = $ensure(this.settings);\n      const checkSettings = $check(this.settings);\n      // @OK\n    },\n    makeEditable() {\n      this.$trace(\"lsw-control-label-control.methods.makeEditable\");\n      Behaviour_for_controls: {\n        const immediateControl = LswVue2.getClosestParent(this, component => {\n          return component.$el.classList.contains(\"lsw_form_control\");\n        });\n        if (immediateControl) {\n          immediateControl.isEditable = true;\n          // immediateControl.$forceUpdate(true);\n        }\n      }\n      Behaviour_for_schema_forms: {\n        \n      }\n    },\n    makeUneditable() {\n      this.$trace(\"lsw-control-label-control.methods.makeUneditable\");\n      Behaviour_for_controls: {\n        const immediateControl = LswVue2.getClosestParent(this, component => {\n          return component.$el.classList.contains(\"lsw_form_control\");\n        });\n        if (immediateControl) {\n          immediateControl.isEditable = false;\n          // immediateControl.$forceUpdate(true);\n        }\n\n      }\n      Behaviour_for_schema_forms: {\n        \n      }\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-control-label-control.mounted\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswControlLabel API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswErrorViewer component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/partials/lsw-error-viewer/lsw-error-viewer.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 118,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswErrorViewer component",
            "$code": "Vue.component(\"LswErrorViewer\", {\n  template: $template,\n  props: {\n    error: {\n      type: [Object, Boolean],\n      default: () => false\n    },\n    onClearError: {\n      type: Function,\n      default: () => {}\n    }\n  },\n  data() {\n    this.$trace(\"lsw-error-viewer.data\");\n    return {\n      currentError: this.error,\n    };\n  },\n  methods: {\n    setError(error = undefined) {\n      this.$trace(\"lsw-error-viewer.methods.setError\");\n      this.currentError = error;\n      if(typeof error === \"undefined\") {\n        this.onClearError();\n      }\n    },\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-error-viewer.mounted\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswErrorViewer API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswBooleanControl component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-boolean-control/lsw-boolean-control.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 124,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswBooleanControl component",
            "$code": "Vue.component(\"LswBooleanControl\", {\n  template: $template,\n  props: {\n    configurations: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  data() {\n    this.$trace(\"lsw-boolean-control.data\");\n    return {};\n  },\n  methods: {},\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-boolean-control.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswBooleanControl API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswDateControl component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-date-control/lsw-date-control.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 118,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswDateControl component",
            "$code": "Vue.component(\"LswDateControl\", {\n  template: $template,\n  props: {\n    settings: {\n      type: Object,\n      default: () => ({})\n    },\n    mode: {\n      type: String,\n      default: () => \"date\" // can be: date, datetime, time\n    }\n  },\n  data() {\n    this.$trace(\"lsw-date-control.data\");\n    this.validateMode();\n    this.validateSettings();\n    const respectivePlaceholder = this.generatePlaceholder();\n    return {\n      uuid: LswRandomizer.getRandomString(5),\n      value: this.settings?.initialValue || \"\",\n      isEditable: true,\n      isShowingCalendar: false,\n      respectivePlaceholder,\n      formMode: this.settings?.column?.isFormSubtype || this.mode || \"datetime\",\n    };\n  },\n  methods: {\n    toggleCalendar() {\n      this.$trace(\"LswDateControl.methods.toggleCalendar\", arguments);\n      this.isShowingCalendar = !this.isShowingCalendar;\n    },\n    generatePlaceholder() {\n      return this.settings.column.isFormSubtype === \"date\" ? 'Ej: 2025/01/01' :\n        this.settings.column.isFormSubtype === \"datetime\" ? 'Ej: 2025/01/01 00:00' :\n        this.settings.column.isFormSubtype === \"time\" ? 'Ej: 00:00' : ''\n    },\n    async submit() {\n      this.$trace(\"lsw-text-control.methods.submit\");\n      return LswFormtypes.utils.submitControl.call(this);\n    },\n    validate() {\n      this.$trace(\"lsw-text-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateControl.call(this);\n    },\n    validateSettings() {\n      this.$trace(\"lsw-text-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateSettings.call(this);\n    },\n    validateMode() {\n      this.$trace(\"lsw-date-control.methods.validateSettings\");\n      $ensure({mode: this.mode}, 1).to.be.oneOf([\"date\", \"time\", \"datetime\"]);\n    },\n    setValueFromCalendar(v) {\n      this.$trace(\"lsw-date-control.methods.setValueFromCalendar\");\n      console.log(\"Valor:\", v);\n      const value = LswTimer.utils.formatDatestringFromDate(v, false, false, true);\n      if(this.formMode === \"datetime\") {\n        this.value = value;\n      } else if(this.formMode === \"date\") {\n        this.value = value.split(\" \")[0];\n      } else if(this.formMode === \"time\") {\n        this.value = value.split(\" \")[1];\n      } else {\n        this.value = value;\n      }\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-date-control.mounted\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswDateControl API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswDurationControl component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-duration-control/lsw-duration-control.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 126,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswDurationControl component",
            "$code": "Vue.component(\"LswDurationControl\", {\n  template: $template,\n  props: {\n    settings: {\n      type: Object,\n      default: () => ({})\n    },\n  },\n  data() {\n    this.$trace(\"lsw-duration-control.data\");\n    this.validateSettings();\n    const value = this.settings?.initialValue || this.settings?.column.hasDefaultValue || \"\";\n    return {\n      uuid: LswRandomizer.getRandomString(5),\n      value,\n      isEditable: true,\n      isShowingDetails: false,\n      submitError: false,\n      validateError: false,\n    };\n  },\n  methods: {\n    async submit() {\n      this.$trace(\"lsw-text-control.methods.submit\");\n      try {\n        return LswFormtypes.utils.submitControl.call(this);\n      } catch (error) {\n        this.submitError = error;\n        throw error;\n      }\n    },\n    validate() {\n      this.$trace(\"lsw-text-control.methods.validateSettings\");\n      try {\n        return LswFormtypes.utils.validateControl.call(this);\n      } catch (error) {\n        this.validateError = error;\n        throw error;\n      }\n    },\n    validateSettings() {\n      this.$trace(\"lsw-text-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateSettings.call(this);\n    },\n    toggleDetails() {\n      this.$trace(\"lsw-duration-control.methods.toggleDetails\");\n      this.isShowingDetails = !this.isShowingDetails;\n    },\n    increasePosition(pos) {\n      this.$trace(\"lsw-duration-control.methods.increasePosition\");\n\n    },\n    decreasePosition(pos) {\n      this.$trace(\"lsw-duration-control.methods.decreasePosition\");\n\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-duration-control.mounted\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswDurationControl API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswLongTextControl component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-long-text-control/lsw-long-text-control.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 126,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswLongTextControl component",
            "$code": "Vue.component(\"LswLongTextControl\", {\n  template: $template,\n  props: {\n    settings: {\n      type: Object,\n      default: () => ({})\n    },\n  },\n  data() {\n    this.$trace(\"lsw-long-text-control.data\");\n    this.validateSettings();\n    const value = this.settings?.initialValue || this.settings?.column.hasDefaultValue || \"\";\n    return {\n      uuid: LswRandomizer.getRandomString(5),\n      value,\n      isEditable: true,\n    };\n  },\n  methods: {\n    async submit() {\n      this.$trace(\"lsw-text-control.methods.submit\");\n      return LswFormtypes.utils.submitControl.call(this);\n      \n    },\n    validate() {\n      this.$trace(\"lsw-text-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateControl.call(this);\n    },\n    validateSettings() {\n      this.$trace(\"lsw-text-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateSettings.call(this);\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-long-text-control.mounted\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswLongTextControl API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswNumberControl component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-number-control/lsw-number-control.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 122,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswNumberControl component",
            "$code": "Vue.component(\"LswNumberControl\", {\n  template: $template,\n  props: {\n    configurations: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  data() {\n    this.$trace(\"lsw-number-control.data\");\n    return {};\n  },\n  methods: {},\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-number-control.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswNumberControl API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswOptionsControl component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-options-control/lsw-options-control.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 124,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswOptionsControl component",
            "$code": "Vue.component(\"LswOptionsControl\", {\n  template: $template,\n  props: {\n    settings: {\n      type: Object,\n      default: () => ({})\n    },\n  },\n  data() {\n    this.$trace(\"lsw-options-control.data\");\n    this.validateSettings();\n    const value = this.settings?.initialValue || this.settings?.column.hasDefaultValue || \"\";\n    return {\n      uuid: LswRandomizer.getRandomString(5),\n      value,\n      isEditable: true,\n      parameters: this.settings?.hasFormtypeParameters || {}\n    };\n  },\n  methods: {\n    async submit() {\n      this.$trace(\"lsw-text-control.methods.submit\");\n      return LswFormtypes.utils.submitControl.call(this);\n    },\n    validate() {\n      this.$trace(\"lsw-text-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateControl.call(this);\n    },\n    validateSettings() {\n      this.$trace(\"lsw-text-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateSettings.call(this);\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-options-control.mounted\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswOptionsControl API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswRefListControl component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-list-control/lsw-ref-list-control.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 124,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswRefListControl component",
            "$code": "Vue.component(\"LswRefListControl\", {\n  template: $template,\n  props: {\n    settings: {\n      type: Object,\n      default: () => ({})\n    },\n  },\n  data() {\n    this.$trace(\"lsw-ref-list-control.data\");\n    this.validateSettings();\n    return {\n      uuid: LswRandomizer.getRandomString(5),\n      value: this.settings.initialValue || [],\n      isValueLoaded: false,\n      isEditable: true,\n      isShownSelector: false,\n      isShownInfo: false,\n      rows: []\n    };\n  },\n  methods: {\n    toggleSelector() {\n      this.$trace(\"lsw-ref-list-control.methods.toggleSelector\");\n      this.isShownSelector = !this.isShownSelector;\n    },\n    toggleInfo() {\n      this.$trace(\"lsw-ref-list-control.methods.toggleInfo\");\n      this.isShownInfo = !this.isShownInfo;\n    },\n    async submit() {\n      this.$trace(\"lsw-ref-list-control.methods.submit\");\n      return LswFormtypes.utils.submitControl.call(this);\n      \n    },\n    validate() {\n      this.$trace(\"lsw-ref-list-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateControl.call(this);\n    },\n    validateSettings() {\n      this.$trace(\"lsw-ref-list-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateSettings.call(this);\n    },\n    async loadRows() {\n      this.$trace(\"lsw-page-rows.methods.loadRows\", arguments);\n      const selection = await this.$lsw.database.select(this.settings.column.refersTo.table, it => true);\n      this.rows = selection;\n      return selection;\n    },\n    async loadValue() {\n      this.$trace(\"lsw-ref-list-control.methods.loadValue\");\n      const selection = await this.$lsw.database.select(this.settings.tableId, it => true);\n    },\n  },\n  watch: {},\n  async mounted() {\n    try {\n      this.$trace(\"lsw-ref-list-control.mounted\");\n      await this.loadRows();\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswRefListControl API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswRefObjectControl component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-object-control/lsw-ref-object-control.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 128,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswRefObjectControl component",
            "$code": "Vue.component(\"LswRefObjectControl\", {\n  template: $template,\n  props: {\n    settings: {\n      type: Object,\n      default: () => ({})\n    },\n  },\n  data() {\n    this.$trace(\"lsw-ref-object-control.data\");\n    this.validateSettings();\n    return {\n      uuid: LswRandomizer.getRandomString(5),\n      value: this.settings.initialValue || [],\n      isValueLoaded: false,\n      isEditable: true,\n      isShownSelector: false,\n      isShownInfo: false,\n      rows: []\n    };\n  },\n  methods: {\n    toggleSelector() {\n      this.$trace(\"lsw-ref-object-control.methods.toggleSelector\");\n      this.isShownSelector = !this.isShownSelector;\n    },\n    toggleInfo() {\n      this.$trace(\"lsw-ref-object-control.methods.toggleInfo\");\n      this.isShownInfo = !this.isShownInfo;\n    },\n    async submit() {\n      this.$trace(\"lsw-ref-object-control.methods.submit\");\n      return LswFormtypes.utils.submitControl.call(this);\n      \n    },\n    validate() {\n      this.$trace(\"lsw-ref-object-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateControl.call(this);\n    },\n    validateSettings() {\n      this.$trace(\"lsw-ref-object-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateSettings.call(this);\n    },\n    async loadRows() {\n      this.$trace(\"lsw-page-rows.methods.loadRows\", arguments);\n      const selection = await this.$lsw.database.select(this.settings.column.refersTo.table, it => true);\n      this.rows = selection;\n      return selection;\n    },\n    async loadValue() {\n      this.$trace(\"lsw-ref-object-control.methods.loadValue\");\n      const selection = await this.$lsw.database.select(this.settings.tableId, it => true);\n    },\n  },\n  watch: {},\n  async mounted() {\n    try {\n      this.$trace(\"lsw-ref-object-control.mounted\");\n      await this.loadRows();\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswRefObjectControl API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswRefRelationControl component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-ref-relation-control/lsw-ref-relation-control.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 132,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswRefRelationControl component",
            "$code": "Vue.component(\"LswRefRelationControl\", {\n  template: $template,\n  props: {\n    settings: {\n      type: Object,\n      default: () => ({})\n    },\n  },\n  data() {\n    this.$trace(\"lsw-ref-relation-control.data\");\n    this.validateSettings();\n    return {\n      uuid: LswRandomizer.getRandomString(5),\n      value: this.settings?.initialValue || \"\",\n      isEditable: true,\n    };\n  },\n  methods: {\n    async submit() {\n      this.$trace(\"lsw-ref-relation-control.methods.submit\");\n      return LswFormtypes.utils.submitControl.call(this);\n      \n    },\n    validate() {\n      this.$trace(\"lsw-ref-relation-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateControl.call(this);\n    },\n    validateSettings() {\n      this.$trace(\"lsw-ref-relation-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateSettings.call(this);\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-ref-relation-control.mounted\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswRefRelationControl API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswSourceCodeControl component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-source-code-control/lsw-source-code-control.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 130,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswSourceCodeControl component",
            "$code": "Vue.component(\"LswSourceCodeControl\", {\n  template: $template,\n  props: {\n    configurations: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  data() {\n    this.$trace(\"lsw-source-code.data\");\n    return {};\n  },\n  methods: {},\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-source-code.mounted\");\n    } catch(error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswSourceCodeControl API",
            "$output": "index.html"
          }
        ],
        "Vue.js (v2) Components » Lsw Formtypes API » LswTextControl component": [
          {
            "$file": "/home/carlos/Escritorio/lsw-one/src/lsw-framework/src/components/lsw-formtypes/components/lsw-formtype/type/lsw-text-control/lsw-text-control.js",
            "$location": {
              "start": {
                "offset": 0,
                "line": 1,
                "column": 1
              },
              "end": {
                "offset": 118,
                "line": 2,
                "column": 1
              }
            },
            "$section": "Vue.js (v2) Components » Lsw Formtypes API » LswTextControl component",
            "$code": "Vue.component(\"LswTextControl\", {\n  template: $template,\n  props: {\n    settings: {\n      type: Object,\n      default: () => ({})\n    },\n  },\n  data() {\n    this.$trace(\"lsw-text-control.data\");\n    this.validateSettings();\n    const value = this.settings?.initialValue || this.settings?.column.hasDefaultValue || \"\";\n    return {\n      uuid: LswRandomizer.getRandomString(5),\n      value,\n      isEditable: true,\n    };\n  },\n  methods: {\n    async submit() {\n      this.$trace(\"lsw-text-control.methods.submit\");\n      return LswFormtypes.utils.submitControl.call(this);\n      \n    },\n    validate() {\n      this.$trace(\"lsw-text-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateControl.call(this);\n    },\n    validateSettings() {\n      this.$trace(\"lsw-text-control.methods.validateSettings\");\n      return LswFormtypes.utils.validateSettings.call(this);\n    }\n  },\n  watch: {},\n  mounted() {\n    try {\n      this.$trace(\"lsw-text-control.mounted\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n});\n",
            "$code.label": "LswTextControl API",
            "$output": "index.html"
          }
        ]
      }
    }
  }
}